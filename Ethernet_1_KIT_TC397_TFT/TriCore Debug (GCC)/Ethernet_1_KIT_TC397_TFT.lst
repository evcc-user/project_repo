
Ethernet_1_KIT_TC397_TFT.elf:     file format elf32-tricore

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .CPU5.ustack  00000800  10014e00  10014e00  00000714  2**0
                  ALLOC
  1 .CPU5.istack  00000400  10015700  10015700  00000714  2**0
                  ALLOC
  2 .CPU5.csa     00002000  10015c00  10015c00  00000714  2**0
                  ALLOC
  3 .CPU4.ustack  00000800  30014e00  30014e00  00000714  2**0
                  ALLOC
  4 .CPU4.istack  00000400  30015700  30015700  00000714  2**0
                  ALLOC
  5 .CPU4.csa     00002000  30015c00  30015c00  00000714  2**0
                  ALLOC
  6 .CPU3.ustack  00000800  40014e00  40014e00  00000714  2**0
                  ALLOC
  7 .CPU3.istack  00000400  40015700  40015700  00000714  2**0
                  ALLOC
  8 .CPU3.csa     00002000  40015c00  40015c00  00000714  2**0
                  ALLOC
  9 .CPU2.ustack  00000800  50014e00  50014e00  00000714  2**0
                  ALLOC
 10 .CPU2.istack  00000400  50015700  50015700  00000714  2**0
                  ALLOC
 11 .CPU2.csa     00002000  50015c00  50015c00  00000714  2**0
                  ALLOC
 12 .CPU1.ustack  00000800  60038e00  60038e00  00000714  2**0
                  ALLOC
 13 .CPU1.istack  00000400  60039700  60039700  00000714  2**0
                  ALLOC
 14 .CPU1.csa     00002000  60039c00  60039c00  00000714  2**0
                  ALLOC
 15 .CPU0.ustack  00000800  70038e00  70038e00  00000714  2**0
                  ALLOC
 16 .CPU0.istack  00000400  70039700  70039700  00000714  2**0
                  ALLOC
 17 .CPU0.csa     00002000  70039c00  70039c00  00000714  2**0
                  ALLOC
 18 .start_tc0    0000000c  a0000000  a0000000  00030670  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .traptab_tc0  00000100  80000100  80000100  00000720  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 20 .traptab_tc1  00000100  80300000  80300000  0002f700  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 21 .traptab_tc2  00000100  80600000  80600000  0002fa20  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 22 .traptab_tc3  00000100  80900000  80900000  0002fd40  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 23 .traptab_tc4  00000100  80c00000  80c00000  00030060  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 24 .traptab_tc5  00000100  80f00000  80f00000  00030380  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 25 .start_tc1    0000000c  a0300100  a0300100  0003067c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .start_tc2    0000000c  a0600100  a0600100  00030688  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .start_tc3    0000000c  a0900100  a0900100  00030694  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .start_tc4    0000000c  a0c00100  a0c00100  000306a0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .start_tc5    0000000c  a0f00100  a0f00100  000306ac  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .inttab_tc0_000 00000000  802fe000  802fe000  00031658  2**0
                  CONTENTS
 31 .inttab_tc0_001 00000000  802fe020  802fe020  00031658  2**0
                  CONTENTS
 32 .inttab_tc0_002 00000000  802fe040  802fe040  00031658  2**0
                  CONTENTS
 33 .inttab_tc0_003 00000000  802fe060  802fe060  00031658  2**0
                  CONTENTS
 34 .inttab_tc0_004 00000000  802fe080  802fe080  00031658  2**0
                  CONTENTS
 35 .inttab_tc0_005 00000000  802fe0a0  802fe0a0  00031658  2**0
                  CONTENTS
 36 .inttab_tc0_006 00000000  802fe0c0  802fe0c0  00031658  2**0
                  CONTENTS
 37 .inttab_tc0_007 00000000  802fe0e0  802fe0e0  00031658  2**0
                  CONTENTS
 38 .inttab_tc0_008 00000000  802fe100  802fe100  00031658  2**0
                  CONTENTS
 39 .inttab_tc0_009 00000000  802fe120  802fe120  00031658  2**0
                  CONTENTS
 40 .inttab_tc0_00A 00000000  802fe140  802fe140  00031658  2**0
                  CONTENTS
 41 .inttab_tc0_00B 00000000  802fe160  802fe160  00031658  2**0
                  CONTENTS
 42 .inttab_tc0_00C 00000000  802fe180  802fe180  00031658  2**0
                  CONTENTS
 43 .inttab_tc0_00D 00000000  802fe1a0  802fe1a0  00031658  2**0
                  CONTENTS
 44 .inttab_tc0_00E 00000000  802fe1c0  802fe1c0  00031658  2**0
                  CONTENTS
 45 .inttab_tc0_00F 00000000  802fe1e0  802fe1e0  00031658  2**0
                  CONTENTS
 46 .inttab_tc0_010 00000000  802fe200  802fe200  00031658  2**0
                  CONTENTS
 47 .inttab_tc0_011 00000000  802fe220  802fe220  00031658  2**0
                  CONTENTS
 48 .inttab_tc0_012 00000000  802fe240  802fe240  00031658  2**0
                  CONTENTS
 49 .inttab_tc0_013 0000000e  802fe260  802fe260  0002f6b4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .inttab_tc0_014 00000000  802fe280  802fe280  00031658  2**0
                  CONTENTS
 51 .inttab_tc0_015 00000000  802fe2a0  802fe2a0  00031658  2**0
                  CONTENTS
 52 .inttab_tc0_016 00000000  802fe2c0  802fe2c0  00031658  2**0
                  CONTENTS
 53 .inttab_tc0_017 00000000  802fe2e0  802fe2e0  00031658  2**0
                  CONTENTS
 54 .inttab_tc0_018 00000000  802fe300  802fe300  00031658  2**0
                  CONTENTS
 55 .inttab_tc0_019 00000000  802fe320  802fe320  00031658  2**0
                  CONTENTS
 56 .inttab_tc0_01A 00000000  802fe340  802fe340  00031658  2**0
                  CONTENTS
 57 .inttab_tc0_01B 00000000  802fe360  802fe360  00031658  2**0
                  CONTENTS
 58 .inttab_tc0_01C 00000000  802fe380  802fe380  00031658  2**0
                  CONTENTS
 59 .inttab_tc0_01D 00000000  802fe3a0  802fe3a0  00031658  2**0
                  CONTENTS
 60 .inttab_tc0_01E 00000000  802fe3c0  802fe3c0  00031658  2**0
                  CONTENTS
 61 .inttab_tc0_01F 00000000  802fe3e0  802fe3e0  00031658  2**0
                  CONTENTS
 62 .inttab_tc0_020 00000000  802fe400  802fe400  00031658  2**0
                  CONTENTS
 63 .inttab_tc0_021 00000000  802fe420  802fe420  00031658  2**0
                  CONTENTS
 64 .inttab_tc0_022 00000000  802fe440  802fe440  00031658  2**0
                  CONTENTS
 65 .inttab_tc0_023 00000000  802fe460  802fe460  00031658  2**0
                  CONTENTS
 66 .inttab_tc0_024 00000000  802fe480  802fe480  00031658  2**0
                  CONTENTS
 67 .inttab_tc0_025 00000000  802fe4a0  802fe4a0  00031658  2**0
                  CONTENTS
 68 .inttab_tc0_026 00000000  802fe4c0  802fe4c0  00031658  2**0
                  CONTENTS
 69 .inttab_tc0_027 00000000  802fe4e0  802fe4e0  00031658  2**0
                  CONTENTS
 70 .inttab_tc0_028 00000000  802fe500  802fe500  00031658  2**0
                  CONTENTS
 71 .inttab_tc0_029 00000000  802fe520  802fe520  00031658  2**0
                  CONTENTS
 72 .inttab_tc0_02A 00000000  802fe540  802fe540  00031658  2**0
                  CONTENTS
 73 .inttab_tc0_02B 00000000  802fe560  802fe560  00031658  2**0
                  CONTENTS
 74 .inttab_tc0_02C 00000000  802fe580  802fe580  00031658  2**0
                  CONTENTS
 75 .inttab_tc0_02D 00000000  802fe5a0  802fe5a0  00031658  2**0
                  CONTENTS
 76 .inttab_tc0_02E 00000000  802fe5c0  802fe5c0  00031658  2**0
                  CONTENTS
 77 .inttab_tc0_02F 00000000  802fe5e0  802fe5e0  00031658  2**0
                  CONTENTS
 78 .inttab_tc0_030 00000000  802fe600  802fe600  00031658  2**0
                  CONTENTS
 79 .inttab_tc0_031 00000000  802fe620  802fe620  00031658  2**0
                  CONTENTS
 80 .inttab_tc0_032 00000000  802fe640  802fe640  00031658  2**0
                  CONTENTS
 81 .inttab_tc0_033 00000000  802fe660  802fe660  00031658  2**0
                  CONTENTS
 82 .inttab_tc0_034 00000000  802fe680  802fe680  00031658  2**0
                  CONTENTS
 83 .inttab_tc0_035 00000000  802fe6a0  802fe6a0  00031658  2**0
                  CONTENTS
 84 .inttab_tc0_036 00000000  802fe6c0  802fe6c0  00031658  2**0
                  CONTENTS
 85 .inttab_tc0_037 00000000  802fe6e0  802fe6e0  00031658  2**0
                  CONTENTS
 86 .inttab_tc0_038 00000000  802fe700  802fe700  00031658  2**0
                  CONTENTS
 87 .inttab_tc0_039 00000000  802fe720  802fe720  00031658  2**0
                  CONTENTS
 88 .inttab_tc0_03A 00000000  802fe740  802fe740  00031658  2**0
                  CONTENTS
 89 .inttab_tc0_03B 00000000  802fe760  802fe760  00031658  2**0
                  CONTENTS
 90 .inttab_tc0_03C 00000000  802fe780  802fe780  00031658  2**0
                  CONTENTS
 91 .inttab_tc0_03D 00000000  802fe7a0  802fe7a0  00031658  2**0
                  CONTENTS
 92 .inttab_tc0_03E 00000000  802fe7c0  802fe7c0  00031658  2**0
                  CONTENTS
 93 .inttab_tc0_03F 00000000  802fe7e0  802fe7e0  00031658  2**0
                  CONTENTS
 94 .inttab_tc0_040 00000000  802fe800  802fe800  00031658  2**0
                  CONTENTS
 95 .inttab_tc0_041 00000000  802fe820  802fe820  00031658  2**0
                  CONTENTS
 96 .inttab_tc0_042 00000000  802fe840  802fe840  00031658  2**0
                  CONTENTS
 97 .inttab_tc0_043 00000000  802fe860  802fe860  00031658  2**0
                  CONTENTS
 98 .inttab_tc0_044 00000000  802fe880  802fe880  00031658  2**0
                  CONTENTS
 99 .inttab_tc0_045 00000000  802fe8a0  802fe8a0  00031658  2**0
                  CONTENTS
100 .inttab_tc0_046 00000000  802fe8c0  802fe8c0  00031658  2**0
                  CONTENTS
101 .inttab_tc0_047 00000000  802fe8e0  802fe8e0  00031658  2**0
                  CONTENTS
102 .inttab_tc0_048 00000000  802fe900  802fe900  00031658  2**0
                  CONTENTS
103 .inttab_tc0_049 00000000  802fe920  802fe920  00031658  2**0
                  CONTENTS
104 .inttab_tc0_04A 00000000  802fe940  802fe940  00031658  2**0
                  CONTENTS
105 .inttab_tc0_04B 00000000  802fe960  802fe960  00031658  2**0
                  CONTENTS
106 .inttab_tc0_04C 00000000  802fe980  802fe980  00031658  2**0
                  CONTENTS
107 .inttab_tc0_04D 00000000  802fe9a0  802fe9a0  00031658  2**0
                  CONTENTS
108 .inttab_tc0_04E 00000000  802fe9c0  802fe9c0  00031658  2**0
                  CONTENTS
109 .inttab_tc0_04F 00000000  802fe9e0  802fe9e0  00031658  2**0
                  CONTENTS
110 .inttab_tc0_050 00000000  802fea00  802fea00  00031658  2**0
                  CONTENTS
111 .inttab_tc0_051 00000000  802fea20  802fea20  00031658  2**0
                  CONTENTS
112 .inttab_tc0_052 00000000  802fea40  802fea40  00031658  2**0
                  CONTENTS
113 .inttab_tc0_053 00000000  802fea60  802fea60  00031658  2**0
                  CONTENTS
114 .inttab_tc0_054 00000000  802fea80  802fea80  00031658  2**0
                  CONTENTS
115 .inttab_tc0_055 00000000  802feaa0  802feaa0  00031658  2**0
                  CONTENTS
116 .inttab_tc0_056 00000000  802feac0  802feac0  00031658  2**0
                  CONTENTS
117 .inttab_tc0_057 00000000  802feae0  802feae0  00031658  2**0
                  CONTENTS
118 .inttab_tc0_058 00000000  802feb00  802feb00  00031658  2**0
                  CONTENTS
119 .inttab_tc0_059 00000000  802feb20  802feb20  00031658  2**0
                  CONTENTS
120 .inttab_tc0_05A 00000000  802feb40  802feb40  00031658  2**0
                  CONTENTS
121 .inttab_tc0_05B 00000000  802feb60  802feb60  00031658  2**0
                  CONTENTS
122 .inttab_tc0_05C 00000000  802feb80  802feb80  00031658  2**0
                  CONTENTS
123 .inttab_tc0_05D 00000000  802feba0  802feba0  00031658  2**0
                  CONTENTS
124 .inttab_tc0_05E 00000000  802febc0  802febc0  00031658  2**0
                  CONTENTS
125 .inttab_tc0_05F 00000000  802febe0  802febe0  00031658  2**0
                  CONTENTS
126 .inttab_tc0_060 00000000  802fec00  802fec00  00031658  2**0
                  CONTENTS
127 .inttab_tc0_061 00000000  802fec20  802fec20  00031658  2**0
                  CONTENTS
128 .inttab_tc0_062 00000000  802fec40  802fec40  00031658  2**0
                  CONTENTS
129 .inttab_tc0_063 0000000e  802fec60  802fec60  0002f6c2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
130 .inttab_tc0_064 0000000e  802fec80  802fec80  0002f6d0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
131 .inttab_tc0_065 0000000e  802feca0  802feca0  0002f6de  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
132 .inttab_tc0_066 00000000  802fecc0  802fecc0  00031658  2**0
                  CONTENTS
133 .inttab_tc0_067 00000000  802fece0  802fece0  00031658  2**0
                  CONTENTS
134 .inttab_tc0_068 00000000  802fed00  802fed00  00031658  2**0
                  CONTENTS
135 .inttab_tc0_069 00000000  802fed20  802fed20  00031658  2**0
                  CONTENTS
136 .inttab_tc0_06A 00000000  802fed40  802fed40  00031658  2**0
                  CONTENTS
137 .inttab_tc0_06B 00000000  802fed60  802fed60  00031658  2**0
                  CONTENTS
138 .inttab_tc0_06C 00000000  802fed80  802fed80  00031658  2**0
                  CONTENTS
139 .inttab_tc0_06D 00000000  802feda0  802feda0  00031658  2**0
                  CONTENTS
140 .inttab_tc0_06E 00000000  802fedc0  802fedc0  00031658  2**0
                  CONTENTS
141 .inttab_tc0_06F 00000000  802fede0  802fede0  00031658  2**0
                  CONTENTS
142 .inttab_tc0_070 00000000  802fee00  802fee00  00031658  2**0
                  CONTENTS
143 .inttab_tc0_071 00000000  802fee20  802fee20  00031658  2**0
                  CONTENTS
144 .inttab_tc0_072 00000000  802fee40  802fee40  00031658  2**0
                  CONTENTS
145 .inttab_tc0_073 00000000  802fee60  802fee60  00031658  2**0
                  CONTENTS
146 .inttab_tc0_074 00000000  802fee80  802fee80  00031658  2**0
                  CONTENTS
147 .inttab_tc0_075 00000000  802feea0  802feea0  00031658  2**0
                  CONTENTS
148 .inttab_tc0_076 00000000  802feec0  802feec0  00031658  2**0
                  CONTENTS
149 .inttab_tc0_077 00000000  802feee0  802feee0  00031658  2**0
                  CONTENTS
150 .inttab_tc0_078 00000000  802fef00  802fef00  00031658  2**0
                  CONTENTS
151 .inttab_tc0_079 00000000  802fef20  802fef20  00031658  2**0
                  CONTENTS
152 .inttab_tc0_07A 00000000  802fef40  802fef40  00031658  2**0
                  CONTENTS
153 .inttab_tc0_07B 00000000  802fef60  802fef60  00031658  2**0
                  CONTENTS
154 .inttab_tc0_07C 00000000  802fef80  802fef80  00031658  2**0
                  CONTENTS
155 .inttab_tc0_07D 00000000  802fefa0  802fefa0  00031658  2**0
                  CONTENTS
156 .inttab_tc0_07E 00000000  802fefc0  802fefc0  00031658  2**0
                  CONTENTS
157 .inttab_tc0_07F 00000000  802fefe0  802fefe0  00031658  2**0
                  CONTENTS
158 .inttab_tc0_080 00000000  802ff000  802ff000  00031658  2**0
                  CONTENTS
159 .inttab_tc0_081 00000000  802ff020  802ff020  00031658  2**0
                  CONTENTS
160 .inttab_tc0_082 00000000  802ff040  802ff040  00031658  2**0
                  CONTENTS
161 .inttab_tc0_083 00000000  802ff060  802ff060  00031658  2**0
                  CONTENTS
162 .inttab_tc0_084 00000000  802ff080  802ff080  00031658  2**0
                  CONTENTS
163 .inttab_tc0_085 00000000  802ff0a0  802ff0a0  00031658  2**0
                  CONTENTS
164 .inttab_tc0_086 00000000  802ff0c0  802ff0c0  00031658  2**0
                  CONTENTS
165 .inttab_tc0_087 00000000  802ff0e0  802ff0e0  00031658  2**0
                  CONTENTS
166 .inttab_tc0_088 00000000  802ff100  802ff100  00031658  2**0
                  CONTENTS
167 .inttab_tc0_089 00000000  802ff120  802ff120  00031658  2**0
                  CONTENTS
168 .inttab_tc0_08A 00000000  802ff140  802ff140  00031658  2**0
                  CONTENTS
169 .inttab_tc0_08B 00000000  802ff160  802ff160  00031658  2**0
                  CONTENTS
170 .inttab_tc0_08C 00000000  802ff180  802ff180  00031658  2**0
                  CONTENTS
171 .inttab_tc0_08D 00000000  802ff1a0  802ff1a0  00031658  2**0
                  CONTENTS
172 .inttab_tc0_08E 00000000  802ff1c0  802ff1c0  00031658  2**0
                  CONTENTS
173 .inttab_tc0_08F 00000000  802ff1e0  802ff1e0  00031658  2**0
                  CONTENTS
174 .inttab_tc0_090 00000000  802ff200  802ff200  00031658  2**0
                  CONTENTS
175 .inttab_tc0_091 00000000  802ff220  802ff220  00031658  2**0
                  CONTENTS
176 .inttab_tc0_092 00000000  802ff240  802ff240  00031658  2**0
                  CONTENTS
177 .inttab_tc0_093 00000000  802ff260  802ff260  00031658  2**0
                  CONTENTS
178 .inttab_tc0_094 00000000  802ff280  802ff280  00031658  2**0
                  CONTENTS
179 .inttab_tc0_095 00000000  802ff2a0  802ff2a0  00031658  2**0
                  CONTENTS
180 .inttab_tc0_096 00000000  802ff2c0  802ff2c0  00031658  2**0
                  CONTENTS
181 .inttab_tc0_097 00000000  802ff2e0  802ff2e0  00031658  2**0
                  CONTENTS
182 .inttab_tc0_098 00000000  802ff300  802ff300  00031658  2**0
                  CONTENTS
183 .inttab_tc0_099 00000000  802ff320  802ff320  00031658  2**0
                  CONTENTS
184 .inttab_tc0_09A 00000000  802ff340  802ff340  00031658  2**0
                  CONTENTS
185 .inttab_tc0_09B 00000000  802ff360  802ff360  00031658  2**0
                  CONTENTS
186 .inttab_tc0_09C 00000000  802ff380  802ff380  00031658  2**0
                  CONTENTS
187 .inttab_tc0_09D 00000000  802ff3a0  802ff3a0  00031658  2**0
                  CONTENTS
188 .inttab_tc0_09E 00000000  802ff3c0  802ff3c0  00031658  2**0
                  CONTENTS
189 .inttab_tc0_09F 00000000  802ff3e0  802ff3e0  00031658  2**0
                  CONTENTS
190 .inttab_tc0_0A0 00000000  802ff400  802ff400  00031658  2**0
                  CONTENTS
191 .inttab_tc0_0A1 00000000  802ff420  802ff420  00031658  2**0
                  CONTENTS
192 .inttab_tc0_0A2 00000000  802ff440  802ff440  00031658  2**0
                  CONTENTS
193 .inttab_tc0_0A3 00000000  802ff460  802ff460  00031658  2**0
                  CONTENTS
194 .inttab_tc0_0A4 00000000  802ff480  802ff480  00031658  2**0
                  CONTENTS
195 .inttab_tc0_0A5 00000000  802ff4a0  802ff4a0  00031658  2**0
                  CONTENTS
196 .inttab_tc0_0A6 00000000  802ff4c0  802ff4c0  00031658  2**0
                  CONTENTS
197 .inttab_tc0_0A7 00000000  802ff4e0  802ff4e0  00031658  2**0
                  CONTENTS
198 .inttab_tc0_0A8 00000000  802ff500  802ff500  00031658  2**0
                  CONTENTS
199 .inttab_tc0_0A9 00000000  802ff520  802ff520  00031658  2**0
                  CONTENTS
200 .inttab_tc0_0AA 00000000  802ff540  802ff540  00031658  2**0
                  CONTENTS
201 .inttab_tc0_0AB 00000000  802ff560  802ff560  00031658  2**0
                  CONTENTS
202 .inttab_tc0_0AC 00000000  802ff580  802ff580  00031658  2**0
                  CONTENTS
203 .inttab_tc0_0AD 00000000  802ff5a0  802ff5a0  00031658  2**0
                  CONTENTS
204 .inttab_tc0_0AE 00000000  802ff5c0  802ff5c0  00031658  2**0
                  CONTENTS
205 .inttab_tc0_0AF 00000000  802ff5e0  802ff5e0  00031658  2**0
                  CONTENTS
206 .inttab_tc0_0B0 00000000  802ff600  802ff600  00031658  2**0
                  CONTENTS
207 .inttab_tc0_0B1 00000000  802ff620  802ff620  00031658  2**0
                  CONTENTS
208 .inttab_tc0_0B2 00000000  802ff640  802ff640  00031658  2**0
                  CONTENTS
209 .inttab_tc0_0B3 00000000  802ff660  802ff660  00031658  2**0
                  CONTENTS
210 .inttab_tc0_0B4 00000000  802ff680  802ff680  00031658  2**0
                  CONTENTS
211 .inttab_tc0_0B5 00000000  802ff6a0  802ff6a0  00031658  2**0
                  CONTENTS
212 .inttab_tc0_0B6 00000000  802ff6c0  802ff6c0  00031658  2**0
                  CONTENTS
213 .inttab_tc0_0B7 00000000  802ff6e0  802ff6e0  00031658  2**0
                  CONTENTS
214 .inttab_tc0_0B8 00000000  802ff700  802ff700  00031658  2**0
                  CONTENTS
215 .inttab_tc0_0B9 00000000  802ff720  802ff720  00031658  2**0
                  CONTENTS
216 .inttab_tc0_0BA 00000000  802ff740  802ff740  00031658  2**0
                  CONTENTS
217 .inttab_tc0_0BB 00000000  802ff760  802ff760  00031658  2**0
                  CONTENTS
218 .inttab_tc0_0BC 00000000  802ff780  802ff780  00031658  2**0
                  CONTENTS
219 .inttab_tc0_0BD 00000000  802ff7a0  802ff7a0  00031658  2**0
                  CONTENTS
220 .inttab_tc0_0BE 00000000  802ff7c0  802ff7c0  00031658  2**0
                  CONTENTS
221 .inttab_tc0_0BF 00000000  802ff7e0  802ff7e0  00031658  2**0
                  CONTENTS
222 .inttab_tc0_0C0 00000000  802ff800  802ff800  00031658  2**0
                  CONTENTS
223 .inttab_tc0_0C1 00000000  802ff820  802ff820  00031658  2**0
                  CONTENTS
224 .inttab_tc0_0C2 00000000  802ff840  802ff840  00031658  2**0
                  CONTENTS
225 .inttab_tc0_0C3 00000000  802ff860  802ff860  00031658  2**0
                  CONTENTS
226 .inttab_tc0_0C4 00000000  802ff880  802ff880  00031658  2**0
                  CONTENTS
227 .inttab_tc0_0C5 00000000  802ff8a0  802ff8a0  00031658  2**0
                  CONTENTS
228 .inttab_tc0_0C6 00000000  802ff8c0  802ff8c0  00031658  2**0
                  CONTENTS
229 .inttab_tc0_0C7 00000000  802ff8e0  802ff8e0  00031658  2**0
                  CONTENTS
230 .inttab_tc0_0C8 00000000  802ff900  802ff900  00031658  2**0
                  CONTENTS
231 .inttab_tc0_0C9 00000000  802ff920  802ff920  00031658  2**0
                  CONTENTS
232 .inttab_tc0_0CA 00000000  802ff940  802ff940  00031658  2**0
                  CONTENTS
233 .inttab_tc0_0CB 00000000  802ff960  802ff960  00031658  2**0
                  CONTENTS
234 .inttab_tc0_0CC 00000000  802ff980  802ff980  00031658  2**0
                  CONTENTS
235 .inttab_tc0_0CD 00000000  802ff9a0  802ff9a0  00031658  2**0
                  CONTENTS
236 .inttab_tc0_0CE 00000000  802ff9c0  802ff9c0  00031658  2**0
                  CONTENTS
237 .inttab_tc0_0CF 00000000  802ff9e0  802ff9e0  00031658  2**0
                  CONTENTS
238 .inttab_tc0_0D0 00000000  802ffa00  802ffa00  00031658  2**0
                  CONTENTS
239 .inttab_tc0_0D1 00000000  802ffa20  802ffa20  00031658  2**0
                  CONTENTS
240 .inttab_tc0_0D2 00000000  802ffa40  802ffa40  00031658  2**0
                  CONTENTS
241 .inttab_tc0_0D3 00000000  802ffa60  802ffa60  00031658  2**0
                  CONTENTS
242 .inttab_tc0_0D4 00000000  802ffa80  802ffa80  00031658  2**0
                  CONTENTS
243 .inttab_tc0_0D5 00000000  802ffaa0  802ffaa0  00031658  2**0
                  CONTENTS
244 .inttab_tc0_0D6 00000000  802ffac0  802ffac0  00031658  2**0
                  CONTENTS
245 .inttab_tc0_0D7 00000000  802ffae0  802ffae0  00031658  2**0
                  CONTENTS
246 .inttab_tc0_0D8 00000000  802ffb00  802ffb00  00031658  2**0
                  CONTENTS
247 .inttab_tc0_0D9 00000000  802ffb20  802ffb20  00031658  2**0
                  CONTENTS
248 .inttab_tc0_0DA 00000000  802ffb40  802ffb40  00031658  2**0
                  CONTENTS
249 .inttab_tc0_0DB 00000000  802ffb60  802ffb60  00031658  2**0
                  CONTENTS
250 .inttab_tc0_0DC 00000000  802ffb80  802ffb80  00031658  2**0
                  CONTENTS
251 .inttab_tc0_0DD 00000000  802ffba0  802ffba0  00031658  2**0
                  CONTENTS
252 .inttab_tc0_0DE 00000000  802ffbc0  802ffbc0  00031658  2**0
                  CONTENTS
253 .inttab_tc0_0DF 00000000  802ffbe0  802ffbe0  00031658  2**0
                  CONTENTS
254 .inttab_tc0_0E0 00000000  802ffc00  802ffc00  00031658  2**0
                  CONTENTS
255 .inttab_tc0_0E1 00000000  802ffc20  802ffc20  00031658  2**0
                  CONTENTS
256 .inttab_tc0_0E2 00000000  802ffc40  802ffc40  00031658  2**0
                  CONTENTS
257 .inttab_tc0_0E3 00000000  802ffc60  802ffc60  00031658  2**0
                  CONTENTS
258 .inttab_tc0_0E4 00000000  802ffc80  802ffc80  00031658  2**0
                  CONTENTS
259 .inttab_tc0_0E5 00000000  802ffca0  802ffca0  00031658  2**0
                  CONTENTS
260 .inttab_tc0_0E6 00000000  802ffcc0  802ffcc0  00031658  2**0
                  CONTENTS
261 .inttab_tc0_0E7 00000000  802ffce0  802ffce0  00031658  2**0
                  CONTENTS
262 .inttab_tc0_0E8 00000000  802ffd00  802ffd00  00031658  2**0
                  CONTENTS
263 .inttab_tc0_0E9 00000000  802ffd20  802ffd20  00031658  2**0
                  CONTENTS
264 .inttab_tc0_0EA 00000000  802ffd40  802ffd40  00031658  2**0
                  CONTENTS
265 .inttab_tc0_0EB 00000000  802ffd60  802ffd60  00031658  2**0
                  CONTENTS
266 .inttab_tc0_0EC 00000000  802ffd80  802ffd80  00031658  2**0
                  CONTENTS
267 .inttab_tc0_0ED 00000000  802ffda0  802ffda0  00031658  2**0
                  CONTENTS
268 .inttab_tc0_0EE 00000000  802ffdc0  802ffdc0  00031658  2**0
                  CONTENTS
269 .inttab_tc0_0EF 00000000  802ffde0  802ffde0  00031658  2**0
                  CONTENTS
270 .inttab_tc0_0F0 00000000  802ffe00  802ffe00  00031658  2**0
                  CONTENTS
271 .inttab_tc0_0F1 00000000  802ffe20  802ffe20  00031658  2**0
                  CONTENTS
272 .inttab_tc0_0F2 00000000  802ffe40  802ffe40  00031658  2**0
                  CONTENTS
273 .inttab_tc0_0F3 00000000  802ffe60  802ffe60  00031658  2**0
                  CONTENTS
274 .inttab_tc0_0F4 00000000  802ffe80  802ffe80  00031658  2**0
                  CONTENTS
275 .inttab_tc0_0F5 00000000  802ffea0  802ffea0  00031658  2**0
                  CONTENTS
276 .inttab_tc0_0F6 00000000  802ffec0  802ffec0  00031658  2**0
                  CONTENTS
277 .inttab_tc0_0F7 00000000  802ffee0  802ffee0  00031658  2**0
                  CONTENTS
278 .inttab_tc0_0F8 00000000  802fff00  802fff00  00031658  2**0
                  CONTENTS
279 .inttab_tc0_0F9 00000000  802fff20  802fff20  00031658  2**0
                  CONTENTS
280 .inttab_tc0_0FA 00000000  802fff40  802fff40  00031658  2**0
                  CONTENTS
281 .inttab_tc0_0FB 00000000  802fff60  802fff60  00031658  2**0
                  CONTENTS
282 .inttab_tc0_0FC 00000000  802fff80  802fff80  00031658  2**0
                  CONTENTS
283 .inttab_tc0_0FD 00000000  802fffa0  802fffa0  00031658  2**0
                  CONTENTS
284 .inttab_tc0_0FE 00000000  802fffc0  802fffc0  00031658  2**0
                  CONTENTS
285 .inttab_tc0_0FF 00000000  802fffe0  802fffe0  00031658  2**0
                  CONTENTS
286 .inttab_tc1_000 00000000  805fe000  805fe000  00031658  2**0
                  CONTENTS
287 .inttab_tc1_001 00000000  805fe020  805fe020  00031658  2**0
                  CONTENTS
288 .inttab_tc1_002 00000000  805fe040  805fe040  00031658  2**0
                  CONTENTS
289 .inttab_tc1_003 00000000  805fe060  805fe060  00031658  2**0
                  CONTENTS
290 .inttab_tc1_004 00000000  805fe080  805fe080  00031658  2**0
                  CONTENTS
291 .inttab_tc1_005 00000000  805fe0a0  805fe0a0  00031658  2**0
                  CONTENTS
292 .inttab_tc1_006 00000000  805fe0c0  805fe0c0  00031658  2**0
                  CONTENTS
293 .inttab_tc1_007 00000000  805fe0e0  805fe0e0  00031658  2**0
                  CONTENTS
294 .inttab_tc1_008 00000000  805fe100  805fe100  00031658  2**0
                  CONTENTS
295 .inttab_tc1_009 00000000  805fe120  805fe120  00031658  2**0
                  CONTENTS
296 .inttab_tc1_00A 00000000  805fe140  805fe140  00031658  2**0
                  CONTENTS
297 .inttab_tc1_00B 00000000  805fe160  805fe160  00031658  2**0
                  CONTENTS
298 .inttab_tc1_00C 00000000  805fe180  805fe180  00031658  2**0
                  CONTENTS
299 .inttab_tc1_00D 00000000  805fe1a0  805fe1a0  00031658  2**0
                  CONTENTS
300 .inttab_tc1_00E 00000000  805fe1c0  805fe1c0  00031658  2**0
                  CONTENTS
301 .inttab_tc1_00F 00000000  805fe1e0  805fe1e0  00031658  2**0
                  CONTENTS
302 .inttab_tc1_010 00000000  805fe200  805fe200  00031658  2**0
                  CONTENTS
303 .inttab_tc1_011 00000000  805fe220  805fe220  00031658  2**0
                  CONTENTS
304 .inttab_tc1_012 00000000  805fe240  805fe240  00031658  2**0
                  CONTENTS
305 .inttab_tc1_013 00000000  805fe260  805fe260  00031658  2**0
                  CONTENTS
306 .inttab_tc1_014 00000000  805fe280  805fe280  00031658  2**0
                  CONTENTS
307 .inttab_tc1_015 00000000  805fe2a0  805fe2a0  00031658  2**0
                  CONTENTS
308 .inttab_tc1_016 00000000  805fe2c0  805fe2c0  00031658  2**0
                  CONTENTS
309 .inttab_tc1_017 00000000  805fe2e0  805fe2e0  00031658  2**0
                  CONTENTS
310 .inttab_tc1_018 00000000  805fe300  805fe300  00031658  2**0
                  CONTENTS
311 .inttab_tc1_019 00000000  805fe320  805fe320  00031658  2**0
                  CONTENTS
312 .inttab_tc1_01A 00000000  805fe340  805fe340  00031658  2**0
                  CONTENTS
313 .inttab_tc1_01B 00000000  805fe360  805fe360  00031658  2**0
                  CONTENTS
314 .inttab_tc1_01C 00000000  805fe380  805fe380  00031658  2**0
                  CONTENTS
315 .inttab_tc1_01D 00000000  805fe3a0  805fe3a0  00031658  2**0
                  CONTENTS
316 .inttab_tc1_01E 00000000  805fe3c0  805fe3c0  00031658  2**0
                  CONTENTS
317 .inttab_tc1_01F 00000000  805fe3e0  805fe3e0  00031658  2**0
                  CONTENTS
318 .inttab_tc1_020 00000000  805fe400  805fe400  00031658  2**0
                  CONTENTS
319 .inttab_tc1_021 00000000  805fe420  805fe420  00031658  2**0
                  CONTENTS
320 .inttab_tc1_022 00000000  805fe440  805fe440  00031658  2**0
                  CONTENTS
321 .inttab_tc1_023 00000000  805fe460  805fe460  00031658  2**0
                  CONTENTS
322 .inttab_tc1_024 00000000  805fe480  805fe480  00031658  2**0
                  CONTENTS
323 .inttab_tc1_025 00000000  805fe4a0  805fe4a0  00031658  2**0
                  CONTENTS
324 .inttab_tc1_026 00000000  805fe4c0  805fe4c0  00031658  2**0
                  CONTENTS
325 .inttab_tc1_027 00000000  805fe4e0  805fe4e0  00031658  2**0
                  CONTENTS
326 .inttab_tc1_028 00000000  805fe500  805fe500  00031658  2**0
                  CONTENTS
327 .inttab_tc1_029 00000000  805fe520  805fe520  00031658  2**0
                  CONTENTS
328 .inttab_tc1_02A 00000000  805fe540  805fe540  00031658  2**0
                  CONTENTS
329 .inttab_tc1_02B 00000000  805fe560  805fe560  00031658  2**0
                  CONTENTS
330 .inttab_tc1_02C 00000000  805fe580  805fe580  00031658  2**0
                  CONTENTS
331 .inttab_tc1_02D 00000000  805fe5a0  805fe5a0  00031658  2**0
                  CONTENTS
332 .inttab_tc1_02E 00000000  805fe5c0  805fe5c0  00031658  2**0
                  CONTENTS
333 .inttab_tc1_02F 00000000  805fe5e0  805fe5e0  00031658  2**0
                  CONTENTS
334 .inttab_tc1_030 00000000  805fe600  805fe600  00031658  2**0
                  CONTENTS
335 .inttab_tc1_031 00000000  805fe620  805fe620  00031658  2**0
                  CONTENTS
336 .inttab_tc1_032 00000000  805fe640  805fe640  00031658  2**0
                  CONTENTS
337 .inttab_tc1_033 00000000  805fe660  805fe660  00031658  2**0
                  CONTENTS
338 .inttab_tc1_034 00000000  805fe680  805fe680  00031658  2**0
                  CONTENTS
339 .inttab_tc1_035 00000000  805fe6a0  805fe6a0  00031658  2**0
                  CONTENTS
340 .inttab_tc1_036 00000000  805fe6c0  805fe6c0  00031658  2**0
                  CONTENTS
341 .inttab_tc1_037 00000000  805fe6e0  805fe6e0  00031658  2**0
                  CONTENTS
342 .inttab_tc1_038 00000000  805fe700  805fe700  00031658  2**0
                  CONTENTS
343 .inttab_tc1_039 00000000  805fe720  805fe720  00031658  2**0
                  CONTENTS
344 .inttab_tc1_03A 00000000  805fe740  805fe740  00031658  2**0
                  CONTENTS
345 .inttab_tc1_03B 00000000  805fe760  805fe760  00031658  2**0
                  CONTENTS
346 .inttab_tc1_03C 00000000  805fe780  805fe780  00031658  2**0
                  CONTENTS
347 .inttab_tc1_03D 00000000  805fe7a0  805fe7a0  00031658  2**0
                  CONTENTS
348 .inttab_tc1_03E 00000000  805fe7c0  805fe7c0  00031658  2**0
                  CONTENTS
349 .inttab_tc1_03F 00000000  805fe7e0  805fe7e0  00031658  2**0
                  CONTENTS
350 .inttab_tc1_040 00000000  805fe800  805fe800  00031658  2**0
                  CONTENTS
351 .inttab_tc1_041 00000000  805fe820  805fe820  00031658  2**0
                  CONTENTS
352 .inttab_tc1_042 00000000  805fe840  805fe840  00031658  2**0
                  CONTENTS
353 .inttab_tc1_043 00000000  805fe860  805fe860  00031658  2**0
                  CONTENTS
354 .inttab_tc1_044 00000000  805fe880  805fe880  00031658  2**0
                  CONTENTS
355 .inttab_tc1_045 00000000  805fe8a0  805fe8a0  00031658  2**0
                  CONTENTS
356 .inttab_tc1_046 00000000  805fe8c0  805fe8c0  00031658  2**0
                  CONTENTS
357 .inttab_tc1_047 00000000  805fe8e0  805fe8e0  00031658  2**0
                  CONTENTS
358 .inttab_tc1_048 00000000  805fe900  805fe900  00031658  2**0
                  CONTENTS
359 .inttab_tc1_049 00000000  805fe920  805fe920  00031658  2**0
                  CONTENTS
360 .inttab_tc1_04A 00000000  805fe940  805fe940  00031658  2**0
                  CONTENTS
361 .inttab_tc1_04B 00000000  805fe960  805fe960  00031658  2**0
                  CONTENTS
362 .inttab_tc1_04C 00000000  805fe980  805fe980  00031658  2**0
                  CONTENTS
363 .inttab_tc1_04D 00000000  805fe9a0  805fe9a0  00031658  2**0
                  CONTENTS
364 .inttab_tc1_04E 00000000  805fe9c0  805fe9c0  00031658  2**0
                  CONTENTS
365 .inttab_tc1_04F 00000000  805fe9e0  805fe9e0  00031658  2**0
                  CONTENTS
366 .inttab_tc1_050 00000000  805fea00  805fea00  00031658  2**0
                  CONTENTS
367 .inttab_tc1_051 00000000  805fea20  805fea20  00031658  2**0
                  CONTENTS
368 .inttab_tc1_052 00000000  805fea40  805fea40  00031658  2**0
                  CONTENTS
369 .inttab_tc1_053 00000000  805fea60  805fea60  00031658  2**0
                  CONTENTS
370 .inttab_tc1_054 00000000  805fea80  805fea80  00031658  2**0
                  CONTENTS
371 .inttab_tc1_055 00000000  805feaa0  805feaa0  00031658  2**0
                  CONTENTS
372 .inttab_tc1_056 00000000  805feac0  805feac0  00031658  2**0
                  CONTENTS
373 .inttab_tc1_057 00000000  805feae0  805feae0  00031658  2**0
                  CONTENTS
374 .inttab_tc1_058 00000000  805feb00  805feb00  00031658  2**0
                  CONTENTS
375 .inttab_tc1_059 00000000  805feb20  805feb20  00031658  2**0
                  CONTENTS
376 .inttab_tc1_05A 00000000  805feb40  805feb40  00031658  2**0
                  CONTENTS
377 .inttab_tc1_05B 00000000  805feb60  805feb60  00031658  2**0
                  CONTENTS
378 .inttab_tc1_05C 00000000  805feb80  805feb80  00031658  2**0
                  CONTENTS
379 .inttab_tc1_05D 00000000  805feba0  805feba0  00031658  2**0
                  CONTENTS
380 .inttab_tc1_05E 00000000  805febc0  805febc0  00031658  2**0
                  CONTENTS
381 .inttab_tc1_05F 00000000  805febe0  805febe0  00031658  2**0
                  CONTENTS
382 .inttab_tc1_060 00000000  805fec00  805fec00  00031658  2**0
                  CONTENTS
383 .inttab_tc1_061 00000000  805fec20  805fec20  00031658  2**0
                  CONTENTS
384 .inttab_tc1_062 00000000  805fec40  805fec40  00031658  2**0
                  CONTENTS
385 .inttab_tc1_063 00000000  805fec60  805fec60  00031658  2**0
                  CONTENTS
386 .inttab_tc1_064 00000000  805fec80  805fec80  00031658  2**0
                  CONTENTS
387 .inttab_tc1_065 00000000  805feca0  805feca0  00031658  2**0
                  CONTENTS
388 .inttab_tc1_066 00000000  805fecc0  805fecc0  00031658  2**0
                  CONTENTS
389 .inttab_tc1_067 00000000  805fece0  805fece0  00031658  2**0
                  CONTENTS
390 .inttab_tc1_068 00000000  805fed00  805fed00  00031658  2**0
                  CONTENTS
391 .inttab_tc1_069 00000000  805fed20  805fed20  00031658  2**0
                  CONTENTS
392 .inttab_tc1_06A 00000000  805fed40  805fed40  00031658  2**0
                  CONTENTS
393 .inttab_tc1_06B 00000000  805fed60  805fed60  00031658  2**0
                  CONTENTS
394 .inttab_tc1_06C 00000000  805fed80  805fed80  00031658  2**0
                  CONTENTS
395 .inttab_tc1_06D 00000000  805feda0  805feda0  00031658  2**0
                  CONTENTS
396 .inttab_tc1_06E 00000000  805fedc0  805fedc0  00031658  2**0
                  CONTENTS
397 .inttab_tc1_06F 00000000  805fede0  805fede0  00031658  2**0
                  CONTENTS
398 .inttab_tc1_070 00000000  805fee00  805fee00  00031658  2**0
                  CONTENTS
399 .inttab_tc1_071 00000000  805fee20  805fee20  00031658  2**0
                  CONTENTS
400 .inttab_tc1_072 00000000  805fee40  805fee40  00031658  2**0
                  CONTENTS
401 .inttab_tc1_073 00000000  805fee60  805fee60  00031658  2**0
                  CONTENTS
402 .inttab_tc1_074 00000000  805fee80  805fee80  00031658  2**0
                  CONTENTS
403 .inttab_tc1_075 00000000  805feea0  805feea0  00031658  2**0
                  CONTENTS
404 .inttab_tc1_076 00000000  805feec0  805feec0  00031658  2**0
                  CONTENTS
405 .inttab_tc1_077 00000000  805feee0  805feee0  00031658  2**0
                  CONTENTS
406 .inttab_tc1_078 00000000  805fef00  805fef00  00031658  2**0
                  CONTENTS
407 .inttab_tc1_079 00000000  805fef20  805fef20  00031658  2**0
                  CONTENTS
408 .inttab_tc1_07A 00000000  805fef40  805fef40  00031658  2**0
                  CONTENTS
409 .inttab_tc1_07B 00000000  805fef60  805fef60  00031658  2**0
                  CONTENTS
410 .inttab_tc1_07C 00000000  805fef80  805fef80  00031658  2**0
                  CONTENTS
411 .inttab_tc1_07D 00000000  805fefa0  805fefa0  00031658  2**0
                  CONTENTS
412 .inttab_tc1_07E 00000000  805fefc0  805fefc0  00031658  2**0
                  CONTENTS
413 .inttab_tc1_07F 00000000  805fefe0  805fefe0  00031658  2**0
                  CONTENTS
414 .inttab_tc1_080 00000000  805ff000  805ff000  00031658  2**0
                  CONTENTS
415 .inttab_tc1_081 00000000  805ff020  805ff020  00031658  2**0
                  CONTENTS
416 .inttab_tc1_082 00000000  805ff040  805ff040  00031658  2**0
                  CONTENTS
417 .inttab_tc1_083 00000000  805ff060  805ff060  00031658  2**0
                  CONTENTS
418 .inttab_tc1_084 00000000  805ff080  805ff080  00031658  2**0
                  CONTENTS
419 .inttab_tc1_085 00000000  805ff0a0  805ff0a0  00031658  2**0
                  CONTENTS
420 .inttab_tc1_086 00000000  805ff0c0  805ff0c0  00031658  2**0
                  CONTENTS
421 .inttab_tc1_087 00000000  805ff0e0  805ff0e0  00031658  2**0
                  CONTENTS
422 .inttab_tc1_088 00000000  805ff100  805ff100  00031658  2**0
                  CONTENTS
423 .inttab_tc1_089 00000000  805ff120  805ff120  00031658  2**0
                  CONTENTS
424 .inttab_tc1_08A 00000000  805ff140  805ff140  00031658  2**0
                  CONTENTS
425 .inttab_tc1_08B 00000000  805ff160  805ff160  00031658  2**0
                  CONTENTS
426 .inttab_tc1_08C 00000000  805ff180  805ff180  00031658  2**0
                  CONTENTS
427 .inttab_tc1_08D 00000000  805ff1a0  805ff1a0  00031658  2**0
                  CONTENTS
428 .inttab_tc1_08E 00000000  805ff1c0  805ff1c0  00031658  2**0
                  CONTENTS
429 .inttab_tc1_08F 00000000  805ff1e0  805ff1e0  00031658  2**0
                  CONTENTS
430 .inttab_tc1_090 00000000  805ff200  805ff200  00031658  2**0
                  CONTENTS
431 .inttab_tc1_091 00000000  805ff220  805ff220  00031658  2**0
                  CONTENTS
432 .inttab_tc1_092 00000000  805ff240  805ff240  00031658  2**0
                  CONTENTS
433 .inttab_tc1_093 00000000  805ff260  805ff260  00031658  2**0
                  CONTENTS
434 .inttab_tc1_094 00000000  805ff280  805ff280  00031658  2**0
                  CONTENTS
435 .inttab_tc1_095 00000000  805ff2a0  805ff2a0  00031658  2**0
                  CONTENTS
436 .inttab_tc1_096 00000000  805ff2c0  805ff2c0  00031658  2**0
                  CONTENTS
437 .inttab_tc1_097 00000000  805ff2e0  805ff2e0  00031658  2**0
                  CONTENTS
438 .inttab_tc1_098 00000000  805ff300  805ff300  00031658  2**0
                  CONTENTS
439 .inttab_tc1_099 00000000  805ff320  805ff320  00031658  2**0
                  CONTENTS
440 .inttab_tc1_09A 00000000  805ff340  805ff340  00031658  2**0
                  CONTENTS
441 .inttab_tc1_09B 00000000  805ff360  805ff360  00031658  2**0
                  CONTENTS
442 .inttab_tc1_09C 00000000  805ff380  805ff380  00031658  2**0
                  CONTENTS
443 .inttab_tc1_09D 00000000  805ff3a0  805ff3a0  00031658  2**0
                  CONTENTS
444 .inttab_tc1_09E 00000000  805ff3c0  805ff3c0  00031658  2**0
                  CONTENTS
445 .inttab_tc1_09F 00000000  805ff3e0  805ff3e0  00031658  2**0
                  CONTENTS
446 .inttab_tc1_0A0 00000000  805ff400  805ff400  00031658  2**0
                  CONTENTS
447 .inttab_tc1_0A1 00000000  805ff420  805ff420  00031658  2**0
                  CONTENTS
448 .inttab_tc1_0A2 00000000  805ff440  805ff440  00031658  2**0
                  CONTENTS
449 .inttab_tc1_0A3 00000000  805ff460  805ff460  00031658  2**0
                  CONTENTS
450 .inttab_tc1_0A4 00000000  805ff480  805ff480  00031658  2**0
                  CONTENTS
451 .inttab_tc1_0A5 00000000  805ff4a0  805ff4a0  00031658  2**0
                  CONTENTS
452 .inttab_tc1_0A6 00000000  805ff4c0  805ff4c0  00031658  2**0
                  CONTENTS
453 .inttab_tc1_0A7 00000000  805ff4e0  805ff4e0  00031658  2**0
                  CONTENTS
454 .inttab_tc1_0A8 00000000  805ff500  805ff500  00031658  2**0
                  CONTENTS
455 .inttab_tc1_0A9 00000000  805ff520  805ff520  00031658  2**0
                  CONTENTS
456 .inttab_tc1_0AA 00000000  805ff540  805ff540  00031658  2**0
                  CONTENTS
457 .inttab_tc1_0AB 00000000  805ff560  805ff560  00031658  2**0
                  CONTENTS
458 .inttab_tc1_0AC 00000000  805ff580  805ff580  00031658  2**0
                  CONTENTS
459 .inttab_tc1_0AD 00000000  805ff5a0  805ff5a0  00031658  2**0
                  CONTENTS
460 .inttab_tc1_0AE 00000000  805ff5c0  805ff5c0  00031658  2**0
                  CONTENTS
461 .inttab_tc1_0AF 00000000  805ff5e0  805ff5e0  00031658  2**0
                  CONTENTS
462 .inttab_tc1_0B0 00000000  805ff600  805ff600  00031658  2**0
                  CONTENTS
463 .inttab_tc1_0B1 00000000  805ff620  805ff620  00031658  2**0
                  CONTENTS
464 .inttab_tc1_0B2 00000000  805ff640  805ff640  00031658  2**0
                  CONTENTS
465 .inttab_tc1_0B3 00000000  805ff660  805ff660  00031658  2**0
                  CONTENTS
466 .inttab_tc1_0B4 00000000  805ff680  805ff680  00031658  2**0
                  CONTENTS
467 .inttab_tc1_0B5 00000000  805ff6a0  805ff6a0  00031658  2**0
                  CONTENTS
468 .inttab_tc1_0B6 00000000  805ff6c0  805ff6c0  00031658  2**0
                  CONTENTS
469 .inttab_tc1_0B7 00000000  805ff6e0  805ff6e0  00031658  2**0
                  CONTENTS
470 .inttab_tc1_0B8 00000000  805ff700  805ff700  00031658  2**0
                  CONTENTS
471 .inttab_tc1_0B9 00000000  805ff720  805ff720  00031658  2**0
                  CONTENTS
472 .inttab_tc1_0BA 00000000  805ff740  805ff740  00031658  2**0
                  CONTENTS
473 .inttab_tc1_0BB 00000000  805ff760  805ff760  00031658  2**0
                  CONTENTS
474 .inttab_tc1_0BC 00000000  805ff780  805ff780  00031658  2**0
                  CONTENTS
475 .inttab_tc1_0BD 00000000  805ff7a0  805ff7a0  00031658  2**0
                  CONTENTS
476 .inttab_tc1_0BE 00000000  805ff7c0  805ff7c0  00031658  2**0
                  CONTENTS
477 .inttab_tc1_0BF 00000000  805ff7e0  805ff7e0  00031658  2**0
                  CONTENTS
478 .inttab_tc1_0C0 00000000  805ff800  805ff800  00031658  2**0
                  CONTENTS
479 .inttab_tc1_0C1 00000000  805ff820  805ff820  00031658  2**0
                  CONTENTS
480 .inttab_tc1_0C2 00000000  805ff840  805ff840  00031658  2**0
                  CONTENTS
481 .inttab_tc1_0C3 00000000  805ff860  805ff860  00031658  2**0
                  CONTENTS
482 .inttab_tc1_0C4 00000000  805ff880  805ff880  00031658  2**0
                  CONTENTS
483 .inttab_tc1_0C5 00000000  805ff8a0  805ff8a0  00031658  2**0
                  CONTENTS
484 .inttab_tc1_0C6 00000000  805ff8c0  805ff8c0  00031658  2**0
                  CONTENTS
485 .inttab_tc1_0C7 00000000  805ff8e0  805ff8e0  00031658  2**0
                  CONTENTS
486 .inttab_tc1_0C8 00000000  805ff900  805ff900  00031658  2**0
                  CONTENTS
487 .inttab_tc1_0C9 00000000  805ff920  805ff920  00031658  2**0
                  CONTENTS
488 .inttab_tc1_0CA 00000000  805ff940  805ff940  00031658  2**0
                  CONTENTS
489 .inttab_tc1_0CB 00000000  805ff960  805ff960  00031658  2**0
                  CONTENTS
490 .inttab_tc1_0CC 00000000  805ff980  805ff980  00031658  2**0
                  CONTENTS
491 .inttab_tc1_0CD 00000000  805ff9a0  805ff9a0  00031658  2**0
                  CONTENTS
492 .inttab_tc1_0CE 00000000  805ff9c0  805ff9c0  00031658  2**0
                  CONTENTS
493 .inttab_tc1_0CF 00000000  805ff9e0  805ff9e0  00031658  2**0
                  CONTENTS
494 .inttab_tc1_0D0 00000000  805ffa00  805ffa00  00031658  2**0
                  CONTENTS
495 .inttab_tc1_0D1 00000000  805ffa20  805ffa20  00031658  2**0
                  CONTENTS
496 .inttab_tc1_0D2 00000000  805ffa40  805ffa40  00031658  2**0
                  CONTENTS
497 .inttab_tc1_0D3 00000000  805ffa60  805ffa60  00031658  2**0
                  CONTENTS
498 .inttab_tc1_0D4 00000000  805ffa80  805ffa80  00031658  2**0
                  CONTENTS
499 .inttab_tc1_0D5 00000000  805ffaa0  805ffaa0  00031658  2**0
                  CONTENTS
500 .inttab_tc1_0D6 00000000  805ffac0  805ffac0  00031658  2**0
                  CONTENTS
501 .inttab_tc1_0D7 00000000  805ffae0  805ffae0  00031658  2**0
                  CONTENTS
502 .inttab_tc1_0D8 00000000  805ffb00  805ffb00  00031658  2**0
                  CONTENTS
503 .inttab_tc1_0D9 00000000  805ffb20  805ffb20  00031658  2**0
                  CONTENTS
504 .inttab_tc1_0DA 00000000  805ffb40  805ffb40  00031658  2**0
                  CONTENTS
505 .inttab_tc1_0DB 00000000  805ffb60  805ffb60  00031658  2**0
                  CONTENTS
506 .inttab_tc1_0DC 00000000  805ffb80  805ffb80  00031658  2**0
                  CONTENTS
507 .inttab_tc1_0DD 00000000  805ffba0  805ffba0  00031658  2**0
                  CONTENTS
508 .inttab_tc1_0DE 00000000  805ffbc0  805ffbc0  00031658  2**0
                  CONTENTS
509 .inttab_tc1_0DF 00000000  805ffbe0  805ffbe0  00031658  2**0
                  CONTENTS
510 .inttab_tc1_0E0 00000000  805ffc00  805ffc00  00031658  2**0
                  CONTENTS
511 .inttab_tc1_0E1 00000000  805ffc20  805ffc20  00031658  2**0
                  CONTENTS
512 .inttab_tc1_0E2 00000000  805ffc40  805ffc40  00031658  2**0
                  CONTENTS
513 .inttab_tc1_0E3 00000000  805ffc60  805ffc60  00031658  2**0
                  CONTENTS
514 .inttab_tc1_0E4 00000000  805ffc80  805ffc80  00031658  2**0
                  CONTENTS
515 .inttab_tc1_0E5 00000000  805ffca0  805ffca0  00031658  2**0
                  CONTENTS
516 .inttab_tc1_0E6 00000000  805ffcc0  805ffcc0  00031658  2**0
                  CONTENTS
517 .inttab_tc1_0E7 00000000  805ffce0  805ffce0  00031658  2**0
                  CONTENTS
518 .inttab_tc1_0E8 00000000  805ffd00  805ffd00  00031658  2**0
                  CONTENTS
519 .inttab_tc1_0E9 00000000  805ffd20  805ffd20  00031658  2**0
                  CONTENTS
520 .inttab_tc1_0EA 00000000  805ffd40  805ffd40  00031658  2**0
                  CONTENTS
521 .inttab_tc1_0EB 00000000  805ffd60  805ffd60  00031658  2**0
                  CONTENTS
522 .inttab_tc1_0EC 00000000  805ffd80  805ffd80  00031658  2**0
                  CONTENTS
523 .inttab_tc1_0ED 00000000  805ffda0  805ffda0  00031658  2**0
                  CONTENTS
524 .inttab_tc1_0EE 00000000  805ffdc0  805ffdc0  00031658  2**0
                  CONTENTS
525 .inttab_tc1_0EF 00000000  805ffde0  805ffde0  00031658  2**0
                  CONTENTS
526 .inttab_tc1_0F0 00000000  805ffe00  805ffe00  00031658  2**0
                  CONTENTS
527 .inttab_tc1_0F1 00000000  805ffe20  805ffe20  00031658  2**0
                  CONTENTS
528 .inttab_tc1_0F2 00000000  805ffe40  805ffe40  00031658  2**0
                  CONTENTS
529 .inttab_tc1_0F3 00000000  805ffe60  805ffe60  00031658  2**0
                  CONTENTS
530 .inttab_tc1_0F4 00000000  805ffe80  805ffe80  00031658  2**0
                  CONTENTS
531 .inttab_tc1_0F5 00000000  805ffea0  805ffea0  00031658  2**0
                  CONTENTS
532 .inttab_tc1_0F6 00000000  805ffec0  805ffec0  00031658  2**0
                  CONTENTS
533 .inttab_tc1_0F7 00000000  805ffee0  805ffee0  00031658  2**0
                  CONTENTS
534 .inttab_tc1_0F8 00000000  805fff00  805fff00  00031658  2**0
                  CONTENTS
535 .inttab_tc1_0F9 00000000  805fff20  805fff20  00031658  2**0
                  CONTENTS
536 .inttab_tc1_0FA 00000000  805fff40  805fff40  00031658  2**0
                  CONTENTS
537 .inttab_tc1_0FB 00000000  805fff60  805fff60  00031658  2**0
                  CONTENTS
538 .inttab_tc1_0FC 00000000  805fff80  805fff80  00031658  2**0
                  CONTENTS
539 .inttab_tc1_0FD 00000000  805fffa0  805fffa0  00031658  2**0
                  CONTENTS
540 .inttab_tc1_0FE 00000000  805fffc0  805fffc0  00031658  2**0
                  CONTENTS
541 .inttab_tc1_0FF 00000000  805fffe0  805fffe0  00031658  2**0
                  CONTENTS
542 .inttab_tc2_000 00000000  808fe000  808fe000  00031658  2**0
                  CONTENTS
543 .inttab_tc2_001 00000000  808fe020  808fe020  00031658  2**0
                  CONTENTS
544 .inttab_tc2_002 00000000  808fe040  808fe040  00031658  2**0
                  CONTENTS
545 .inttab_tc2_003 00000000  808fe060  808fe060  00031658  2**0
                  CONTENTS
546 .inttab_tc2_004 00000000  808fe080  808fe080  00031658  2**0
                  CONTENTS
547 .inttab_tc2_005 00000000  808fe0a0  808fe0a0  00031658  2**0
                  CONTENTS
548 .inttab_tc2_006 00000000  808fe0c0  808fe0c0  00031658  2**0
                  CONTENTS
549 .inttab_tc2_007 00000000  808fe0e0  808fe0e0  00031658  2**0
                  CONTENTS
550 .inttab_tc2_008 00000000  808fe100  808fe100  00031658  2**0
                  CONTENTS
551 .inttab_tc2_009 00000000  808fe120  808fe120  00031658  2**0
                  CONTENTS
552 .inttab_tc2_00A 00000000  808fe140  808fe140  00031658  2**0
                  CONTENTS
553 .inttab_tc2_00B 00000000  808fe160  808fe160  00031658  2**0
                  CONTENTS
554 .inttab_tc2_00C 00000000  808fe180  808fe180  00031658  2**0
                  CONTENTS
555 .inttab_tc2_00D 00000000  808fe1a0  808fe1a0  00031658  2**0
                  CONTENTS
556 .inttab_tc2_00E 00000000  808fe1c0  808fe1c0  00031658  2**0
                  CONTENTS
557 .inttab_tc2_00F 00000000  808fe1e0  808fe1e0  00031658  2**0
                  CONTENTS
558 .inttab_tc2_010 00000000  808fe200  808fe200  00031658  2**0
                  CONTENTS
559 .inttab_tc2_011 00000000  808fe220  808fe220  00031658  2**0
                  CONTENTS
560 .inttab_tc2_012 00000000  808fe240  808fe240  00031658  2**0
                  CONTENTS
561 .inttab_tc2_013 00000000  808fe260  808fe260  00031658  2**0
                  CONTENTS
562 .inttab_tc2_014 00000000  808fe280  808fe280  00031658  2**0
                  CONTENTS
563 .inttab_tc2_015 00000000  808fe2a0  808fe2a0  00031658  2**0
                  CONTENTS
564 .inttab_tc2_016 00000000  808fe2c0  808fe2c0  00031658  2**0
                  CONTENTS
565 .inttab_tc2_017 00000000  808fe2e0  808fe2e0  00031658  2**0
                  CONTENTS
566 .inttab_tc2_018 00000000  808fe300  808fe300  00031658  2**0
                  CONTENTS
567 .inttab_tc2_019 00000000  808fe320  808fe320  00031658  2**0
                  CONTENTS
568 .inttab_tc2_01A 00000000  808fe340  808fe340  00031658  2**0
                  CONTENTS
569 .inttab_tc2_01B 00000000  808fe360  808fe360  00031658  2**0
                  CONTENTS
570 .inttab_tc2_01C 00000000  808fe380  808fe380  00031658  2**0
                  CONTENTS
571 .inttab_tc2_01D 00000000  808fe3a0  808fe3a0  00031658  2**0
                  CONTENTS
572 .inttab_tc2_01E 00000000  808fe3c0  808fe3c0  00031658  2**0
                  CONTENTS
573 .inttab_tc2_01F 00000000  808fe3e0  808fe3e0  00031658  2**0
                  CONTENTS
574 .inttab_tc2_020 00000000  808fe400  808fe400  00031658  2**0
                  CONTENTS
575 .inttab_tc2_021 00000000  808fe420  808fe420  00031658  2**0
                  CONTENTS
576 .inttab_tc2_022 00000000  808fe440  808fe440  00031658  2**0
                  CONTENTS
577 .inttab_tc2_023 00000000  808fe460  808fe460  00031658  2**0
                  CONTENTS
578 .inttab_tc2_024 00000000  808fe480  808fe480  00031658  2**0
                  CONTENTS
579 .inttab_tc2_025 00000000  808fe4a0  808fe4a0  00031658  2**0
                  CONTENTS
580 .inttab_tc2_026 00000000  808fe4c0  808fe4c0  00031658  2**0
                  CONTENTS
581 .inttab_tc2_027 00000000  808fe4e0  808fe4e0  00031658  2**0
                  CONTENTS
582 .inttab_tc2_028 00000000  808fe500  808fe500  00031658  2**0
                  CONTENTS
583 .inttab_tc2_029 00000000  808fe520  808fe520  00031658  2**0
                  CONTENTS
584 .inttab_tc2_02A 00000000  808fe540  808fe540  00031658  2**0
                  CONTENTS
585 .inttab_tc2_02B 00000000  808fe560  808fe560  00031658  2**0
                  CONTENTS
586 .inttab_tc2_02C 00000000  808fe580  808fe580  00031658  2**0
                  CONTENTS
587 .inttab_tc2_02D 00000000  808fe5a0  808fe5a0  00031658  2**0
                  CONTENTS
588 .inttab_tc2_02E 00000000  808fe5c0  808fe5c0  00031658  2**0
                  CONTENTS
589 .inttab_tc2_02F 00000000  808fe5e0  808fe5e0  00031658  2**0
                  CONTENTS
590 .inttab_tc2_030 00000000  808fe600  808fe600  00031658  2**0
                  CONTENTS
591 .inttab_tc2_031 00000000  808fe620  808fe620  00031658  2**0
                  CONTENTS
592 .inttab_tc2_032 00000000  808fe640  808fe640  00031658  2**0
                  CONTENTS
593 .inttab_tc2_033 00000000  808fe660  808fe660  00031658  2**0
                  CONTENTS
594 .inttab_tc2_034 00000000  808fe680  808fe680  00031658  2**0
                  CONTENTS
595 .inttab_tc2_035 00000000  808fe6a0  808fe6a0  00031658  2**0
                  CONTENTS
596 .inttab_tc2_036 00000000  808fe6c0  808fe6c0  00031658  2**0
                  CONTENTS
597 .inttab_tc2_037 00000000  808fe6e0  808fe6e0  00031658  2**0
                  CONTENTS
598 .inttab_tc2_038 00000000  808fe700  808fe700  00031658  2**0
                  CONTENTS
599 .inttab_tc2_039 00000000  808fe720  808fe720  00031658  2**0
                  CONTENTS
600 .inttab_tc2_03A 00000000  808fe740  808fe740  00031658  2**0
                  CONTENTS
601 .inttab_tc2_03B 00000000  808fe760  808fe760  00031658  2**0
                  CONTENTS
602 .inttab_tc2_03C 00000000  808fe780  808fe780  00031658  2**0
                  CONTENTS
603 .inttab_tc2_03D 00000000  808fe7a0  808fe7a0  00031658  2**0
                  CONTENTS
604 .inttab_tc2_03E 00000000  808fe7c0  808fe7c0  00031658  2**0
                  CONTENTS
605 .inttab_tc2_03F 00000000  808fe7e0  808fe7e0  00031658  2**0
                  CONTENTS
606 .inttab_tc2_040 00000000  808fe800  808fe800  00031658  2**0
                  CONTENTS
607 .inttab_tc2_041 00000000  808fe820  808fe820  00031658  2**0
                  CONTENTS
608 .inttab_tc2_042 00000000  808fe840  808fe840  00031658  2**0
                  CONTENTS
609 .inttab_tc2_043 00000000  808fe860  808fe860  00031658  2**0
                  CONTENTS
610 .inttab_tc2_044 00000000  808fe880  808fe880  00031658  2**0
                  CONTENTS
611 .inttab_tc2_045 00000000  808fe8a0  808fe8a0  00031658  2**0
                  CONTENTS
612 .inttab_tc2_046 00000000  808fe8c0  808fe8c0  00031658  2**0
                  CONTENTS
613 .inttab_tc2_047 00000000  808fe8e0  808fe8e0  00031658  2**0
                  CONTENTS
614 .inttab_tc2_048 00000000  808fe900  808fe900  00031658  2**0
                  CONTENTS
615 .inttab_tc2_049 00000000  808fe920  808fe920  00031658  2**0
                  CONTENTS
616 .inttab_tc2_04A 00000000  808fe940  808fe940  00031658  2**0
                  CONTENTS
617 .inttab_tc2_04B 00000000  808fe960  808fe960  00031658  2**0
                  CONTENTS
618 .inttab_tc2_04C 00000000  808fe980  808fe980  00031658  2**0
                  CONTENTS
619 .inttab_tc2_04D 00000000  808fe9a0  808fe9a0  00031658  2**0
                  CONTENTS
620 .inttab_tc2_04E 00000000  808fe9c0  808fe9c0  00031658  2**0
                  CONTENTS
621 .inttab_tc2_04F 00000000  808fe9e0  808fe9e0  00031658  2**0
                  CONTENTS
622 .inttab_tc2_050 00000000  808fea00  808fea00  00031658  2**0
                  CONTENTS
623 .inttab_tc2_051 00000000  808fea20  808fea20  00031658  2**0
                  CONTENTS
624 .inttab_tc2_052 00000000  808fea40  808fea40  00031658  2**0
                  CONTENTS
625 .inttab_tc2_053 00000000  808fea60  808fea60  00031658  2**0
                  CONTENTS
626 .inttab_tc2_054 00000000  808fea80  808fea80  00031658  2**0
                  CONTENTS
627 .inttab_tc2_055 00000000  808feaa0  808feaa0  00031658  2**0
                  CONTENTS
628 .inttab_tc2_056 00000000  808feac0  808feac0  00031658  2**0
                  CONTENTS
629 .inttab_tc2_057 00000000  808feae0  808feae0  00031658  2**0
                  CONTENTS
630 .inttab_tc2_058 00000000  808feb00  808feb00  00031658  2**0
                  CONTENTS
631 .inttab_tc2_059 00000000  808feb20  808feb20  00031658  2**0
                  CONTENTS
632 .inttab_tc2_05A 00000000  808feb40  808feb40  00031658  2**0
                  CONTENTS
633 .inttab_tc2_05B 00000000  808feb60  808feb60  00031658  2**0
                  CONTENTS
634 .inttab_tc2_05C 00000000  808feb80  808feb80  00031658  2**0
                  CONTENTS
635 .inttab_tc2_05D 00000000  808feba0  808feba0  00031658  2**0
                  CONTENTS
636 .inttab_tc2_05E 00000000  808febc0  808febc0  00031658  2**0
                  CONTENTS
637 .inttab_tc2_05F 00000000  808febe0  808febe0  00031658  2**0
                  CONTENTS
638 .inttab_tc2_060 00000000  808fec00  808fec00  00031658  2**0
                  CONTENTS
639 .inttab_tc2_061 00000000  808fec20  808fec20  00031658  2**0
                  CONTENTS
640 .inttab_tc2_062 00000000  808fec40  808fec40  00031658  2**0
                  CONTENTS
641 .inttab_tc2_063 00000000  808fec60  808fec60  00031658  2**0
                  CONTENTS
642 .inttab_tc2_064 00000000  808fec80  808fec80  00031658  2**0
                  CONTENTS
643 .inttab_tc2_065 00000000  808feca0  808feca0  00031658  2**0
                  CONTENTS
644 .inttab_tc2_066 00000000  808fecc0  808fecc0  00031658  2**0
                  CONTENTS
645 .inttab_tc2_067 00000000  808fece0  808fece0  00031658  2**0
                  CONTENTS
646 .inttab_tc2_068 00000000  808fed00  808fed00  00031658  2**0
                  CONTENTS
647 .inttab_tc2_069 00000000  808fed20  808fed20  00031658  2**0
                  CONTENTS
648 .inttab_tc2_06A 00000000  808fed40  808fed40  00031658  2**0
                  CONTENTS
649 .inttab_tc2_06B 00000000  808fed60  808fed60  00031658  2**0
                  CONTENTS
650 .inttab_tc2_06C 00000000  808fed80  808fed80  00031658  2**0
                  CONTENTS
651 .inttab_tc2_06D 00000000  808feda0  808feda0  00031658  2**0
                  CONTENTS
652 .inttab_tc2_06E 00000000  808fedc0  808fedc0  00031658  2**0
                  CONTENTS
653 .inttab_tc2_06F 00000000  808fede0  808fede0  00031658  2**0
                  CONTENTS
654 .inttab_tc2_070 00000000  808fee00  808fee00  00031658  2**0
                  CONTENTS
655 .inttab_tc2_071 00000000  808fee20  808fee20  00031658  2**0
                  CONTENTS
656 .inttab_tc2_072 00000000  808fee40  808fee40  00031658  2**0
                  CONTENTS
657 .inttab_tc2_073 00000000  808fee60  808fee60  00031658  2**0
                  CONTENTS
658 .inttab_tc2_074 00000000  808fee80  808fee80  00031658  2**0
                  CONTENTS
659 .inttab_tc2_075 00000000  808feea0  808feea0  00031658  2**0
                  CONTENTS
660 .inttab_tc2_076 00000000  808feec0  808feec0  00031658  2**0
                  CONTENTS
661 .inttab_tc2_077 00000000  808feee0  808feee0  00031658  2**0
                  CONTENTS
662 .inttab_tc2_078 00000000  808fef00  808fef00  00031658  2**0
                  CONTENTS
663 .inttab_tc2_079 00000000  808fef20  808fef20  00031658  2**0
                  CONTENTS
664 .inttab_tc2_07A 00000000  808fef40  808fef40  00031658  2**0
                  CONTENTS
665 .inttab_tc2_07B 00000000  808fef60  808fef60  00031658  2**0
                  CONTENTS
666 .inttab_tc2_07C 00000000  808fef80  808fef80  00031658  2**0
                  CONTENTS
667 .inttab_tc2_07D 00000000  808fefa0  808fefa0  00031658  2**0
                  CONTENTS
668 .inttab_tc2_07E 00000000  808fefc0  808fefc0  00031658  2**0
                  CONTENTS
669 .inttab_tc2_07F 00000000  808fefe0  808fefe0  00031658  2**0
                  CONTENTS
670 .inttab_tc2_080 00000000  808ff000  808ff000  00031658  2**0
                  CONTENTS
671 .inttab_tc2_081 00000000  808ff020  808ff020  00031658  2**0
                  CONTENTS
672 .inttab_tc2_082 00000000  808ff040  808ff040  00031658  2**0
                  CONTENTS
673 .inttab_tc2_083 00000000  808ff060  808ff060  00031658  2**0
                  CONTENTS
674 .inttab_tc2_084 00000000  808ff080  808ff080  00031658  2**0
                  CONTENTS
675 .inttab_tc2_085 00000000  808ff0a0  808ff0a0  00031658  2**0
                  CONTENTS
676 .inttab_tc2_086 00000000  808ff0c0  808ff0c0  00031658  2**0
                  CONTENTS
677 .inttab_tc2_087 00000000  808ff0e0  808ff0e0  00031658  2**0
                  CONTENTS
678 .inttab_tc2_088 00000000  808ff100  808ff100  00031658  2**0
                  CONTENTS
679 .inttab_tc2_089 00000000  808ff120  808ff120  00031658  2**0
                  CONTENTS
680 .inttab_tc2_08A 00000000  808ff140  808ff140  00031658  2**0
                  CONTENTS
681 .inttab_tc2_08B 00000000  808ff160  808ff160  00031658  2**0
                  CONTENTS
682 .inttab_tc2_08C 00000000  808ff180  808ff180  00031658  2**0
                  CONTENTS
683 .inttab_tc2_08D 00000000  808ff1a0  808ff1a0  00031658  2**0
                  CONTENTS
684 .inttab_tc2_08E 00000000  808ff1c0  808ff1c0  00031658  2**0
                  CONTENTS
685 .inttab_tc2_08F 00000000  808ff1e0  808ff1e0  00031658  2**0
                  CONTENTS
686 .inttab_tc2_090 00000000  808ff200  808ff200  00031658  2**0
                  CONTENTS
687 .inttab_tc2_091 00000000  808ff220  808ff220  00031658  2**0
                  CONTENTS
688 .inttab_tc2_092 00000000  808ff240  808ff240  00031658  2**0
                  CONTENTS
689 .inttab_tc2_093 00000000  808ff260  808ff260  00031658  2**0
                  CONTENTS
690 .inttab_tc2_094 00000000  808ff280  808ff280  00031658  2**0
                  CONTENTS
691 .inttab_tc2_095 00000000  808ff2a0  808ff2a0  00031658  2**0
                  CONTENTS
692 .inttab_tc2_096 00000000  808ff2c0  808ff2c0  00031658  2**0
                  CONTENTS
693 .inttab_tc2_097 00000000  808ff2e0  808ff2e0  00031658  2**0
                  CONTENTS
694 .inttab_tc2_098 00000000  808ff300  808ff300  00031658  2**0
                  CONTENTS
695 .inttab_tc2_099 00000000  808ff320  808ff320  00031658  2**0
                  CONTENTS
696 .inttab_tc2_09A 00000000  808ff340  808ff340  00031658  2**0
                  CONTENTS
697 .inttab_tc2_09B 00000000  808ff360  808ff360  00031658  2**0
                  CONTENTS
698 .inttab_tc2_09C 00000000  808ff380  808ff380  00031658  2**0
                  CONTENTS
699 .inttab_tc2_09D 00000000  808ff3a0  808ff3a0  00031658  2**0
                  CONTENTS
700 .inttab_tc2_09E 00000000  808ff3c0  808ff3c0  00031658  2**0
                  CONTENTS
701 .inttab_tc2_09F 00000000  808ff3e0  808ff3e0  00031658  2**0
                  CONTENTS
702 .inttab_tc2_0A0 00000000  808ff400  808ff400  00031658  2**0
                  CONTENTS
703 .inttab_tc2_0A1 00000000  808ff420  808ff420  00031658  2**0
                  CONTENTS
704 .inttab_tc2_0A2 00000000  808ff440  808ff440  00031658  2**0
                  CONTENTS
705 .inttab_tc2_0A3 00000000  808ff460  808ff460  00031658  2**0
                  CONTENTS
706 .inttab_tc2_0A4 00000000  808ff480  808ff480  00031658  2**0
                  CONTENTS
707 .inttab_tc2_0A5 00000000  808ff4a0  808ff4a0  00031658  2**0
                  CONTENTS
708 .inttab_tc2_0A6 00000000  808ff4c0  808ff4c0  00031658  2**0
                  CONTENTS
709 .inttab_tc2_0A7 00000000  808ff4e0  808ff4e0  00031658  2**0
                  CONTENTS
710 .inttab_tc2_0A8 00000000  808ff500  808ff500  00031658  2**0
                  CONTENTS
711 .inttab_tc2_0A9 00000000  808ff520  808ff520  00031658  2**0
                  CONTENTS
712 .inttab_tc2_0AA 00000000  808ff540  808ff540  00031658  2**0
                  CONTENTS
713 .inttab_tc2_0AB 00000000  808ff560  808ff560  00031658  2**0
                  CONTENTS
714 .inttab_tc2_0AC 00000000  808ff580  808ff580  00031658  2**0
                  CONTENTS
715 .inttab_tc2_0AD 00000000  808ff5a0  808ff5a0  00031658  2**0
                  CONTENTS
716 .inttab_tc2_0AE 00000000  808ff5c0  808ff5c0  00031658  2**0
                  CONTENTS
717 .inttab_tc2_0AF 00000000  808ff5e0  808ff5e0  00031658  2**0
                  CONTENTS
718 .inttab_tc2_0B0 00000000  808ff600  808ff600  00031658  2**0
                  CONTENTS
719 .inttab_tc2_0B1 00000000  808ff620  808ff620  00031658  2**0
                  CONTENTS
720 .inttab_tc2_0B2 00000000  808ff640  808ff640  00031658  2**0
                  CONTENTS
721 .inttab_tc2_0B3 00000000  808ff660  808ff660  00031658  2**0
                  CONTENTS
722 .inttab_tc2_0B4 00000000  808ff680  808ff680  00031658  2**0
                  CONTENTS
723 .inttab_tc2_0B5 00000000  808ff6a0  808ff6a0  00031658  2**0
                  CONTENTS
724 .inttab_tc2_0B6 00000000  808ff6c0  808ff6c0  00031658  2**0
                  CONTENTS
725 .inttab_tc2_0B7 00000000  808ff6e0  808ff6e0  00031658  2**0
                  CONTENTS
726 .inttab_tc2_0B8 00000000  808ff700  808ff700  00031658  2**0
                  CONTENTS
727 .inttab_tc2_0B9 00000000  808ff720  808ff720  00031658  2**0
                  CONTENTS
728 .inttab_tc2_0BA 00000000  808ff740  808ff740  00031658  2**0
                  CONTENTS
729 .inttab_tc2_0BB 00000000  808ff760  808ff760  00031658  2**0
                  CONTENTS
730 .inttab_tc2_0BC 00000000  808ff780  808ff780  00031658  2**0
                  CONTENTS
731 .inttab_tc2_0BD 00000000  808ff7a0  808ff7a0  00031658  2**0
                  CONTENTS
732 .inttab_tc2_0BE 00000000  808ff7c0  808ff7c0  00031658  2**0
                  CONTENTS
733 .inttab_tc2_0BF 00000000  808ff7e0  808ff7e0  00031658  2**0
                  CONTENTS
734 .inttab_tc2_0C0 00000000  808ff800  808ff800  00031658  2**0
                  CONTENTS
735 .inttab_tc2_0C1 00000000  808ff820  808ff820  00031658  2**0
                  CONTENTS
736 .inttab_tc2_0C2 00000000  808ff840  808ff840  00031658  2**0
                  CONTENTS
737 .inttab_tc2_0C3 00000000  808ff860  808ff860  00031658  2**0
                  CONTENTS
738 .inttab_tc2_0C4 00000000  808ff880  808ff880  00031658  2**0
                  CONTENTS
739 .inttab_tc2_0C5 00000000  808ff8a0  808ff8a0  00031658  2**0
                  CONTENTS
740 .inttab_tc2_0C6 00000000  808ff8c0  808ff8c0  00031658  2**0
                  CONTENTS
741 .inttab_tc2_0C7 00000000  808ff8e0  808ff8e0  00031658  2**0
                  CONTENTS
742 .inttab_tc2_0C8 00000000  808ff900  808ff900  00031658  2**0
                  CONTENTS
743 .inttab_tc2_0C9 00000000  808ff920  808ff920  00031658  2**0
                  CONTENTS
744 .inttab_tc2_0CA 00000000  808ff940  808ff940  00031658  2**0
                  CONTENTS
745 .inttab_tc2_0CB 00000000  808ff960  808ff960  00031658  2**0
                  CONTENTS
746 .inttab_tc2_0CC 00000000  808ff980  808ff980  00031658  2**0
                  CONTENTS
747 .inttab_tc2_0CD 00000000  808ff9a0  808ff9a0  00031658  2**0
                  CONTENTS
748 .inttab_tc2_0CE 00000000  808ff9c0  808ff9c0  00031658  2**0
                  CONTENTS
749 .inttab_tc2_0CF 00000000  808ff9e0  808ff9e0  00031658  2**0
                  CONTENTS
750 .inttab_tc2_0D0 00000000  808ffa00  808ffa00  00031658  2**0
                  CONTENTS
751 .inttab_tc2_0D1 00000000  808ffa20  808ffa20  00031658  2**0
                  CONTENTS
752 .inttab_tc2_0D2 00000000  808ffa40  808ffa40  00031658  2**0
                  CONTENTS
753 .inttab_tc2_0D3 00000000  808ffa60  808ffa60  00031658  2**0
                  CONTENTS
754 .inttab_tc2_0D4 00000000  808ffa80  808ffa80  00031658  2**0
                  CONTENTS
755 .inttab_tc2_0D5 00000000  808ffaa0  808ffaa0  00031658  2**0
                  CONTENTS
756 .inttab_tc2_0D6 00000000  808ffac0  808ffac0  00031658  2**0
                  CONTENTS
757 .inttab_tc2_0D7 00000000  808ffae0  808ffae0  00031658  2**0
                  CONTENTS
758 .inttab_tc2_0D8 00000000  808ffb00  808ffb00  00031658  2**0
                  CONTENTS
759 .inttab_tc2_0D9 00000000  808ffb20  808ffb20  00031658  2**0
                  CONTENTS
760 .inttab_tc2_0DA 00000000  808ffb40  808ffb40  00031658  2**0
                  CONTENTS
761 .inttab_tc2_0DB 00000000  808ffb60  808ffb60  00031658  2**0
                  CONTENTS
762 .inttab_tc2_0DC 00000000  808ffb80  808ffb80  00031658  2**0
                  CONTENTS
763 .inttab_tc2_0DD 00000000  808ffba0  808ffba0  00031658  2**0
                  CONTENTS
764 .inttab_tc2_0DE 00000000  808ffbc0  808ffbc0  00031658  2**0
                  CONTENTS
765 .inttab_tc2_0DF 00000000  808ffbe0  808ffbe0  00031658  2**0
                  CONTENTS
766 .inttab_tc2_0E0 00000000  808ffc00  808ffc00  00031658  2**0
                  CONTENTS
767 .inttab_tc2_0E1 00000000  808ffc20  808ffc20  00031658  2**0
                  CONTENTS
768 .inttab_tc2_0E2 00000000  808ffc40  808ffc40  00031658  2**0
                  CONTENTS
769 .inttab_tc2_0E3 00000000  808ffc60  808ffc60  00031658  2**0
                  CONTENTS
770 .inttab_tc2_0E4 00000000  808ffc80  808ffc80  00031658  2**0
                  CONTENTS
771 .inttab_tc2_0E5 00000000  808ffca0  808ffca0  00031658  2**0
                  CONTENTS
772 .inttab_tc2_0E6 00000000  808ffcc0  808ffcc0  00031658  2**0
                  CONTENTS
773 .inttab_tc2_0E7 00000000  808ffce0  808ffce0  00031658  2**0
                  CONTENTS
774 .inttab_tc2_0E8 00000000  808ffd00  808ffd00  00031658  2**0
                  CONTENTS
775 .inttab_tc2_0E9 00000000  808ffd20  808ffd20  00031658  2**0
                  CONTENTS
776 .inttab_tc2_0EA 00000000  808ffd40  808ffd40  00031658  2**0
                  CONTENTS
777 .inttab_tc2_0EB 00000000  808ffd60  808ffd60  00031658  2**0
                  CONTENTS
778 .inttab_tc2_0EC 00000000  808ffd80  808ffd80  00031658  2**0
                  CONTENTS
779 .inttab_tc2_0ED 00000000  808ffda0  808ffda0  00031658  2**0
                  CONTENTS
780 .inttab_tc2_0EE 00000000  808ffdc0  808ffdc0  00031658  2**0
                  CONTENTS
781 .inttab_tc2_0EF 00000000  808ffde0  808ffde0  00031658  2**0
                  CONTENTS
782 .inttab_tc2_0F0 00000000  808ffe00  808ffe00  00031658  2**0
                  CONTENTS
783 .inttab_tc2_0F1 00000000  808ffe20  808ffe20  00031658  2**0
                  CONTENTS
784 .inttab_tc2_0F2 00000000  808ffe40  808ffe40  00031658  2**0
                  CONTENTS
785 .inttab_tc2_0F3 00000000  808ffe60  808ffe60  00031658  2**0
                  CONTENTS
786 .inttab_tc2_0F4 00000000  808ffe80  808ffe80  00031658  2**0
                  CONTENTS
787 .inttab_tc2_0F5 00000000  808ffea0  808ffea0  00031658  2**0
                  CONTENTS
788 .inttab_tc2_0F6 00000000  808ffec0  808ffec0  00031658  2**0
                  CONTENTS
789 .inttab_tc2_0F7 00000000  808ffee0  808ffee0  00031658  2**0
                  CONTENTS
790 .inttab_tc2_0F8 00000000  808fff00  808fff00  00031658  2**0
                  CONTENTS
791 .inttab_tc2_0F9 00000000  808fff20  808fff20  00031658  2**0
                  CONTENTS
792 .inttab_tc2_0FA 00000000  808fff40  808fff40  00031658  2**0
                  CONTENTS
793 .inttab_tc2_0FB 00000000  808fff60  808fff60  00031658  2**0
                  CONTENTS
794 .inttab_tc2_0FC 00000000  808fff80  808fff80  00031658  2**0
                  CONTENTS
795 .inttab_tc2_0FD 00000000  808fffa0  808fffa0  00031658  2**0
                  CONTENTS
796 .inttab_tc2_0FE 00000000  808fffc0  808fffc0  00031658  2**0
                  CONTENTS
797 .inttab_tc2_0FF 00000000  808fffe0  808fffe0  00031658  2**0
                  CONTENTS
798 .inttab_tc3_000 00000000  80bfe000  80bfe000  00031658  2**0
                  CONTENTS
799 .inttab_tc3_001 00000000  80bfe020  80bfe020  00031658  2**0
                  CONTENTS
800 .inttab_tc3_002 00000000  80bfe040  80bfe040  00031658  2**0
                  CONTENTS
801 .inttab_tc3_003 00000000  80bfe060  80bfe060  00031658  2**0
                  CONTENTS
802 .inttab_tc3_004 00000000  80bfe080  80bfe080  00031658  2**0
                  CONTENTS
803 .inttab_tc3_005 00000000  80bfe0a0  80bfe0a0  00031658  2**0
                  CONTENTS
804 .inttab_tc3_006 00000000  80bfe0c0  80bfe0c0  00031658  2**0
                  CONTENTS
805 .inttab_tc3_007 00000000  80bfe0e0  80bfe0e0  00031658  2**0
                  CONTENTS
806 .inttab_tc3_008 00000000  80bfe100  80bfe100  00031658  2**0
                  CONTENTS
807 .inttab_tc3_009 00000000  80bfe120  80bfe120  00031658  2**0
                  CONTENTS
808 .inttab_tc3_00A 00000000  80bfe140  80bfe140  00031658  2**0
                  CONTENTS
809 .inttab_tc3_00B 00000000  80bfe160  80bfe160  00031658  2**0
                  CONTENTS
810 .inttab_tc3_00C 00000000  80bfe180  80bfe180  00031658  2**0
                  CONTENTS
811 .inttab_tc3_00D 00000000  80bfe1a0  80bfe1a0  00031658  2**0
                  CONTENTS
812 .inttab_tc3_00E 00000000  80bfe1c0  80bfe1c0  00031658  2**0
                  CONTENTS
813 .inttab_tc3_00F 00000000  80bfe1e0  80bfe1e0  00031658  2**0
                  CONTENTS
814 .inttab_tc3_010 00000000  80bfe200  80bfe200  00031658  2**0
                  CONTENTS
815 .inttab_tc3_011 00000000  80bfe220  80bfe220  00031658  2**0
                  CONTENTS
816 .inttab_tc3_012 00000000  80bfe240  80bfe240  00031658  2**0
                  CONTENTS
817 .inttab_tc3_013 00000000  80bfe260  80bfe260  00031658  2**0
                  CONTENTS
818 .inttab_tc3_014 00000000  80bfe280  80bfe280  00031658  2**0
                  CONTENTS
819 .inttab_tc3_015 00000000  80bfe2a0  80bfe2a0  00031658  2**0
                  CONTENTS
820 .inttab_tc3_016 00000000  80bfe2c0  80bfe2c0  00031658  2**0
                  CONTENTS
821 .inttab_tc3_017 00000000  80bfe2e0  80bfe2e0  00031658  2**0
                  CONTENTS
822 .inttab_tc3_018 00000000  80bfe300  80bfe300  00031658  2**0
                  CONTENTS
823 .inttab_tc3_019 00000000  80bfe320  80bfe320  00031658  2**0
                  CONTENTS
824 .inttab_tc3_01A 00000000  80bfe340  80bfe340  00031658  2**0
                  CONTENTS
825 .inttab_tc3_01B 00000000  80bfe360  80bfe360  00031658  2**0
                  CONTENTS
826 .inttab_tc3_01C 00000000  80bfe380  80bfe380  00031658  2**0
                  CONTENTS
827 .inttab_tc3_01D 00000000  80bfe3a0  80bfe3a0  00031658  2**0
                  CONTENTS
828 .inttab_tc3_01E 00000000  80bfe3c0  80bfe3c0  00031658  2**0
                  CONTENTS
829 .inttab_tc3_01F 00000000  80bfe3e0  80bfe3e0  00031658  2**0
                  CONTENTS
830 .inttab_tc3_020 00000000  80bfe400  80bfe400  00031658  2**0
                  CONTENTS
831 .inttab_tc3_021 00000000  80bfe420  80bfe420  00031658  2**0
                  CONTENTS
832 .inttab_tc3_022 00000000  80bfe440  80bfe440  00031658  2**0
                  CONTENTS
833 .inttab_tc3_023 00000000  80bfe460  80bfe460  00031658  2**0
                  CONTENTS
834 .inttab_tc3_024 00000000  80bfe480  80bfe480  00031658  2**0
                  CONTENTS
835 .inttab_tc3_025 00000000  80bfe4a0  80bfe4a0  00031658  2**0
                  CONTENTS
836 .inttab_tc3_026 00000000  80bfe4c0  80bfe4c0  00031658  2**0
                  CONTENTS
837 .inttab_tc3_027 00000000  80bfe4e0  80bfe4e0  00031658  2**0
                  CONTENTS
838 .inttab_tc3_028 00000000  80bfe500  80bfe500  00031658  2**0
                  CONTENTS
839 .inttab_tc3_029 00000000  80bfe520  80bfe520  00031658  2**0
                  CONTENTS
840 .inttab_tc3_02A 00000000  80bfe540  80bfe540  00031658  2**0
                  CONTENTS
841 .inttab_tc3_02B 00000000  80bfe560  80bfe560  00031658  2**0
                  CONTENTS
842 .inttab_tc3_02C 00000000  80bfe580  80bfe580  00031658  2**0
                  CONTENTS
843 .inttab_tc3_02D 00000000  80bfe5a0  80bfe5a0  00031658  2**0
                  CONTENTS
844 .inttab_tc3_02E 00000000  80bfe5c0  80bfe5c0  00031658  2**0
                  CONTENTS
845 .inttab_tc3_02F 00000000  80bfe5e0  80bfe5e0  00031658  2**0
                  CONTENTS
846 .inttab_tc3_030 00000000  80bfe600  80bfe600  00031658  2**0
                  CONTENTS
847 .inttab_tc3_031 00000000  80bfe620  80bfe620  00031658  2**0
                  CONTENTS
848 .inttab_tc3_032 00000000  80bfe640  80bfe640  00031658  2**0
                  CONTENTS
849 .inttab_tc3_033 00000000  80bfe660  80bfe660  00031658  2**0
                  CONTENTS
850 .inttab_tc3_034 00000000  80bfe680  80bfe680  00031658  2**0
                  CONTENTS
851 .inttab_tc3_035 00000000  80bfe6a0  80bfe6a0  00031658  2**0
                  CONTENTS
852 .inttab_tc3_036 00000000  80bfe6c0  80bfe6c0  00031658  2**0
                  CONTENTS
853 .inttab_tc3_037 00000000  80bfe6e0  80bfe6e0  00031658  2**0
                  CONTENTS
854 .inttab_tc3_038 00000000  80bfe700  80bfe700  00031658  2**0
                  CONTENTS
855 .inttab_tc3_039 00000000  80bfe720  80bfe720  00031658  2**0
                  CONTENTS
856 .inttab_tc3_03A 00000000  80bfe740  80bfe740  00031658  2**0
                  CONTENTS
857 .inttab_tc3_03B 00000000  80bfe760  80bfe760  00031658  2**0
                  CONTENTS
858 .inttab_tc3_03C 00000000  80bfe780  80bfe780  00031658  2**0
                  CONTENTS
859 .inttab_tc3_03D 00000000  80bfe7a0  80bfe7a0  00031658  2**0
                  CONTENTS
860 .inttab_tc3_03E 00000000  80bfe7c0  80bfe7c0  00031658  2**0
                  CONTENTS
861 .inttab_tc3_03F 00000000  80bfe7e0  80bfe7e0  00031658  2**0
                  CONTENTS
862 .inttab_tc3_040 00000000  80bfe800  80bfe800  00031658  2**0
                  CONTENTS
863 .inttab_tc3_041 00000000  80bfe820  80bfe820  00031658  2**0
                  CONTENTS
864 .inttab_tc3_042 00000000  80bfe840  80bfe840  00031658  2**0
                  CONTENTS
865 .inttab_tc3_043 00000000  80bfe860  80bfe860  00031658  2**0
                  CONTENTS
866 .inttab_tc3_044 00000000  80bfe880  80bfe880  00031658  2**0
                  CONTENTS
867 .inttab_tc3_045 00000000  80bfe8a0  80bfe8a0  00031658  2**0
                  CONTENTS
868 .inttab_tc3_046 00000000  80bfe8c0  80bfe8c0  00031658  2**0
                  CONTENTS
869 .inttab_tc3_047 00000000  80bfe8e0  80bfe8e0  00031658  2**0
                  CONTENTS
870 .inttab_tc3_048 00000000  80bfe900  80bfe900  00031658  2**0
                  CONTENTS
871 .inttab_tc3_049 00000000  80bfe920  80bfe920  00031658  2**0
                  CONTENTS
872 .inttab_tc3_04A 00000000  80bfe940  80bfe940  00031658  2**0
                  CONTENTS
873 .inttab_tc3_04B 00000000  80bfe960  80bfe960  00031658  2**0
                  CONTENTS
874 .inttab_tc3_04C 00000000  80bfe980  80bfe980  00031658  2**0
                  CONTENTS
875 .inttab_tc3_04D 00000000  80bfe9a0  80bfe9a0  00031658  2**0
                  CONTENTS
876 .inttab_tc3_04E 00000000  80bfe9c0  80bfe9c0  00031658  2**0
                  CONTENTS
877 .inttab_tc3_04F 00000000  80bfe9e0  80bfe9e0  00031658  2**0
                  CONTENTS
878 .inttab_tc3_050 00000000  80bfea00  80bfea00  00031658  2**0
                  CONTENTS
879 .inttab_tc3_051 00000000  80bfea20  80bfea20  00031658  2**0
                  CONTENTS
880 .inttab_tc3_052 00000000  80bfea40  80bfea40  00031658  2**0
                  CONTENTS
881 .inttab_tc3_053 00000000  80bfea60  80bfea60  00031658  2**0
                  CONTENTS
882 .inttab_tc3_054 00000000  80bfea80  80bfea80  00031658  2**0
                  CONTENTS
883 .inttab_tc3_055 00000000  80bfeaa0  80bfeaa0  00031658  2**0
                  CONTENTS
884 .inttab_tc3_056 00000000  80bfeac0  80bfeac0  00031658  2**0
                  CONTENTS
885 .inttab_tc3_057 00000000  80bfeae0  80bfeae0  00031658  2**0
                  CONTENTS
886 .inttab_tc3_058 00000000  80bfeb00  80bfeb00  00031658  2**0
                  CONTENTS
887 .inttab_tc3_059 00000000  80bfeb20  80bfeb20  00031658  2**0
                  CONTENTS
888 .inttab_tc3_05A 00000000  80bfeb40  80bfeb40  00031658  2**0
                  CONTENTS
889 .inttab_tc3_05B 00000000  80bfeb60  80bfeb60  00031658  2**0
                  CONTENTS
890 .inttab_tc3_05C 00000000  80bfeb80  80bfeb80  00031658  2**0
                  CONTENTS
891 .inttab_tc3_05D 00000000  80bfeba0  80bfeba0  00031658  2**0
                  CONTENTS
892 .inttab_tc3_05E 00000000  80bfebc0  80bfebc0  00031658  2**0
                  CONTENTS
893 .inttab_tc3_05F 00000000  80bfebe0  80bfebe0  00031658  2**0
                  CONTENTS
894 .inttab_tc3_060 00000000  80bfec00  80bfec00  00031658  2**0
                  CONTENTS
895 .inttab_tc3_061 00000000  80bfec20  80bfec20  00031658  2**0
                  CONTENTS
896 .inttab_tc3_062 00000000  80bfec40  80bfec40  00031658  2**0
                  CONTENTS
897 .inttab_tc3_063 00000000  80bfec60  80bfec60  00031658  2**0
                  CONTENTS
898 .inttab_tc3_064 00000000  80bfec80  80bfec80  00031658  2**0
                  CONTENTS
899 .inttab_tc3_065 00000000  80bfeca0  80bfeca0  00031658  2**0
                  CONTENTS
900 .inttab_tc3_066 00000000  80bfecc0  80bfecc0  00031658  2**0
                  CONTENTS
901 .inttab_tc3_067 00000000  80bfece0  80bfece0  00031658  2**0
                  CONTENTS
902 .inttab_tc3_068 00000000  80bfed00  80bfed00  00031658  2**0
                  CONTENTS
903 .inttab_tc3_069 00000000  80bfed20  80bfed20  00031658  2**0
                  CONTENTS
904 .inttab_tc3_06A 00000000  80bfed40  80bfed40  00031658  2**0
                  CONTENTS
905 .inttab_tc3_06B 00000000  80bfed60  80bfed60  00031658  2**0
                  CONTENTS
906 .inttab_tc3_06C 00000000  80bfed80  80bfed80  00031658  2**0
                  CONTENTS
907 .inttab_tc3_06D 00000000  80bfeda0  80bfeda0  00031658  2**0
                  CONTENTS
908 .inttab_tc3_06E 00000000  80bfedc0  80bfedc0  00031658  2**0
                  CONTENTS
909 .inttab_tc3_06F 00000000  80bfede0  80bfede0  00031658  2**0
                  CONTENTS
910 .inttab_tc3_070 00000000  80bfee00  80bfee00  00031658  2**0
                  CONTENTS
911 .inttab_tc3_071 00000000  80bfee20  80bfee20  00031658  2**0
                  CONTENTS
912 .inttab_tc3_072 00000000  80bfee40  80bfee40  00031658  2**0
                  CONTENTS
913 .inttab_tc3_073 00000000  80bfee60  80bfee60  00031658  2**0
                  CONTENTS
914 .inttab_tc3_074 00000000  80bfee80  80bfee80  00031658  2**0
                  CONTENTS
915 .inttab_tc3_075 00000000  80bfeea0  80bfeea0  00031658  2**0
                  CONTENTS
916 .inttab_tc3_076 00000000  80bfeec0  80bfeec0  00031658  2**0
                  CONTENTS
917 .inttab_tc3_077 00000000  80bfeee0  80bfeee0  00031658  2**0
                  CONTENTS
918 .inttab_tc3_078 00000000  80bfef00  80bfef00  00031658  2**0
                  CONTENTS
919 .inttab_tc3_079 00000000  80bfef20  80bfef20  00031658  2**0
                  CONTENTS
920 .inttab_tc3_07A 00000000  80bfef40  80bfef40  00031658  2**0
                  CONTENTS
921 .inttab_tc3_07B 00000000  80bfef60  80bfef60  00031658  2**0
                  CONTENTS
922 .inttab_tc3_07C 00000000  80bfef80  80bfef80  00031658  2**0
                  CONTENTS
923 .inttab_tc3_07D 00000000  80bfefa0  80bfefa0  00031658  2**0
                  CONTENTS
924 .inttab_tc3_07E 00000000  80bfefc0  80bfefc0  00031658  2**0
                  CONTENTS
925 .inttab_tc3_07F 00000000  80bfefe0  80bfefe0  00031658  2**0
                  CONTENTS
926 .inttab_tc3_080 00000000  80bff000  80bff000  00031658  2**0
                  CONTENTS
927 .inttab_tc3_081 00000000  80bff020  80bff020  00031658  2**0
                  CONTENTS
928 .inttab_tc3_082 00000000  80bff040  80bff040  00031658  2**0
                  CONTENTS
929 .inttab_tc3_083 00000000  80bff060  80bff060  00031658  2**0
                  CONTENTS
930 .inttab_tc3_084 00000000  80bff080  80bff080  00031658  2**0
                  CONTENTS
931 .inttab_tc3_085 00000000  80bff0a0  80bff0a0  00031658  2**0
                  CONTENTS
932 .inttab_tc3_086 00000000  80bff0c0  80bff0c0  00031658  2**0
                  CONTENTS
933 .inttab_tc3_087 00000000  80bff0e0  80bff0e0  00031658  2**0
                  CONTENTS
934 .inttab_tc3_088 00000000  80bff100  80bff100  00031658  2**0
                  CONTENTS
935 .inttab_tc3_089 00000000  80bff120  80bff120  00031658  2**0
                  CONTENTS
936 .inttab_tc3_08A 00000000  80bff140  80bff140  00031658  2**0
                  CONTENTS
937 .inttab_tc3_08B 00000000  80bff160  80bff160  00031658  2**0
                  CONTENTS
938 .inttab_tc3_08C 00000000  80bff180  80bff180  00031658  2**0
                  CONTENTS
939 .inttab_tc3_08D 00000000  80bff1a0  80bff1a0  00031658  2**0
                  CONTENTS
940 .inttab_tc3_08E 00000000  80bff1c0  80bff1c0  00031658  2**0
                  CONTENTS
941 .inttab_tc3_08F 00000000  80bff1e0  80bff1e0  00031658  2**0
                  CONTENTS
942 .inttab_tc3_090 00000000  80bff200  80bff200  00031658  2**0
                  CONTENTS
943 .inttab_tc3_091 00000000  80bff220  80bff220  00031658  2**0
                  CONTENTS
944 .inttab_tc3_092 00000000  80bff240  80bff240  00031658  2**0
                  CONTENTS
945 .inttab_tc3_093 00000000  80bff260  80bff260  00031658  2**0
                  CONTENTS
946 .inttab_tc3_094 00000000  80bff280  80bff280  00031658  2**0
                  CONTENTS
947 .inttab_tc3_095 00000000  80bff2a0  80bff2a0  00031658  2**0
                  CONTENTS
948 .inttab_tc3_096 00000000  80bff2c0  80bff2c0  00031658  2**0
                  CONTENTS
949 .inttab_tc3_097 00000000  80bff2e0  80bff2e0  00031658  2**0
                  CONTENTS
950 .inttab_tc3_098 00000000  80bff300  80bff300  00031658  2**0
                  CONTENTS
951 .inttab_tc3_099 00000000  80bff320  80bff320  00031658  2**0
                  CONTENTS
952 .inttab_tc3_09A 00000000  80bff340  80bff340  00031658  2**0
                  CONTENTS
953 .inttab_tc3_09B 00000000  80bff360  80bff360  00031658  2**0
                  CONTENTS
954 .inttab_tc3_09C 00000000  80bff380  80bff380  00031658  2**0
                  CONTENTS
955 .inttab_tc3_09D 00000000  80bff3a0  80bff3a0  00031658  2**0
                  CONTENTS
956 .inttab_tc3_09E 00000000  80bff3c0  80bff3c0  00031658  2**0
                  CONTENTS
957 .inttab_tc3_09F 00000000  80bff3e0  80bff3e0  00031658  2**0
                  CONTENTS
958 .inttab_tc3_0A0 00000000  80bff400  80bff400  00031658  2**0
                  CONTENTS
959 .inttab_tc3_0A1 00000000  80bff420  80bff420  00031658  2**0
                  CONTENTS
960 .inttab_tc3_0A2 00000000  80bff440  80bff440  00031658  2**0
                  CONTENTS
961 .inttab_tc3_0A3 00000000  80bff460  80bff460  00031658  2**0
                  CONTENTS
962 .inttab_tc3_0A4 00000000  80bff480  80bff480  00031658  2**0
                  CONTENTS
963 .inttab_tc3_0A5 00000000  80bff4a0  80bff4a0  00031658  2**0
                  CONTENTS
964 .inttab_tc3_0A6 00000000  80bff4c0  80bff4c0  00031658  2**0
                  CONTENTS
965 .inttab_tc3_0A7 00000000  80bff4e0  80bff4e0  00031658  2**0
                  CONTENTS
966 .inttab_tc3_0A8 00000000  80bff500  80bff500  00031658  2**0
                  CONTENTS
967 .inttab_tc3_0A9 00000000  80bff520  80bff520  00031658  2**0
                  CONTENTS
968 .inttab_tc3_0AA 00000000  80bff540  80bff540  00031658  2**0
                  CONTENTS
969 .inttab_tc3_0AB 00000000  80bff560  80bff560  00031658  2**0
                  CONTENTS
970 .inttab_tc3_0AC 00000000  80bff580  80bff580  00031658  2**0
                  CONTENTS
971 .inttab_tc3_0AD 00000000  80bff5a0  80bff5a0  00031658  2**0
                  CONTENTS
972 .inttab_tc3_0AE 00000000  80bff5c0  80bff5c0  00031658  2**0
                  CONTENTS
973 .inttab_tc3_0AF 00000000  80bff5e0  80bff5e0  00031658  2**0
                  CONTENTS
974 .inttab_tc3_0B0 00000000  80bff600  80bff600  00031658  2**0
                  CONTENTS
975 .inttab_tc3_0B1 00000000  80bff620  80bff620  00031658  2**0
                  CONTENTS
976 .inttab_tc3_0B2 00000000  80bff640  80bff640  00031658  2**0
                  CONTENTS
977 .inttab_tc3_0B3 00000000  80bff660  80bff660  00031658  2**0
                  CONTENTS
978 .inttab_tc3_0B4 00000000  80bff680  80bff680  00031658  2**0
                  CONTENTS
979 .inttab_tc3_0B5 00000000  80bff6a0  80bff6a0  00031658  2**0
                  CONTENTS
980 .inttab_tc3_0B6 00000000  80bff6c0  80bff6c0  00031658  2**0
                  CONTENTS
981 .inttab_tc3_0B7 00000000  80bff6e0  80bff6e0  00031658  2**0
                  CONTENTS
982 .inttab_tc3_0B8 00000000  80bff700  80bff700  00031658  2**0
                  CONTENTS
983 .inttab_tc3_0B9 00000000  80bff720  80bff720  00031658  2**0
                  CONTENTS
984 .inttab_tc3_0BA 00000000  80bff740  80bff740  00031658  2**0
                  CONTENTS
985 .inttab_tc3_0BB 00000000  80bff760  80bff760  00031658  2**0
                  CONTENTS
986 .inttab_tc3_0BC 00000000  80bff780  80bff780  00031658  2**0
                  CONTENTS
987 .inttab_tc3_0BD 00000000  80bff7a0  80bff7a0  00031658  2**0
                  CONTENTS
988 .inttab_tc3_0BE 00000000  80bff7c0  80bff7c0  00031658  2**0
                  CONTENTS
989 .inttab_tc3_0BF 00000000  80bff7e0  80bff7e0  00031658  2**0
                  CONTENTS
990 .inttab_tc3_0C0 00000000  80bff800  80bff800  00031658  2**0
                  CONTENTS
991 .inttab_tc3_0C1 00000000  80bff820  80bff820  00031658  2**0
                  CONTENTS
992 .inttab_tc3_0C2 00000000  80bff840  80bff840  00031658  2**0
                  CONTENTS
993 .inttab_tc3_0C3 00000000  80bff860  80bff860  00031658  2**0
                  CONTENTS
994 .inttab_tc3_0C4 00000000  80bff880  80bff880  00031658  2**0
                  CONTENTS
995 .inttab_tc3_0C5 00000000  80bff8a0  80bff8a0  00031658  2**0
                  CONTENTS
996 .inttab_tc3_0C6 00000000  80bff8c0  80bff8c0  00031658  2**0
                  CONTENTS
997 .inttab_tc3_0C7 00000000  80bff8e0  80bff8e0  00031658  2**0
                  CONTENTS
998 .inttab_tc3_0C8 00000000  80bff900  80bff900  00031658  2**0
                  CONTENTS
999 .inttab_tc3_0C9 00000000  80bff920  80bff920  00031658  2**0
                  CONTENTS
1000 .inttab_tc3_0CA 00000000  80bff940  80bff940  00031658  2**0
                  CONTENTS
1001 .inttab_tc3_0CB 00000000  80bff960  80bff960  00031658  2**0
                  CONTENTS
1002 .inttab_tc3_0CC 00000000  80bff980  80bff980  00031658  2**0
                  CONTENTS
1003 .inttab_tc3_0CD 00000000  80bff9a0  80bff9a0  00031658  2**0
                  CONTENTS
1004 .inttab_tc3_0CE 00000000  80bff9c0  80bff9c0  00031658  2**0
                  CONTENTS
1005 .inttab_tc3_0CF 00000000  80bff9e0  80bff9e0  00031658  2**0
                  CONTENTS
1006 .inttab_tc3_0D0 00000000  80bffa00  80bffa00  00031658  2**0
                  CONTENTS
1007 .inttab_tc3_0D1 00000000  80bffa20  80bffa20  00031658  2**0
                  CONTENTS
1008 .inttab_tc3_0D2 00000000  80bffa40  80bffa40  00031658  2**0
                  CONTENTS
1009 .inttab_tc3_0D3 00000000  80bffa60  80bffa60  00031658  2**0
                  CONTENTS
1010 .inttab_tc3_0D4 00000000  80bffa80  80bffa80  00031658  2**0
                  CONTENTS
1011 .inttab_tc3_0D5 00000000  80bffaa0  80bffaa0  00031658  2**0
                  CONTENTS
1012 .inttab_tc3_0D6 00000000  80bffac0  80bffac0  00031658  2**0
                  CONTENTS
1013 .inttab_tc3_0D7 00000000  80bffae0  80bffae0  00031658  2**0
                  CONTENTS
1014 .inttab_tc3_0D8 00000000  80bffb00  80bffb00  00031658  2**0
                  CONTENTS
1015 .inttab_tc3_0D9 00000000  80bffb20  80bffb20  00031658  2**0
                  CONTENTS
1016 .inttab_tc3_0DA 00000000  80bffb40  80bffb40  00031658  2**0
                  CONTENTS
1017 .inttab_tc3_0DB 00000000  80bffb60  80bffb60  00031658  2**0
                  CONTENTS
1018 .inttab_tc3_0DC 00000000  80bffb80  80bffb80  00031658  2**0
                  CONTENTS
1019 .inttab_tc3_0DD 00000000  80bffba0  80bffba0  00031658  2**0
                  CONTENTS
1020 .inttab_tc3_0DE 00000000  80bffbc0  80bffbc0  00031658  2**0
                  CONTENTS
1021 .inttab_tc3_0DF 00000000  80bffbe0  80bffbe0  00031658  2**0
                  CONTENTS
1022 .inttab_tc3_0E0 00000000  80bffc00  80bffc00  00031658  2**0
                  CONTENTS
1023 .inttab_tc3_0E1 00000000  80bffc20  80bffc20  00031658  2**0
                  CONTENTS
1024 .inttab_tc3_0E2 00000000  80bffc40  80bffc40  00031658  2**0
                  CONTENTS
1025 .inttab_tc3_0E3 00000000  80bffc60  80bffc60  00031658  2**0
                  CONTENTS
1026 .inttab_tc3_0E4 00000000  80bffc80  80bffc80  00031658  2**0
                  CONTENTS
1027 .inttab_tc3_0E5 00000000  80bffca0  80bffca0  00031658  2**0
                  CONTENTS
1028 .inttab_tc3_0E6 00000000  80bffcc0  80bffcc0  00031658  2**0
                  CONTENTS
1029 .inttab_tc3_0E7 00000000  80bffce0  80bffce0  00031658  2**0
                  CONTENTS
1030 .inttab_tc3_0E8 00000000  80bffd00  80bffd00  00031658  2**0
                  CONTENTS
1031 .inttab_tc3_0E9 00000000  80bffd20  80bffd20  00031658  2**0
                  CONTENTS
1032 .inttab_tc3_0EA 00000000  80bffd40  80bffd40  00031658  2**0
                  CONTENTS
1033 .inttab_tc3_0EB 00000000  80bffd60  80bffd60  00031658  2**0
                  CONTENTS
1034 .inttab_tc3_0EC 00000000  80bffd80  80bffd80  00031658  2**0
                  CONTENTS
1035 .inttab_tc3_0ED 00000000  80bffda0  80bffda0  00031658  2**0
                  CONTENTS
1036 .inttab_tc3_0EE 00000000  80bffdc0  80bffdc0  00031658  2**0
                  CONTENTS
1037 .inttab_tc3_0EF 00000000  80bffde0  80bffde0  00031658  2**0
                  CONTENTS
1038 .inttab_tc3_0F0 00000000  80bffe00  80bffe00  00031658  2**0
                  CONTENTS
1039 .inttab_tc3_0F1 00000000  80bffe20  80bffe20  00031658  2**0
                  CONTENTS
1040 .inttab_tc3_0F2 00000000  80bffe40  80bffe40  00031658  2**0
                  CONTENTS
1041 .inttab_tc3_0F3 00000000  80bffe60  80bffe60  00031658  2**0
                  CONTENTS
1042 .inttab_tc3_0F4 00000000  80bffe80  80bffe80  00031658  2**0
                  CONTENTS
1043 .inttab_tc3_0F5 00000000  80bffea0  80bffea0  00031658  2**0
                  CONTENTS
1044 .inttab_tc3_0F6 00000000  80bffec0  80bffec0  00031658  2**0
                  CONTENTS
1045 .inttab_tc3_0F7 00000000  80bffee0  80bffee0  00031658  2**0
                  CONTENTS
1046 .inttab_tc3_0F8 00000000  80bfff00  80bfff00  00031658  2**0
                  CONTENTS
1047 .inttab_tc3_0F9 00000000  80bfff20  80bfff20  00031658  2**0
                  CONTENTS
1048 .inttab_tc3_0FA 00000000  80bfff40  80bfff40  00031658  2**0
                  CONTENTS
1049 .inttab_tc3_0FB 00000000  80bfff60  80bfff60  00031658  2**0
                  CONTENTS
1050 .inttab_tc3_0FC 00000000  80bfff80  80bfff80  00031658  2**0
                  CONTENTS
1051 .inttab_tc3_0FD 00000000  80bfffa0  80bfffa0  00031658  2**0
                  CONTENTS
1052 .inttab_tc3_0FE 00000000  80bfffc0  80bfffc0  00031658  2**0
                  CONTENTS
1053 .inttab_tc3_0FF 00000000  80bfffe0  80bfffe0  00031658  2**0
                  CONTENTS
1054 .inttab_tc4_000 00000000  80efe000  80efe000  00031658  2**0
                  CONTENTS
1055 .inttab_tc4_001 00000000  80efe020  80efe020  00031658  2**0
                  CONTENTS
1056 .inttab_tc4_002 00000000  80efe040  80efe040  00031658  2**0
                  CONTENTS
1057 .inttab_tc4_003 00000000  80efe060  80efe060  00031658  2**0
                  CONTENTS
1058 .inttab_tc4_004 00000000  80efe080  80efe080  00031658  2**0
                  CONTENTS
1059 .inttab_tc4_005 00000000  80efe0a0  80efe0a0  00031658  2**0
                  CONTENTS
1060 .inttab_tc4_006 00000000  80efe0c0  80efe0c0  00031658  2**0
                  CONTENTS
1061 .inttab_tc4_007 00000000  80efe0e0  80efe0e0  00031658  2**0
                  CONTENTS
1062 .inttab_tc4_008 00000000  80efe100  80efe100  00031658  2**0
                  CONTENTS
1063 .inttab_tc4_009 00000000  80efe120  80efe120  00031658  2**0
                  CONTENTS
1064 .inttab_tc4_00A 00000000  80efe140  80efe140  00031658  2**0
                  CONTENTS
1065 .inttab_tc4_00B 00000000  80efe160  80efe160  00031658  2**0
                  CONTENTS
1066 .inttab_tc4_00C 00000000  80efe180  80efe180  00031658  2**0
                  CONTENTS
1067 .inttab_tc4_00D 00000000  80efe1a0  80efe1a0  00031658  2**0
                  CONTENTS
1068 .inttab_tc4_00E 00000000  80efe1c0  80efe1c0  00031658  2**0
                  CONTENTS
1069 .inttab_tc4_00F 00000000  80efe1e0  80efe1e0  00031658  2**0
                  CONTENTS
1070 .inttab_tc4_010 00000000  80efe200  80efe200  00031658  2**0
                  CONTENTS
1071 .inttab_tc4_011 00000000  80efe220  80efe220  00031658  2**0
                  CONTENTS
1072 .inttab_tc4_012 00000000  80efe240  80efe240  00031658  2**0
                  CONTENTS
1073 .inttab_tc4_013 00000000  80efe260  80efe260  00031658  2**0
                  CONTENTS
1074 .inttab_tc4_014 00000000  80efe280  80efe280  00031658  2**0
                  CONTENTS
1075 .inttab_tc4_015 00000000  80efe2a0  80efe2a0  00031658  2**0
                  CONTENTS
1076 .inttab_tc4_016 00000000  80efe2c0  80efe2c0  00031658  2**0
                  CONTENTS
1077 .inttab_tc4_017 00000000  80efe2e0  80efe2e0  00031658  2**0
                  CONTENTS
1078 .inttab_tc4_018 00000000  80efe300  80efe300  00031658  2**0
                  CONTENTS
1079 .inttab_tc4_019 00000000  80efe320  80efe320  00031658  2**0
                  CONTENTS
1080 .inttab_tc4_01A 00000000  80efe340  80efe340  00031658  2**0
                  CONTENTS
1081 .inttab_tc4_01B 00000000  80efe360  80efe360  00031658  2**0
                  CONTENTS
1082 .inttab_tc4_01C 00000000  80efe380  80efe380  00031658  2**0
                  CONTENTS
1083 .inttab_tc4_01D 00000000  80efe3a0  80efe3a0  00031658  2**0
                  CONTENTS
1084 .inttab_tc4_01E 00000000  80efe3c0  80efe3c0  00031658  2**0
                  CONTENTS
1085 .inttab_tc4_01F 00000000  80efe3e0  80efe3e0  00031658  2**0
                  CONTENTS
1086 .inttab_tc4_020 00000000  80efe400  80efe400  00031658  2**0
                  CONTENTS
1087 .inttab_tc4_021 00000000  80efe420  80efe420  00031658  2**0
                  CONTENTS
1088 .inttab_tc4_022 00000000  80efe440  80efe440  00031658  2**0
                  CONTENTS
1089 .inttab_tc4_023 00000000  80efe460  80efe460  00031658  2**0
                  CONTENTS
1090 .inttab_tc4_024 00000000  80efe480  80efe480  00031658  2**0
                  CONTENTS
1091 .inttab_tc4_025 00000000  80efe4a0  80efe4a0  00031658  2**0
                  CONTENTS
1092 .inttab_tc4_026 00000000  80efe4c0  80efe4c0  00031658  2**0
                  CONTENTS
1093 .inttab_tc4_027 00000000  80efe4e0  80efe4e0  00031658  2**0
                  CONTENTS
1094 .inttab_tc4_028 00000000  80efe500  80efe500  00031658  2**0
                  CONTENTS
1095 .inttab_tc4_029 00000000  80efe520  80efe520  00031658  2**0
                  CONTENTS
1096 .inttab_tc4_02A 00000000  80efe540  80efe540  00031658  2**0
                  CONTENTS
1097 .inttab_tc4_02B 00000000  80efe560  80efe560  00031658  2**0
                  CONTENTS
1098 .inttab_tc4_02C 00000000  80efe580  80efe580  00031658  2**0
                  CONTENTS
1099 .inttab_tc4_02D 00000000  80efe5a0  80efe5a0  00031658  2**0
                  CONTENTS
1100 .inttab_tc4_02E 00000000  80efe5c0  80efe5c0  00031658  2**0
                  CONTENTS
1101 .inttab_tc4_02F 00000000  80efe5e0  80efe5e0  00031658  2**0
                  CONTENTS
1102 .inttab_tc4_030 00000000  80efe600  80efe600  00031658  2**0
                  CONTENTS
1103 .inttab_tc4_031 00000000  80efe620  80efe620  00031658  2**0
                  CONTENTS
1104 .inttab_tc4_032 00000000  80efe640  80efe640  00031658  2**0
                  CONTENTS
1105 .inttab_tc4_033 00000000  80efe660  80efe660  00031658  2**0
                  CONTENTS
1106 .inttab_tc4_034 00000000  80efe680  80efe680  00031658  2**0
                  CONTENTS
1107 .inttab_tc4_035 00000000  80efe6a0  80efe6a0  00031658  2**0
                  CONTENTS
1108 .inttab_tc4_036 00000000  80efe6c0  80efe6c0  00031658  2**0
                  CONTENTS
1109 .inttab_tc4_037 00000000  80efe6e0  80efe6e0  00031658  2**0
                  CONTENTS
1110 .inttab_tc4_038 00000000  80efe700  80efe700  00031658  2**0
                  CONTENTS
1111 .inttab_tc4_039 00000000  80efe720  80efe720  00031658  2**0
                  CONTENTS
1112 .inttab_tc4_03A 00000000  80efe740  80efe740  00031658  2**0
                  CONTENTS
1113 .inttab_tc4_03B 00000000  80efe760  80efe760  00031658  2**0
                  CONTENTS
1114 .inttab_tc4_03C 00000000  80efe780  80efe780  00031658  2**0
                  CONTENTS
1115 .inttab_tc4_03D 00000000  80efe7a0  80efe7a0  00031658  2**0
                  CONTENTS
1116 .inttab_tc4_03E 00000000  80efe7c0  80efe7c0  00031658  2**0
                  CONTENTS
1117 .inttab_tc4_03F 00000000  80efe7e0  80efe7e0  00031658  2**0
                  CONTENTS
1118 .inttab_tc4_040 00000000  80efe800  80efe800  00031658  2**0
                  CONTENTS
1119 .inttab_tc4_041 00000000  80efe820  80efe820  00031658  2**0
                  CONTENTS
1120 .inttab_tc4_042 00000000  80efe840  80efe840  00031658  2**0
                  CONTENTS
1121 .inttab_tc4_043 00000000  80efe860  80efe860  00031658  2**0
                  CONTENTS
1122 .inttab_tc4_044 00000000  80efe880  80efe880  00031658  2**0
                  CONTENTS
1123 .inttab_tc4_045 00000000  80efe8a0  80efe8a0  00031658  2**0
                  CONTENTS
1124 .inttab_tc4_046 00000000  80efe8c0  80efe8c0  00031658  2**0
                  CONTENTS
1125 .inttab_tc4_047 00000000  80efe8e0  80efe8e0  00031658  2**0
                  CONTENTS
1126 .inttab_tc4_048 00000000  80efe900  80efe900  00031658  2**0
                  CONTENTS
1127 .inttab_tc4_049 00000000  80efe920  80efe920  00031658  2**0
                  CONTENTS
1128 .inttab_tc4_04A 00000000  80efe940  80efe940  00031658  2**0
                  CONTENTS
1129 .inttab_tc4_04B 00000000  80efe960  80efe960  00031658  2**0
                  CONTENTS
1130 .inttab_tc4_04C 00000000  80efe980  80efe980  00031658  2**0
                  CONTENTS
1131 .inttab_tc4_04D 00000000  80efe9a0  80efe9a0  00031658  2**0
                  CONTENTS
1132 .inttab_tc4_04E 00000000  80efe9c0  80efe9c0  00031658  2**0
                  CONTENTS
1133 .inttab_tc4_04F 00000000  80efe9e0  80efe9e0  00031658  2**0
                  CONTENTS
1134 .inttab_tc4_050 00000000  80efea00  80efea00  00031658  2**0
                  CONTENTS
1135 .inttab_tc4_051 00000000  80efea20  80efea20  00031658  2**0
                  CONTENTS
1136 .inttab_tc4_052 00000000  80efea40  80efea40  00031658  2**0
                  CONTENTS
1137 .inttab_tc4_053 00000000  80efea60  80efea60  00031658  2**0
                  CONTENTS
1138 .inttab_tc4_054 00000000  80efea80  80efea80  00031658  2**0
                  CONTENTS
1139 .inttab_tc4_055 00000000  80efeaa0  80efeaa0  00031658  2**0
                  CONTENTS
1140 .inttab_tc4_056 00000000  80efeac0  80efeac0  00031658  2**0
                  CONTENTS
1141 .inttab_tc4_057 00000000  80efeae0  80efeae0  00031658  2**0
                  CONTENTS
1142 .inttab_tc4_058 00000000  80efeb00  80efeb00  00031658  2**0
                  CONTENTS
1143 .inttab_tc4_059 00000000  80efeb20  80efeb20  00031658  2**0
                  CONTENTS
1144 .inttab_tc4_05A 00000000  80efeb40  80efeb40  00031658  2**0
                  CONTENTS
1145 .inttab_tc4_05B 00000000  80efeb60  80efeb60  00031658  2**0
                  CONTENTS
1146 .inttab_tc4_05C 00000000  80efeb80  80efeb80  00031658  2**0
                  CONTENTS
1147 .inttab_tc4_05D 00000000  80efeba0  80efeba0  00031658  2**0
                  CONTENTS
1148 .inttab_tc4_05E 00000000  80efebc0  80efebc0  00031658  2**0
                  CONTENTS
1149 .inttab_tc4_05F 00000000  80efebe0  80efebe0  00031658  2**0
                  CONTENTS
1150 .inttab_tc4_060 00000000  80efec00  80efec00  00031658  2**0
                  CONTENTS
1151 .inttab_tc4_061 00000000  80efec20  80efec20  00031658  2**0
                  CONTENTS
1152 .inttab_tc4_062 00000000  80efec40  80efec40  00031658  2**0
                  CONTENTS
1153 .inttab_tc4_063 00000000  80efec60  80efec60  00031658  2**0
                  CONTENTS
1154 .inttab_tc4_064 00000000  80efec80  80efec80  00031658  2**0
                  CONTENTS
1155 .inttab_tc4_065 00000000  80efeca0  80efeca0  00031658  2**0
                  CONTENTS
1156 .inttab_tc4_066 00000000  80efecc0  80efecc0  00031658  2**0
                  CONTENTS
1157 .inttab_tc4_067 00000000  80efece0  80efece0  00031658  2**0
                  CONTENTS
1158 .inttab_tc4_068 00000000  80efed00  80efed00  00031658  2**0
                  CONTENTS
1159 .inttab_tc4_069 00000000  80efed20  80efed20  00031658  2**0
                  CONTENTS
1160 .inttab_tc4_06A 00000000  80efed40  80efed40  00031658  2**0
                  CONTENTS
1161 .inttab_tc4_06B 00000000  80efed60  80efed60  00031658  2**0
                  CONTENTS
1162 .inttab_tc4_06C 00000000  80efed80  80efed80  00031658  2**0
                  CONTENTS
1163 .inttab_tc4_06D 00000000  80efeda0  80efeda0  00031658  2**0
                  CONTENTS
1164 .inttab_tc4_06E 00000000  80efedc0  80efedc0  00031658  2**0
                  CONTENTS
1165 .inttab_tc4_06F 00000000  80efede0  80efede0  00031658  2**0
                  CONTENTS
1166 .inttab_tc4_070 00000000  80efee00  80efee00  00031658  2**0
                  CONTENTS
1167 .inttab_tc4_071 00000000  80efee20  80efee20  00031658  2**0
                  CONTENTS
1168 .inttab_tc4_072 00000000  80efee40  80efee40  00031658  2**0
                  CONTENTS
1169 .inttab_tc4_073 00000000  80efee60  80efee60  00031658  2**0
                  CONTENTS
1170 .inttab_tc4_074 00000000  80efee80  80efee80  00031658  2**0
                  CONTENTS
1171 .inttab_tc4_075 00000000  80efeea0  80efeea0  00031658  2**0
                  CONTENTS
1172 .inttab_tc4_076 00000000  80efeec0  80efeec0  00031658  2**0
                  CONTENTS
1173 .inttab_tc4_077 00000000  80efeee0  80efeee0  00031658  2**0
                  CONTENTS
1174 .inttab_tc4_078 00000000  80efef00  80efef00  00031658  2**0
                  CONTENTS
1175 .inttab_tc4_079 00000000  80efef20  80efef20  00031658  2**0
                  CONTENTS
1176 .inttab_tc4_07A 00000000  80efef40  80efef40  00031658  2**0
                  CONTENTS
1177 .inttab_tc4_07B 00000000  80efef60  80efef60  00031658  2**0
                  CONTENTS
1178 .inttab_tc4_07C 00000000  80efef80  80efef80  00031658  2**0
                  CONTENTS
1179 .inttab_tc4_07D 00000000  80efefa0  80efefa0  00031658  2**0
                  CONTENTS
1180 .inttab_tc4_07E 00000000  80efefc0  80efefc0  00031658  2**0
                  CONTENTS
1181 .inttab_tc4_07F 00000000  80efefe0  80efefe0  00031658  2**0
                  CONTENTS
1182 .inttab_tc4_080 00000000  80eff000  80eff000  00031658  2**0
                  CONTENTS
1183 .inttab_tc4_081 00000000  80eff020  80eff020  00031658  2**0
                  CONTENTS
1184 .inttab_tc4_082 00000000  80eff040  80eff040  00031658  2**0
                  CONTENTS
1185 .inttab_tc4_083 00000000  80eff060  80eff060  00031658  2**0
                  CONTENTS
1186 .inttab_tc4_084 00000000  80eff080  80eff080  00031658  2**0
                  CONTENTS
1187 .inttab_tc4_085 00000000  80eff0a0  80eff0a0  00031658  2**0
                  CONTENTS
1188 .inttab_tc4_086 00000000  80eff0c0  80eff0c0  00031658  2**0
                  CONTENTS
1189 .inttab_tc4_087 00000000  80eff0e0  80eff0e0  00031658  2**0
                  CONTENTS
1190 .inttab_tc4_088 00000000  80eff100  80eff100  00031658  2**0
                  CONTENTS
1191 .inttab_tc4_089 00000000  80eff120  80eff120  00031658  2**0
                  CONTENTS
1192 .inttab_tc4_08A 00000000  80eff140  80eff140  00031658  2**0
                  CONTENTS
1193 .inttab_tc4_08B 00000000  80eff160  80eff160  00031658  2**0
                  CONTENTS
1194 .inttab_tc4_08C 00000000  80eff180  80eff180  00031658  2**0
                  CONTENTS
1195 .inttab_tc4_08D 00000000  80eff1a0  80eff1a0  00031658  2**0
                  CONTENTS
1196 .inttab_tc4_08E 00000000  80eff1c0  80eff1c0  00031658  2**0
                  CONTENTS
1197 .inttab_tc4_08F 00000000  80eff1e0  80eff1e0  00031658  2**0
                  CONTENTS
1198 .inttab_tc4_090 00000000  80eff200  80eff200  00031658  2**0
                  CONTENTS
1199 .inttab_tc4_091 00000000  80eff220  80eff220  00031658  2**0
                  CONTENTS
1200 .inttab_tc4_092 00000000  80eff240  80eff240  00031658  2**0
                  CONTENTS
1201 .inttab_tc4_093 00000000  80eff260  80eff260  00031658  2**0
                  CONTENTS
1202 .inttab_tc4_094 00000000  80eff280  80eff280  00031658  2**0
                  CONTENTS
1203 .inttab_tc4_095 00000000  80eff2a0  80eff2a0  00031658  2**0
                  CONTENTS
1204 .inttab_tc4_096 00000000  80eff2c0  80eff2c0  00031658  2**0
                  CONTENTS
1205 .inttab_tc4_097 00000000  80eff2e0  80eff2e0  00031658  2**0
                  CONTENTS
1206 .inttab_tc4_098 00000000  80eff300  80eff300  00031658  2**0
                  CONTENTS
1207 .inttab_tc4_099 00000000  80eff320  80eff320  00031658  2**0
                  CONTENTS
1208 .inttab_tc4_09A 00000000  80eff340  80eff340  00031658  2**0
                  CONTENTS
1209 .inttab_tc4_09B 00000000  80eff360  80eff360  00031658  2**0
                  CONTENTS
1210 .inttab_tc4_09C 00000000  80eff380  80eff380  00031658  2**0
                  CONTENTS
1211 .inttab_tc4_09D 00000000  80eff3a0  80eff3a0  00031658  2**0
                  CONTENTS
1212 .inttab_tc4_09E 00000000  80eff3c0  80eff3c0  00031658  2**0
                  CONTENTS
1213 .inttab_tc4_09F 00000000  80eff3e0  80eff3e0  00031658  2**0
                  CONTENTS
1214 .inttab_tc4_0A0 00000000  80eff400  80eff400  00031658  2**0
                  CONTENTS
1215 .inttab_tc4_0A1 00000000  80eff420  80eff420  00031658  2**0
                  CONTENTS
1216 .inttab_tc4_0A2 00000000  80eff440  80eff440  00031658  2**0
                  CONTENTS
1217 .inttab_tc4_0A3 00000000  80eff460  80eff460  00031658  2**0
                  CONTENTS
1218 .inttab_tc4_0A4 00000000  80eff480  80eff480  00031658  2**0
                  CONTENTS
1219 .inttab_tc4_0A5 00000000  80eff4a0  80eff4a0  00031658  2**0
                  CONTENTS
1220 .inttab_tc4_0A6 00000000  80eff4c0  80eff4c0  00031658  2**0
                  CONTENTS
1221 .inttab_tc4_0A7 00000000  80eff4e0  80eff4e0  00031658  2**0
                  CONTENTS
1222 .inttab_tc4_0A8 00000000  80eff500  80eff500  00031658  2**0
                  CONTENTS
1223 .inttab_tc4_0A9 00000000  80eff520  80eff520  00031658  2**0
                  CONTENTS
1224 .inttab_tc4_0AA 00000000  80eff540  80eff540  00031658  2**0
                  CONTENTS
1225 .inttab_tc4_0AB 00000000  80eff560  80eff560  00031658  2**0
                  CONTENTS
1226 .inttab_tc4_0AC 00000000  80eff580  80eff580  00031658  2**0
                  CONTENTS
1227 .inttab_tc4_0AD 00000000  80eff5a0  80eff5a0  00031658  2**0
                  CONTENTS
1228 .inttab_tc4_0AE 00000000  80eff5c0  80eff5c0  00031658  2**0
                  CONTENTS
1229 .inttab_tc4_0AF 00000000  80eff5e0  80eff5e0  00031658  2**0
                  CONTENTS
1230 .inttab_tc4_0B0 00000000  80eff600  80eff600  00031658  2**0
                  CONTENTS
1231 .inttab_tc4_0B1 00000000  80eff620  80eff620  00031658  2**0
                  CONTENTS
1232 .inttab_tc4_0B2 00000000  80eff640  80eff640  00031658  2**0
                  CONTENTS
1233 .inttab_tc4_0B3 00000000  80eff660  80eff660  00031658  2**0
                  CONTENTS
1234 .inttab_tc4_0B4 00000000  80eff680  80eff680  00031658  2**0
                  CONTENTS
1235 .inttab_tc4_0B5 00000000  80eff6a0  80eff6a0  00031658  2**0
                  CONTENTS
1236 .inttab_tc4_0B6 00000000  80eff6c0  80eff6c0  00031658  2**0
                  CONTENTS
1237 .inttab_tc4_0B7 00000000  80eff6e0  80eff6e0  00031658  2**0
                  CONTENTS
1238 .inttab_tc4_0B8 00000000  80eff700  80eff700  00031658  2**0
                  CONTENTS
1239 .inttab_tc4_0B9 00000000  80eff720  80eff720  00031658  2**0
                  CONTENTS
1240 .inttab_tc4_0BA 00000000  80eff740  80eff740  00031658  2**0
                  CONTENTS
1241 .inttab_tc4_0BB 00000000  80eff760  80eff760  00031658  2**0
                  CONTENTS
1242 .inttab_tc4_0BC 00000000  80eff780  80eff780  00031658  2**0
                  CONTENTS
1243 .inttab_tc4_0BD 00000000  80eff7a0  80eff7a0  00031658  2**0
                  CONTENTS
1244 .inttab_tc4_0BE 00000000  80eff7c0  80eff7c0  00031658  2**0
                  CONTENTS
1245 .inttab_tc4_0BF 00000000  80eff7e0  80eff7e0  00031658  2**0
                  CONTENTS
1246 .inttab_tc4_0C0 00000000  80eff800  80eff800  00031658  2**0
                  CONTENTS
1247 .inttab_tc4_0C1 00000000  80eff820  80eff820  00031658  2**0
                  CONTENTS
1248 .inttab_tc4_0C2 00000000  80eff840  80eff840  00031658  2**0
                  CONTENTS
1249 .inttab_tc4_0C3 00000000  80eff860  80eff860  00031658  2**0
                  CONTENTS
1250 .inttab_tc4_0C4 00000000  80eff880  80eff880  00031658  2**0
                  CONTENTS
1251 .inttab_tc4_0C5 00000000  80eff8a0  80eff8a0  00031658  2**0
                  CONTENTS
1252 .inttab_tc4_0C6 00000000  80eff8c0  80eff8c0  00031658  2**0
                  CONTENTS
1253 .inttab_tc4_0C7 00000000  80eff8e0  80eff8e0  00031658  2**0
                  CONTENTS
1254 .inttab_tc4_0C8 00000000  80eff900  80eff900  00031658  2**0
                  CONTENTS
1255 .inttab_tc4_0C9 00000000  80eff920  80eff920  00031658  2**0
                  CONTENTS
1256 .inttab_tc4_0CA 00000000  80eff940  80eff940  00031658  2**0
                  CONTENTS
1257 .inttab_tc4_0CB 00000000  80eff960  80eff960  00031658  2**0
                  CONTENTS
1258 .inttab_tc4_0CC 00000000  80eff980  80eff980  00031658  2**0
                  CONTENTS
1259 .inttab_tc4_0CD 00000000  80eff9a0  80eff9a0  00031658  2**0
                  CONTENTS
1260 .inttab_tc4_0CE 00000000  80eff9c0  80eff9c0  00031658  2**0
                  CONTENTS
1261 .inttab_tc4_0CF 00000000  80eff9e0  80eff9e0  00031658  2**0
                  CONTENTS
1262 .inttab_tc4_0D0 00000000  80effa00  80effa00  00031658  2**0
                  CONTENTS
1263 .inttab_tc4_0D1 00000000  80effa20  80effa20  00031658  2**0
                  CONTENTS
1264 .inttab_tc4_0D2 00000000  80effa40  80effa40  00031658  2**0
                  CONTENTS
1265 .inttab_tc4_0D3 00000000  80effa60  80effa60  00031658  2**0
                  CONTENTS
1266 .inttab_tc4_0D4 00000000  80effa80  80effa80  00031658  2**0
                  CONTENTS
1267 .inttab_tc4_0D5 00000000  80effaa0  80effaa0  00031658  2**0
                  CONTENTS
1268 .inttab_tc4_0D6 00000000  80effac0  80effac0  00031658  2**0
                  CONTENTS
1269 .inttab_tc4_0D7 00000000  80effae0  80effae0  00031658  2**0
                  CONTENTS
1270 .inttab_tc4_0D8 00000000  80effb00  80effb00  00031658  2**0
                  CONTENTS
1271 .inttab_tc4_0D9 00000000  80effb20  80effb20  00031658  2**0
                  CONTENTS
1272 .inttab_tc4_0DA 00000000  80effb40  80effb40  00031658  2**0
                  CONTENTS
1273 .inttab_tc4_0DB 00000000  80effb60  80effb60  00031658  2**0
                  CONTENTS
1274 .inttab_tc4_0DC 00000000  80effb80  80effb80  00031658  2**0
                  CONTENTS
1275 .inttab_tc4_0DD 00000000  80effba0  80effba0  00031658  2**0
                  CONTENTS
1276 .inttab_tc4_0DE 00000000  80effbc0  80effbc0  00031658  2**0
                  CONTENTS
1277 .inttab_tc4_0DF 00000000  80effbe0  80effbe0  00031658  2**0
                  CONTENTS
1278 .inttab_tc4_0E0 00000000  80effc00  80effc00  00031658  2**0
                  CONTENTS
1279 .inttab_tc4_0E1 00000000  80effc20  80effc20  00031658  2**0
                  CONTENTS
1280 .inttab_tc4_0E2 00000000  80effc40  80effc40  00031658  2**0
                  CONTENTS
1281 .inttab_tc4_0E3 00000000  80effc60  80effc60  00031658  2**0
                  CONTENTS
1282 .inttab_tc4_0E4 00000000  80effc80  80effc80  00031658  2**0
                  CONTENTS
1283 .inttab_tc4_0E5 00000000  80effca0  80effca0  00031658  2**0
                  CONTENTS
1284 .inttab_tc4_0E6 00000000  80effcc0  80effcc0  00031658  2**0
                  CONTENTS
1285 .inttab_tc4_0E7 00000000  80effce0  80effce0  00031658  2**0
                  CONTENTS
1286 .inttab_tc4_0E8 00000000  80effd00  80effd00  00031658  2**0
                  CONTENTS
1287 .inttab_tc4_0E9 00000000  80effd20  80effd20  00031658  2**0
                  CONTENTS
1288 .inttab_tc4_0EA 00000000  80effd40  80effd40  00031658  2**0
                  CONTENTS
1289 .inttab_tc4_0EB 00000000  80effd60  80effd60  00031658  2**0
                  CONTENTS
1290 .inttab_tc4_0EC 00000000  80effd80  80effd80  00031658  2**0
                  CONTENTS
1291 .inttab_tc4_0ED 00000000  80effda0  80effda0  00031658  2**0
                  CONTENTS
1292 .inttab_tc4_0EE 00000000  80effdc0  80effdc0  00031658  2**0
                  CONTENTS
1293 .inttab_tc4_0EF 00000000  80effde0  80effde0  00031658  2**0
                  CONTENTS
1294 .inttab_tc4_0F0 00000000  80effe00  80effe00  00031658  2**0
                  CONTENTS
1295 .inttab_tc4_0F1 00000000  80effe20  80effe20  00031658  2**0
                  CONTENTS
1296 .inttab_tc4_0F2 00000000  80effe40  80effe40  00031658  2**0
                  CONTENTS
1297 .inttab_tc4_0F3 00000000  80effe60  80effe60  00031658  2**0
                  CONTENTS
1298 .inttab_tc4_0F4 00000000  80effe80  80effe80  00031658  2**0
                  CONTENTS
1299 .inttab_tc4_0F5 00000000  80effea0  80effea0  00031658  2**0
                  CONTENTS
1300 .inttab_tc4_0F6 00000000  80effec0  80effec0  00031658  2**0
                  CONTENTS
1301 .inttab_tc4_0F7 00000000  80effee0  80effee0  00031658  2**0
                  CONTENTS
1302 .inttab_tc4_0F8 00000000  80efff00  80efff00  00031658  2**0
                  CONTENTS
1303 .inttab_tc4_0F9 00000000  80efff20  80efff20  00031658  2**0
                  CONTENTS
1304 .inttab_tc4_0FA 00000000  80efff40  80efff40  00031658  2**0
                  CONTENTS
1305 .inttab_tc4_0FB 00000000  80efff60  80efff60  00031658  2**0
                  CONTENTS
1306 .inttab_tc4_0FC 00000000  80efff80  80efff80  00031658  2**0
                  CONTENTS
1307 .inttab_tc4_0FD 00000000  80efffa0  80efffa0  00031658  2**0
                  CONTENTS
1308 .inttab_tc4_0FE 00000000  80efffc0  80efffc0  00031658  2**0
                  CONTENTS
1309 .inttab_tc4_0FF 00000000  80efffe0  80efffe0  00031658  2**0
                  CONTENTS
1310 .inttab_tc5_000 00000000  80ffe000  80ffe000  00031658  2**0
                  CONTENTS
1311 .inttab_tc5_001 00000000  80ffe020  80ffe020  00031658  2**0
                  CONTENTS
1312 .inttab_tc5_002 00000000  80ffe040  80ffe040  00031658  2**0
                  CONTENTS
1313 .inttab_tc5_003 00000000  80ffe060  80ffe060  00031658  2**0
                  CONTENTS
1314 .inttab_tc5_004 00000000  80ffe080  80ffe080  00031658  2**0
                  CONTENTS
1315 .inttab_tc5_005 00000000  80ffe0a0  80ffe0a0  00031658  2**0
                  CONTENTS
1316 .inttab_tc5_006 00000000  80ffe0c0  80ffe0c0  00031658  2**0
                  CONTENTS
1317 .inttab_tc5_007 00000000  80ffe0e0  80ffe0e0  00031658  2**0
                  CONTENTS
1318 .inttab_tc5_008 00000000  80ffe100  80ffe100  00031658  2**0
                  CONTENTS
1319 .inttab_tc5_009 00000000  80ffe120  80ffe120  00031658  2**0
                  CONTENTS
1320 .inttab_tc5_00A 00000000  80ffe140  80ffe140  00031658  2**0
                  CONTENTS
1321 .inttab_tc5_00B 00000000  80ffe160  80ffe160  00031658  2**0
                  CONTENTS
1322 .inttab_tc5_00C 00000000  80ffe180  80ffe180  00031658  2**0
                  CONTENTS
1323 .inttab_tc5_00D 00000000  80ffe1a0  80ffe1a0  00031658  2**0
                  CONTENTS
1324 .inttab_tc5_00E 00000000  80ffe1c0  80ffe1c0  00031658  2**0
                  CONTENTS
1325 .inttab_tc5_00F 00000000  80ffe1e0  80ffe1e0  00031658  2**0
                  CONTENTS
1326 .inttab_tc5_010 00000000  80ffe200  80ffe200  00031658  2**0
                  CONTENTS
1327 .inttab_tc5_011 00000000  80ffe220  80ffe220  00031658  2**0
                  CONTENTS
1328 .inttab_tc5_012 00000000  80ffe240  80ffe240  00031658  2**0
                  CONTENTS
1329 .inttab_tc5_013 00000000  80ffe260  80ffe260  00031658  2**0
                  CONTENTS
1330 .inttab_tc5_014 00000000  80ffe280  80ffe280  00031658  2**0
                  CONTENTS
1331 .inttab_tc5_015 00000000  80ffe2a0  80ffe2a0  00031658  2**0
                  CONTENTS
1332 .inttab_tc5_016 00000000  80ffe2c0  80ffe2c0  00031658  2**0
                  CONTENTS
1333 .inttab_tc5_017 00000000  80ffe2e0  80ffe2e0  00031658  2**0
                  CONTENTS
1334 .inttab_tc5_018 00000000  80ffe300  80ffe300  00031658  2**0
                  CONTENTS
1335 .inttab_tc5_019 00000000  80ffe320  80ffe320  00031658  2**0
                  CONTENTS
1336 .inttab_tc5_01A 00000000  80ffe340  80ffe340  00031658  2**0
                  CONTENTS
1337 .inttab_tc5_01B 00000000  80ffe360  80ffe360  00031658  2**0
                  CONTENTS
1338 .inttab_tc5_01C 00000000  80ffe380  80ffe380  00031658  2**0
                  CONTENTS
1339 .inttab_tc5_01D 00000000  80ffe3a0  80ffe3a0  00031658  2**0
                  CONTENTS
1340 .inttab_tc5_01E 00000000  80ffe3c0  80ffe3c0  00031658  2**0
                  CONTENTS
1341 .inttab_tc5_01F 00000000  80ffe3e0  80ffe3e0  00031658  2**0
                  CONTENTS
1342 .inttab_tc5_020 00000000  80ffe400  80ffe400  00031658  2**0
                  CONTENTS
1343 .inttab_tc5_021 00000000  80ffe420  80ffe420  00031658  2**0
                  CONTENTS
1344 .inttab_tc5_022 00000000  80ffe440  80ffe440  00031658  2**0
                  CONTENTS
1345 .inttab_tc5_023 00000000  80ffe460  80ffe460  00031658  2**0
                  CONTENTS
1346 .inttab_tc5_024 00000000  80ffe480  80ffe480  00031658  2**0
                  CONTENTS
1347 .inttab_tc5_025 00000000  80ffe4a0  80ffe4a0  00031658  2**0
                  CONTENTS
1348 .inttab_tc5_026 00000000  80ffe4c0  80ffe4c0  00031658  2**0
                  CONTENTS
1349 .inttab_tc5_027 00000000  80ffe4e0  80ffe4e0  00031658  2**0
                  CONTENTS
1350 .inttab_tc5_028 00000000  80ffe500  80ffe500  00031658  2**0
                  CONTENTS
1351 .inttab_tc5_029 00000000  80ffe520  80ffe520  00031658  2**0
                  CONTENTS
1352 .inttab_tc5_02A 00000000  80ffe540  80ffe540  00031658  2**0
                  CONTENTS
1353 .inttab_tc5_02B 00000000  80ffe560  80ffe560  00031658  2**0
                  CONTENTS
1354 .inttab_tc5_02C 00000000  80ffe580  80ffe580  00031658  2**0
                  CONTENTS
1355 .inttab_tc5_02D 00000000  80ffe5a0  80ffe5a0  00031658  2**0
                  CONTENTS
1356 .inttab_tc5_02E 00000000  80ffe5c0  80ffe5c0  00031658  2**0
                  CONTENTS
1357 .inttab_tc5_02F 00000000  80ffe5e0  80ffe5e0  00031658  2**0
                  CONTENTS
1358 .inttab_tc5_030 00000000  80ffe600  80ffe600  00031658  2**0
                  CONTENTS
1359 .inttab_tc5_031 00000000  80ffe620  80ffe620  00031658  2**0
                  CONTENTS
1360 .inttab_tc5_032 00000000  80ffe640  80ffe640  00031658  2**0
                  CONTENTS
1361 .inttab_tc5_033 00000000  80ffe660  80ffe660  00031658  2**0
                  CONTENTS
1362 .inttab_tc5_034 00000000  80ffe680  80ffe680  00031658  2**0
                  CONTENTS
1363 .inttab_tc5_035 00000000  80ffe6a0  80ffe6a0  00031658  2**0
                  CONTENTS
1364 .inttab_tc5_036 00000000  80ffe6c0  80ffe6c0  00031658  2**0
                  CONTENTS
1365 .inttab_tc5_037 00000000  80ffe6e0  80ffe6e0  00031658  2**0
                  CONTENTS
1366 .inttab_tc5_038 00000000  80ffe700  80ffe700  00031658  2**0
                  CONTENTS
1367 .inttab_tc5_039 00000000  80ffe720  80ffe720  00031658  2**0
                  CONTENTS
1368 .inttab_tc5_03A 00000000  80ffe740  80ffe740  00031658  2**0
                  CONTENTS
1369 .inttab_tc5_03B 00000000  80ffe760  80ffe760  00031658  2**0
                  CONTENTS
1370 .inttab_tc5_03C 00000000  80ffe780  80ffe780  00031658  2**0
                  CONTENTS
1371 .inttab_tc5_03D 00000000  80ffe7a0  80ffe7a0  00031658  2**0
                  CONTENTS
1372 .inttab_tc5_03E 00000000  80ffe7c0  80ffe7c0  00031658  2**0
                  CONTENTS
1373 .inttab_tc5_03F 00000000  80ffe7e0  80ffe7e0  00031658  2**0
                  CONTENTS
1374 .inttab_tc5_040 00000000  80ffe800  80ffe800  00031658  2**0
                  CONTENTS
1375 .inttab_tc5_041 00000000  80ffe820  80ffe820  00031658  2**0
                  CONTENTS
1376 .inttab_tc5_042 00000000  80ffe840  80ffe840  00031658  2**0
                  CONTENTS
1377 .inttab_tc5_043 00000000  80ffe860  80ffe860  00031658  2**0
                  CONTENTS
1378 .inttab_tc5_044 00000000  80ffe880  80ffe880  00031658  2**0
                  CONTENTS
1379 .inttab_tc5_045 00000000  80ffe8a0  80ffe8a0  00031658  2**0
                  CONTENTS
1380 .inttab_tc5_046 00000000  80ffe8c0  80ffe8c0  00031658  2**0
                  CONTENTS
1381 .inttab_tc5_047 00000000  80ffe8e0  80ffe8e0  00031658  2**0
                  CONTENTS
1382 .inttab_tc5_048 00000000  80ffe900  80ffe900  00031658  2**0
                  CONTENTS
1383 .inttab_tc5_049 00000000  80ffe920  80ffe920  00031658  2**0
                  CONTENTS
1384 .inttab_tc5_04A 00000000  80ffe940  80ffe940  00031658  2**0
                  CONTENTS
1385 .inttab_tc5_04B 00000000  80ffe960  80ffe960  00031658  2**0
                  CONTENTS
1386 .inttab_tc5_04C 00000000  80ffe980  80ffe980  00031658  2**0
                  CONTENTS
1387 .inttab_tc5_04D 00000000  80ffe9a0  80ffe9a0  00031658  2**0
                  CONTENTS
1388 .inttab_tc5_04E 00000000  80ffe9c0  80ffe9c0  00031658  2**0
                  CONTENTS
1389 .inttab_tc5_04F 00000000  80ffe9e0  80ffe9e0  00031658  2**0
                  CONTENTS
1390 .inttab_tc5_050 00000000  80ffea00  80ffea00  00031658  2**0
                  CONTENTS
1391 .inttab_tc5_051 00000000  80ffea20  80ffea20  00031658  2**0
                  CONTENTS
1392 .inttab_tc5_052 00000000  80ffea40  80ffea40  00031658  2**0
                  CONTENTS
1393 .inttab_tc5_053 00000000  80ffea60  80ffea60  00031658  2**0
                  CONTENTS
1394 .inttab_tc5_054 00000000  80ffea80  80ffea80  00031658  2**0
                  CONTENTS
1395 .inttab_tc5_055 00000000  80ffeaa0  80ffeaa0  00031658  2**0
                  CONTENTS
1396 .inttab_tc5_056 00000000  80ffeac0  80ffeac0  00031658  2**0
                  CONTENTS
1397 .inttab_tc5_057 00000000  80ffeae0  80ffeae0  00031658  2**0
                  CONTENTS
1398 .inttab_tc5_058 00000000  80ffeb00  80ffeb00  00031658  2**0
                  CONTENTS
1399 .inttab_tc5_059 00000000  80ffeb20  80ffeb20  00031658  2**0
                  CONTENTS
1400 .inttab_tc5_05A 00000000  80ffeb40  80ffeb40  00031658  2**0
                  CONTENTS
1401 .inttab_tc5_05B 00000000  80ffeb60  80ffeb60  00031658  2**0
                  CONTENTS
1402 .inttab_tc5_05C 00000000  80ffeb80  80ffeb80  00031658  2**0
                  CONTENTS
1403 .inttab_tc5_05D 00000000  80ffeba0  80ffeba0  00031658  2**0
                  CONTENTS
1404 .inttab_tc5_05E 00000000  80ffebc0  80ffebc0  00031658  2**0
                  CONTENTS
1405 .inttab_tc5_05F 00000000  80ffebe0  80ffebe0  00031658  2**0
                  CONTENTS
1406 .inttab_tc5_060 00000000  80ffec00  80ffec00  00031658  2**0
                  CONTENTS
1407 .inttab_tc5_061 00000000  80ffec20  80ffec20  00031658  2**0
                  CONTENTS
1408 .inttab_tc5_062 00000000  80ffec40  80ffec40  00031658  2**0
                  CONTENTS
1409 .inttab_tc5_063 00000000  80ffec60  80ffec60  00031658  2**0
                  CONTENTS
1410 .inttab_tc5_064 00000000  80ffec80  80ffec80  00031658  2**0
                  CONTENTS
1411 .inttab_tc5_065 00000000  80ffeca0  80ffeca0  00031658  2**0
                  CONTENTS
1412 .inttab_tc5_066 00000000  80ffecc0  80ffecc0  00031658  2**0
                  CONTENTS
1413 .inttab_tc5_067 00000000  80ffece0  80ffece0  00031658  2**0
                  CONTENTS
1414 .inttab_tc5_068 00000000  80ffed00  80ffed00  00031658  2**0
                  CONTENTS
1415 .inttab_tc5_069 00000000  80ffed20  80ffed20  00031658  2**0
                  CONTENTS
1416 .inttab_tc5_06A 00000000  80ffed40  80ffed40  00031658  2**0
                  CONTENTS
1417 .inttab_tc5_06B 00000000  80ffed60  80ffed60  00031658  2**0
                  CONTENTS
1418 .inttab_tc5_06C 00000000  80ffed80  80ffed80  00031658  2**0
                  CONTENTS
1419 .inttab_tc5_06D 00000000  80ffeda0  80ffeda0  00031658  2**0
                  CONTENTS
1420 .inttab_tc5_06E 00000000  80ffedc0  80ffedc0  00031658  2**0
                  CONTENTS
1421 .inttab_tc5_06F 00000000  80ffede0  80ffede0  00031658  2**0
                  CONTENTS
1422 .inttab_tc5_070 00000000  80ffee00  80ffee00  00031658  2**0
                  CONTENTS
1423 .inttab_tc5_071 00000000  80ffee20  80ffee20  00031658  2**0
                  CONTENTS
1424 .inttab_tc5_072 00000000  80ffee40  80ffee40  00031658  2**0
                  CONTENTS
1425 .inttab_tc5_073 00000000  80ffee60  80ffee60  00031658  2**0
                  CONTENTS
1426 .inttab_tc5_074 00000000  80ffee80  80ffee80  00031658  2**0
                  CONTENTS
1427 .inttab_tc5_075 00000000  80ffeea0  80ffeea0  00031658  2**0
                  CONTENTS
1428 .inttab_tc5_076 00000000  80ffeec0  80ffeec0  00031658  2**0
                  CONTENTS
1429 .inttab_tc5_077 00000000  80ffeee0  80ffeee0  00031658  2**0
                  CONTENTS
1430 .inttab_tc5_078 00000000  80ffef00  80ffef00  00031658  2**0
                  CONTENTS
1431 .inttab_tc5_079 00000000  80ffef20  80ffef20  00031658  2**0
                  CONTENTS
1432 .inttab_tc5_07A 00000000  80ffef40  80ffef40  00031658  2**0
                  CONTENTS
1433 .inttab_tc5_07B 00000000  80ffef60  80ffef60  00031658  2**0
                  CONTENTS
1434 .inttab_tc5_07C 00000000  80ffef80  80ffef80  00031658  2**0
                  CONTENTS
1435 .inttab_tc5_07D 00000000  80ffefa0  80ffefa0  00031658  2**0
                  CONTENTS
1436 .inttab_tc5_07E 00000000  80ffefc0  80ffefc0  00031658  2**0
                  CONTENTS
1437 .inttab_tc5_07F 00000000  80ffefe0  80ffefe0  00031658  2**0
                  CONTENTS
1438 .inttab_tc5_080 00000000  80fff000  80fff000  00031658  2**0
                  CONTENTS
1439 .inttab_tc5_081 00000000  80fff020  80fff020  00031658  2**0
                  CONTENTS
1440 .inttab_tc5_082 00000000  80fff040  80fff040  00031658  2**0
                  CONTENTS
1441 .inttab_tc5_083 00000000  80fff060  80fff060  00031658  2**0
                  CONTENTS
1442 .inttab_tc5_084 00000000  80fff080  80fff080  00031658  2**0
                  CONTENTS
1443 .inttab_tc5_085 00000000  80fff0a0  80fff0a0  00031658  2**0
                  CONTENTS
1444 .inttab_tc5_086 00000000  80fff0c0  80fff0c0  00031658  2**0
                  CONTENTS
1445 .inttab_tc5_087 00000000  80fff0e0  80fff0e0  00031658  2**0
                  CONTENTS
1446 .inttab_tc5_088 00000000  80fff100  80fff100  00031658  2**0
                  CONTENTS
1447 .inttab_tc5_089 00000000  80fff120  80fff120  00031658  2**0
                  CONTENTS
1448 .inttab_tc5_08A 00000000  80fff140  80fff140  00031658  2**0
                  CONTENTS
1449 .inttab_tc5_08B 00000000  80fff160  80fff160  00031658  2**0
                  CONTENTS
1450 .inttab_tc5_08C 00000000  80fff180  80fff180  00031658  2**0
                  CONTENTS
1451 .inttab_tc5_08D 00000000  80fff1a0  80fff1a0  00031658  2**0
                  CONTENTS
1452 .inttab_tc5_08E 00000000  80fff1c0  80fff1c0  00031658  2**0
                  CONTENTS
1453 .inttab_tc5_08F 00000000  80fff1e0  80fff1e0  00031658  2**0
                  CONTENTS
1454 .inttab_tc5_090 00000000  80fff200  80fff200  00031658  2**0
                  CONTENTS
1455 .inttab_tc5_091 00000000  80fff220  80fff220  00031658  2**0
                  CONTENTS
1456 .inttab_tc5_092 00000000  80fff240  80fff240  00031658  2**0
                  CONTENTS
1457 .inttab_tc5_093 00000000  80fff260  80fff260  00031658  2**0
                  CONTENTS
1458 .inttab_tc5_094 00000000  80fff280  80fff280  00031658  2**0
                  CONTENTS
1459 .inttab_tc5_095 00000000  80fff2a0  80fff2a0  00031658  2**0
                  CONTENTS
1460 .inttab_tc5_096 00000000  80fff2c0  80fff2c0  00031658  2**0
                  CONTENTS
1461 .inttab_tc5_097 00000000  80fff2e0  80fff2e0  00031658  2**0
                  CONTENTS
1462 .inttab_tc5_098 00000000  80fff300  80fff300  00031658  2**0
                  CONTENTS
1463 .inttab_tc5_099 00000000  80fff320  80fff320  00031658  2**0
                  CONTENTS
1464 .inttab_tc5_09A 00000000  80fff340  80fff340  00031658  2**0
                  CONTENTS
1465 .inttab_tc5_09B 00000000  80fff360  80fff360  00031658  2**0
                  CONTENTS
1466 .inttab_tc5_09C 00000000  80fff380  80fff380  00031658  2**0
                  CONTENTS
1467 .inttab_tc5_09D 00000000  80fff3a0  80fff3a0  00031658  2**0
                  CONTENTS
1468 .inttab_tc5_09E 00000000  80fff3c0  80fff3c0  00031658  2**0
                  CONTENTS
1469 .inttab_tc5_09F 00000000  80fff3e0  80fff3e0  00031658  2**0
                  CONTENTS
1470 .inttab_tc5_0A0 00000000  80fff400  80fff400  00031658  2**0
                  CONTENTS
1471 .inttab_tc5_0A1 00000000  80fff420  80fff420  00031658  2**0
                  CONTENTS
1472 .inttab_tc5_0A2 00000000  80fff440  80fff440  00031658  2**0
                  CONTENTS
1473 .inttab_tc5_0A3 00000000  80fff460  80fff460  00031658  2**0
                  CONTENTS
1474 .inttab_tc5_0A4 00000000  80fff480  80fff480  00031658  2**0
                  CONTENTS
1475 .inttab_tc5_0A5 00000000  80fff4a0  80fff4a0  00031658  2**0
                  CONTENTS
1476 .inttab_tc5_0A6 00000000  80fff4c0  80fff4c0  00031658  2**0
                  CONTENTS
1477 .inttab_tc5_0A7 00000000  80fff4e0  80fff4e0  00031658  2**0
                  CONTENTS
1478 .inttab_tc5_0A8 00000000  80fff500  80fff500  00031658  2**0
                  CONTENTS
1479 .inttab_tc5_0A9 00000000  80fff520  80fff520  00031658  2**0
                  CONTENTS
1480 .inttab_tc5_0AA 00000000  80fff540  80fff540  00031658  2**0
                  CONTENTS
1481 .inttab_tc5_0AB 00000000  80fff560  80fff560  00031658  2**0
                  CONTENTS
1482 .inttab_tc5_0AC 00000000  80fff580  80fff580  00031658  2**0
                  CONTENTS
1483 .inttab_tc5_0AD 00000000  80fff5a0  80fff5a0  00031658  2**0
                  CONTENTS
1484 .inttab_tc5_0AE 00000000  80fff5c0  80fff5c0  00031658  2**0
                  CONTENTS
1485 .inttab_tc5_0AF 00000000  80fff5e0  80fff5e0  00031658  2**0
                  CONTENTS
1486 .inttab_tc5_0B0 00000000  80fff600  80fff600  00031658  2**0
                  CONTENTS
1487 .inttab_tc5_0B1 00000000  80fff620  80fff620  00031658  2**0
                  CONTENTS
1488 .inttab_tc5_0B2 00000000  80fff640  80fff640  00031658  2**0
                  CONTENTS
1489 .inttab_tc5_0B3 00000000  80fff660  80fff660  00031658  2**0
                  CONTENTS
1490 .inttab_tc5_0B4 00000000  80fff680  80fff680  00031658  2**0
                  CONTENTS
1491 .inttab_tc5_0B5 00000000  80fff6a0  80fff6a0  00031658  2**0
                  CONTENTS
1492 .inttab_tc5_0B6 00000000  80fff6c0  80fff6c0  00031658  2**0
                  CONTENTS
1493 .inttab_tc5_0B7 00000000  80fff6e0  80fff6e0  00031658  2**0
                  CONTENTS
1494 .inttab_tc5_0B8 00000000  80fff700  80fff700  00031658  2**0
                  CONTENTS
1495 .inttab_tc5_0B9 00000000  80fff720  80fff720  00031658  2**0
                  CONTENTS
1496 .inttab_tc5_0BA 00000000  80fff740  80fff740  00031658  2**0
                  CONTENTS
1497 .inttab_tc5_0BB 00000000  80fff760  80fff760  00031658  2**0
                  CONTENTS
1498 .inttab_tc5_0BC 00000000  80fff780  80fff780  00031658  2**0
                  CONTENTS
1499 .inttab_tc5_0BD 00000000  80fff7a0  80fff7a0  00031658  2**0
                  CONTENTS
1500 .inttab_tc5_0BE 00000000  80fff7c0  80fff7c0  00031658  2**0
                  CONTENTS
1501 .inttab_tc5_0BF 00000000  80fff7e0  80fff7e0  00031658  2**0
                  CONTENTS
1502 .inttab_tc5_0C0 00000000  80fff800  80fff800  00031658  2**0
                  CONTENTS
1503 .inttab_tc5_0C1 00000000  80fff820  80fff820  00031658  2**0
                  CONTENTS
1504 .inttab_tc5_0C2 00000000  80fff840  80fff840  00031658  2**0
                  CONTENTS
1505 .inttab_tc5_0C3 00000000  80fff860  80fff860  00031658  2**0
                  CONTENTS
1506 .inttab_tc5_0C4 00000000  80fff880  80fff880  00031658  2**0
                  CONTENTS
1507 .inttab_tc5_0C5 00000000  80fff8a0  80fff8a0  00031658  2**0
                  CONTENTS
1508 .inttab_tc5_0C6 00000000  80fff8c0  80fff8c0  00031658  2**0
                  CONTENTS
1509 .inttab_tc5_0C7 00000000  80fff8e0  80fff8e0  00031658  2**0
                  CONTENTS
1510 .inttab_tc5_0C8 00000000  80fff900  80fff900  00031658  2**0
                  CONTENTS
1511 .inttab_tc5_0C9 00000000  80fff920  80fff920  00031658  2**0
                  CONTENTS
1512 .inttab_tc5_0CA 00000000  80fff940  80fff940  00031658  2**0
                  CONTENTS
1513 .inttab_tc5_0CB 00000000  80fff960  80fff960  00031658  2**0
                  CONTENTS
1514 .inttab_tc5_0CC 00000000  80fff980  80fff980  00031658  2**0
                  CONTENTS
1515 .inttab_tc5_0CD 00000000  80fff9a0  80fff9a0  00031658  2**0
                  CONTENTS
1516 .inttab_tc5_0CE 00000000  80fff9c0  80fff9c0  00031658  2**0
                  CONTENTS
1517 .inttab_tc5_0CF 00000000  80fff9e0  80fff9e0  00031658  2**0
                  CONTENTS
1518 .inttab_tc5_0D0 00000000  80fffa00  80fffa00  00031658  2**0
                  CONTENTS
1519 .inttab_tc5_0D1 00000000  80fffa20  80fffa20  00031658  2**0
                  CONTENTS
1520 .inttab_tc5_0D2 00000000  80fffa40  80fffa40  00031658  2**0
                  CONTENTS
1521 .inttab_tc5_0D3 00000000  80fffa60  80fffa60  00031658  2**0
                  CONTENTS
1522 .inttab_tc5_0D4 00000000  80fffa80  80fffa80  00031658  2**0
                  CONTENTS
1523 .inttab_tc5_0D5 00000000  80fffaa0  80fffaa0  00031658  2**0
                  CONTENTS
1524 .inttab_tc5_0D6 00000000  80fffac0  80fffac0  00031658  2**0
                  CONTENTS
1525 .inttab_tc5_0D7 00000000  80fffae0  80fffae0  00031658  2**0
                  CONTENTS
1526 .inttab_tc5_0D8 00000000  80fffb00  80fffb00  00031658  2**0
                  CONTENTS
1527 .inttab_tc5_0D9 00000000  80fffb20  80fffb20  00031658  2**0
                  CONTENTS
1528 .inttab_tc5_0DA 00000000  80fffb40  80fffb40  00031658  2**0
                  CONTENTS
1529 .inttab_tc5_0DB 00000000  80fffb60  80fffb60  00031658  2**0
                  CONTENTS
1530 .inttab_tc5_0DC 00000000  80fffb80  80fffb80  00031658  2**0
                  CONTENTS
1531 .inttab_tc5_0DD 00000000  80fffba0  80fffba0  00031658  2**0
                  CONTENTS
1532 .inttab_tc5_0DE 00000000  80fffbc0  80fffbc0  00031658  2**0
                  CONTENTS
1533 .inttab_tc5_0DF 00000000  80fffbe0  80fffbe0  00031658  2**0
                  CONTENTS
1534 .inttab_tc5_0E0 00000000  80fffc00  80fffc00  00031658  2**0
                  CONTENTS
1535 .inttab_tc5_0E1 00000000  80fffc20  80fffc20  00031658  2**0
                  CONTENTS
1536 .inttab_tc5_0E2 00000000  80fffc40  80fffc40  00031658  2**0
                  CONTENTS
1537 .inttab_tc5_0E3 00000000  80fffc60  80fffc60  00031658  2**0
                  CONTENTS
1538 .inttab_tc5_0E4 00000000  80fffc80  80fffc80  00031658  2**0
                  CONTENTS
1539 .inttab_tc5_0E5 00000000  80fffca0  80fffca0  00031658  2**0
                  CONTENTS
1540 .inttab_tc5_0E6 00000000  80fffcc0  80fffcc0  00031658  2**0
                  CONTENTS
1541 .inttab_tc5_0E7 00000000  80fffce0  80fffce0  00031658  2**0
                  CONTENTS
1542 .inttab_tc5_0E8 00000000  80fffd00  80fffd00  00031658  2**0
                  CONTENTS
1543 .inttab_tc5_0E9 00000000  80fffd20  80fffd20  00031658  2**0
                  CONTENTS
1544 .inttab_tc5_0EA 00000000  80fffd40  80fffd40  00031658  2**0
                  CONTENTS
1545 .inttab_tc5_0EB 00000000  80fffd60  80fffd60  00031658  2**0
                  CONTENTS
1546 .inttab_tc5_0EC 00000000  80fffd80  80fffd80  00031658  2**0
                  CONTENTS
1547 .inttab_tc5_0ED 00000000  80fffda0  80fffda0  00031658  2**0
                  CONTENTS
1548 .inttab_tc5_0EE 00000000  80fffdc0  80fffdc0  00031658  2**0
                  CONTENTS
1549 .inttab_tc5_0EF 00000000  80fffde0  80fffde0  00031658  2**0
                  CONTENTS
1550 .inttab_tc5_0F0 00000000  80fffe00  80fffe00  00031658  2**0
                  CONTENTS
1551 .inttab_tc5_0F1 00000000  80fffe20  80fffe20  00031658  2**0
                  CONTENTS
1552 .inttab_tc5_0F2 00000000  80fffe40  80fffe40  00031658  2**0
                  CONTENTS
1553 .inttab_tc5_0F3 00000000  80fffe60  80fffe60  00031658  2**0
                  CONTENTS
1554 .inttab_tc5_0F4 00000000  80fffe80  80fffe80  00031658  2**0
                  CONTENTS
1555 .inttab_tc5_0F5 00000000  80fffea0  80fffea0  00031658  2**0
                  CONTENTS
1556 .inttab_tc5_0F6 00000000  80fffec0  80fffec0  00031658  2**0
                  CONTENTS
1557 .inttab_tc5_0F7 00000000  80fffee0  80fffee0  00031658  2**0
                  CONTENTS
1558 .inttab_tc5_0F8 00000000  80ffff00  80ffff00  00031658  2**0
                  CONTENTS
1559 .inttab_tc5_0F9 00000000  80ffff20  80ffff20  00031658  2**0
                  CONTENTS
1560 .inttab_tc5_0FA 00000000  80ffff40  80ffff40  00031658  2**0
                  CONTENTS
1561 .inttab_tc5_0FB 00000000  80ffff60  80ffff60  00031658  2**0
                  CONTENTS
1562 .inttab_tc5_0FC 00000000  80ffff80  80ffff80  00031658  2**0
                  CONTENTS
1563 .inttab_tc5_0FD 00000000  80ffffa0  80ffffa0  00031658  2**0
                  CONTENTS
1564 .inttab_tc5_0FE 00000000  80ffffc0  80ffffc0  00031658  2**0
                  CONTENTS
1565 .inttab_tc5_0FF 00000000  80ffffe0  80ffffe0  00031658  2**0
                  CONTENTS
1566 .bmhd_0_org   000001f4  af400000  af400000  000306b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1567 .bmhd_1_org   000001f4  af400200  af400200  000308ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1568 .bmhd_2_org   000001f4  af400400  af400400  00030aa0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1569 .bmhd_3_org   000001f4  af400600  af400600  00030c94  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1570 .bmhd_0_copy  000001f4  af401000  af401000  00030e88  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1571 .bmhd_1_copy  000001f4  af401200  af401200  0003107c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1572 .bmhd_2_copy  000001f4  af401400  af401400  00031270  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1573 .bmhd_3_copy  000001f4  af401600  af401600  00031464  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1574 .CPU5.zdata   00000000  10000000  10000000  00031658  2**0
                  CONTENTS
1575 .CPU4.zdata   00000000  30000000  30000000  00031658  2**0
                  CONTENTS
1576 .CPU3.zdata   00000000  40000000  40000000  00031658  2**0
                  CONTENTS
1577 .CPU2.zdata   00000000  50000000  50000000  00031658  2**0
                  CONTENTS
1578 .CPU1.zdata   00000000  60000000  60000000  00031658  2**0
                  CONTENTS
1579 .CPU0.zdata   00000000  70000000  70000000  00031658  2**0
                  CONTENTS
1580 .zdata_powerOn 00000000  70000000  70000000  00031658  2**0
                  CONTENTS
1581 .zdata        00000000  70000000  70000000  00031658  2**0
                  CONTENTS, ALLOC, LOAD, DATA
1582 .lmuzdata     00000000  90000000  90000000  00031658  2**0
                  CONTENTS
1583 .sdata        00000000  70000000  70000000  00031658  2**0
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
1584 .sdata4       00000000  90040000  90040000  00031658  2**0
                  CONTENTS, ALLOC, LOAD, DATA
1585 .CPU5.data    00000000  10000000  10000000  00031658  2**0
                  CONTENTS
1586 .CPU5.lmudata 00000000  90110000  90110000  00031658  2**0
                  CONTENTS
1587 .CPU4.data    00000000  30000000  30000000  00031658  2**0
                  CONTENTS
1588 .CPU4.lmudata 00000000  90100000  90100000  00031658  2**0
                  CONTENTS
1589 .CPU3.data    00000000  40000000  40000000  00031658  2**0
                  CONTENTS
1590 .CPU3.lmudata 00000000  90030000  90030000  00031658  2**0
                  CONTENTS
1591 .CPU2.data    00000000  50000000  50000000  00031658  2**0
                  CONTENTS
1592 .CPU2.lmudata 00000000  90020000  90020000  00031658  2**0
                  CONTENTS
1593 .CPU1.data    00000000  60000000  60000000  00031658  2**0
                  CONTENTS
1594 .CPU1.lmudata 00000000  90010000  90010000  00031658  2**0
                  CONTENTS
1595 .CPU0.data    00000000  70000000  70000000  00031658  2**0
                  CONTENTS
1596 .CPU0.bss     0000a22c  70000000  80000200  00000820  2**2
                  ALLOC
1597 .CPU0.lmudata 00000000  90000000  90000000  00031658  2**0
                  CONTENTS
1598 .data         00000710  7000a230  80000200  00000820  2**3
                  CONTENTS, ALLOC, LOAD, DATA
1599 .bss          00009ce4  7000a940  80000910  00000f30  2**3
                  ALLOC
1600 .heap         00001000  70014624  80000910  00000f30  2**0
                  ALLOC
1601 .lmudata      00000000  90040000  90040000  00031658  2**0
                  CONTENTS
1602 .CPU0.rodata  00000027  80000910  80000910  00000f30  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1603 .rodata       00003fa0  80000938  80000938  00000f58  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
1604 .CPU0.psram_text 00000000  70100000  70100000  00031658  2**0
                  CONTENTS
1605 .CPU1.psram_text 00000000  60100000  60100000  00031658  2**0
                  CONTENTS
1606 .CPU2.psram_text 00000000  50100000  50100000  00031658  2**0
                  CONTENTS
1607 .CPU3.psram_text 00000000  40100000  40100000  00031658  2**0
                  CONTENTS
1608 .CPU4.psram_text 00000000  30100000  30100000  00031658  2**0
                  CONTENTS
1609 .CPU5.psram_text 00000000  10100000  10100000  00031658  2**0
                  CONTENTS
1610 .CPU0.text    00000c6e  800048d8  800048d8  00004ef8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1611 .init         00000010  80005548  80005548  00005b68  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1612 .fini         00000008  80005558  80005558  00005b78  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1613 .CPU1.text    00000206  8030010c  8030010c  0002f800  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1614 .CPU2.text    00000206  8060010c  8060010c  0002fb20  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1615 .CPU3.text    00000202  8090010c  8090010c  0002fe40  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1616 .CPU4.text    00000202  80c0010c  80c0010c  00030160  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1617 .CPU5.text    000001f0  80f0010c  80f0010c  00030480  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1618 .text         00029b14  80005560  80005560  00005b80  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
1619 .eh_frame     00000004  8002f074  8002f074  0002f694  2**0
                  ALLOC
1620 .ctors        00000010  8002f078  8002f078  0002f694  2**2
                  CONTENTS, ALLOC, LOAD, DATA
1621 .dtors        00000010  8002f088  8002f088  0002f6a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
1622 .comment      000000c3  00000000  00000000  00031658  2**0
                  CONTENTS, READONLY
1623 .debug_aranges 00002580  00000000  00000000  00031720  2**3
                  CONTENTS, READONLY, DEBUGGING
1624 .debug_info   001a00ed  00000000  00000000  00033ca0  2**0
                  CONTENTS, READONLY, DEBUGGING
1625 .debug_abbrev 000122d5  00000000  00000000  001d3d8d  2**0
                  CONTENTS, READONLY, DEBUGGING
1626 .debug_line   0004353b  00000000  00000000  001e6062  2**0
                  CONTENTS, READONLY, DEBUGGING
1627 .debug_frame  00004cd8  00000000  00000000  002295a0  2**2
                  CONTENTS, READONLY, DEBUGGING
1628 .debug_str    00004385  00000000  00000000  0022e278  2**0
                  CONTENTS, READONLY, DEBUGGING
1629 .debug_loc    00011a40  00000000  00000000  002325fd  2**0
                  CONTENTS, READONLY, DEBUGGING
1630 .debug_ranges 00001160  00000000  00000000  00244040  2**3
                  CONTENTS, READONLY, DEBUGGING
1631 .debug_macro  00104773  00000000  00000000  002451a0  2**0
                  CONTENTS, READONLY, DEBUGGING
1632 .debug_rnglists 00001627  00000000  00000000  00349913  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .start_tc0:

a0000000 <_START>:
}


IFX_SSW_INLINE void Ifx_Ssw_jumpToFunction(void (*fun)(void))
{
    __asm__ volatile ("ji %0" ::"a" (fun));
a0000000:	91 00 00 28 	movh.a %a2,32768
a0000004:	d9 22 9c 34 	lea %a2,[%a2]18652 <800048dc <__StartUpSoftware>>
a0000008:	dc 02       	ji %a2
#endif

void _START(void)
{
    Ifx_Ssw_jumpToFunction(__StartUpSoftware);
}
a000000a:	00 90       	ret 

Disassembly of section .traptab_tc0:

80000100 <IfxCpu_Trap_vectorTable0>:
#pragma ghs section
#pragma ghs section text=".traptab_cpu0"
#endif
void IfxCpu_Trap_vectorTable0(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80000100:	0d 00 00 02 	svlcx 
80000104:	02 f4       	mov %d4,%d15
80000106:	91 10 00 28 	movh.a %a2,32769
8000010a:	d9 22 48 2d 	lea %a2,[%a2]-11128 <8000d488 <IfxCpu_Trap_memoryManagementError>>
8000010e:	dc 02       	ji %a2
80000110:	00 80       	rfe 
	...
8000011e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80000120:	0d 00 00 02 	svlcx 
80000124:	02 f4       	mov %d4,%d15
80000126:	91 10 00 28 	movh.a %a2,32769
8000012a:	d9 22 4a 4d 	lea %a2,[%a2]-10998 <8000d50a <IfxCpu_Trap_internalProtectionError>>
8000012e:	dc 02       	ji %a2
80000130:	00 80       	rfe 
	...
8000013e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80000140:	0d 00 00 02 	svlcx 
80000144:	02 f4       	mov %d4,%d15
80000146:	91 10 00 28 	movh.a %a2,32769
8000014a:	d9 22 4c 6d 	lea %a2,[%a2]-10868 <8000d58c <IfxCpu_Trap_instructionError>>
8000014e:	dc 02       	ji %a2
80000150:	00 80       	rfe 
	...
8000015e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80000160:	02 f4       	mov %d4,%d15
80000162:	91 10 00 28 	movh.a %a2,32769
80000166:	d9 22 4e 8d 	lea %a2,[%a2]-10738 <8000d60e <IfxCpu_Trap_contextManagementError>>
8000016a:	dc 02       	ji %a2
8000016c:	00 80       	rfe 
	...
8000017e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80000180:	0d 00 00 02 	svlcx 
80000184:	02 f4       	mov %d4,%d15
80000186:	91 10 00 28 	movh.a %a2,32769
8000018a:	d9 22 50 ad 	lea %a2,[%a2]-10608 <8000d690 <IfxCpu_Trap_busError>>
8000018e:	dc 02       	ji %a2
80000190:	00 80       	rfe 
	...
8000019e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
800001a0:	0d 00 00 02 	svlcx 
800001a4:	02 f4       	mov %d4,%d15
800001a6:	91 10 00 28 	movh.a %a2,32769
800001aa:	d9 22 52 cd 	lea %a2,[%a2]-10478 <8000d712 <IfxCpu_Trap_assertion>>
800001ae:	dc 02       	ji %a2
800001b0:	00 80       	rfe 
	...
800001be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu0);
800001c0:	0d 00 00 02 	svlcx 
800001c4:	02 f4       	mov %d4,%d15
800001c6:	91 10 00 28 	movh.a %a2,32769
800001ca:	d9 22 54 ed 	lea %a2,[%a2]-10348 <8000d794 <IfxCpu_Trap_systemCall_Cpu0>>
800001ce:	dc 02       	ji %a2
800001d0:	00 80       	rfe 
	...
800001de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
800001e0:	0d 00 00 02 	svlcx 
800001e4:	02 f4       	mov %d4,%d15
800001e6:	91 10 00 28 	movh.a %a2,32769
800001ea:	d9 22 88 ad 	lea %a2,[%a2]-9592 <8000da88 <IfxCpu_Trap_nonMaskableInterrupt>>
800001ee:	dc 02       	ji %a2
800001f0:	00 80       	rfe 
}
800001f2:	00 90       	ret 

800001f4 <IfxCpu_Trap_vectorTable0_end>:
	...

Disassembly of section .traptab_tc1:

80300000 <IfxCpu_Trap_vectorTable1>:
#pragma ghs section
#pragma ghs section text=".traptab_cpu1"
#endif
void IfxCpu_Trap_vectorTable1(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80300000:	0d 00 00 02 	svlcx 
80300004:	02 f4       	mov %d4,%d15
80300006:	91 10 00 28 	movh.a %a2,32769
8030000a:	d9 22 48 2d 	lea %a2,[%a2]-11128 <8000d488 <IfxCpu_Trap_memoryManagementError>>
8030000e:	dc 02       	ji %a2
80300010:	00 80       	rfe 
	...
8030001e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80300020:	0d 00 00 02 	svlcx 
80300024:	02 f4       	mov %d4,%d15
80300026:	91 10 00 28 	movh.a %a2,32769
8030002a:	d9 22 4a 4d 	lea %a2,[%a2]-10998 <8000d50a <IfxCpu_Trap_internalProtectionError>>
8030002e:	dc 02       	ji %a2
80300030:	00 80       	rfe 
	...
8030003e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80300040:	0d 00 00 02 	svlcx 
80300044:	02 f4       	mov %d4,%d15
80300046:	91 10 00 28 	movh.a %a2,32769
8030004a:	d9 22 4c 6d 	lea %a2,[%a2]-10868 <8000d58c <IfxCpu_Trap_instructionError>>
8030004e:	dc 02       	ji %a2
80300050:	00 80       	rfe 
	...
8030005e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80300060:	02 f4       	mov %d4,%d15
80300062:	91 10 00 28 	movh.a %a2,32769
80300066:	d9 22 4e 8d 	lea %a2,[%a2]-10738 <8000d60e <IfxCpu_Trap_contextManagementError>>
8030006a:	dc 02       	ji %a2
8030006c:	00 80       	rfe 
	...
8030007e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80300080:	0d 00 00 02 	svlcx 
80300084:	02 f4       	mov %d4,%d15
80300086:	91 10 00 28 	movh.a %a2,32769
8030008a:	d9 22 50 ad 	lea %a2,[%a2]-10608 <8000d690 <IfxCpu_Trap_busError>>
8030008e:	dc 02       	ji %a2
80300090:	00 80       	rfe 
	...
8030009e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
803000a0:	0d 00 00 02 	svlcx 
803000a4:	02 f4       	mov %d4,%d15
803000a6:	91 10 00 28 	movh.a %a2,32769
803000aa:	d9 22 52 cd 	lea %a2,[%a2]-10478 <8000d712 <IfxCpu_Trap_assertion>>
803000ae:	dc 02       	ji %a2
803000b0:	00 80       	rfe 
	...
803000be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu1);
803000c0:	0d 00 00 02 	svlcx 
803000c4:	02 f4       	mov %d4,%d15
803000c6:	91 10 00 28 	movh.a %a2,32769
803000ca:	d9 22 92 0d 	lea %a2,[%a2]-10222 <8000d812 <IfxCpu_Trap_systemCall_Cpu1>>
803000ce:	dc 02       	ji %a2
803000d0:	00 80       	rfe 
	...
803000de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
803000e0:	0d 00 00 02 	svlcx 
803000e4:	02 f4       	mov %d4,%d15
803000e6:	91 10 00 28 	movh.a %a2,32769
803000ea:	d9 22 88 ad 	lea %a2,[%a2]-9592 <8000da88 <IfxCpu_Trap_nonMaskableInterrupt>>
803000ee:	dc 02       	ji %a2
803000f0:	00 80       	rfe 
}
803000f2:	00 90       	ret 

803000f4 <IfxCpu_Trap_vectorTable1_end>:
	...

Disassembly of section .traptab_tc2:

80600000 <IfxCpu_Trap_vectorTable2>:
#pragma ghs section text=".traptab_cpu2"
#endif

void IfxCpu_Trap_vectorTable2(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80600000:	0d 00 00 02 	svlcx 
80600004:	02 f4       	mov %d4,%d15
80600006:	91 10 00 28 	movh.a %a2,32769
8060000a:	d9 22 48 2d 	lea %a2,[%a2]-11128 <8000d488 <IfxCpu_Trap_memoryManagementError>>
8060000e:	dc 02       	ji %a2
80600010:	00 80       	rfe 
	...
8060001e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80600020:	0d 00 00 02 	svlcx 
80600024:	02 f4       	mov %d4,%d15
80600026:	91 10 00 28 	movh.a %a2,32769
8060002a:	d9 22 4a 4d 	lea %a2,[%a2]-10998 <8000d50a <IfxCpu_Trap_internalProtectionError>>
8060002e:	dc 02       	ji %a2
80600030:	00 80       	rfe 
	...
8060003e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80600040:	0d 00 00 02 	svlcx 
80600044:	02 f4       	mov %d4,%d15
80600046:	91 10 00 28 	movh.a %a2,32769
8060004a:	d9 22 4c 6d 	lea %a2,[%a2]-10868 <8000d58c <IfxCpu_Trap_instructionError>>
8060004e:	dc 02       	ji %a2
80600050:	00 80       	rfe 
	...
8060005e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80600060:	02 f4       	mov %d4,%d15
80600062:	91 10 00 28 	movh.a %a2,32769
80600066:	d9 22 4e 8d 	lea %a2,[%a2]-10738 <8000d60e <IfxCpu_Trap_contextManagementError>>
8060006a:	dc 02       	ji %a2
8060006c:	00 80       	rfe 
	...
8060007e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80600080:	0d 00 00 02 	svlcx 
80600084:	02 f4       	mov %d4,%d15
80600086:	91 10 00 28 	movh.a %a2,32769
8060008a:	d9 22 50 ad 	lea %a2,[%a2]-10608 <8000d690 <IfxCpu_Trap_busError>>
8060008e:	dc 02       	ji %a2
80600090:	00 80       	rfe 
	...
8060009e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
806000a0:	0d 00 00 02 	svlcx 
806000a4:	02 f4       	mov %d4,%d15
806000a6:	91 10 00 28 	movh.a %a2,32769
806000aa:	d9 22 52 cd 	lea %a2,[%a2]-10478 <8000d712 <IfxCpu_Trap_assertion>>
806000ae:	dc 02       	ji %a2
806000b0:	00 80       	rfe 
	...
806000be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu2);
806000c0:	0d 00 00 02 	svlcx 
806000c4:	02 f4       	mov %d4,%d15
806000c6:	91 10 00 28 	movh.a %a2,32769
806000ca:	d9 22 90 2d 	lea %a2,[%a2]-10096 <8000d890 <IfxCpu_Trap_systemCall_Cpu2>>
806000ce:	dc 02       	ji %a2
806000d0:	00 80       	rfe 
	...
806000de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
806000e0:	0d 00 00 02 	svlcx 
806000e4:	02 f4       	mov %d4,%d15
806000e6:	91 10 00 28 	movh.a %a2,32769
806000ea:	d9 22 88 ad 	lea %a2,[%a2]-9592 <8000da88 <IfxCpu_Trap_nonMaskableInterrupt>>
806000ee:	dc 02       	ji %a2
806000f0:	00 80       	rfe 
}
806000f2:	00 90       	ret 

806000f4 <IfxCpu_Trap_vectorTable2_end>:
	...

Disassembly of section .traptab_tc3:

80900000 <IfxCpu_Trap_vectorTable3>:
#endif


void IfxCpu_Trap_vectorTable3(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80900000:	0d 00 00 02 	svlcx 
80900004:	02 f4       	mov %d4,%d15
80900006:	91 10 00 28 	movh.a %a2,32769
8090000a:	d9 22 48 2d 	lea %a2,[%a2]-11128 <8000d488 <IfxCpu_Trap_memoryManagementError>>
8090000e:	dc 02       	ji %a2
80900010:	00 80       	rfe 
	...
8090001e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80900020:	0d 00 00 02 	svlcx 
80900024:	02 f4       	mov %d4,%d15
80900026:	91 10 00 28 	movh.a %a2,32769
8090002a:	d9 22 4a 4d 	lea %a2,[%a2]-10998 <8000d50a <IfxCpu_Trap_internalProtectionError>>
8090002e:	dc 02       	ji %a2
80900030:	00 80       	rfe 
	...
8090003e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80900040:	0d 00 00 02 	svlcx 
80900044:	02 f4       	mov %d4,%d15
80900046:	91 10 00 28 	movh.a %a2,32769
8090004a:	d9 22 4c 6d 	lea %a2,[%a2]-10868 <8000d58c <IfxCpu_Trap_instructionError>>
8090004e:	dc 02       	ji %a2
80900050:	00 80       	rfe 
	...
8090005e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80900060:	02 f4       	mov %d4,%d15
80900062:	91 10 00 28 	movh.a %a2,32769
80900066:	d9 22 4e 8d 	lea %a2,[%a2]-10738 <8000d60e <IfxCpu_Trap_contextManagementError>>
8090006a:	dc 02       	ji %a2
8090006c:	00 80       	rfe 
	...
8090007e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80900080:	0d 00 00 02 	svlcx 
80900084:	02 f4       	mov %d4,%d15
80900086:	91 10 00 28 	movh.a %a2,32769
8090008a:	d9 22 50 ad 	lea %a2,[%a2]-10608 <8000d690 <IfxCpu_Trap_busError>>
8090008e:	dc 02       	ji %a2
80900090:	00 80       	rfe 
	...
8090009e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
809000a0:	0d 00 00 02 	svlcx 
809000a4:	02 f4       	mov %d4,%d15
809000a6:	91 10 00 28 	movh.a %a2,32769
809000aa:	d9 22 52 cd 	lea %a2,[%a2]-10478 <8000d712 <IfxCpu_Trap_assertion>>
809000ae:	dc 02       	ji %a2
809000b0:	00 80       	rfe 
	...
809000be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu3);
809000c0:	0d 00 00 02 	svlcx 
809000c4:	02 f4       	mov %d4,%d15
809000c6:	91 10 00 28 	movh.a %a2,32769
809000ca:	d9 22 8e 4d 	lea %a2,[%a2]-9970 <8000d90e <IfxCpu_Trap_systemCall_Cpu3>>
809000ce:	dc 02       	ji %a2
809000d0:	00 80       	rfe 
	...
809000de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
809000e0:	0d 00 00 02 	svlcx 
809000e4:	02 f4       	mov %d4,%d15
809000e6:	91 10 00 28 	movh.a %a2,32769
809000ea:	d9 22 88 ad 	lea %a2,[%a2]-9592 <8000da88 <IfxCpu_Trap_nonMaskableInterrupt>>
809000ee:	dc 02       	ji %a2
809000f0:	00 80       	rfe 
}
809000f2:	00 90       	ret 

809000f4 <IfxCpu_Trap_vectorTable3_end>:
	...

Disassembly of section .traptab_tc4:

80c00000 <IfxCpu_Trap_vectorTable4>:
#pragma ghs section text=".traptab_cpu4"
#endif

void IfxCpu_Trap_vectorTable4(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80c00000:	0d 00 00 02 	svlcx 
80c00004:	02 f4       	mov %d4,%d15
80c00006:	91 10 00 28 	movh.a %a2,32769
80c0000a:	d9 22 48 2d 	lea %a2,[%a2]-11128 <8000d488 <IfxCpu_Trap_memoryManagementError>>
80c0000e:	dc 02       	ji %a2
80c00010:	00 80       	rfe 
	...
80c0001e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80c00020:	0d 00 00 02 	svlcx 
80c00024:	02 f4       	mov %d4,%d15
80c00026:	91 10 00 28 	movh.a %a2,32769
80c0002a:	d9 22 4a 4d 	lea %a2,[%a2]-10998 <8000d50a <IfxCpu_Trap_internalProtectionError>>
80c0002e:	dc 02       	ji %a2
80c00030:	00 80       	rfe 
	...
80c0003e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80c00040:	0d 00 00 02 	svlcx 
80c00044:	02 f4       	mov %d4,%d15
80c00046:	91 10 00 28 	movh.a %a2,32769
80c0004a:	d9 22 4c 6d 	lea %a2,[%a2]-10868 <8000d58c <IfxCpu_Trap_instructionError>>
80c0004e:	dc 02       	ji %a2
80c00050:	00 80       	rfe 
	...
80c0005e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80c00060:	02 f4       	mov %d4,%d15
80c00062:	91 10 00 28 	movh.a %a2,32769
80c00066:	d9 22 4e 8d 	lea %a2,[%a2]-10738 <8000d60e <IfxCpu_Trap_contextManagementError>>
80c0006a:	dc 02       	ji %a2
80c0006c:	00 80       	rfe 
	...
80c0007e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80c00080:	0d 00 00 02 	svlcx 
80c00084:	02 f4       	mov %d4,%d15
80c00086:	91 10 00 28 	movh.a %a2,32769
80c0008a:	d9 22 50 ad 	lea %a2,[%a2]-10608 <8000d690 <IfxCpu_Trap_busError>>
80c0008e:	dc 02       	ji %a2
80c00090:	00 80       	rfe 
	...
80c0009e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
80c000a0:	0d 00 00 02 	svlcx 
80c000a4:	02 f4       	mov %d4,%d15
80c000a6:	91 10 00 28 	movh.a %a2,32769
80c000aa:	d9 22 52 cd 	lea %a2,[%a2]-10478 <8000d712 <IfxCpu_Trap_assertion>>
80c000ae:	dc 02       	ji %a2
80c000b0:	00 80       	rfe 
	...
80c000be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu4);
80c000c0:	0d 00 00 02 	svlcx 
80c000c4:	02 f4       	mov %d4,%d15
80c000c6:	91 10 00 28 	movh.a %a2,32769
80c000ca:	d9 22 8c 6d 	lea %a2,[%a2]-9844 <8000d98c <IfxCpu_Trap_systemCall_Cpu4>>
80c000ce:	dc 02       	ji %a2
80c000d0:	00 80       	rfe 
	...
80c000de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
80c000e0:	0d 00 00 02 	svlcx 
80c000e4:	02 f4       	mov %d4,%d15
80c000e6:	91 10 00 28 	movh.a %a2,32769
80c000ea:	d9 22 88 ad 	lea %a2,[%a2]-9592 <8000da88 <IfxCpu_Trap_nonMaskableInterrupt>>
80c000ee:	dc 02       	ji %a2
80c000f0:	00 80       	rfe 
}
80c000f2:	00 90       	ret 

80c000f4 <IfxCpu_Trap_vectorTable4_end>:
	...

Disassembly of section .traptab_tc5:

80f00000 <IfxCpu_Trap_vectorTable5>:
#pragma ghs section text=".traptab_cpu5"
#endif

void IfxCpu_Trap_vectorTable5(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80f00000:	0d 00 00 02 	svlcx 
80f00004:	02 f4       	mov %d4,%d15
80f00006:	91 10 00 28 	movh.a %a2,32769
80f0000a:	d9 22 48 2d 	lea %a2,[%a2]-11128 <8000d488 <IfxCpu_Trap_memoryManagementError>>
80f0000e:	dc 02       	ji %a2
80f00010:	00 80       	rfe 
	...
80f0001e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80f00020:	0d 00 00 02 	svlcx 
80f00024:	02 f4       	mov %d4,%d15
80f00026:	91 10 00 28 	movh.a %a2,32769
80f0002a:	d9 22 4a 4d 	lea %a2,[%a2]-10998 <8000d50a <IfxCpu_Trap_internalProtectionError>>
80f0002e:	dc 02       	ji %a2
80f00030:	00 80       	rfe 
	...
80f0003e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80f00040:	0d 00 00 02 	svlcx 
80f00044:	02 f4       	mov %d4,%d15
80f00046:	91 10 00 28 	movh.a %a2,32769
80f0004a:	d9 22 4c 6d 	lea %a2,[%a2]-10868 <8000d58c <IfxCpu_Trap_instructionError>>
80f0004e:	dc 02       	ji %a2
80f00050:	00 80       	rfe 
	...
80f0005e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80f00060:	02 f4       	mov %d4,%d15
80f00062:	91 10 00 28 	movh.a %a2,32769
80f00066:	d9 22 4e 8d 	lea %a2,[%a2]-10738 <8000d60e <IfxCpu_Trap_contextManagementError>>
80f0006a:	dc 02       	ji %a2
80f0006c:	00 80       	rfe 
	...
80f0007e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80f00080:	0d 00 00 02 	svlcx 
80f00084:	02 f4       	mov %d4,%d15
80f00086:	91 10 00 28 	movh.a %a2,32769
80f0008a:	d9 22 50 ad 	lea %a2,[%a2]-10608 <8000d690 <IfxCpu_Trap_busError>>
80f0008e:	dc 02       	ji %a2
80f00090:	00 80       	rfe 
	...
80f0009e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
80f000a0:	0d 00 00 02 	svlcx 
80f000a4:	02 f4       	mov %d4,%d15
80f000a6:	91 10 00 28 	movh.a %a2,32769
80f000aa:	d9 22 52 cd 	lea %a2,[%a2]-10478 <8000d712 <IfxCpu_Trap_assertion>>
80f000ae:	dc 02       	ji %a2
80f000b0:	00 80       	rfe 
	...
80f000be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu5);
80f000c0:	0d 00 00 02 	svlcx 
80f000c4:	02 f4       	mov %d4,%d15
80f000c6:	91 10 00 28 	movh.a %a2,32769
80f000ca:	d9 22 8a 8d 	lea %a2,[%a2]-9718 <8000da0a <IfxCpu_Trap_systemCall_Cpu5>>
80f000ce:	dc 02       	ji %a2
80f000d0:	00 80       	rfe 
	...
80f000de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
80f000e0:	0d 00 00 02 	svlcx 
80f000e4:	02 f4       	mov %d4,%d15
80f000e6:	91 10 00 28 	movh.a %a2,32769
80f000ea:	d9 22 88 ad 	lea %a2,[%a2]-9592 <8000da88 <IfxCpu_Trap_nonMaskableInterrupt>>
80f000ee:	dc 02       	ji %a2
80f000f0:	00 80       	rfe 
}
80f000f2:	00 90       	ret 

80f000f4 <IfxCpu_Trap_vectorTable5_end>:
	...

Disassembly of section .start_tc1:

a0300100 <_START1>:
a0300100:	91 00 03 28 	movh.a %a2,32816
a0300104:	d9 22 0c 40 	lea %a2,[%a2]268 <8030010c <__Core1_start>>
a0300108:	dc 02       	ji %a2
#endif

void _START1(void)
{
    Ifx_Ssw_jumpToFunction(__Core1_start);
}
a030010a:	00 90       	ret 

Disassembly of section .start_tc2:

a0600100 <_START2>:
a0600100:	91 00 06 28 	movh.a %a2,32864
a0600104:	d9 22 0c 40 	lea %a2,[%a2]268 <8060010c <__Core2_start>>
a0600108:	dc 02       	ji %a2
#endif

void _START2(void)
{
    Ifx_Ssw_jumpToFunction(__Core2_start);
}
a060010a:	00 90       	ret 

Disassembly of section .start_tc3:

a0900100 <_START3>:
a0900100:	91 00 09 28 	movh.a %a2,32912
a0900104:	d9 22 0c 40 	lea %a2,[%a2]268 <8090010c <__Core3_start>>
a0900108:	dc 02       	ji %a2
#endif

void _START3(void)
{
    Ifx_Ssw_jumpToFunction(__Core3_start);
}
a090010a:	00 90       	ret 

Disassembly of section .start_tc4:

a0c00100 <_START4>:
a0c00100:	91 00 0c 28 	movh.a %a2,32960
a0c00104:	d9 22 0c 40 	lea %a2,[%a2]268 <80c0010c <__Core4_start>>
a0c00108:	dc 02       	ji %a2
#endif

void _START4(void)
{
    Ifx_Ssw_jumpToFunction(__Core4_start);
}
a0c0010a:	00 90       	ret 

Disassembly of section .start_tc5:

a0f00100 <_START5>:
a0f00100:	91 00 0f 28 	movh.a %a2,33008
a0f00104:	d9 22 0c 40 	lea %a2,[%a2]268 <80f0010c <__Core5_start>>
a0f00108:	dc 02       	ji %a2
#endif

void _START5(void)
{
    Ifx_Ssw_jumpToFunction(__Core5_start);
}
a0f0010a:	00 90       	ret 

Disassembly of section .inttab_tc0_013:

802fe260 <__intvec_tc0_19>:
802fe260:	0d 00 00 02 	svlcx 
802fe264:	91 10 00 e8 	movh.a %a14,32769
802fe268:	d9 ee 60 6f 	lea %a14,[%a14]-2656 <8000f5a0 <asclin0TxISR>>
802fe26c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_063:

802fec60 <__intvec_tc0_99>:
802fec60:	0d 00 00 02 	svlcx 
802fec64:	91 00 00 e8 	movh.a %a14,32768
802fec68:	d9 ee d6 54 	lea %a14,[%a14]19798 <80004d56 <updateLwIPStackISR>>
802fec6c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_064:

802fec80 <__intvec_tc0_100>:
802fec80:	0d 00 00 02 	svlcx 
802fec84:	91 00 00 e8 	movh.a %a14,32768
802fec88:	d9 ee 36 b5 	lea %a14,[%a14]21238 <800052f6 <ISR_Geth_Tx>>
802fec8c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_065:

802feca0 <__intvec_tc0_101>:
802feca0:	0d 00 00 02 	svlcx 
802feca4:	91 00 00 e8 	movh.a %a14,32768
802feca8:	d9 ee 16 c5 	lea %a14,[%a14]21270 <80005316 <ISR_Geth_Rx>>
802fecac:	dc 0e       	ji %a14

Disassembly of section .CPU0.text:

800048d8 <hardware_init_hook>:
{}
800048d8:	00 90       	ret 

800048da <software_init_hook>:
{}
800048da:	00 90       	ret 

800048dc <__StartUpSoftware>:
    Ifx_Ssw_setAddressReg(a1, __SDATA2(0));
800048dc:	91 10 00 18 	movh.a %a1,32769
800048e0:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
800048e4:	3b 00 98 20 	mov %d2,2432
800048e8:	cd 42 e0 0f 	mtcr $psw,%d2
#endif

IFX_SSW_INLINE unsigned char Ifx_Ssw_isApplicationReset(void)
{
    unsigned char returnVal;
    unsigned int  tempValue = SCU_RSTSTAT.U;
800048ec:	91 30 00 2f 	movh.a %a2,61443
800048f0:	19 22 10 16 	ld.w %d2,[%a2]24656 <f0036050 <bmhd_3_copy+0x40c34a50>>

    if ((tempValue & IFX_SSW_POWERONRESET_MASK) > 0U)
800048f4:	7b d0 38 31 	movh %d3,5005
800048f8:	26 23       	and %d3,%d2
    unsigned int  tempValue = SCU_RSTSTAT.U;
800048fa:	d9 22 10 16 	lea %a2,[%a2]24656 <f0036050 <bmhd_3_copy+0x40c34a50>>
    if ((tempValue & IFX_SSW_POWERONRESET_MASK) > 0U)
800048fe:	df 03 16 80 	jne %d3,0,8000492a <__StartUpSoftware+0x4e>
    {
        returnVal = 0U;
    }
    else if ((tempValue & IFX_SSW_APPLICATIONRESET_MASK) > 0U)
80004902:	3b b0 7f 30 	mov %d3,2043
80004906:	26 23       	and %d3,%d2
80004908:	df 03 17 00 	jeq %d3,0,80004936 <__StartUpSoftware+0x5a>
    {
        /* get the bit which is set at RSTSTAT (assumption: RSTSTAT register was cleared before and only one bit can be set) */
        tempValue = tempValue & IFX_SSW_APPLICATIONRESET_MASK;
        tempValue = (SCU_RSTCON.U >> ((31U - Ifx_Ssw_CLZ(tempValue)) << 1U)) & 3U;
8000490c:	91 30 00 2f 	movh.a %a2,61443
80004910:	0f 03 b0 21 	clz %d2,%d3
80004914:	8b f2 01 21 	rsub %d2,%d2,31
80004918:	19 23 18 16 	ld.w %d3,[%a2]24664 <f0036058 <bmhd_3_copy+0x40c34a58>>
8000491c:	06 12       	sh %d2,1
8000491e:	57 03 62 22 	extr.u %d2,%d3,%d2,2
80004922:	d9 22 18 16 	lea %a2,[%a2]24664 <f0036058 <bmhd_3_copy+0x40c34a58>>

        if (tempValue == IFX_SSW_APPLICATIONRESET)
80004926:	df 22 0a 00 	jeq %d2,2,8000493a <__StartUpSoftware+0x5e>
8000492a:	91 00 00 28 	movh.a %a2,32768
8000492e:	d9 22 9e 54 	lea %a2,[%a2]18782 <8000495e <__StartUpSoftware_Phase2>>
80004932:	dc 02       	ji %a2
}
80004934:	00 90       	ret 
        else
        {
            returnVal = 0U;
        }
    }
    else if (((unsigned int)tempValue & ((unsigned int)IFX_SCU_RSTSTAT_CB3_MSK << IFX_SCU_RSTSTAT_CB3_OFF)))
80004936:	ef 42 08 00 	jz.t %d2,20,80004946 <__StartUpSoftware+0x6a>
    __asm__ volatile ("ji %0" ::"a" (fun));
8000493a:	91 00 00 28 	movh.a %a2,32768
8000493e:	d9 22 b0 84 	lea %a2,[%a2]18992 <80004a30 <__StartUpSoftware_Phase3ApplicationResetPath>>
80004942:	dc 02       	ji %a2
}
80004944:	00 90       	ret 
    {
        /* CB3 reset is not configurable and is always application reset */
        returnVal = 1U;
    }
    else if (CPU0_KRST0.B.RSTSTAT != 0)   /*CPU0 KRST status */
80004946:	91 10 88 2f 	movh.a %a2,63617
8000494a:	19 22 00 0d 	ld.w %d2,[%a2]-12288 <f880d000 <bmhd_3_copy+0x4940ba00>>
8000494e:	d9 22 00 0d 	lea %a2,[%a2]-12288 <f880d000 <bmhd_3_copy+0x4940ba00>>
80004952:	37 02 e2 20 	extr.u %d2,%d2,1,2
80004956:	df 02 f2 ff 	jne %d2,0,8000493a <__StartUpSoftware+0x5e>
8000495a:	1d ff e8 ff 	j 8000492a <__StartUpSoftware+0x4e>

8000495e <__StartUpSoftware_Phase2>:


IFX_SSW_INLINE void Ifx_Ssw_jumpToFunctionWithLink(void *fun)
{
    __asm__ volatile ("jli %0" ::"a" (fun));
8000495e:	91 20 00 28 	movh.a %a2,32770
80004962:	d9 22 ba 96 	lea %a2,[%a2]27258 <80026a7a <Ifx_Ssw_Pms_Init>>
80004966:	2d 02 20 00 	jli %a2
8000496a:	91 20 00 28 	movh.a %a2,32770
8000496e:	d9 22 a0 e6 	lea %a2,[%a2]27552 <80026ba0 <Ifx_Ssw_Pms_InitCheck>>
80004972:	2d 02 20 00 	jli %a2
    __asm__ volatile ("ji %0" ::"a" (fun));
80004976:	91 00 00 28 	movh.a %a2,32768
8000497a:	d9 22 82 64 	lea %a2,[%a2]18818 <80004982 <__StartUpSoftware_Phase3PowerOnResetPath>>
8000497e:	dc 02       	ji %a2
}
80004980:	00 90       	ret 

80004982 <__StartUpSoftware_Phase3PowerOnResetPath>:
    IFX_SSW_INIT_CONTEXT();
80004982:	91 40 00 a7 	movh.a %sp,28676
80004986:	d9 aa 40 89 	lea %sp,[%sp]-27136 <70039600 <__USTACK0>>
    __asm__ volatile ("dsync" : : : "memory");
8000498a:	0d 00 80 04 	dsync 
{
    unsigned int  k;
    unsigned int  nxt_cxi_val = 0U;
    unsigned int *prvCsa      = 0U;
    unsigned int *nxtCsa      = csaBegin;
    unsigned int  numOfCsa    = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
8000498e:	91 40 00 37 	movh.a %a3,28676
80004992:	91 40 00 27 	movh.a %a2,28676
80004996:	d9 33 c0 09 	lea %a3,[%a3]-25600 <70039c00 <__CSA0>>
8000499a:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <7003bc00 <__CSA0_END>>
8000499e:	01 32 20 20 	sub.a %a2,%a2,%a3
800049a2:	80 22       	mov.d %d2,%a2
800049a4:	8f a2 1f 60 	sh %d6,%d2,-6

    for (k = 0U; k < numOfCsa; k++)
800049a8:	df 06 40 00 	jeq %d6,0,80004a28 <__StartUpSoftware_Phase3PowerOnResetPath+0xa6>
    unsigned int *nxtCsa      = csaBegin;
800049ac:	80 32       	mov.d %d2,%a3
    {
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
800049ae:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
800049b2:	7b f0 00 70 	movh %d7,15
800049b6:	8f 42 1f 50 	sh %d5,%d2,-12
800049ba:	26 75       	and %d5,%d7
    for (k = 0U; k < numOfCsa; k++)
800049bc:	82 03       	mov %d3,0
        else
        {
            *prvCsa = nxt_cxi_val;
        }

        if (k == (numOfCsa - 3U))
800049be:	1b d6 ff 0f 	addi %d0,%d6,-3
    unsigned int *prvCsa      = 0U;
800049c2:	a0 02       	mov.a %a2,0
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
800049c4:	a6 54       	or %d4,%d5
        if (k == 0U)
800049c6:	df 03 14 00 	jeq %d3,0,800049ee <__StartUpSoftware_Phase3PowerOnResetPath+0x6c>
            *prvCsa = nxt_cxi_val;
800049ca:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
800049cc:	5f 03 15 00 	jeq %d3,%d0,800049f6 <__StartUpSoftware_Phase3PowerOnResetPath+0x74>
    for (k = 0U; k < numOfCsa; k++)
800049d0:	c2 13       	add %d3,1
800049d2:	60 22       	mov.a %a2,%d2
        {
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
        }

        prvCsa  = (unsigned int *)nxtCsa;
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
800049d4:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
800049d8:	5f 36 17 00 	jeq %d6,%d3,80004a06 <__StartUpSoftware_Phase3PowerOnResetPath+0x84>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
800049dc:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
800049de:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
800049e2:	8f 42 1f 50 	sh %d5,%d2,-12
800049e6:	26 75       	and %d5,%d7
800049e8:	a6 54       	or %d4,%d5
        if (k == 0U)
800049ea:	df 03 f0 ff 	jne %d3,0,800049ca <__StartUpSoftware_Phase3PowerOnResetPath+0x48>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
800049ee:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
800049f2:	5f 03 ef ff 	jne %d3,%d0,800049d0 <__StartUpSoftware_Phase3PowerOnResetPath+0x4e>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
800049f6:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
800049fa:	c2 13       	add %d3,1
800049fc:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
800049fe:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80004a02:	5f 36 ed ff 	jne %d6,%d3,800049dc <__StartUpSoftware_Phase3PowerOnResetPath+0x5a>
    }

    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
80004a06:	1b f6 ff 2f 	addi %d2,%d6,-1
80004a0a:	06 62       	sh %d2,6
80004a0c:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80004a10:	82 02       	mov %d2,0
80004a12:	74 32       	st.w [%a3],%d2
80004a14:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
80004a18:	0d 00 c0 04 	isync 
    __asm__ volatile ("ji %0" ::"a" (fun));
80004a1c:	91 00 00 28 	movh.a %a2,32768
80004a20:	d9 22 9e b4 	lea %a2,[%a2]19166 <80004ade <__StartUpSoftware_Phase4>>
80004a24:	dc 02       	ji %a2
}
80004a26:	00 90       	ret 
80004a28:	a5 06 00 00 	st.w 0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>,%d6
80004a2c:	6d 01 0e 51 	call 8002ec48 <abort>

80004a30 <__StartUpSoftware_Phase3ApplicationResetPath>:
    IFX_SSW_INIT_CONTEXT();
80004a30:	91 40 00 a7 	movh.a %sp,28676
80004a34:	d9 aa 40 89 	lea %sp,[%sp]-27136 <70039600 <__USTACK0>>
    __asm__ volatile ("dsync" : : : "memory");
80004a38:	0d 00 80 04 	dsync 
    unsigned int  numOfCsa    = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
80004a3c:	91 40 00 37 	movh.a %a3,28676
80004a40:	91 40 00 27 	movh.a %a2,28676
80004a44:	d9 33 c0 09 	lea %a3,[%a3]-25600 <70039c00 <__CSA0>>
80004a48:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <7003bc00 <__CSA0_END>>
80004a4c:	01 32 20 20 	sub.a %a2,%a2,%a3
80004a50:	80 22       	mov.d %d2,%a2
80004a52:	8f a2 1f 60 	sh %d6,%d2,-6
    for (k = 0U; k < numOfCsa; k++)
80004a56:	df 06 40 00 	jeq %d6,0,80004ad6 <__StartUpSoftware_Phase3ApplicationResetPath+0xa6>
    unsigned int *nxtCsa      = csaBegin;
80004a5a:	80 32       	mov.d %d2,%a3
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80004a5c:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80004a60:	7b f0 00 70 	movh %d7,15
80004a64:	8f 42 1f 50 	sh %d5,%d2,-12
80004a68:	26 75       	and %d5,%d7
    for (k = 0U; k < numOfCsa; k++)
80004a6a:	82 03       	mov %d3,0
        if (k == (numOfCsa - 3U))
80004a6c:	1b d6 ff 0f 	addi %d0,%d6,-3
    unsigned int *prvCsa      = 0U;
80004a70:	a0 02       	mov.a %a2,0
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80004a72:	a6 54       	or %d4,%d5
        if (k == 0U)
80004a74:	df 03 14 00 	jeq %d3,0,80004a9c <__StartUpSoftware_Phase3ApplicationResetPath+0x6c>
            *prvCsa = nxt_cxi_val;
80004a78:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80004a7a:	5f 03 15 00 	jeq %d3,%d0,80004aa4 <__StartUpSoftware_Phase3ApplicationResetPath+0x74>
    for (k = 0U; k < numOfCsa; k++)
80004a7e:	c2 13       	add %d3,1
80004a80:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80004a82:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80004a86:	5f 36 17 00 	jeq %d6,%d3,80004ab4 <__StartUpSoftware_Phase3ApplicationResetPath+0x84>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80004a8a:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80004a8c:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80004a90:	8f 42 1f 50 	sh %d5,%d2,-12
80004a94:	26 75       	and %d5,%d7
80004a96:	a6 54       	or %d4,%d5
        if (k == 0U)
80004a98:	df 03 f0 ff 	jne %d3,0,80004a78 <__StartUpSoftware_Phase3ApplicationResetPath+0x48>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80004a9c:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80004aa0:	5f 03 ef ff 	jne %d3,%d0,80004a7e <__StartUpSoftware_Phase3ApplicationResetPath+0x4e>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
80004aa4:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
80004aa8:	c2 13       	add %d3,1
80004aaa:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80004aac:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80004ab0:	5f 36 ed ff 	jne %d6,%d3,80004a8a <__StartUpSoftware_Phase3ApplicationResetPath+0x5a>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
80004ab4:	1b f6 ff 2f 	addi %d2,%d6,-1
80004ab8:	06 62       	sh %d2,6
80004aba:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80004abe:	82 02       	mov %d2,0
80004ac0:	74 32       	st.w [%a3],%d2
80004ac2:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
80004ac6:	0d 00 c0 04 	isync 
    __asm__ volatile ("ji %0" ::"a" (fun));
80004aca:	91 00 00 28 	movh.a %a2,32768
80004ace:	d9 22 ac c4 	lea %a2,[%a2]19244 <80004b2c <__StartUpSoftware_Phase5>>
80004ad2:	dc 02       	ji %a2
}
80004ad4:	00 90       	ret 
80004ad6:	a5 06 00 00 	st.w 0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>,%d6
80004ada:	6d 01 b7 50 	call 8002ec48 <abort>

80004ade <__StartUpSoftware_Phase4>:
    password  = watchdog->CON0.B.PW;
80004ade:	91 30 00 4f 	movh.a %a4,61443
80004ae2:	19 44 0c 96 	ld.w %d4,[%a4]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
    password  = watchdog->CON0.B.PW;
80004ae6:	91 30 00 2f 	movh.a %a2,61443
80004aea:	19 28 28 a6 	ld.w %d8,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
    password  = watchdog->CON0.B.PW;
80004aee:	37 04 6e 41 	extr.u %d4,%d4,2,14
80004af2:	d9 44 0c 96 	lea %a4,[%a4]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
    password  = watchdog->CON0.B.PW;
80004af6:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
        Ifx_Ssw_serviceCpuWatchdog(&MODULE_SCU.WDTCPU[0], cpuWdtPassword);
80004afa:	8f f4 83 41 	xor %d4,%d4,63
80004afe:	37 08 6e 81 	extr.u %d8,%d8,2,14
80004b02:	6d 00 ee 56 	call 8000f8de <Ifx_Ssw_serviceCpuWatchdog>
        Ifx_Ssw_serviceSafetyWatchdog(safetyWdtPassword);
80004b06:	8f f8 83 41 	xor %d4,%d8,63
80004b0a:	6d 00 2d 57 	call 8000f964 <Ifx_Ssw_serviceSafetyWatchdog>
    IFX_CFG_SSW_CALLOUT_PLL_INIT();
80004b0e:	91 00 00 48 	movh.a %a4,32768
80004b12:	d9 44 00 94 	lea %a4,[%a4]16960 <80004240 <IfxScuCcu_defaultClockConfig>>
80004b16:	6d 00 2e 12 	call 80006f72 <IfxScuCcu_init>
80004b1a:	df 12 03 80 	jne %d2,1,80004b20 <__StartUpSoftware_Phase4+0x42>

/** Insert DEBUG instruction
 */
IFX_INLINE void Ifx__debug(void)
{
    __asm__ volatile ("debug" : : : "memory");
80004b1e:	00 a0       	debug 
80004b20:	91 00 00 28 	movh.a %a2,32768
80004b24:	d9 22 ac c4 	lea %a2,[%a2]19244 <80004b2c <__StartUpSoftware_Phase5>>
80004b28:	dc 02       	ji %a2
}
80004b2a:	00 90       	ret 

80004b2c <__StartUpSoftware_Phase5>:
80004b2c:	91 00 00 28 	movh.a %a2,32768
80004b30:	d9 22 b8 c4 	lea %a2,[%a2]19256 <80004b38 <__StartUpSoftware_Phase6>>
80004b34:	dc 02       	ji %a2
}
80004b36:	00 90       	ret 

80004b38 <__StartUpSoftware_Phase6>:
    Ifx_Ssw_startCore(&MODULE_CPU1, (unsigned int)__START(1));           /*The status returned by function call is ignored */
80004b38:	91 00 03 2a 	movh.a %a2,41008
80004b3c:	80 22       	mov.d %d2,%a2
80004b3e:	1b 02 10 40 	addi %d4,%d2,256
80004b42:	91 20 88 4f 	movh.a %a4,63618
80004b46:	6d 00 20 58 	call 8000fb86 <Ifx_Ssw_startCore>
80004b4a:	91 00 00 28 	movh.a %a2,32768
80004b4e:	d9 22 96 d4 	lea %a2,[%a2]19286 <80004b56 <__Core0_start>>
80004b52:	dc 02       	ji %a2
}
80004b54:	00 90       	ret 

80004b56 <__Core0_start>:
    password  = watchdog->CON0.B.PW;
80004b56:	91 30 00 2f 	movh.a %a2,61443
    password  = watchdog->CON0.B.PW;
80004b5a:	91 30 00 3f 	movh.a %a3,61443
    password  = watchdog->CON0.B.PW;
80004b5e:	19 23 0c 96 	ld.w %d3,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
    password  = watchdog->CON0.B.PW;
80004b62:	19 32 28 a6 	ld.w %d2,[%a3]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
    password  = watchdog->CON0.B.PW;
80004b66:	37 03 6e 31 	extr.u %d3,%d3,2,14
    password  = watchdog->CON0.B.PW;
80004b6a:	37 02 6e 21 	extr.u %d2,%d2,2,14
    if (watchdog->CON0.B.LCK)
80004b6e:	19 24 0c 96 	ld.w %d4,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
80004b72:	8f f3 83 81 	xor %d8,%d3,63
    password  = watchdog->CON0.B.PW;
80004b76:	d9 22 0c 96 	lea %a2,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
    password  = watchdog->CON0.B.PW;
80004b7a:	d9 33 28 a6 	lea %a3,[%a3]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80004b7e:	8f f2 83 91 	xor %d9,%d2,63
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004b82:	8f 28 00 20 	sh %d2,%d8,2
    if (watchdog->CON0.B.LCK)
80004b86:	6f 14 0b 00 	jz.t %d4,1,80004b9c <__Core0_start+0x46>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004b8a:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004b8c:	8f 28 00 20 	sh %d2,%d8,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004b90:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004b94:	a6 23       	or %d3,%d2
80004b96:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004b9a:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004b9c:	91 30 00 2f 	movh.a %a2,61443
80004ba0:	19 24 0c 96 	ld.w %d4,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
80004ba4:	d9 22 0c 96 	lea %a2,[%a2]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
80004ba8:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
80004bac:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004bae:	a6 24       	or %d4,%d2
80004bb0:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004bb4:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80004bb6:	54 24       	ld.w %d4,[%a2]
80004bb8:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
80004bbc:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80004bc0:	cd 03 04 09 	mtcr $dcon0,%d3
80004bc4:	0d 00 c0 04 	isync 
    Ifx_Ssw_setAddressReg(a0, __SDATA1(0));
80004bc8:	91 10 00 07 	movh.a %a0,28673
80004bcc:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(0));
80004bd0:	91 10 00 88 	movh.a %a8,32769
80004bd4:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(0));
80004bd8:	91 10 00 99 	movh.a %a9,36865
80004bdc:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(0));
80004be0:	91 00 00 38 	movh.a %a3,32768
80004be4:	80 33       	mov.d %d3,%a3
80004be6:	1b 03 10 30 	addi %d3,%d3,256
80004bea:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(0));
80004bee:	91 00 03 38 	movh.a %a3,32816
80004bf2:	80 33       	mov.d %d3,%a3
80004bf4:	1b 03 00 3e 	addi %d3,%d3,-8192
80004bf8:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(0));
80004bfc:	91 40 00 37 	movh.a %a3,28676
80004c00:	80 33       	mov.d %d3,%a3
80004c02:	1b 03 b0 39 	addi %d3,%d3,-25856
80004c06:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80004c0a:	54 23       	ld.w %d3,[%a2]
80004c0c:	6f 13 09 00 	jz.t %d3,1,80004c1e <__Core0_start+0xc8>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004c10:	54 23       	ld.w %d3,[%a2]
80004c12:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004c16:	a6 23       	or %d3,%d2
80004c18:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004c1c:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80004c1e:	91 30 00 cf 	movh.a %a12,61443
80004c22:	19 c3 0c 96 	ld.w %d3,[%a12]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
80004c26:	d9 cc 0c 96 	lea %a12,[%a12]25164 <f003624c <bmhd_3_copy+0x40c34c4c>>
80004c2a:	b7 03 10 30 	insert %d3,%d3,0,0,16
    Ifx_Ssw_disableCpuWatchdog(&MODULE_SCU.WDTCPU[0], cpuWdtPassword);
80004c2e:	40 c4       	mov.aa %a4,%a12
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80004c30:	a6 32       	or %d2,%d3
80004c32:	8f 32 40 21 	or %d2,%d2,3
80004c36:	02 84       	mov %d4,%d8
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80004c38:	74 c2       	st.w [%a12],%d2
    watchdog->CON0.U;
80004c3a:	54 c2       	ld.w %d2,[%a12]
80004c3c:	6d 00 dd 56 	call 8000f9f6 <Ifx_Ssw_disableCpuWatchdog>
    Ifx_Ssw_disableSafetyWatchdog(safetyWdtPassword);
80004c40:	02 94       	mov %d4,%d9
80004c42:	6d 00 70 57 	call 8000fb22 <Ifx_Ssw_disableSafetyWatchdog>
	hardware_init_hook();
80004c46:	6d ff 49 fe 	call 800048d8 <hardware_init_hook>
	(void)Ifx_Ssw_doCppInit();
80004c4a:	6d 00 59 58 	call 8000fcfc <Ifx_Ssw_doCppInit>
	software_init_hook();
80004c4e:	6d ff 46 fe 	call 800048da <software_init_hook>
    Ifx_Ssw_enableSafetyWatchdog(safetyWdtPassword);
80004c52:	02 94       	mov %d4,%d9
80004c54:	6d 00 80 57 	call 8000fb54 <Ifx_Ssw_enableSafetyWatchdog>
    Ifx_Ssw_enableCpuWatchdog(&MODULE_SCU.WDTCPU[0], cpuWdtPassword);
80004c58:	02 84       	mov %d4,%d8
80004c5a:	40 c4       	mov.aa %a4,%a12
80004c5c:	6d 00 18 57 	call 8000fa8c <Ifx_Ssw_enableCpuWatchdog>
    __asm__ volatile ("ji %0" ::"a" (fun));
80004c60:	91 00 00 28 	movh.a %a2,32768
80004c64:	d9 22 f0 14 	lea %a2,[%a2]19568 <80004c70 <core0_main>>
80004c68:	dc 02       	ji %a2

80004c6a <x>:
    __asm__ volatile ("ji %a11");
}

IFX_SSW_INLINE void Ifx_Ssw_infiniteLoop(void)
{
    __asm("x: loopu\t x");
80004c6a:	fd 00 00 80 	loopu 80004c6a <x>
}
80004c6e:	00 90       	ret 

80004c70 <core0_main>:

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void core0_main (void)
{
80004c70:	40 ae       	mov.aa %a14,%sp
80004c72:	20 28       	sub.a %sp,40
}


IFX_INLINE void IfxCpu_enableInterrupts(void)
{
    __enable();
80004c74:	0d 00 00 03 	enable 
}
80004c78:	00 00       	nop 
    IfxCpu_enableInterrupts();

    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80004c7a:	6d 00 2d 1d 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
80004c7e:	02 24       	mov %d4,%d2
80004c80:	6d 00 e0 1b 	call 80008440 <IfxScuWdt_disableCpuWatchdog>
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
80004c84:	6d 00 5e 1d 	call 80008740 <IfxScuWdt_getSafetyWatchdogPassword>
80004c88:	02 24       	mov %d4,%d2
80004c8a:	6d 00 8b 1c 	call 800085a0 <IfxScuWdt_disableSafetyWatchdog>

    /* Wait for CPU sync event: wait until all CPUs are in CpuX_Main to avoid variables' initialization problems */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80004c8e:	91 10 00 27 	movh.a %a2,28673
80004c92:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
80004c96:	6d 00 a6 47 	call 8000dbe2 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80004c9a:	82 14       	mov %d4,1
80004c9c:	91 10 00 27 	movh.a %a2,28673
80004ca0:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
80004ca4:	6d 00 31 47 	call 8000db06 <IfxCpu_waitEvent>

    IfxStm_CompareConfig stmCompareConfig;                                  /* STM Configuration declaration                */

    IfxStm_initCompareConfig(&stmCompareConfig);                            /* Initialize a default configuration for STM   */
80004ca8:	d9 e2 e4 ff 	lea %a2,[%a14]-28
80004cac:	40 24       	mov.aa %a4,%a2
80004cae:	6d 00 14 0e 	call 800068d6 <IfxStm_initCompareConfig>

    stmCompareConfig.triggerPriority     = ISR_PRIORITY_OS_TICK;            /* Priority of the interrupt generated by STM   */
80004cb2:	3b 30 06 20 	mov %d2,99
80004cb6:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
    stmCompareConfig.comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;  /* Select the request source 0                  */
80004cba:	82 02       	mov %d2,0
80004cbc:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    stmCompareConfig.ticks               = IFX_CFG_STM_TICKS_PER_MS * 10;   /* First interrupt shall occur after 10 ms      */
80004cc0:	7b f0 00 20 	movh %d2,15
80004cc4:	1b 02 24 24 	addi %d2,%d2,16960
80004cc8:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    stmCompareConfig.typeOfService       = IfxSrc_Tos_cpu0;                 /* CPU0 serves the interrupts                   */
80004ccc:	82 02       	mov %d2,0
80004cce:	59 e2 fc ff 	st.w [%a14]-4,%d2

    IfxStm_initCompare(&MODULE_STM0, &stmCompareConfig);                    /* Initialize the Compare functionality         */
80004cd2:	d9 e2 e4 ff 	lea %a2,[%a14]-28
80004cd6:	40 25       	mov.aa %a5,%a2
80004cd8:	c5 f4 00 01 	lea %a4,f0001000 <bmhd_3_copy+0x40bffa00>
80004cdc:	6d 00 31 0c 	call 8000653e <IfxStm_initCompare>

    IfxGeth_enableModule(&MODULE_GETH);                     /* Enable Gigabit Ethernet Media Access Controller (GETH) module*/
80004ce0:	91 20 00 4f 	movh.a %a4,61442
80004ce4:	d9 44 00 0d 	lea %a4,[%a4]-12288 <f001d000 <bmhd_3_copy+0x40c1ba00>>
80004ce8:	6d 00 02 1f 	call 80008aec <IfxGeth_enableModule>

    /* Define a MAC Address */
    eth_addr_t ethAddr;
    ethAddr.addr[0] = 0xDE;
80004cec:	3b e0 fd 2f 	mov %d2,-34
80004cf0:	e9 e2 de ff 	st.b [%a14]-34,%d2
    ethAddr.addr[1] = 0xAD;
80004cf4:	3b d0 fa 2f 	mov %d2,-83
80004cf8:	e9 e2 df ff 	st.b [%a14]-33,%d2
    ethAddr.addr[2] = 0xBE;
80004cfc:	3b e0 fb 2f 	mov %d2,-66
80004d00:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
    ethAddr.addr[3] = 0xEF;
80004d04:	3b f0 fe 2f 	mov %d2,-17
80004d08:	e9 e2 e1 ff 	st.b [%a14]-31,%d2
    ethAddr.addr[4] = 0xFE;
80004d0c:	82 e2       	mov %d2,-2
80004d0e:	e9 e2 e2 ff 	st.b [%a14]-30,%d2
    ethAddr.addr[5] = 0xED;
80004d12:	3b d0 fe 2f 	mov %d2,-19
80004d16:	e9 e2 e3 ff 	st.b [%a14]-29,%d2

    Ifx_Lwip_init(ethAddr);                                 /* Initialize LwIP with the MAC address                         */
80004d1a:	b9 e2 de ff 	ld.hu %d2,[%a14]-34
80004d1e:	b9 e3 e0 ff 	ld.hu %d3,[%a14]-32
80004d22:	8f 03 01 30 	sh %d3,%d3,16
80004d26:	a6 32       	or %d2,%d3
80004d28:	02 24       	mov %d4,%d2
80004d2a:	b9 e3 e2 ff 	ld.hu %d3,[%a14]-30
80004d2e:	82 02       	mov %d2,0
80004d30:	37 32 10 20 	insert %d2,%d2,%d3,0,16
80004d34:	02 25       	mov %d5,%d2
80004d36:	6d 00 68 02 	call 80005206 <Ifx_Lwip_init>

    echoInit();                                             /* Initialize ECHO application                                  */
80004d3a:	6d 01 67 0f 	call 80026c08 <echoInit>

    while (1)
    {
        Ifx_Lwip_pollTimerFlags();                          /* Poll LwIP timers and trigger protocols execution if required */
80004d3e:	6d 00 12 01 	call 80004f62 <Ifx_Lwip_pollTimerFlags>
        Ifx_Lwip_pollReceiveFlags();                        /* Receive data package through ETH                             */
80004d42:	6d 00 28 02 	call 80005192 <Ifx_Lwip_pollReceiveFlags>
        Ifx_Lwip_printf("[DEBUG] tcp_connect returning with %d\n");
80004d46:	91 00 00 28 	movh.a %a2,32768
80004d4a:	d9 24 90 40 	lea %a4,[%a2]2320 <80000910 <IfxCpu_Trap_vectorTable0_end+0x71c>>
80004d4e:	6d 00 f4 02 	call 80005336 <Ifx_Lwip_printf>
        Ifx_Lwip_pollTimerFlags();                          /* Poll LwIP timers and trigger protocols execution if required */
80004d52:	1d ff f6 ff 	j 80004d3e <core0_main+0xce>

80004d56 <updateLwIPStackISR>:
/* This interrupt is raised by the STM0 */
IFX_INTERRUPT (updateLwIPStackISR, 0, ISR_PRIORITY_OS_TICK);

/* ISR to update LwIP stack */
void updateLwIPStackISR(void)
{
80004d56:	40 ae       	mov.aa %a14,%sp
80004d58:	20 10       	sub.a %sp,16
80004d5a:	7b 00 00 2f 	movh %d2,61440
80004d5e:	1b 02 00 21 	addi %d2,%d2,4096
80004d62:	59 e2 fc ff 	st.w [%a14]-4,%d2
80004d66:	82 02       	mov %d2,0
80004d68:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80004d6c:	7b 20 00 20 	movh %d2,2
80004d70:	1b 02 6a 28 	addi %d2,%d2,-31072
80004d74:	59 e2 f4 ff 	st.w [%a14]-12,%d2
}


IFX_INLINE void IfxStm_increaseCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks)
{
    stm->CMP[comparator].B.CMPVAL = stm->CMP[comparator].B.CMPVAL + ticks;
80004d78:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80004d7c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80004d80:	1b c2 00 20 	addi %d2,%d2,12
80004d84:	06 22       	sh %d2,2
80004d86:	60 32       	mov.a %a2,%d3
80004d88:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80004d8c:	54 23       	ld.w %d3,[%a2]
80004d8e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80004d92:	42 23       	add %d3,%d2
80004d94:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80004d98:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80004d9c:	1b c2 00 20 	addi %d2,%d2,12
80004da0:	06 22       	sh %d2,2
80004da2:	60 42       	mov.a %a2,%d4
80004da4:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80004da8:	74 23       	st.w [%a2],%d3
}
80004daa:	00 00       	nop 
    /* Configure STM to generate an interrupt in 1 ms */
    IfxStm_increaseCompare(&MODULE_STM0, IfxStm_Comparator_0, IFX_CFG_STM_TICKS_PER_MS);

    g_TickCount_1ms++;                                      /* Increase LwIP system time                                    */
80004dac:	91 00 00 27 	movh.a %a2,28672
80004db0:	d9 22 00 00 	lea %a2,[%a2]0 <70000000 <g_TickCount_1ms>>
80004db4:	54 22       	ld.w %d2,[%a2]
80004db6:	c2 12       	add %d2,1
80004db8:	91 00 00 27 	movh.a %a2,28672
80004dbc:	d9 22 00 00 	lea %a2,[%a2]0 <70000000 <g_TickCount_1ms>>
80004dc0:	74 22       	st.w [%a2],%d2

    Ifx_Lwip_onTimerTick();                                 /* Every 1 ms LwIP timers are increased for all the enabled
80004dc2:	6d 00 06 00 	call 80004dce <Ifx_Lwip_onTimerTick>
                                                             * protocols (ARP, TCP, DHCP, LINK)                             */
}
80004dc6:	00 00       	nop 
80004dc8:	0d 00 40 02 	rslcx 
80004dcc:	00 80       	rfe 

80004dce <Ifx_Lwip_onTimerTick>:
        }                                     \
    }

/** \brief Timer interrupt callback */
void Ifx_Lwip_onTimerTick(void)
{
80004dce:	40 ae       	mov.aa %a14,%sp
80004dd0:	20 08       	sub.a %sp,8
    Ifx_Lwip *lwip       = &g_Lwip;
80004dd2:	91 00 00 27 	movh.a %a2,28672
80004dd6:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
80004dda:	b5 e2 f8 ff 	st.a [%a14]-8 <70000004 <g_Lwip>>,%a2
    uint16    timerFlags = lwip->timerFlags;
80004dde:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <70000004 <g_Lwip>>
80004de2:	c9 22 3e 10 	ld.h %d2,[%a2]126 <70000004 <g_Lwip>>
80004de6:	f9 e2 fe ff 	st.h [%a14]-2 <70000004 <g_Lwip>>,%d2

    Ifx_Lwip_timerIncr(lwip->timer.arp, IFX_LWIP_ARP_PERIOD, IFX_LWIP_FLAG_ARP);
80004dea:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <70000004 <g_Lwip>>
80004dee:	b9 22 32 10 	ld.hu %d2,[%a2]114 <70000004 <g_Lwip>>
80004df2:	c2 12       	add %d2,1
80004df4:	37 02 70 20 	extr.u %d2,%d2,0,16
80004df8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004dfc:	f9 22 32 10 	st.h [%a2]114,%d2
80004e00:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e04:	b9 22 32 10 	ld.hu %d2,[%a2]114
80004e08:	3b 80 3e 30 	mov %d3,1000
80004e0c:	3f 32 0d 80 	jlt.u %d2,%d3,80004e26 <Ifx_Lwip_onTimerTick+0x58>
80004e10:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e14:	82 02       	mov %d2,0
80004e16:	f9 22 32 10 	st.h [%a2]114,%d2
80004e1a:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80004e1e:	8f 22 40 21 	or %d2,%d2,2
80004e22:	f9 e2 fe ff 	st.h [%a14]-2,%d2

    Ifx_Lwip_timerIncr(lwip->timer.tcp_fast, IFX_LWIP_TCP_FAST_PERIOD, IFX_LWIP_FLAG_TCP_FAST);
80004e26:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e2a:	b9 22 38 10 	ld.hu %d2,[%a2]120
80004e2e:	c2 12       	add %d2,1
80004e30:	37 02 70 20 	extr.u %d2,%d2,0,16
80004e34:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e38:	f9 22 38 10 	st.h [%a2]120,%d2
80004e3c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e40:	b9 22 38 10 	ld.hu %d2,[%a2]120
80004e44:	8b a2 6f 22 	lt.u %d2,%d2,250
80004e48:	df 02 0d 80 	jne %d2,0,80004e62 <Ifx_Lwip_onTimerTick+0x94>
80004e4c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e50:	82 02       	mov %d2,0
80004e52:	f9 22 38 10 	st.h [%a2]120,%d2
80004e56:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80004e5a:	8f 42 40 21 	or %d2,%d2,4
80004e5e:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    Ifx_Lwip_timerIncr(lwip->timer.tcp_slow, IFX_LWIP_TCP_SLOW_PERIOD, IFX_LWIP_FLAG_TCP_SLOW);
80004e62:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e66:	b9 22 3a 10 	ld.hu %d2,[%a2]122
80004e6a:	c2 12       	add %d2,1
80004e6c:	37 02 70 20 	extr.u %d2,%d2,0,16
80004e70:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e74:	f9 22 3a 10 	st.h [%a2]122,%d2
80004e78:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e7c:	b9 22 3a 10 	ld.hu %d2,[%a2]122
80004e80:	8b 42 7f 22 	lt.u %d2,%d2,500
80004e84:	df 02 0d 80 	jne %d2,0,80004e9e <Ifx_Lwip_onTimerTick+0xd0>
80004e88:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004e8c:	82 02       	mov %d2,0
80004e8e:	f9 22 3a 10 	st.h [%a2]122,%d2
80004e92:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80004e96:	8f 82 40 21 	or %d2,%d2,8
80004e9a:	f9 e2 fe ff 	st.h [%a14]-2,%d2

#if LWIP_DHCP
    Ifx_Lwip_timerIncr(lwip->timer.dhcp_coarse, IFX_LWIP_DHCP_COARSE_PERIOD, IFX_LWIP_FLAG_DHCP_COARSE);
80004e9e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004ea2:	b9 22 34 10 	ld.hu %d2,[%a2]116
80004ea6:	c2 12       	add %d2,1
80004ea8:	37 02 70 20 	extr.u %d2,%d2,0,16
80004eac:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004eb0:	f9 22 34 10 	st.h [%a2]116,%d2
80004eb4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004eb8:	b9 22 34 10 	ld.hu %d2,[%a2]116
80004ebc:	bb 00 a6 3e 	mov.u %d3,60000
80004ec0:	3f 32 0d 80 	jlt.u %d2,%d3,80004eda <Ifx_Lwip_onTimerTick+0x10c>
80004ec4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004ec8:	82 02       	mov %d2,0
80004eca:	f9 22 34 10 	st.h [%a2]116,%d2
80004ece:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80004ed2:	8f 02 42 21 	or %d2,%d2,32
80004ed6:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    Ifx_Lwip_timerIncr(lwip->timer.dhcp_fine, IFX_LWIP_DHCP_FINE_PERIOD, IFX_LWIP_FLAG_DHCP_FINE);
80004eda:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004ede:	b9 22 36 10 	ld.hu %d2,[%a2]118
80004ee2:	c2 12       	add %d2,1
80004ee4:	37 02 70 20 	extr.u %d2,%d2,0,16
80004ee8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004eec:	f9 22 36 10 	st.h [%a2]118,%d2
80004ef0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004ef4:	b9 22 36 10 	ld.hu %d2,[%a2]118
80004ef8:	8b 42 7f 22 	lt.u %d2,%d2,500
80004efc:	df 02 0d 80 	jne %d2,0,80004f16 <Ifx_Lwip_onTimerTick+0x148>
80004f00:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004f04:	82 02       	mov %d2,0
80004f06:	f9 22 36 10 	st.h [%a2]118,%d2
80004f0a:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80004f0e:	8f 02 44 21 	or %d2,%d2,64
80004f12:	f9 e2 fe ff 	st.h [%a14]-2,%d2
#endif

    Ifx_Lwip_timerIncr(lwip->timer.link, IFX_LWIP_LINK_PERIOD, IFX_LWIP_FLAG_LINK);
80004f16:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004f1a:	b9 22 3c 10 	ld.hu %d2,[%a2]124
80004f1e:	c2 12       	add %d2,1
80004f20:	37 02 70 20 	extr.u %d2,%d2,0,16
80004f24:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004f28:	f9 22 3c 10 	st.h [%a2]124,%d2
80004f2c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004f30:	b9 22 3c 10 	ld.hu %d2,[%a2]124
80004f34:	8b 42 66 22 	lt.u %d2,%d2,100
80004f38:	df 02 0d 80 	jne %d2,0,80004f52 <Ifx_Lwip_onTimerTick+0x184>
80004f3c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004f40:	82 02       	mov %d2,0
80004f42:	f9 22 3c 10 	st.h [%a2]124,%d2
80004f46:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80004f4a:	8f 02 41 21 	or %d2,%d2,16
80004f4e:	f9 e2 fe ff 	st.h [%a14]-2,%d2

    lwip->timerFlags = timerFlags;
80004f52:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80004f56:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80004f5a:	f9 22 3e 10 	st.h [%a2]126,%d2
}
80004f5e:	00 00       	nop 
80004f60:	00 90       	ret 

80004f62 <Ifx_Lwip_pollTimerFlags>:


/** \brief Polling the timer event flags */
void Ifx_Lwip_pollTimerFlags(void)
{
80004f62:	40 ae       	mov.aa %a14,%sp
80004f64:	20 30       	sub.a %sp,48
    Ifx_Lwip *lwip = &g_Lwip;
80004f66:	91 00 00 27 	movh.a %a2,28672
80004f6a:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
80004f6e:	b5 e2 fc ff 	st.a [%a14]-4 <70000004 <g_Lwip>>,%a2
    reg.U = __mfcr(CPU_ICR);
80004f72:	4d c0 e2 2f 	mfcr %d2,$icr
80004f76:	59 e2 ec ff 	st.w [%a14]-20,%d2
80004f7a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80004f7e:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    return reg.B.IE != 0;
80004f82:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
80004f86:	37 02 e1 27 	extr.u %d2,%d2,15,1
80004f8a:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
80004f8e:	e9 e2 eb ff 	st.b [%a14]-21,%d2
    __disable();
80004f92:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80004f96:	00 00       	nop 
}
80004f98:	00 00       	nop 
    return enabled;
80004f9a:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
    uint16    timerFlags;

    /* disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();
80004f9e:	e9 e2 fb ff 	st.b [%a14]-5,%d2

    timerFlags       = lwip->timerFlags;
80004fa2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80004fa6:	c9 22 3e 10 	ld.h %d2,[%a2]126
80004faa:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
    lwip->timerFlags = 0;
80004fae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80004fb2:	82 02       	mov %d2,0
80004fb4:	f9 22 3e 10 	st.h [%a2]126,%d2

    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);
80004fb8:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80004fbc:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80004fc0:	39 e2 f3 ff 	ld.bu %d2,[%a14]-13
80004fc4:	df 02 04 00 	jeq %d2,0,80004fcc <Ifx_Lwip_pollTimerFlags+0x6a>
    {
        __enable();
80004fc8:	0d 00 00 03 	enable 
    }
}
80004fcc:	00 00       	nop 

#if LWIP_DHCP
    if (timerFlags & IFX_LWIP_FLAG_DHCP_COARSE)
80004fce:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80004fd2:	8f 02 02 21 	and %d2,%d2,32
80004fd6:	df 02 0e 00 	jeq %d2,0,80004ff2 <Ifx_Lwip_pollTimerFlags+0x90>
    {
        /* only if we have a link we will check the dhcp */
        if (g_Lwip.netif.flags & NETIF_FLAG_LINK_UP)
80004fda:	91 00 00 27 	movh.a %a2,28672
80004fde:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
80004fe2:	39 22 31 00 	ld.bu %d2,[%a2]49 <70000031 <g_Lwip+0x2d>>
80004fe6:	8f 42 00 21 	and %d2,%d2,4
80004fea:	df 02 04 00 	jeq %d2,0,80004ff2 <Ifx_Lwip_pollTimerFlags+0x90>
            dhcp_coarse_tmr();
80004fee:	6d 00 19 5c 	call 80010820 <dhcp_coarse_tmr>
    }

    if (timerFlags & IFX_LWIP_FLAG_DHCP_FINE)
80004ff2:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80004ff6:	8f 02 04 21 	and %d2,%d2,64
80004ffa:	df 02 0e 00 	jeq %d2,0,80005016 <Ifx_Lwip_pollTimerFlags+0xb4>
    {
        /* only if we have a link we will check the dhcp */
        if (g_Lwip.netif.flags & NETIF_FLAG_LINK_UP)
80004ffe:	91 00 00 27 	movh.a %a2,28672
80005002:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
80005006:	39 22 31 00 	ld.bu %d2,[%a2]49 <70000031 <g_Lwip+0x2d>>
8000500a:	8f 42 00 21 	and %d2,%d2,4
8000500e:	df 02 04 00 	jeq %d2,0,80005016 <Ifx_Lwip_pollTimerFlags+0xb4>
            dhcp_fine_tmr();
80005012:	6d 00 86 5c 	call 8001091e <dhcp_fine_tmr>
    }
#endif

    if (timerFlags & IFX_LWIP_FLAG_TCP_FAST)
80005016:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
8000501a:	8f 42 00 21 	and %d2,%d2,4
8000501e:	df 02 0e 00 	jeq %d2,0,8000503a <Ifx_Lwip_pollTimerFlags+0xd8>
    {
        /* only if we have a link we will check the tcp */
        if (g_Lwip.netif.flags & NETIF_FLAG_LINK_UP)
80005022:	91 00 00 27 	movh.a %a2,28672
80005026:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
8000502a:	39 22 31 00 	ld.bu %d2,[%a2]49 <70000031 <g_Lwip+0x2d>>
8000502e:	8f 42 00 21 	and %d2,%d2,4
80005032:	df 02 04 00 	jeq %d2,0,8000503a <Ifx_Lwip_pollTimerFlags+0xd8>
            tcp_fasttmr();
80005036:	6d 00 4e b9 	call 8001c2d2 <tcp_fasttmr>
    }

    if (timerFlags & IFX_LWIP_FLAG_TCP_SLOW)
8000503a:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
8000503e:	8f 82 00 21 	and %d2,%d2,8
80005042:	df 02 0e 00 	jeq %d2,0,8000505e <Ifx_Lwip_pollTimerFlags+0xfc>
    {
        /* only if we have a link we will check the tcp */
        if (g_Lwip.netif.flags & NETIF_FLAG_LINK_UP)
80005046:	91 00 00 27 	movh.a %a2,28672
8000504a:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
8000504e:	39 22 31 00 	ld.bu %d2,[%a2]49 <70000031 <g_Lwip+0x2d>>
80005052:	8f 42 00 21 	and %d2,%d2,4
80005056:	df 02 04 00 	jeq %d2,0,8000505e <Ifx_Lwip_pollTimerFlags+0xfc>
            tcp_slowtmr();
8000505a:	6d 00 28 b4 	call 8001b8aa <tcp_slowtmr>
    }

    if (timerFlags & IFX_LWIP_FLAG_ARP)
8000505e:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80005062:	8f 22 00 21 	and %d2,%d2,2
80005066:	df 02 0e 00 	jeq %d2,0,80005082 <Ifx_Lwip_pollTimerFlags+0x120>
    {
        /* only if we have a link we will check the arp */
        if (g_Lwip.netif.flags & NETIF_FLAG_LINK_UP)
8000506a:	91 00 00 27 	movh.a %a2,28672
8000506e:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
80005072:	39 22 31 00 	ld.bu %d2,[%a2]49 <70000031 <g_Lwip+0x2d>>
80005076:	8f 42 00 21 	and %d2,%d2,4
8000507a:	df 02 04 00 	jeq %d2,0,80005082 <Ifx_Lwip_pollTimerFlags+0x120>
            etharp_tmr();
8000507e:	6d 00 ca 70 	call 80013212 <etharp_tmr>
    }

    if (timerFlags & IFX_LWIP_FLAG_LINK)
80005082:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80005086:	8f 02 01 21 	and %d2,%d2,16
8000508a:	df 02 82 00 	jeq %d2,0,8000518e <Ifx_Lwip_pollTimerFlags+0x22c>
    {
        Ifx_GETH_MAC_PHYIF_CONTROL_STATUS ctrl_status;
        ctrl_status.U = GETH_MAC_PHYIF_CONTROL_STATUS.U;
8000508e:	91 20 00 2f 	movh.a %a2,61442
80005092:	d9 22 38 3d 	lea %a2,[%a2]-12040 <f001d0f8 <bmhd_3_copy+0x40c1baf8>>
80005096:	54 22       	ld.w %d2,[%a2]
80005098:	59 e2 d0 ff 	st.w [%a14]-48 <f001d0f8 <bmhd_3_copy+0x40c1baf8>>,%d2
        if (ctrl_status.B.LNKSTS == 0)
8000509c:	19 e2 d0 ff 	ld.w %d2,[%a14]-48 <f001d0f8 <bmhd_3_copy+0x40c1baf8>>
800050a0:	7b 80 00 30 	movh %d3,8
800050a4:	26 32       	and %d2,%d3
800050a6:	df 02 0a 80 	jne %d2,0,800050ba <Ifx_Lwip_pollTimerFlags+0x158>
            netif_set_link_down(&g_Lwip.netif);
800050aa:	91 00 00 27 	movh.a %a2,28672
800050ae:	d9 24 04 00 	lea %a4,[%a2]4 <70000004 <g_Lwip>>
800050b2:	6d 00 c4 a1 	call 8001943a <netif_set_link_down>
                    // 1000MBit speed
                    IfxGeth_mac_setLineSpeed(ethernetif->gethSFR, IfxGeth_LineSpeed_1000Mbps);
            netif_set_link_up(&g_Lwip.netif);
        }
    }
}
800050b6:	1d 00 6c 00 	j 8000518e <Ifx_Lwip_pollTimerFlags+0x22c>
            IfxGeth_Eth *ethernetif = g_Lwip.netif.state;
800050ba:	91 00 00 27 	movh.a %a2,28672
800050be:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
800050c2:	d9 22 1c 00 	lea %a2,[%a2]28 <7000001c <g_Lwip+0x18>>
800050c6:	54 22       	ld.w %d2,[%a2]
800050c8:	59 e2 f4 ff 	st.w [%a14]-12 <7000001c <g_Lwip+0x18>>,%d2
            if (ctrl_status.B.LNKMOD == 1)
800050cc:	19 e2 d0 ff 	ld.w %d2,[%a14]-48 <7000001c <g_Lwip+0x18>>
800050d0:	7b 10 00 30 	movh %d3,1
800050d4:	26 32       	and %d2,%d3
800050d6:	df 02 18 00 	jeq %d2,0,80005106 <Ifx_Lwip_pollTimerFlags+0x1a4>
                IfxGeth_mac_setDuplexMode(ethernetif->gethSFR, IfxGeth_DuplexMode_fullDuplex);
800050da:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800050de:	54 22       	ld.w %d2,[%a2]
800050e0:	59 e2 e4 ff 	st.w [%a14]-28,%d2
800050e4:	82 12       	mov %d2,1
800050e6:	59 e2 e0 ff 	st.w [%a14]-32,%d2
}


IFX_INLINE void IfxGeth_mac_setDuplexMode(Ifx_GETH *gethSFR, IfxGeth_DuplexMode mode)
{
    gethSFR->MAC_CONFIGURATION.B.DM = mode;
800050ea:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800050ee:	8f 12 00 21 	and %d2,%d2,1
800050f2:	8f f2 0f 31 	and %d3,%d2,255
800050f6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800050fa:	54 22       	ld.w %d2,[%a2]
800050fc:	67 32 0d 20 	ins.t %d2,%d2,13,%d3,0
80005100:	74 22       	st.w [%a2],%d2
}
80005102:	1d 00 17 00 	j 80005130 <Ifx_Lwip_pollTimerFlags+0x1ce>
                IfxGeth_mac_setDuplexMode(ethernetif->gethSFR, IfxGeth_DuplexMode_halfDuplex);
80005106:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000510a:	54 22       	ld.w %d2,[%a2]
8000510c:	59 e2 dc ff 	st.w [%a14]-36,%d2
80005110:	82 02       	mov %d2,0
80005112:	59 e2 d8 ff 	st.w [%a14]-40,%d2
    gethSFR->MAC_CONFIGURATION.B.DM = mode;
80005116:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000511a:	8f 12 00 21 	and %d2,%d2,1
8000511e:	8f f2 0f 31 	and %d3,%d2,255
80005122:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005126:	54 22       	ld.w %d2,[%a2]
80005128:	67 32 0d 20 	ins.t %d2,%d2,13,%d3,0
8000512c:	74 22       	st.w [%a2],%d2
}
8000512e:	00 00       	nop 
            if (ctrl_status.B.LNKSPEED == 0)
80005130:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
80005134:	7b 60 00 30 	movh %d3,6
80005138:	26 32       	and %d2,%d3
8000513a:	df 02 0b 80 	jne %d2,0,80005150 <Ifx_Lwip_pollTimerFlags+0x1ee>
                IfxGeth_mac_setLineSpeed(ethernetif->gethSFR, IfxGeth_LineSpeed_10Mbps);
8000513e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005142:	54 22       	ld.w %d2,[%a2]
80005144:	82 04       	mov %d4,0
80005146:	60 24       	mov.a %a4,%d2
80005148:	6d 00 1e 1d 	call 80008b84 <IfxGeth_mac_setLineSpeed>
8000514c:	1d 00 1b 00 	j 80005182 <Ifx_Lwip_pollTimerFlags+0x220>
                if (ctrl_status.B.LNKSPEED == 1)
80005150:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
80005154:	7b 60 00 30 	movh %d3,6
80005158:	26 32       	and %d2,%d3
8000515a:	7b 20 00 30 	movh %d3,2
8000515e:	5f 32 0b 80 	jne %d2,%d3,80005174 <Ifx_Lwip_pollTimerFlags+0x212>
                    IfxGeth_mac_setLineSpeed(ethernetif->gethSFR, IfxGeth_LineSpeed_100Mbps);
80005162:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005166:	54 22       	ld.w %d2,[%a2]
80005168:	82 14       	mov %d4,1
8000516a:	60 24       	mov.a %a4,%d2
8000516c:	6d 00 0c 1d 	call 80008b84 <IfxGeth_mac_setLineSpeed>
80005170:	1d 00 09 00 	j 80005182 <Ifx_Lwip_pollTimerFlags+0x220>
                    IfxGeth_mac_setLineSpeed(ethernetif->gethSFR, IfxGeth_LineSpeed_1000Mbps);
80005174:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005178:	54 22       	ld.w %d2,[%a2]
8000517a:	82 24       	mov %d4,2
8000517c:	60 24       	mov.a %a4,%d2
8000517e:	6d 00 03 1d 	call 80008b84 <IfxGeth_mac_setLineSpeed>
            netif_set_link_up(&g_Lwip.netif);
80005182:	91 00 00 27 	movh.a %a2,28672
80005186:	d9 24 04 00 	lea %a4,[%a2]4 <70000004 <g_Lwip>>
8000518a:	6d 00 11 a1 	call 800193ac <netif_set_link_up>
}
8000518e:	00 00       	nop 
80005190:	00 90       	ret 

80005192 <Ifx_Lwip_pollReceiveFlags>:


/** \brief Polling the ETH receive event flags */
void Ifx_Lwip_pollReceiveFlags(void)
{
80005192:	40 ae       	mov.aa %a14,%sp
    /**
     * We are assuming that the only interrupt source is an incoming packet
     */
    //while (ethernetif_tc29x_timerFlags_interrupt())
    {
        ifx_netif_input(&g_Lwip.netif);
80005194:	91 00 00 27 	movh.a %a2,28672
80005198:	d9 24 04 00 	lea %a4,[%a2]4 <70000004 <g_Lwip>>
8000519c:	6d 01 c4 0b 	call 80026924 <ifx_netif_input>
    }
}
800051a0:	00 00       	nop 
800051a2:	00 90       	ret 

800051a4 <netif_state_changed>:

#if LWIP_NETIF_EXT_STATUS_CALLBACK
static netif_ext_callback_t g_extCallback;

void netif_state_changed(struct netif* netif, netif_nsc_reason_t reason, const netif_ext_callback_args_t* args) {
800051a4:	40 ae       	mov.aa %a14,%sp
800051a6:	20 20       	sub.a %sp,32
800051a8:	b5 e4 fc ff 	st.a [%a14]-4,%a4
800051ac:	02 42       	mov %d2,%d4
800051ae:	b5 e5 f4 ff 	st.a [%a14]-12,%a5
800051b2:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
    if(reason | LWIP_NSC_IPV4_ADDRESS_CHANGED) {
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: new ip address assigned: %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
800051b6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800051ba:	c2 42       	add %d2,4
800051bc:	60 22       	mov.a %a2,%d2
800051be:	14 22       	ld.bu %d2,[%a2]
800051c0:	02 23       	mov %d3,%d2
800051c2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800051c6:	c2 42       	add %d2,4
800051c8:	60 22       	mov.a %a2,%d2
800051ca:	b0 12       	add.a %a2,1
800051cc:	14 22       	ld.bu %d2,[%a2]
800051ce:	02 24       	mov %d4,%d2
800051d0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800051d4:	c2 42       	add %d2,4
800051d6:	60 22       	mov.a %a2,%d2
800051d8:	b0 22       	add.a %a2,2
800051da:	14 22       	ld.bu %d2,[%a2]
800051dc:	02 25       	mov %d5,%d2
800051de:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800051e2:	c2 42       	add %d2,4
800051e4:	60 22       	mov.a %a2,%d2
800051e6:	b0 32       	add.a %a2,3
800051e8:	14 22       	ld.bu %d2,[%a2]
800051ea:	59 a2 0c 00 	st.w [%sp]12,%d2
800051ee:	59 a5 08 00 	st.w [%sp]8,%d5
800051f2:	59 a4 04 00 	st.w [%sp]4,%d4
800051f6:	74 a3       	st.w [%sp],%d3
800051f8:	91 00 00 28 	movh.a %a2,32768
800051fc:	d9 24 68 83 	lea %a4,[%a2]13864 <80003628 <IfxCpu_Trap_vectorTable0_end+0x3434>>
80005200:	6d 00 9b 00 	call 80005336 <Ifx_Lwip_printf>
                        ip4_addr2_16(netif_ip4_addr(netif)),
                        ip4_addr3_16(netif_ip4_addr(netif)),
                        ip4_addr4_16(netif_ip4_addr(netif))));
    }

}
80005204:	00 90       	ret 

80005206 <Ifx_Lwip_init>:

/** \brief LWIP initialization function
 *
 * The followings are executed: */
void Ifx_Lwip_init(eth_addr_t ethAddr)
{
80005206:	40 ae       	mov.aa %a14,%sp
80005208:	20 28       	sub.a %sp,40
8000520a:	59 e4 e8 ff 	st.w [%a14]-24,%d4
8000520e:	59 e5 ec ff 	st.w [%a14]-20,%d5
#ifdef __LWIP_DEBUG__
    //Init uart for debugging
    initUART();
80005212:	6d 00 d2 51 	call 8000f5b6 <initUART>
#endif
    ip_addr_t default_ipaddr, default_netmask, default_gw;
    IP4_ADDR(&default_gw, 0,0,0,0);
80005216:	82 02       	mov %d2,0
80005218:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    IP4_ADDR(&default_ipaddr, 0,0,0,0);
8000521c:	82 02       	mov %d2,0
8000521e:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IP4_ADDR(&default_netmask, 255,0,0,0);
80005222:	3b f0 0f 20 	mov %d2,255
80005226:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    LWIP_DEBUGF(IFX_LWIP_DEBUG, ("Ifx_Lwip_init start!\n"));

    /** - initialise LWIP (lwip_init()) */
    lwip_init();
8000522a:	6d 00 02 94 	call 80017a2e <lwip_init>

    /** - initialise and add a \ref netif */
    g_Lwip.eth_addr = ethAddr;
8000522e:	91 00 00 27 	movh.a %a2,28672
80005232:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
80005236:	19 e2 e8 ff 	ld.w %d2,[%a14]-24 <70000004 <g_Lwip>>
8000523a:	d9 23 2c 10 	lea %a3,[%a2]108 <7000006c <g_Lwip+0x68>>
8000523e:	74 32       	st.w [%a3],%d2
80005240:	c9 e2 ec ff 	ld.h %d2,[%a14]-20 <7000006c <g_Lwip+0x68>>
80005244:	f9 22 30 10 	st.h [%a2]112 <70000070 <g_Lwip+0x6c>>,%d2
    netif_add(&g_Lwip.netif, &default_ipaddr, &default_netmask, &default_gw,
80005248:	d9 e3 f4 ff 	lea %a3,[%a14]-12 <70000070 <g_Lwip+0x6c>>
8000524c:	d9 e5 f8 ff 	lea %a5,[%a14]-8 <70000070 <g_Lwip+0x6c>>
80005250:	d9 e4 fc ff 	lea %a4,[%a14]-4 <70000070 <g_Lwip+0x6c>>
80005254:	91 10 00 28 	movh.a %a2,32769
80005258:	d9 22 dc bf 	lea %a2,[%a2]-292 <8000fedc <ethernet_input>>
8000525c:	b5 a2 08 00 	st.a [%sp]8 <8000fedc <ethernet_input>>,%a2
80005260:	91 20 00 28 	movh.a %a2,32770
80005264:	d9 22 80 76 	lea %a2,[%a2]27072 <800269c0 <ifx_netif_init>>
80005268:	b5 a2 04 00 	st.a [%sp]4 <800269c0 <ifx_netif_init>>,%a2
8000526c:	82 02       	mov %d2,0
8000526e:	74 a2       	st.w [%sp],%d2
80005270:	40 37       	mov.aa %a7,%a3
80005272:	40 56       	mov.aa %a6,%a5
80005274:	40 45       	mov.aa %a5,%a4
80005276:	91 00 00 27 	movh.a %a2,28672
8000527a:	d9 24 04 00 	lea %a4,[%a2]4 <70000004 <g_Lwip>>
8000527e:	6d 00 55 9c 	call 80018b28 <netif_add>
        (void *)0, ifx_netif_init, ethernet_input);
    netif_set_default(&g_Lwip.netif);
80005282:	91 00 00 27 	movh.a %a2,28672
80005286:	d9 24 04 00 	lea %a4,[%a2]4 <70000004 <g_Lwip>>
8000528a:	6d 00 f1 9f 	call 8001926c <netif_set_default>
    netif_set_up(&g_Lwip.netif);
8000528e:	91 00 00 27 	movh.a %a2,28672
80005292:	d9 24 04 00 	lea %a4,[%a2]4 <70000004 <g_Lwip>>
80005296:	6d 00 f8 9f 	call 80019286 <netif_set_up>

#if LWIP_NETIF_HOSTNAME
    g_Lwip.netif.hostname = BOARDNAME;
8000529a:	91 00 00 27 	movh.a %a2,28672
8000529e:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
800052a2:	91 00 00 38 	movh.a %a3,32768
800052a6:	d9 33 55 93 	lea %a3,[%a3]13909 <80003655 <IfxCpu_Trap_vectorTable0_end+0x3461>>
800052aa:	d9 22 24 00 	lea %a2,[%a2]36 <70000024 <g_Lwip+0x20>>
800052ae:	f4 23       	st.a [%a2],%a3
#endif

#if LWIP_DHCP
    /** - assign \ref dhcp to \ref netif */
    dhcp_set_struct(&g_Lwip.netif, &g_Lwip.dhcp);
800052b0:	91 00 00 27 	movh.a %a2,28672
800052b4:	d9 25 3c 00 	lea %a5,[%a2]60 <7000003c <g_Lwip+0x38>>
800052b8:	91 00 00 27 	movh.a %a2,28672
800052bc:	d9 24 04 00 	lea %a4,[%a2]4 <70000004 <g_Lwip>>
800052c0:	6d 00 3f 5d 	call 80010d3e <dhcp_set_struct>

    /* we start the dhcp always here also when we don't have a link here */
    dhcp_start(&g_Lwip.netif);
800052c4:	91 00 00 27 	movh.a %a2,28672
800052c8:	d9 24 04 00 	lea %a4,[%a2]4 <70000004 <g_Lwip>>
800052cc:	6d 00 9d 5d 	call 80010e06 <dhcp_start>
#endif

#if LWIP_NETIF_EXT_STATUS_CALLBACK
    netif_add_ext_callback(&g_extCallback, netif_state_changed);
800052d0:	91 00 00 28 	movh.a %a2,32768
800052d4:	d9 25 24 65 	lea %a5,[%a2]20900 <800051a4 <netif_state_changed>>
800052d8:	91 10 00 27 	movh.a %a2,28673
800052dc:	d9 24 54 84 	lea %a4,[%a2]17940 <70014614 <g_extCallback>>
800052e0:	6d 00 23 a1 	call 80019526 <netif_add_ext_callback>
#endif
    LWIP_DEBUGF(IFX_LWIP_DEBUG, ("Ifx_Lwip_init end!\n"));
}
800052e4:	00 00       	nop 
800052e6:	00 90       	ret 

800052e8 <sys_now>:

/** Returns the current time in milliseconds,
 * may be the same as sys_jiffies or at least based on it. */
inline u32_t sys_now(void)
{
800052e8:	40 ae       	mov.aa %a14,%sp
    return g_TickCount_1ms;
800052ea:	91 00 00 27 	movh.a %a2,28672
800052ee:	d9 22 00 00 	lea %a2,[%a2]0 <70000000 <g_TickCount_1ms>>
800052f2:	54 22       	ld.w %d2,[%a2]
}
800052f4:	00 90       	ret 

800052f6 <ISR_Geth_Tx>:
 * \isrProvider \ref ISR_PROVIDER_ETH
 * \isrPriority \ref ISR_PRIORITY_GETH_TX
 *
 */
IFX_INTERRUPT(ISR_Geth_Tx, CPU_WHICH_SERVICE_ETHERNET, ISR_PRIORITY_GETH_TX)
{
800052f6:	40 ae       	mov.aa %a14,%sp
    isrTxCount++;
800052f8:	91 00 00 27 	movh.a %a2,28672
800052fc:	d9 22 20 40 	lea %a2,[%a2]288 <70000120 <isrTxCount>>
80005300:	54 22       	ld.w %d2,[%a2]
80005302:	c2 12       	add %d2,1
80005304:	91 00 00 27 	movh.a %a2,28672
80005308:	d9 22 20 40 	lea %a2,[%a2]288 <70000120 <isrTxCount>>
8000530c:	74 22       	st.w [%a2],%d2
}
8000530e:	00 00       	nop 
80005310:	0d 00 40 02 	rslcx 
80005314:	00 80       	rfe 

80005316 <ISR_Geth_Rx>:
 * \isrProvider \ref ISR_PROVIDER_ETH
 * \isrPriority \ref ISR_PRIORITY_GETH_RX
 *
 */
IFX_INTERRUPT(ISR_Geth_Rx, CPU_WHICH_SERVICE_ETHERNET, ISR_PRIORITY_GETH_RX)
{
80005316:	40 ae       	mov.aa %a14,%sp
    isrRxCount++;
80005318:	91 00 00 27 	movh.a %a2,28672
8000531c:	d9 22 24 40 	lea %a2,[%a2]292 <70000124 <isrRxCount>>
80005320:	54 22       	ld.w %d2,[%a2]
80005322:	c2 12       	add %d2,1
80005324:	91 00 00 27 	movh.a %a2,28672
80005328:	d9 22 24 40 	lea %a2,[%a2]292 <70000124 <isrRxCount>>
8000532c:	74 22       	st.w [%a2],%d2
}
8000532e:	00 00       	nop 
80005330:	0d 00 40 02 	rslcx 
80005334:	00 80       	rfe 

80005336 <Ifx_Lwip_printf>:
#include <string.h>

#define MAXCHARS 256

s8_t Ifx_Lwip_printf(const char *format, ...)
{
80005336:	40 ae       	mov.aa %a14,%sp
80005338:	d9 aa e8 bf 	lea %sp,[%sp]-280
8000533c:	b5 e4 ec bf 	st.a [%a14]-276,%a4
#ifdef __LWIP_DEBUG__
    char    str[MAXCHARS + 4];
    s8_t    result = ERR_CONN;
80005340:	3b 50 ff 2f 	mov %d2,-11
80005344:	e9 e2 fd ff 	st.b [%a14]-3,%d2

    va_list args;
    va_start(args, format);
80005348:	80 e2       	mov.d %d2,%a14
8000534a:	59 e2 f4 bf 	st.w [%a14]-268,%d2
    vsnprintf(str, MAXCHARS, format, args);
8000534e:	19 e2 f4 bf 	ld.w %d2,[%a14]-268
80005352:	d9 e2 f9 bf 	lea %a2,[%a14]-263
80005356:	60 26       	mov.a %a6,%d2
80005358:	99 e5 ec bf 	ld.a %a5,[%a14]-276
8000535c:	3b 00 10 40 	mov %d4,256
80005360:	40 24       	mov.aa %a4,%a2
80005362:	6d 01 2f 19 	call 800285c0 <vsnprintf>
    va_end(args);
    {
        Ifx_SizeT cnt = 0;
80005366:	82 02       	mov %d2,0
80005368:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        while(str[cnt]!=0)
8000536c:	1d 00 0b 00 	j 80005382 <Ifx_Lwip_printf+0x4c>
            cnt++;
80005370:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80005374:	37 02 70 20 	extr.u %d2,%d2,0,16
80005378:	c2 12       	add %d2,1
8000537a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000537e:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        while(str[cnt]!=0)
80005382:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80005386:	d9 e2 f9 bf 	lea %a2,[%a14]-263
8000538a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000538e:	79 22 00 00 	ld.b %d2,[%a2]0
80005392:	df 02 ef ff 	jne %d2,0,80005370 <Ifx_Lwip_printf+0x3a>
        sendUARTMessage(str, cnt);
80005396:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8000539a:	d9 e2 f9 bf 	lea %a2,[%a14]-263
8000539e:	02 24       	mov %d4,%d2
800053a0:	40 24       	mov.aa %a4,%a2
800053a2:	6d 00 6f 51 	call 8000f680 <sendUARTMessage>
        sendUARTMessage("\r\n", 2);
800053a6:	82 24       	mov %d4,2
800053a8:	91 00 00 28 	movh.a %a2,32768
800053ac:	d9 24 63 93 	lea %a4,[%a2]13923 <80003663 <IfxCpu_Trap_vectorTable0_end+0x346f>>
800053b0:	6d 00 68 51 	call 8000f680 <sendUARTMessage>
    }
#endif
    return result;
800053b4:	79 e2 fd ff 	ld.b %d2,[%a14]-3
}
800053b8:	00 90       	ret 

800053ba <IfxGeth_Eth_Phy_Rtl8211f_init>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint32 IfxGeth_Eth_Phy_Rtl8211f_init(void)
{
800053ba:	40 ae       	mov.aa %a14,%sp
800053bc:	20 08       	sub.a %sp,8
    IFXGETH_PHY_RTL8211F_WAIT_MDIO_READY();
800053be:	91 20 00 2f 	movh.a %a2,61442
800053c2:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
800053c6:	54 22       	ld.w %d2,[%a2]
800053c8:	37 02 61 20 	extr.u %d2,%d2,0,1
800053cc:	8f f2 0f 21 	and %d2,%d2,255
800053d0:	df 02 f7 ff 	jne %d2,0,800053be <IfxGeth_Eth_Phy_Rtl8211f_init+0x4>

    // reset PHY
    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_BMCR, 0x8000);   // reset
800053d4:	bb 00 00 68 	mov.u %d6,32768
800053d8:	82 05       	mov %d5,0
800053da:	82 04       	mov %d4,0
800053dc:	6d 00 88 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>
    uint32 value;

    do
    {
        IfxGeth_Eth_Phy_Rtl8211f_read_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_BMCR, &value);
800053e0:	d9 e2 fc ff 	lea %a2,[%a14]-4
800053e4:	40 24       	mov.aa %a4,%a2
800053e6:	82 05       	mov %d5,0
800053e8:	82 04       	mov %d4,0
800053ea:	6d 00 54 00 	call 80005492 <IfxGeth_Eth_Phy_Rtl8211f_read_mdio_reg>
    } while (value & 0x8000);                                                      // wait for reset to finish
800053ee:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800053f2:	bb 00 00 38 	mov.u %d3,32768
800053f6:	26 32       	and %d2,%d3
800053f8:	df 02 f4 ff 	jne %d2,0,800053e0 <IfxGeth_Eth_Phy_Rtl8211f_init+0x26>

    // setup PHY
    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_PAGSR, 0xd08);
800053fc:	3b 80 d0 60 	mov %d6,3336
80005400:	3b f0 01 50 	mov %d5,31
80005404:	82 04       	mov %d4,0
80005406:	6d 00 73 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>
    IfxGeth_Eth_Phy_Rtl8211f_read_mdio_reg(0, 0x11, &value);
8000540a:	d9 e2 fc ff 	lea %a2,[%a14]-4
8000540e:	40 24       	mov.aa %a4,%a2
80005410:	3b 10 01 50 	mov %d5,17
80005414:	82 04       	mov %d4,0
80005416:	6d 00 3e 00 	call 80005492 <IfxGeth_Eth_Phy_Rtl8211f_read_mdio_reg>
    value |= 0x100; // enable TX-delay
8000541a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000541e:	8f 02 50 21 	or %d2,%d2,256
80005422:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, 0x11, value);
80005426:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000542a:	02 26       	mov %d6,%d2
8000542c:	3b 10 01 50 	mov %d5,17
80005430:	82 04       	mov %d4,0
80005432:	6d 00 5d 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>
    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_PAGSR, 0x0);
80005436:	82 06       	mov %d6,0
80005438:	3b f0 01 50 	mov %d5,31
8000543c:	82 04       	mov %d4,0
8000543e:	6d 00 57 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>
    /* Set LEDs */
    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_PAGSR, 0xd04);
80005442:	3b 40 d0 60 	mov %d6,3332
80005446:	3b f0 01 50 	mov %d5,31
8000544a:	82 04       	mov %d4,0
8000544c:	6d 00 50 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>
    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_LCR, 0x8170);
80005450:	bb 00 17 68 	mov.u %d6,33136
80005454:	3b 00 01 50 	mov %d5,16
80005458:	82 04       	mov %d4,0
8000545a:	6d 00 49 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>
    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_EEELCR, 0x0);   // EEE off for all leds
8000545e:	82 06       	mov %d6,0
80005460:	3b 10 01 50 	mov %d5,17
80005464:	82 04       	mov %d4,0
80005466:	6d 00 43 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>
    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_PAGSR, 0x0);
8000546a:	82 06       	mov %d6,0
8000546c:	3b f0 01 50 	mov %d5,31
80005470:	82 04       	mov %d4,0
80005472:	6d 00 3d 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>

    IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(0, IFXGETH_PHY_RTL8211F_MDIO_BMCR, 0x1200);    // enable auto-negotiation, restart auto-negotiation
80005476:	3b 00 20 61 	mov %d6,4608
8000547a:	82 05       	mov %d5,0
8000547c:	82 04       	mov %d4,0
8000547e:	6d 00 37 00 	call 800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>

    // done
    IfxGeth_Eth_Phy_Rtl8211f_iPhyInitDone = 1;
80005482:	91 10 00 27 	movh.a %a2,28673
80005486:	d9 22 28 8a 	lea %a2,[%a2]-24024 <7000a228 <IfxGeth_Eth_Phy_Rtl8211f_iPhyInitDone>>
8000548a:	82 12       	mov %d2,1
8000548c:	74 22       	st.w [%a2],%d2

    return 1;
8000548e:	82 12       	mov %d2,1
}
80005490:	00 90       	ret 

80005492 <IfxGeth_Eth_Phy_Rtl8211f_read_mdio_reg>:


void IfxGeth_Eth_Phy_Rtl8211f_read_mdio_reg(uint32 layeraddr, uint32 regaddr, uint32 *pdata)
{
80005492:	40 ae       	mov.aa %a14,%sp
80005494:	20 10       	sub.a %sp,16
80005496:	59 e4 fc ff 	st.w [%a14]-4,%d4
8000549a:	59 e5 f8 ff 	st.w [%a14]-8,%d5
8000549e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
    // 5bit Physical Layer Adddress, 5bit GMII Regnr, 4bit csrclock divider, Read, Busy
	GETH_MAC_MDIO_ADDRESS.U = (layeraddr << 21) | (regaddr << 16) | (0 << 8) | (3 << 2) | (1 << 0);
800054a2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800054a6:	8f 52 01 30 	sh %d3,%d2,21
800054aa:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800054ae:	8f 02 01 20 	sh %d2,%d2,16
800054b2:	a6 32       	or %d2,%d3
800054b4:	91 20 00 2f 	movh.a %a2,61442
800054b8:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
800054bc:	8f d2 40 21 	or %d2,%d2,13
800054c0:	74 22       	st.w [%a2],%d2

	IFXGETH_PHY_RTL8211F_WAIT_MDIO_READY();
800054c2:	91 20 00 2f 	movh.a %a2,61442
800054c6:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
800054ca:	54 22       	ld.w %d2,[%a2]
800054cc:	37 02 61 20 	extr.u %d2,%d2,0,1
800054d0:	8f f2 0f 21 	and %d2,%d2,255
800054d4:	df 02 f7 ff 	jne %d2,0,800054c2 <IfxGeth_Eth_Phy_Rtl8211f_read_mdio_reg+0x30>

    // get data
    *pdata = GETH_MAC_MDIO_DATA.U;
800054d8:	91 20 00 2f 	movh.a %a2,61442
800054dc:	d9 22 04 8d 	lea %a2,[%a2]-11772 <f001d204 <bmhd_3_copy+0x40c1bc04>>
800054e0:	54 22       	ld.w %d2,[%a2]
800054e2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <f001d204 <bmhd_3_copy+0x40c1bc04>>
800054e6:	74 22       	st.w [%a2],%d2
}
800054e8:	00 00       	nop 
800054ea:	00 90       	ret 

800054ec <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg>:


void IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg(uint32 layeraddr, uint32 regaddr, uint32 data)
{
800054ec:	40 ae       	mov.aa %a14,%sp
800054ee:	20 10       	sub.a %sp,16
800054f0:	59 e4 fc ff 	st.w [%a14]-4,%d4
800054f4:	59 e5 f8 ff 	st.w [%a14]-8,%d5
800054f8:	59 e6 f4 ff 	st.w [%a14]-12,%d6
    // put data
	GETH_MAC_MDIO_DATA.U = data;
800054fc:	91 20 00 2f 	movh.a %a2,61442
80005500:	d9 22 04 8d 	lea %a2,[%a2]-11772 <f001d204 <bmhd_3_copy+0x40c1bc04>>
80005504:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <f001d204 <bmhd_3_copy+0x40c1bc04>>
80005508:	74 22       	st.w [%a2],%d2

    // 5bit Physical Layer Adddress, 5bit GMII Regnr, 4bit csrclock divider, Write, Busy
    GETH_MAC_MDIO_ADDRESS.U = (layeraddr << 21) | (regaddr << 16) | (0 << 8) |  (1 << 2) | (1 << 0);
8000550a:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <f001d204 <bmhd_3_copy+0x40c1bc04>>
8000550e:	8f 52 01 30 	sh %d3,%d2,21
80005512:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80005516:	8f 02 01 20 	sh %d2,%d2,16
8000551a:	a6 32       	or %d2,%d3
8000551c:	91 20 00 2f 	movh.a %a2,61442
80005520:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
80005524:	8f 52 40 21 	or %d2,%d2,5
80005528:	74 22       	st.w [%a2],%d2

    IFXGETH_PHY_RTL8211F_WAIT_MDIO_READY();
8000552a:	91 20 00 2f 	movh.a %a2,61442
8000552e:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
80005532:	54 22       	ld.w %d2,[%a2]
80005534:	37 02 61 20 	extr.u %d2,%d2,0,1
80005538:	8f f2 0f 21 	and %d2,%d2,255
8000553c:	df 02 f7 ff 	jne %d2,0,8000552a <IfxGeth_Eth_Phy_Rtl8211f_write_mdio_reg+0x3e>
}
80005540:	00 00       	nop 
80005542:	00 00       	nop 
80005544:	00 90       	ret 

Disassembly of section .init:

80005548 <_init>:
80005548:	6d 00 70 00 	call 80005628 <frame_dummy>
8000554c:	6d 01 81 4d 	call 8002f04e <__do_global_ctors_aux>
80005550:	00 90       	ret 
80005552:	00 00       	nop 
80005554:	00 00       	nop 
	...

Disassembly of section .fini:

80005558 <_fini>:
80005558:	6d 00 36 00 	call 800055c4 <__do_global_dtors_aux>
8000555c:	00 90       	ret 
	...

Disassembly of section .CPU1.text:

8030010c <__Core1_start>:
    password  = watchdog->CON0.B.PW;
8030010c:	91 30 00 2f 	movh.a %a2,61443
80300110:	d9 22 18 96 	lea %a2,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
    unsigned int   stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80300114:	85 f8 10 01 	ld.w %d8,f0001010 <bmhd_3_copy+0x40bffa10>
80300118:	54 22       	ld.w %d2,[%a2]
8030011a:	37 02 6e 21 	extr.u %d2,%d2,2,14
8030011e:	8f f2 83 21 	xor %d2,%d2,63
    Ifx_Ssw_setAddressReg(sp, __USTACK(1));
80300122:	91 40 00 a6 	movh.a %sp,24580
80300126:	d9 aa 40 89 	lea %sp,[%sp]-27136 <60039600 <__USTACK1>>
    __asm__ volatile ("dsync" : : : "memory");
8030012a:	0d 00 80 04 	dsync 
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
8030012e:	3b 00 98 30 	mov %d3,2432
80300132:	cd 43 e0 0f 	mtcr $psw,%d3
    if (watchdog->CON0.B.LCK)
80300136:	54 23       	ld.w %d3,[%a2]
80300138:	6f 13 c7 80 	jnz.t %d3,1,803002c6 <x+0x6>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8030013c:	06 22       	sh %d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8030013e:	91 30 00 2f 	movh.a %a2,61443
80300142:	19 24 18 96 	ld.w %d4,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
80300146:	d9 22 18 96 	lea %a2,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
8030014a:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
8030014e:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80300150:	a6 24       	or %d4,%d2
80300152:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80300156:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80300158:	54 24       	ld.w %d4,[%a2]
8030015a:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
8030015e:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80300162:	cd 03 04 09 	mtcr $dcon0,%d3
80300166:	0d 00 c0 04 	isync 
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(1));
8030016a:	91 00 03 38 	movh.a %a3,32816
8030016e:	80 33       	mov.d %d3,%a3
80300170:	1b 03 00 30 	addi %d3,%d3,0
80300174:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(1));
80300178:	91 00 06 38 	movh.a %a3,32864
8030017c:	80 33       	mov.d %d3,%a3
8030017e:	1b 03 00 3e 	addi %d3,%d3,-8192
80300182:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(1));
80300186:	91 40 00 36 	movh.a %a3,24580
8030018a:	80 33       	mov.d %d3,%a3
8030018c:	1b 03 b0 39 	addi %d3,%d3,-25856
80300190:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80300194:	54 23       	ld.w %d3,[%a2]
80300196:	6f 13 09 00 	jz.t %d3,1,803001a8 <__Core1_start+0x9c>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8030019a:	54 23       	ld.w %d3,[%a2]
8030019c:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
803001a0:	a6 23       	or %d3,%d2
803001a2:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
803001a6:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
803001a8:	91 30 00 2f 	movh.a %a2,61443
803001ac:	19 23 18 96 	ld.w %d3,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
803001b0:	d9 22 18 96 	lea %a2,[%a2]25176 <f0036258 <bmhd_3_copy+0x40c34c58>>
803001b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
803001b8:	a6 32       	or %d2,%d3
803001ba:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
803001be:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
803001c0:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setAddressReg(a0, __SDATA1(1));
803001c2:	91 10 00 07 	movh.a %a0,28673
803001c6:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a1, __SDATA2(1));
803001ca:	91 10 00 18 	movh.a %a1,32769
803001ce:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(1));
803001d2:	91 10 00 88 	movh.a %a8,32769
803001d6:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(1));
803001da:	91 10 00 99 	movh.a %a9,36865
803001de:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    unsigned int  numOfCsa    = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
803001e2:	91 40 00 36 	movh.a %a3,24580
803001e6:	91 40 00 26 	movh.a %a2,24580
803001ea:	d9 33 c0 09 	lea %a3,[%a3]-25600 <60039c00 <__CSA1>>
803001ee:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <6003bc00 <__CSA1_END>>
803001f2:	01 32 20 20 	sub.a %a2,%a2,%a3
803001f6:	80 22       	mov.d %d2,%a2
803001f8:	8f a2 1f 60 	sh %d6,%d2,-6
    for (k = 0U; k < numOfCsa; k++)
803001fc:	df 06 6f 00 	jeq %d6,0,803002da <x+0x1a>
    unsigned int *nxtCsa      = csaBegin;
80300200:	80 32       	mov.d %d2,%a3
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80300202:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80300206:	7b f0 00 70 	movh %d7,15
8030020a:	8f 42 1f 50 	sh %d5,%d2,-12
8030020e:	26 75       	and %d5,%d7
    for (k = 0U; k < numOfCsa; k++)
80300210:	82 03       	mov %d3,0
        if (k == (numOfCsa - 3U))
80300212:	1b d6 ff 0f 	addi %d0,%d6,-3
    unsigned int *prvCsa      = 0U;
80300216:	a0 02       	mov.a %a2,0
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80300218:	a6 54       	or %d4,%d5
        if (k == 0U)
8030021a:	df 03 14 00 	jeq %d3,0,80300242 <__Core1_start+0x136>
            *prvCsa = nxt_cxi_val;
8030021e:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80300220:	5f 03 15 00 	jeq %d3,%d0,8030024a <__Core1_start+0x13e>
    for (k = 0U; k < numOfCsa; k++)
80300224:	c2 13       	add %d3,1
80300226:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80300228:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
8030022c:	5f 36 17 00 	jeq %d6,%d3,8030025a <__Core1_start+0x14e>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80300230:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80300232:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80300236:	8f 42 1f 50 	sh %d5,%d2,-12
8030023a:	26 75       	and %d5,%d7
8030023c:	a6 54       	or %d4,%d5
        if (k == 0U)
8030023e:	df 03 f0 ff 	jne %d3,0,8030021e <__Core1_start+0x112>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80300242:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80300246:	5f 03 ef ff 	jne %d3,%d0,80300224 <__Core1_start+0x118>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8030024a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
8030024e:	c2 13       	add %d3,1
80300250:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80300252:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80300256:	5f 36 ed ff 	jne %d6,%d3,80300230 <__Core1_start+0x124>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
8030025a:	1b f6 ff 2f 	addi %d2,%d6,-1
8030025e:	06 62       	sh %d2,6
80300260:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80300264:	82 02       	mov %d2,0
80300266:	74 32       	st.w [%a3],%d2
    __asm__ volatile ("dsync" : : : "memory");
80300268:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
8030026c:	0d 00 c0 04 	isync 
    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);
80300270:	6d e8 c8 7c 	call 8000fc00 <Ifx_Ssw_getStmFrequency>
80300274:	02 24       	mov %d4,%d2
80300276:	6d e9 14 38 	call 8002729e <__extendsfdf2>
8030027a:	0b 23 10 48 	mov %e4,%d3,%d2
8030027e:	7b c0 b1 6e 	movh %d6,60188
80300282:	7b a0 f1 73 	movh %d7,16154
80300286:	1b d6 32 64 	addi %d6,%d6,17197
8030028a:	1b 27 6e 73 	addi %d7,%d7,14050
8030028e:	6d e9 8d 39 	call 800275a8 <__muldf3>
80300292:	0b 23 10 48 	mov %e4,%d3,%d2
80300296:	6d e9 e8 37 	call 80027266 <__fixunsdfsi>
    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
8030029a:	85 f3 10 01 	ld.w %d3,f0001010 <bmhd_3_copy+0x40bffa10>
8030029e:	a2 83       	sub %d3,%d8
803002a0:	3f 23 fd ff 	jlt.u %d3,%d2,8030029a <__Core1_start+0x18e>
    (void)Ifx_Ssw_startCore(&MODULE_CPU2, (unsigned int)__START(2));       /*The status returned by function call is ignored */
803002a4:	91 00 06 2a 	movh.a %a2,41056
803002a8:	80 22       	mov.d %d2,%a2
803002aa:	1b 02 10 40 	addi %d4,%d2,256
803002ae:	91 40 88 4f 	movh.a %a4,63620
803002b2:	6d e8 6a 7c 	call 8000fb86 <Ifx_Ssw_startCore>
    __asm__ volatile ("ji %0" ::"a" (fun));
803002b6:	91 00 03 28 	movh.a %a2,32816
803002ba:	d9 22 22 b0 	lea %a2,[%a2]738 <803002e2 <core1_main>>
803002be:	dc 02       	ji %a2

803002c0 <x>:
    __asm("x: loopu\t x");
803002c0:	fd 00 00 80 	loopu 803002c0 <x>
}
803002c4:	00 90       	ret 
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
803002c6:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
803002c8:	06 22       	sh %d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
803002ca:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
803002ce:	a6 23       	or %d3,%d2
803002d0:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
803002d4:	74 23       	st.w [%a2],%d3
803002d6:	1d ff 34 ff 	j 8030013e <__Core1_start+0x32>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
803002da:	a5 06 00 00 	st.w 0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>,%d6
803002de:	6d e9 b5 74 	call 8002ec48 <abort>

803002e2 <core1_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core1_main(void)
{
803002e2:	40 ae       	mov.aa %a14,%sp
    __enable();
803002e4:	0d 00 00 03 	enable 
}
803002e8:	00 00       	nop 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG1 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
803002ea:	6d e8 f5 41 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
803002ee:	02 24       	mov %d4,%d2
803002f0:	6d e8 a8 40 	call 80008440 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
803002f4:	91 10 00 27 	movh.a %a2,28673
803002f8:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
803002fc:	6d e8 73 6c 	call 8000dbe2 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80300300:	82 14       	mov %d4,1
80300302:	91 10 00 27 	movh.a %a2,28673
80300306:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
8030030a:	6d e8 fe 6b 	call 8000db06 <IfxCpu_waitEvent>
    
    while(1)
8030030e:	1d 00 00 00 	j 8030030e <core1_main+0x2c>

Disassembly of section .CPU2.text:

8060010c <__Core2_start>:
    password  = watchdog->CON0.B.PW;
8060010c:	91 30 00 2f 	movh.a %a2,61443
80600110:	d9 22 24 96 	lea %a2,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
    unsigned int   stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80600114:	85 f8 10 01 	ld.w %d8,f0001010 <bmhd_3_copy+0x40bffa10>
80600118:	54 22       	ld.w %d2,[%a2]
8060011a:	37 02 6e 21 	extr.u %d2,%d2,2,14
8060011e:	8f f2 83 21 	xor %d2,%d2,63
    Ifx_Ssw_setAddressReg(sp, __USTACK(2));
80600122:	91 10 00 a5 	movh.a %sp,20481
80600126:	d9 aa 40 85 	lea %sp,[%sp]22016 <50015600 <__USTACK2>>
    __asm__ volatile ("dsync" : : : "memory");
8060012a:	0d 00 80 04 	dsync 
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
8060012e:	3b 00 98 30 	mov %d3,2432
80600132:	cd 43 e0 0f 	mtcr $psw,%d3
    if (watchdog->CON0.B.LCK)
80600136:	54 23       	ld.w %d3,[%a2]
80600138:	6f 13 c7 80 	jnz.t %d3,1,806002c6 <x+0x6>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8060013c:	06 22       	sh %d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8060013e:	91 30 00 2f 	movh.a %a2,61443
80600142:	19 24 24 96 	ld.w %d4,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
80600146:	d9 22 24 96 	lea %a2,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
8060014a:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
8060014e:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80600150:	a6 24       	or %d4,%d2
80600152:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80600156:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80600158:	54 24       	ld.w %d4,[%a2]
8060015a:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
8060015e:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80600162:	cd 03 04 09 	mtcr $dcon0,%d3
80600166:	0d 00 c0 04 	isync 
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(2));
8060016a:	91 00 06 38 	movh.a %a3,32864
8060016e:	80 33       	mov.d %d3,%a3
80600170:	1b 03 00 30 	addi %d3,%d3,0
80600174:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(2));
80600178:	91 00 09 38 	movh.a %a3,32912
8060017c:	80 33       	mov.d %d3,%a3
8060017e:	1b 03 00 3e 	addi %d3,%d3,-8192
80600182:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(2));
80600186:	91 10 00 35 	movh.a %a3,20481
8060018a:	80 33       	mov.d %d3,%a3
8060018c:	1b 03 b0 35 	addi %d3,%d3,23296
80600190:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80600194:	54 23       	ld.w %d3,[%a2]
80600196:	6f 13 09 00 	jz.t %d3,1,806001a8 <__Core2_start+0x9c>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8060019a:	54 23       	ld.w %d3,[%a2]
8060019c:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
806001a0:	a6 23       	or %d3,%d2
806001a2:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
806001a6:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
806001a8:	91 30 00 2f 	movh.a %a2,61443
806001ac:	19 23 24 96 	ld.w %d3,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
806001b0:	d9 22 24 96 	lea %a2,[%a2]25188 <f0036264 <bmhd_3_copy+0x40c34c64>>
806001b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
806001b8:	a6 32       	or %d2,%d3
806001ba:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
806001be:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
806001c0:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setAddressReg(a0, __SDATA1(2));
806001c2:	91 10 00 07 	movh.a %a0,28673
806001c6:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a1, __SDATA2(2));
806001ca:	91 10 00 18 	movh.a %a1,32769
806001ce:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(2));
806001d2:	91 10 00 88 	movh.a %a8,32769
806001d6:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(2));
806001da:	91 10 00 99 	movh.a %a9,36865
806001de:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    unsigned int  numOfCsa    = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
806001e2:	91 10 00 35 	movh.a %a3,20481
806001e6:	91 10 00 25 	movh.a %a2,20481
806001ea:	d9 33 c0 05 	lea %a3,[%a3]23552 <50015c00 <__CSA2>>
806001ee:	d9 22 c0 07 	lea %a2,[%a2]31744 <50017c00 <__CSA2_END>>
806001f2:	01 32 20 20 	sub.a %a2,%a2,%a3
806001f6:	80 22       	mov.d %d2,%a2
806001f8:	8f a2 1f 60 	sh %d6,%d2,-6
    for (k = 0U; k < numOfCsa; k++)
806001fc:	df 06 6f 00 	jeq %d6,0,806002da <x+0x1a>
    unsigned int *nxtCsa      = csaBegin;
80600200:	80 32       	mov.d %d2,%a3
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80600202:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80600206:	7b f0 00 70 	movh %d7,15
8060020a:	8f 42 1f 50 	sh %d5,%d2,-12
8060020e:	26 75       	and %d5,%d7
    for (k = 0U; k < numOfCsa; k++)
80600210:	82 03       	mov %d3,0
        if (k == (numOfCsa - 3U))
80600212:	1b d6 ff 0f 	addi %d0,%d6,-3
    unsigned int *prvCsa      = 0U;
80600216:	a0 02       	mov.a %a2,0
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80600218:	a6 54       	or %d4,%d5
        if (k == 0U)
8060021a:	df 03 14 00 	jeq %d3,0,80600242 <__Core2_start+0x136>
            *prvCsa = nxt_cxi_val;
8060021e:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80600220:	5f 03 15 00 	jeq %d3,%d0,8060024a <__Core2_start+0x13e>
    for (k = 0U; k < numOfCsa; k++)
80600224:	c2 13       	add %d3,1
80600226:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80600228:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
8060022c:	5f 36 17 00 	jeq %d6,%d3,8060025a <__Core2_start+0x14e>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80600230:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80600232:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80600236:	8f 42 1f 50 	sh %d5,%d2,-12
8060023a:	26 75       	and %d5,%d7
8060023c:	a6 54       	or %d4,%d5
        if (k == 0U)
8060023e:	df 03 f0 ff 	jne %d3,0,8060021e <__Core2_start+0x112>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80600242:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80600246:	5f 03 ef ff 	jne %d3,%d0,80600224 <__Core2_start+0x118>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8060024a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
8060024e:	c2 13       	add %d3,1
80600250:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80600252:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80600256:	5f 36 ed ff 	jne %d6,%d3,80600230 <__Core2_start+0x124>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
8060025a:	1b f6 ff 2f 	addi %d2,%d6,-1
8060025e:	06 62       	sh %d2,6
80600260:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80600264:	82 02       	mov %d2,0
80600266:	74 32       	st.w [%a3],%d2
    __asm__ volatile ("dsync" : : : "memory");
80600268:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
8060026c:	0d 00 c0 04 	isync 
    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);
80600270:	6d d0 c8 7c 	call 8000fc00 <Ifx_Ssw_getStmFrequency>
80600274:	02 24       	mov %d4,%d2
80600276:	6d d1 14 38 	call 8002729e <__extendsfdf2>
8060027a:	0b 23 10 48 	mov %e4,%d3,%d2
8060027e:	7b c0 b1 6e 	movh %d6,60188
80600282:	7b a0 f1 73 	movh %d7,16154
80600286:	1b d6 32 64 	addi %d6,%d6,17197
8060028a:	1b 27 6e 73 	addi %d7,%d7,14050
8060028e:	6d d1 8d 39 	call 800275a8 <__muldf3>
80600292:	0b 23 10 48 	mov %e4,%d3,%d2
80600296:	6d d1 e8 37 	call 80027266 <__fixunsdfsi>
    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
8060029a:	85 f3 10 01 	ld.w %d3,f0001010 <bmhd_3_copy+0x40bffa10>
8060029e:	a2 83       	sub %d3,%d8
806002a0:	3f 23 fd ff 	jlt.u %d3,%d2,8060029a <__Core2_start+0x18e>
    (void)Ifx_Ssw_startCore(&MODULE_CPU3, (unsigned int)__START(3));       /*The status returned by function call is ignored */
806002a4:	91 00 09 2a 	movh.a %a2,41104
806002a8:	80 22       	mov.d %d2,%a2
806002aa:	1b 02 10 40 	addi %d4,%d2,256
806002ae:	91 60 88 4f 	movh.a %a4,63622
806002b2:	6d d0 6a 7c 	call 8000fb86 <Ifx_Ssw_startCore>
    __asm__ volatile ("ji %0" ::"a" (fun));
806002b6:	91 00 06 28 	movh.a %a2,32864
806002ba:	d9 22 22 b0 	lea %a2,[%a2]738 <806002e2 <core2_main>>
806002be:	dc 02       	ji %a2

806002c0 <x>:
    __asm("x: loopu\t x");
806002c0:	fd 00 00 80 	loopu 806002c0 <x>
}
806002c4:	00 90       	ret 
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
806002c6:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
806002c8:	06 22       	sh %d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
806002ca:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
806002ce:	a6 23       	or %d3,%d2
806002d0:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
806002d4:	74 23       	st.w [%a2],%d3
806002d6:	1d ff 34 ff 	j 8060013e <__Core2_start+0x32>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
806002da:	a5 06 00 00 	st.w 0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>,%d6
806002de:	6d d1 b5 74 	call 8002ec48 <abort>

806002e2 <core2_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core2_main(void)
{
806002e2:	40 ae       	mov.aa %a14,%sp
    __enable();
806002e4:	0d 00 00 03 	enable 
}
806002e8:	00 00       	nop 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG2 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
806002ea:	6d d0 f5 41 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
806002ee:	02 24       	mov %d4,%d2
806002f0:	6d d0 a8 40 	call 80008440 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
806002f4:	91 10 00 27 	movh.a %a2,28673
806002f8:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
806002fc:	6d d0 73 6c 	call 8000dbe2 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80600300:	82 14       	mov %d4,1
80600302:	91 10 00 27 	movh.a %a2,28673
80600306:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
8060030a:	6d d0 fe 6b 	call 8000db06 <IfxCpu_waitEvent>
    
    while(1)
8060030e:	1d 00 00 00 	j 8060030e <core2_main+0x2c>

Disassembly of section .CPU3.text:

8090010c <__Core3_start>:
    password  = watchdog->CON0.B.PW;
8090010c:	91 30 00 2f 	movh.a %a2,61443
80900110:	d9 22 30 96 	lea %a2,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
    unsigned int   stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80900114:	85 f8 10 01 	ld.w %d8,f0001010 <bmhd_3_copy+0x40bffa10>
80900118:	54 22       	ld.w %d2,[%a2]
8090011a:	37 02 6e 21 	extr.u %d2,%d2,2,14
8090011e:	8f f2 83 21 	xor %d2,%d2,63
    Ifx_Ssw_setAddressReg(sp, __USTACK(3));
80900122:	91 10 00 a4 	movh.a %sp,16385
80900126:	d9 aa 40 85 	lea %sp,[%sp]22016 <40015600 <__USTACK3>>
    __asm__ volatile ("dsync" : : : "memory");
8090012a:	0d 00 80 04 	dsync 
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
8090012e:	3b 00 98 30 	mov %d3,2432
80900132:	cd 43 e0 0f 	mtcr $psw,%d3
    if (watchdog->CON0.B.LCK)
80900136:	54 23       	ld.w %d3,[%a2]
80900138:	6f 13 c5 80 	jnz.t %d3,1,809002c2 <__Core3_start+0x1b6>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8090013c:	06 22       	sh %d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8090013e:	91 30 00 2f 	movh.a %a2,61443
80900142:	19 24 30 96 	ld.w %d4,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
80900146:	d9 22 30 96 	lea %a2,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
8090014a:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
8090014e:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80900150:	a6 24       	or %d4,%d2
80900152:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80900156:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80900158:	54 24       	ld.w %d4,[%a2]
8090015a:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
8090015e:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80900162:	cd 03 04 09 	mtcr $dcon0,%d3
80900166:	0d 00 c0 04 	isync 
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(3));
8090016a:	91 00 09 38 	movh.a %a3,32912
8090016e:	80 33       	mov.d %d3,%a3
80900170:	1b 03 00 30 	addi %d3,%d3,0
80900174:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(3));
80900178:	91 00 0c 38 	movh.a %a3,32960
8090017c:	80 33       	mov.d %d3,%a3
8090017e:	1b 03 00 3e 	addi %d3,%d3,-8192
80900182:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(3));
80900186:	91 10 00 34 	movh.a %a3,16385
8090018a:	80 33       	mov.d %d3,%a3
8090018c:	1b 03 b0 35 	addi %d3,%d3,23296
80900190:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80900194:	54 23       	ld.w %d3,[%a2]
80900196:	6f 13 09 00 	jz.t %d3,1,809001a8 <__Core3_start+0x9c>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8090019a:	54 23       	ld.w %d3,[%a2]
8090019c:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
809001a0:	a6 23       	or %d3,%d2
809001a2:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
809001a6:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
809001a8:	91 30 00 2f 	movh.a %a2,61443
809001ac:	19 23 30 96 	ld.w %d3,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
809001b0:	d9 22 30 96 	lea %a2,[%a2]25200 <f0036270 <bmhd_3_copy+0x40c34c70>>
809001b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
809001b8:	a6 32       	or %d2,%d3
809001ba:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
809001be:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
809001c0:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setAddressReg(a0, __SDATA1(3));
809001c2:	91 10 00 07 	movh.a %a0,28673
809001c6:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a1, __SDATA2(3));
809001ca:	91 10 00 18 	movh.a %a1,32769
809001ce:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(3));
809001d2:	91 10 00 88 	movh.a %a8,32769
809001d6:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(3));
809001da:	91 10 00 99 	movh.a %a9,36865
809001de:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    unsigned int  numOfCsa    = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
809001e2:	91 10 00 34 	movh.a %a3,16385
809001e6:	91 10 00 24 	movh.a %a2,16385
809001ea:	d9 33 c0 05 	lea %a3,[%a3]23552 <40015c00 <__CSA3>>
809001ee:	d9 22 c0 07 	lea %a2,[%a2]31744 <40017c00 <__CSA3_END>>
809001f2:	01 32 20 20 	sub.a %a2,%a2,%a3
809001f6:	80 22       	mov.d %d2,%a2
809001f8:	8f a2 1f 60 	sh %d6,%d2,-6
    for (k = 0U; k < numOfCsa; k++)
809001fc:	df 06 6d 00 	jeq %d6,0,809002d6 <__Core3_start+0x1ca>
    unsigned int *nxtCsa      = csaBegin;
80900200:	80 32       	mov.d %d2,%a3
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80900202:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80900206:	7b f0 00 70 	movh %d7,15
8090020a:	8f 42 1f 50 	sh %d5,%d2,-12
8090020e:	26 75       	and %d5,%d7
    for (k = 0U; k < numOfCsa; k++)
80900210:	82 03       	mov %d3,0
        if (k == (numOfCsa - 3U))
80900212:	1b d6 ff 0f 	addi %d0,%d6,-3
    unsigned int *prvCsa      = 0U;
80900216:	a0 02       	mov.a %a2,0
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80900218:	a6 54       	or %d4,%d5
        if (k == 0U)
8090021a:	df 03 14 00 	jeq %d3,0,80900242 <__Core3_start+0x136>
            *prvCsa = nxt_cxi_val;
8090021e:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80900220:	5f 03 15 00 	jeq %d3,%d0,8090024a <__Core3_start+0x13e>
    for (k = 0U; k < numOfCsa; k++)
80900224:	c2 13       	add %d3,1
80900226:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80900228:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
8090022c:	5f 36 17 00 	jeq %d6,%d3,8090025a <__Core3_start+0x14e>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80900230:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80900232:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80900236:	8f 42 1f 50 	sh %d5,%d2,-12
8090023a:	26 75       	and %d5,%d7
8090023c:	a6 54       	or %d4,%d5
        if (k == 0U)
8090023e:	df 03 f0 ff 	jne %d3,0,8090021e <__Core3_start+0x112>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80900242:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80900246:	5f 03 ef ff 	jne %d3,%d0,80900224 <__Core3_start+0x118>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8090024a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
8090024e:	c2 13       	add %d3,1
80900250:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80900252:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80900256:	5f 36 ed ff 	jne %d6,%d3,80900230 <__Core3_start+0x124>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
8090025a:	1b f6 ff 2f 	addi %d2,%d6,-1
8090025e:	06 62       	sh %d2,6
80900260:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80900264:	82 02       	mov %d2,0
80900266:	74 32       	st.w [%a3],%d2
    __asm__ volatile ("dsync" : : : "memory");
80900268:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
8090026c:	0d 00 c0 04 	isync 
    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);
80900270:	6d b8 c8 7c 	call 8000fc00 <Ifx_Ssw_getStmFrequency>
80900274:	02 24       	mov %d4,%d2
80900276:	6d b9 14 38 	call 8002729e <__extendsfdf2>
8090027a:	0b 23 10 48 	mov %e4,%d3,%d2
8090027e:	7b c0 b1 6e 	movh %d6,60188
80900282:	7b a0 f1 73 	movh %d7,16154
80900286:	1b d6 32 64 	addi %d6,%d6,17197
8090028a:	1b 27 6e 73 	addi %d7,%d7,14050
8090028e:	6d b9 8d 39 	call 800275a8 <__muldf3>
80900292:	0b 23 10 48 	mov %e4,%d3,%d2
80900296:	6d b9 e8 37 	call 80027266 <__fixunsdfsi>
    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
8090029a:	85 f3 10 01 	ld.w %d3,f0001010 <bmhd_3_copy+0x40bffa10>
8090029e:	a2 83       	sub %d3,%d8
809002a0:	3f 23 fd ff 	jlt.u %d3,%d2,8090029a <__Core3_start+0x18e>
    (void)Ifx_Ssw_startCore(&MODULE_CPU4, (unsigned int)__START(4));       /*The status returned by function call is ignored */
809002a4:	91 00 0c 2a 	movh.a %a2,41152
809002a8:	80 22       	mov.d %d2,%a2
809002aa:	1b 02 10 40 	addi %d4,%d2,256
809002ae:	91 80 88 4f 	movh.a %a4,63624
809002b2:	6d b8 6a 7c 	call 8000fb86 <Ifx_Ssw_startCore>
    __asm__ volatile ("ji %0" ::"a" (fun));
809002b6:	91 00 09 28 	movh.a %a2,32912
809002ba:	d9 22 1e b0 	lea %a2,[%a2]734 <809002de <core3_main>>
809002be:	dc 02       	ji %a2
}
809002c0:	00 90       	ret 
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
809002c2:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
809002c4:	06 22       	sh %d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
809002c6:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
809002ca:	a6 23       	or %d3,%d2
809002cc:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
809002d0:	74 23       	st.w [%a2],%d3
809002d2:	1d ff 36 ff 	j 8090013e <__Core3_start+0x32>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
809002d6:	a5 06 00 00 	st.w 0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>,%d6
809002da:	6d b9 b7 74 	call 8002ec48 <abort>

809002de <core3_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core3_main(void)
{
809002de:	40 ae       	mov.aa %a14,%sp
    __enable();
809002e0:	0d 00 00 03 	enable 
}
809002e4:	00 00       	nop 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG3 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
809002e6:	6d b8 f7 41 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
809002ea:	02 24       	mov %d4,%d2
809002ec:	6d b8 aa 40 	call 80008440 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
809002f0:	91 10 00 27 	movh.a %a2,28673
809002f4:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
809002f8:	6d b8 75 6c 	call 8000dbe2 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
809002fc:	82 14       	mov %d4,1
809002fe:	91 10 00 27 	movh.a %a2,28673
80900302:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
80900306:	6d b8 00 6c 	call 8000db06 <IfxCpu_waitEvent>
    
    while(1)
8090030a:	1d 00 00 00 	j 8090030a <core3_main+0x2c>

Disassembly of section .CPU4.text:

80c0010c <__Core4_start>:
    password  = watchdog->CON0.B.PW;
80c0010c:	91 30 00 2f 	movh.a %a2,61443
80c00110:	d9 22 3c 96 	lea %a2,[%a2]25212 <f003627c <bmhd_3_copy+0x40c34c7c>>
    unsigned int   stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80c00114:	85 f8 10 01 	ld.w %d8,f0001010 <bmhd_3_copy+0x40bffa10>
80c00118:	54 22       	ld.w %d2,[%a2]
80c0011a:	37 02 6e 21 	extr.u %d2,%d2,2,14
80c0011e:	8f f2 83 21 	xor %d2,%d2,63
    Ifx_Ssw_setAddressReg(sp, __USTACK(4));
80c00122:	91 10 00 a3 	movh.a %sp,12289
80c00126:	d9 aa 40 85 	lea %sp,[%sp]22016 <30015600 <__USTACK4>>
    __asm__ volatile ("dsync" : : : "memory");
80c0012a:	0d 00 80 04 	dsync 
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
80c0012e:	3b 00 98 30 	mov %d3,2432
80c00132:	cd 43 e0 0f 	mtcr $psw,%d3
    if (watchdog->CON0.B.LCK)
80c00136:	54 23       	ld.w %d3,[%a2]
80c00138:	6f 13 c5 80 	jnz.t %d3,1,80c002c2 <__Core4_start+0x1b6>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80c0013c:	06 22       	sh %d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80c0013e:	91 30 00 2f 	movh.a %a2,61443
80c00142:	19 24 3c 96 	ld.w %d4,[%a2]25212 <f003627c <bmhd_3_copy+0x40c34c7c>>
80c00146:	d9 22 3c 96 	lea %a2,[%a2]25212 <f003627c <bmhd_3_copy+0x40c34c7c>>
80c0014a:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
80c0014e:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80c00150:	a6 24       	or %d4,%d2
80c00152:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80c00156:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80c00158:	54 24       	ld.w %d4,[%a2]
80c0015a:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
80c0015e:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80c00162:	cd 03 04 09 	mtcr $dcon0,%d3
80c00166:	0d 00 c0 04 	isync 
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(4));
80c0016a:	91 00 0c 38 	movh.a %a3,32960
80c0016e:	80 33       	mov.d %d3,%a3
80c00170:	1b 03 00 30 	addi %d3,%d3,0
80c00174:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(4));
80c00178:	91 00 0f 38 	movh.a %a3,33008
80c0017c:	80 33       	mov.d %d3,%a3
80c0017e:	1b 03 00 3e 	addi %d3,%d3,-8192
80c00182:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(4));
80c00186:	91 10 00 33 	movh.a %a3,12289
80c0018a:	80 33       	mov.d %d3,%a3
80c0018c:	1b 03 b0 35 	addi %d3,%d3,23296
80c00190:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80c00194:	54 23       	ld.w %d3,[%a2]
80c00196:	6f 13 09 00 	jz.t %d3,1,80c001a8 <__Core4_start+0x9c>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80c0019a:	54 23       	ld.w %d3,[%a2]
80c0019c:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80c001a0:	a6 23       	or %d3,%d2
80c001a2:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80c001a6:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80c001a8:	91 30 00 2f 	movh.a %a2,61443
80c001ac:	19 23 3c 96 	ld.w %d3,[%a2]25212 <f003627c <bmhd_3_copy+0x40c34c7c>>
80c001b0:	d9 22 3c 96 	lea %a2,[%a2]25212 <f003627c <bmhd_3_copy+0x40c34c7c>>
80c001b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80c001b8:	a6 32       	or %d2,%d3
80c001ba:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80c001be:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
80c001c0:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setAddressReg(a0, __SDATA1(4));
80c001c2:	91 10 00 07 	movh.a %a0,28673
80c001c6:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a1, __SDATA2(4));
80c001ca:	91 10 00 18 	movh.a %a1,32769
80c001ce:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(4));
80c001d2:	91 10 00 88 	movh.a %a8,32769
80c001d6:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(4));
80c001da:	91 10 00 99 	movh.a %a9,36865
80c001de:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    unsigned int  numOfCsa    = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
80c001e2:	91 10 00 33 	movh.a %a3,12289
80c001e6:	91 10 00 23 	movh.a %a2,12289
80c001ea:	d9 33 c0 05 	lea %a3,[%a3]23552 <30015c00 <__CSA4>>
80c001ee:	d9 22 c0 07 	lea %a2,[%a2]31744 <30017c00 <__CSA4_END>>
80c001f2:	01 32 20 20 	sub.a %a2,%a2,%a3
80c001f6:	80 22       	mov.d %d2,%a2
80c001f8:	8f a2 1f 60 	sh %d6,%d2,-6
    for (k = 0U; k < numOfCsa; k++)
80c001fc:	df 06 6d 00 	jeq %d6,0,80c002d6 <__Core4_start+0x1ca>
    unsigned int *nxtCsa      = csaBegin;
80c00200:	80 32       	mov.d %d2,%a3
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80c00202:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80c00206:	7b f0 00 70 	movh %d7,15
80c0020a:	8f 42 1f 50 	sh %d5,%d2,-12
80c0020e:	26 75       	and %d5,%d7
    for (k = 0U; k < numOfCsa; k++)
80c00210:	82 03       	mov %d3,0
        if (k == (numOfCsa - 3U))
80c00212:	1b d6 ff 0f 	addi %d0,%d6,-3
    unsigned int *prvCsa      = 0U;
80c00216:	a0 02       	mov.a %a2,0
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80c00218:	a6 54       	or %d4,%d5
        if (k == 0U)
80c0021a:	df 03 14 00 	jeq %d3,0,80c00242 <__Core4_start+0x136>
            *prvCsa = nxt_cxi_val;
80c0021e:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80c00220:	5f 03 15 00 	jeq %d3,%d0,80c0024a <__Core4_start+0x13e>
    for (k = 0U; k < numOfCsa; k++)
80c00224:	c2 13       	add %d3,1
80c00226:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80c00228:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80c0022c:	5f 36 17 00 	jeq %d6,%d3,80c0025a <__Core4_start+0x14e>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80c00230:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80c00232:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80c00236:	8f 42 1f 50 	sh %d5,%d2,-12
80c0023a:	26 75       	and %d5,%d7
80c0023c:	a6 54       	or %d4,%d5
        if (k == 0U)
80c0023e:	df 03 f0 ff 	jne %d3,0,80c0021e <__Core4_start+0x112>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80c00242:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80c00246:	5f 03 ef ff 	jne %d3,%d0,80c00224 <__Core4_start+0x118>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
80c0024a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
80c0024e:	c2 13       	add %d3,1
80c00250:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80c00252:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80c00256:	5f 36 ed ff 	jne %d6,%d3,80c00230 <__Core4_start+0x124>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
80c0025a:	1b f6 ff 2f 	addi %d2,%d6,-1
80c0025e:	06 62       	sh %d2,6
80c00260:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80c00264:	82 02       	mov %d2,0
80c00266:	74 32       	st.w [%a3],%d2
    __asm__ volatile ("dsync" : : : "memory");
80c00268:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
80c0026c:	0d 00 c0 04 	isync 
    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);
80c00270:	6d a0 c8 7c 	call 8000fc00 <Ifx_Ssw_getStmFrequency>
80c00274:	02 24       	mov %d4,%d2
80c00276:	6d a1 14 38 	call 8002729e <__extendsfdf2>
80c0027a:	0b 23 10 48 	mov %e4,%d3,%d2
80c0027e:	7b c0 b1 6e 	movh %d6,60188
80c00282:	7b a0 f1 73 	movh %d7,16154
80c00286:	1b d6 32 64 	addi %d6,%d6,17197
80c0028a:	1b 27 6e 73 	addi %d7,%d7,14050
80c0028e:	6d a1 8d 39 	call 800275a8 <__muldf3>
80c00292:	0b 23 10 48 	mov %e4,%d3,%d2
80c00296:	6d a1 e8 37 	call 80027266 <__fixunsdfsi>
    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
80c0029a:	85 f3 10 01 	ld.w %d3,f0001010 <bmhd_3_copy+0x40bffa10>
80c0029e:	a2 83       	sub %d3,%d8
80c002a0:	3f 23 fd ff 	jlt.u %d3,%d2,80c0029a <__Core4_start+0x18e>
    (void)Ifx_Ssw_startCore(&MODULE_CPU5, (unsigned int)__START(5));       /*The status returned by function call is ignored */
80c002a4:	91 00 0f 2a 	movh.a %a2,41200
80c002a8:	80 22       	mov.d %d2,%a2
80c002aa:	1b 02 10 40 	addi %d4,%d2,256
80c002ae:	91 c0 88 4f 	movh.a %a4,63628
80c002b2:	6d a0 6a 7c 	call 8000fb86 <Ifx_Ssw_startCore>
    __asm__ volatile ("ji %0" ::"a" (fun));
80c002b6:	91 00 0c 28 	movh.a %a2,32960
80c002ba:	d9 22 1e b0 	lea %a2,[%a2]734 <80c002de <core4_main>>
80c002be:	dc 02       	ji %a2
}
80c002c0:	00 90       	ret 
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80c002c2:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80c002c4:	06 22       	sh %d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80c002c6:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80c002ca:	a6 23       	or %d3,%d2
80c002cc:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80c002d0:	74 23       	st.w [%a2],%d3
80c002d2:	1d ff 36 ff 	j 80c0013e <__Core4_start+0x32>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
80c002d6:	a5 06 00 00 	st.w 0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>,%d6
80c002da:	6d a1 b7 74 	call 8002ec48 <abort>

80c002de <core4_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core4_main(void)
{
80c002de:	40 ae       	mov.aa %a14,%sp
    __enable();
80c002e0:	0d 00 00 03 	enable 
}
80c002e4:	00 00       	nop 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG4 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80c002e6:	6d a0 f7 41 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
80c002ea:	02 24       	mov %d4,%d2
80c002ec:	6d a0 aa 40 	call 80008440 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80c002f0:	91 10 00 27 	movh.a %a2,28673
80c002f4:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
80c002f8:	6d a0 75 6c 	call 8000dbe2 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80c002fc:	82 14       	mov %d4,1
80c002fe:	91 10 00 27 	movh.a %a2,28673
80c00302:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
80c00306:	6d a0 00 6c 	call 8000db06 <IfxCpu_waitEvent>
    
    while(1)
80c0030a:	1d 00 00 00 	j 80c0030a <core4_main+0x2c>

Disassembly of section .CPU5.text:

80f0010c <__Core5_start>:
    password  = watchdog->CON0.B.PW;
80f0010c:	91 30 00 2f 	movh.a %a2,61443
80f00110:	d9 22 08 a6 	lea %a2,[%a2]25224 <f0036288 <bmhd_3_copy+0x40c34c88>>
    unsigned int   stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80f00114:	85 f8 10 01 	ld.w %d8,f0001010 <bmhd_3_copy+0x40bffa10>
80f00118:	54 22       	ld.w %d2,[%a2]
80f0011a:	37 02 6e 21 	extr.u %d2,%d2,2,14
80f0011e:	8f f2 83 21 	xor %d2,%d2,63
    Ifx_Ssw_setAddressReg(sp, __USTACK(5));
80f00122:	91 10 00 a1 	movh.a %sp,4097
80f00126:	d9 aa 40 85 	lea %sp,[%sp]22016 <10015600 <__USTACK5>>
    __asm__ volatile ("dsync" : : : "memory");
80f0012a:	0d 00 80 04 	dsync 
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);
80f0012e:	3b 00 98 30 	mov %d3,2432
80f00132:	cd 43 e0 0f 	mtcr $psw,%d3
    if (watchdog->CON0.B.LCK)
80f00136:	54 23       	ld.w %d3,[%a2]
80f00138:	6f 13 bc 80 	jnz.t %d3,1,80f002b0 <__Core5_start+0x1a4>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80f0013c:	06 22       	sh %d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80f0013e:	91 30 00 2f 	movh.a %a2,61443
80f00142:	19 24 08 a6 	ld.w %d4,[%a2]25224 <f0036288 <bmhd_3_copy+0x40c34c88>>
80f00146:	d9 22 08 a6 	lea %a2,[%a2]25224 <f0036288 <bmhd_3_copy+0x40c34c88>>
80f0014a:	b7 04 10 40 	insert %d4,%d4,0,0,16
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
80f0014e:	82 03       	mov %d3,0
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80f00150:	a6 24       	or %d4,%d2
80f00152:	8f 24 40 41 	or %d4,%d4,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80f00156:	74 24       	st.w [%a2],%d4
    watchdog->CON0.U;
80f00158:	54 24       	ld.w %d4,[%a2]
80f0015a:	cd c3 20 09 	mtcr $pcon0,%d3
    __asm__ volatile ("isync" : : : "memory");
80f0015e:	0d 00 c0 04 	isync 
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
80f00162:	cd 03 04 09 	mtcr $dcon0,%d3
80f00166:	0d 00 c0 04 	isync 
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(5));
80f0016a:	91 00 0f 38 	movh.a %a3,33008
80f0016e:	80 33       	mov.d %d3,%a3
80f00170:	1b 03 00 30 	addi %d3,%d3,0
80f00174:	cd 43 e2 0f 	mtcr $btv,%d3
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(5));
80f00178:	91 00 10 38 	movh.a %a3,33024
80f0017c:	80 33       	mov.d %d3,%a3
80f0017e:	1b 03 00 3e 	addi %d3,%d3,-8192
80f00182:	cd 03 e2 0f 	mtcr $biv,%d3
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(5));
80f00186:	91 10 00 31 	movh.a %a3,4097
80f0018a:	80 33       	mov.d %d3,%a3
80f0018c:	1b 03 b0 35 	addi %d3,%d3,23296
80f00190:	cd 83 e2 0f 	mtcr $isp,%d3
    if (watchdog->CON0.B.LCK)
80f00194:	54 23       	ld.w %d3,[%a2]
80f00196:	6f 13 09 00 	jz.t %d3,1,80f001a8 <__Core5_start+0x9c>
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80f0019a:	54 23       	ld.w %d3,[%a2]
80f0019c:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80f001a0:	a6 23       	or %d3,%d2
80f001a2:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80f001a6:	74 23       	st.w [%a2],%d3
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80f001a8:	91 30 00 2f 	movh.a %a2,61443
80f001ac:	19 23 08 a6 	ld.w %d3,[%a2]25224 <f0036288 <bmhd_3_copy+0x40c34c88>>
80f001b0:	d9 22 08 a6 	lea %a2,[%a2]25224 <f0036288 <bmhd_3_copy+0x40c34c88>>
80f001b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80f001b8:	a6 32       	or %d2,%d3
80f001ba:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80f001be:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
80f001c0:	54 22       	ld.w %d2,[%a2]
    Ifx_Ssw_setAddressReg(a0, __SDATA1(5));
80f001c2:	91 10 00 07 	movh.a %a0,28673
80f001c6:	d9 00 00 08 	lea %a0,[%a0]-32768 <70008000 <_SMALL_DATA_>>
    Ifx_Ssw_setAddressReg(a1, __SDATA2(5));
80f001ca:	91 10 00 18 	movh.a %a1,32769
80f001ce:	d9 11 00 08 	lea %a1,[%a1]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a8, __SDATA3(5));
80f001d2:	91 10 00 88 	movh.a %a8,32769
80f001d6:	d9 88 00 08 	lea %a8,[%a8]-32768 <80008000 <_SMALL_DATA2_>>
    Ifx_Ssw_setAddressReg(a9, __SDATA4(5));
80f001da:	91 10 00 99 	movh.a %a9,36865
80f001de:	d9 99 00 08 	lea %a9,[%a9]-32768 <90008000 <_SMALL_DATA4_>>
    unsigned int  numOfCsa    = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);
80f001e2:	91 10 00 31 	movh.a %a3,4097
80f001e6:	91 10 00 21 	movh.a %a2,4097
80f001ea:	d9 33 c0 05 	lea %a3,[%a3]23552 <10015c00 <__CSA5>>
80f001ee:	d9 22 c0 07 	lea %a2,[%a2]31744 <10017c00 <__CSA5_END>>
80f001f2:	01 32 20 20 	sub.a %a2,%a2,%a3
80f001f6:	80 22       	mov.d %d2,%a2
80f001f8:	8f a2 1f 60 	sh %d6,%d2,-6
    for (k = 0U; k < numOfCsa; k++)
80f001fc:	df 06 64 00 	jeq %d6,0,80f002c4 <__Core5_start+0x1b8>
    unsigned int *nxtCsa      = csaBegin;
80f00200:	80 32       	mov.d %d2,%a3
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80f00202:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80f00206:	7b f0 00 70 	movh %d7,15
80f0020a:	8f 42 1f 50 	sh %d5,%d2,-12
80f0020e:	26 75       	and %d5,%d7
    for (k = 0U; k < numOfCsa; k++)
80f00210:	82 03       	mov %d3,0
        if (k == (numOfCsa - 3U))
80f00212:	1b d6 ff 0f 	addi %d0,%d6,-3
    unsigned int *prvCsa      = 0U;
80f00216:	a0 02       	mov.a %a2,0
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80f00218:	a6 54       	or %d4,%d5
        if (k == 0U)
80f0021a:	df 03 14 00 	jeq %d3,0,80f00242 <__Core5_start+0x136>
            *prvCsa = nxt_cxi_val;
80f0021e:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80f00220:	5f 03 15 00 	jeq %d3,%d0,80f0024a <__Core5_start+0x13e>
    for (k = 0U; k < numOfCsa; k++)
80f00224:	c2 13       	add %d3,1
80f00226:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80f00228:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80f0022c:	5f 36 17 00 	jeq %d6,%d3,80f0025a <__Core5_start+0x14e>
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80f00230:	02 42       	mov %d2,%d4
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);
80f00232:	37 02 70 43 	extr.u %d4,%d2,6,16
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
80f00236:	8f 42 1f 50 	sh %d5,%d2,-12
80f0023a:	26 75       	and %d5,%d7
80f0023c:	a6 54       	or %d4,%d5
        if (k == 0U)
80f0023e:	df 03 f0 ff 	jne %d3,0,80f0021e <__Core5_start+0x112>
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80f00242:	cd 84 e3 0f 	mtcr $fcx,%d4
        if (k == (numOfCsa - 3U))
80f00246:	5f 03 ef ff 	jne %d3,%d0,80f00224 <__Core5_start+0x118>
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
80f0024a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
80f0024e:	c2 13       	add %d3,1
80f00250:	60 22       	mov.a %a2,%d2
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
80f00252:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80f00256:	5f 36 ed ff 	jne %d6,%d3,80f00230 <__Core5_start+0x124>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
80f0025a:	1b f6 ff 2f 	addi %d2,%d6,-1
80f0025e:	06 62       	sh %d2,6
80f00260:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80f00264:	82 02       	mov %d2,0
80f00266:	74 32       	st.w [%a3],%d2
    __asm__ volatile ("dsync" : : : "memory");
80f00268:	0d 00 80 04 	dsync 
    __asm__ volatile ("isync" : : : "memory");
80f0026c:	0d 00 c0 04 	isync 
    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);
80f00270:	6d 88 c8 7c 	call 8000fc00 <Ifx_Ssw_getStmFrequency>
80f00274:	02 24       	mov %d4,%d2
80f00276:	6d 89 14 38 	call 8002729e <__extendsfdf2>
80f0027a:	0b 23 10 48 	mov %e4,%d3,%d2
80f0027e:	7b c0 b1 6e 	movh %d6,60188
80f00282:	7b a0 f1 73 	movh %d7,16154
80f00286:	1b d6 32 64 	addi %d6,%d6,17197
80f0028a:	1b 27 6e 73 	addi %d7,%d7,14050
80f0028e:	6d 89 8d 39 	call 800275a8 <__muldf3>
80f00292:	0b 23 10 48 	mov %e4,%d3,%d2
80f00296:	6d 89 e8 37 	call 80027266 <__fixunsdfsi>
    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
80f0029a:	85 f3 10 01 	ld.w %d3,f0001010 <bmhd_3_copy+0x40bffa10>
80f0029e:	a2 83       	sub %d3,%d8
80f002a0:	3f 23 fd ff 	jlt.u %d3,%d2,80f0029a <__Core5_start+0x18e>
    __asm__ volatile ("ji %0" ::"a" (fun));
80f002a4:	91 00 0f 28 	movh.a %a2,33008
80f002a8:	d9 22 0c b0 	lea %a2,[%a2]716 <80f002cc <core5_main>>
80f002ac:	dc 02       	ji %a2
}
80f002ae:	00 90       	ret 
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80f002b0:	54 23       	ld.w %d3,[%a2]
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80f002b2:	06 22       	sh %d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80f002b4:	b7 03 10 30 	insert %d3,%d3,0,0,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80f002b8:	a6 23       	or %d3,%d2
80f002ba:	8f 13 40 31 	or %d3,%d3,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80f002be:	74 23       	st.w [%a2],%d3
80f002c0:	1d ff 3f ff 	j 80f0013e <__Core5_start+0x32>
    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */
80f002c4:	a5 06 00 00 	st.w 0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>,%d6
80f002c8:	6d 89 c0 74 	call 8002ec48 <abort>

80f002cc <core5_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core5_main(void)
{
80f002cc:	40 ae       	mov.aa %a14,%sp
    __enable();
80f002ce:	0d 00 00 03 	enable 
}
80f002d2:	00 00       	nop 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG5 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80f002d4:	6d 88 00 42 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
80f002d8:	02 24       	mov %d4,%d2
80f002da:	6d 88 b3 40 	call 80008440 <IfxScuWdt_disableCpuWatchdog>

    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80f002de:	91 10 00 27 	movh.a %a2,28673
80f002e2:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
80f002e6:	6d 88 7e 6c 	call 8000dbe2 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80f002ea:	82 14       	mov %d4,1
80f002ec:	91 10 00 27 	movh.a %a2,28673
80f002f0:	d9 24 5c 84 	lea %a4,[%a2]17948 <7001461c <g_cpuSyncEvent>>
80f002f4:	6d 88 09 6c 	call 8000db06 <IfxCpu_waitEvent>
    
    while(1)
80f002f8:	1d 00 00 00 	j 80f002f8 <core5_main+0x2c>

Disassembly of section .text:

80005560 <deregister_tm_clones>:
80005560:	7b 10 00 27 	movh %d2,28673
80005564:	1b 02 94 2a 	addi %d2,%d2,-22208
80005568:	91 10 00 47 	movh.a %a4,28673
8000556c:	60 22       	mov.a %a2,%d2
8000556e:	d9 44 80 5a 	lea %a4,[%a4]-22208 <7000a940 <__TMC_END__>>
80005572:	7d 42 0a 00 	jeq.a %a2,%a4,80005586 <deregister_tm_clones+0x26>
80005576:	91 00 00 20 	movh.a %a2,0
8000557a:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>>
8000557e:	bd 02 04 00 	jz.a %a2,80005586 <deregister_tm_clones+0x26>
80005582:	2d 02 00 00 	calli %a2
80005586:	00 90       	ret 

80005588 <register_tm_clones>:
80005588:	7b 10 00 27 	movh %d2,28673
8000558c:	1b 02 94 2a 	addi %d2,%d2,-22208
80005590:	91 10 00 47 	movh.a %a4,28673
80005594:	60 22       	mov.a %a2,%d2
80005596:	d9 44 80 5a 	lea %a4,[%a4]-22208 <7000a940 <__TMC_END__>>
8000559a:	01 42 20 20 	sub.a %a2,%a2,%a4
8000559e:	80 22       	mov.d %d2,%a2
800055a0:	8f e2 3f 30 	sha %d3,%d2,-2
800055a4:	8f 12 1e 20 	sh %d2,%d2,-31
800055a8:	42 32       	add %d2,%d3
800055aa:	8f f2 3f 40 	sha %d4,%d2,-1
800055ae:	df 04 0a 00 	jeq %d4,0,800055c2 <register_tm_clones+0x3a>
800055b2:	91 00 00 20 	movh.a %a2,0
800055b6:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x390>>
800055ba:	bd 02 04 00 	jz.a %a2,800055c2 <register_tm_clones+0x3a>
800055be:	2d 02 00 00 	calli %a2
800055c2:	00 90       	ret 

800055c4 <__do_global_dtors_aux>:
800055c4:	91 10 00 e7 	movh.a %a14,28673
800055c8:	39 e2 80 5a 	ld.bu %d2,[%a14]-22208 <7000a940 <__TMC_END__>>
800055cc:	df 02 2d 80 	jne %d2,0,80005626 <__do_global_dtors_aux+0x62>
800055d0:	91 30 00 38 	movh.a %a3,32771
800055d4:	91 30 00 28 	movh.a %a2,32771
800055d8:	d9 33 18 2f 	lea %a3,[%a3]-3944 <8002f098 <__DTOR_END__>>
800055dc:	d9 22 0c 2f 	lea %a2,[%a2]-3956 <8002f08c <__DTOR_LIST__>>
800055e0:	01 23 20 20 	sub.a %a2,%a3,%a2
800055e4:	80 22       	mov.d %d2,%a2
800055e6:	86 e2       	sha %d2,-2
800055e8:	1b f2 ff 8f 	addi %d8,%d2,-1
800055ec:	91 10 00 c7 	movh.a %a12,28673
800055f0:	7b 30 00 28 	movh %d2,32771
800055f4:	1b c2 08 2f 	addi %d2,%d2,-3956
800055f8:	60 2d       	mov.a %a13,%d2
800055fa:	19 c2 84 5a 	ld.w %d2,[%a12]-22204 <7000a944 <dtor_idx.0>>
800055fe:	7f 82 0f 80 	jge.u %d2,%d8,8000561c <__do_global_dtors_aux+0x58>
80005602:	d9 cc 84 5a 	lea %a12,[%a12]-22204 <7000a944 <dtor_idx.0>>
80005606:	c2 12       	add %d2,1
80005608:	74 c2       	st.w [%a12],%d2
8000560a:	06 22       	sh %d2,2
8000560c:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80005610:	d4 22       	ld.a %a2,[%a2]
80005612:	2d 02 00 00 	calli %a2
80005616:	54 c2       	ld.w %d2,[%a12]
80005618:	3f 82 f7 ff 	jlt.u %d2,%d8,80005606 <__do_global_dtors_aux+0x42>
8000561c:	6d ff a2 ff 	call 80005560 <deregister_tm_clones>
80005620:	82 12       	mov %d2,1
80005622:	e9 e2 80 5a 	st.b [%a14]-22208 <7000a940 <__TMC_END__>>,%d2
80005626:	00 90       	ret 

80005628 <frame_dummy>:
80005628:	6d ff b0 ff 	call 80005588 <register_tm_clones>
8000562c:	00 90       	ret 

8000562e <Ifx_CircularBuffer_read8>:
    }
}


void *Ifx_CircularBuffer_read8(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
8000562e:	40 ae       	mov.aa %a14,%sp
80005630:	20 18       	sub.a %sp,24
80005632:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80005636:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
8000563a:	02 42       	mov %d2,%d4
8000563c:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    uint8 *Dest = (uint8 *)data;
80005640:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80005644:	59 e2 fc ff 	st.w [%a14]-4,%d2

    do
    {
        count--;
80005648:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
8000564c:	37 02 70 20 	extr.u %d2,%d2,0,16
80005650:	c2 f2       	add %d2,-1
80005652:	37 02 70 20 	extr.u %d2,%d2,0,16
80005656:	f9 e2 ec ff 	st.h [%a14]-20,%d2
        *Dest = ((uint8 *)buffer->base)[buffer->index];
8000565a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000565e:	54 23       	ld.w %d3,[%a2]
80005660:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005664:	b9 22 04 00 	ld.hu %d2,[%a2]4
80005668:	60 32       	mov.a %a2,%d3
8000566a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000566e:	14 22       	ld.bu %d2,[%a2]
80005670:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005674:	34 22       	st.b [%a2],%d2
        Dest  = &Dest[1];
80005676:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000567a:	c2 12       	add %d2,1
8000567c:	59 e2 fc ff 	st.w [%a14]-4,%d2
        buffer->index++;
80005680:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005684:	b9 22 04 00 	ld.hu %d2,[%a2]4
80005688:	c2 12       	add %d2,1
8000568a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000568e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005692:	f9 22 04 00 	st.h [%a2]4,%d2

        if (buffer->index >= buffer->length)
80005696:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000569a:	b9 23 04 00 	ld.hu %d3,[%a2]4
8000569e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800056a2:	b9 22 06 00 	ld.hu %d2,[%a2]6
800056a6:	3f 23 07 80 	jlt.u %d3,%d2,800056b4 <Ifx_CircularBuffer_read8+0x86>
        {
            buffer->index = 0;
800056aa:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800056ae:	82 02       	mov %d2,0
800056b0:	f9 22 04 00 	st.h [%a2]4,%d2
        }
    } while (count > 0);
800056b4:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
800056b8:	ff 12 c8 7f 	jge %d2,1,80005648 <Ifx_CircularBuffer_read8+0x1a>

    return Dest;
800056bc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
800056c0:	60 22       	mov.a %a2,%d2
800056c2:	00 90       	ret 

800056c4 <Ifx_CircularBuffer_write8>:
    return Dest;
}


const void *Ifx_CircularBuffer_write8(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
800056c4:	40 ae       	mov.aa %a14,%sp
800056c6:	20 18       	sub.a %sp,24
800056c8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
800056cc:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
800056d0:	02 42       	mov %d2,%d4
800056d2:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    const uint8 *source = (const uint8 *)data;
800056d6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800056da:	59 e2 fc ff 	st.w [%a14]-4,%d2

    do
    {
        count--;
800056de:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
800056e2:	37 02 70 20 	extr.u %d2,%d2,0,16
800056e6:	c2 f2       	add %d2,-1
800056e8:	37 02 70 20 	extr.u %d2,%d2,0,16
800056ec:	f9 e2 ec ff 	st.h [%a14]-20,%d2
        ((uint8 *)buffer->base)[buffer->index] = *source;
800056f0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800056f4:	54 23       	ld.w %d3,[%a2]
800056f6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800056fa:	b9 22 04 00 	ld.hu %d2,[%a2]4
800056fe:	60 32       	mov.a %a2,%d3
80005700:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80005704:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80005708:	14 32       	ld.bu %d2,[%a3]
8000570a:	34 22       	st.b [%a2],%d2
        source                                 = &source[1];
8000570c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80005710:	c2 12       	add %d2,1
80005712:	59 e2 fc ff 	st.w [%a14]-4,%d2
        buffer->index++;
80005716:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000571a:	b9 22 04 00 	ld.hu %d2,[%a2]4
8000571e:	c2 12       	add %d2,1
80005720:	37 02 70 20 	extr.u %d2,%d2,0,16
80005724:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005728:	f9 22 04 00 	st.h [%a2]4,%d2

        if (buffer->index >= buffer->length)
8000572c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005730:	b9 23 04 00 	ld.hu %d3,[%a2]4
80005734:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005738:	b9 22 06 00 	ld.hu %d2,[%a2]6
8000573c:	3f 23 07 80 	jlt.u %d3,%d2,8000574a <Ifx_CircularBuffer_write8+0x86>
        {
            buffer->index = 0;
80005740:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80005744:	82 02       	mov %d2,0
80005746:	f9 22 04 00 	st.h [%a2]4,%d2
        }
    } while (count > 0);
8000574a:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
8000574e:	ff 12 c8 7f 	jge %d2,1,800056de <Ifx_CircularBuffer_write8+0x1a>

    return source;
80005752:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
80005756:	60 22       	mov.a %a2,%d2
80005758:	00 90       	ret 

8000575a <Ifx_Fifo_create>:
 * This is valid is an OS is used.
 *
 */
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
8000575a:	40 ae       	mov.aa %a14,%sp
8000575c:	20 10       	sub.a %sp,16
8000575e:	02 42       	mov %d2,%d4
80005760:	02 53       	mov %d3,%d5
80005762:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
80005766:	02 32       	mov %d2,%d3
80005768:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
    Ifx_Fifo *fifo = NULL_PTR;
8000576c:	82 02       	mov %d2,0
8000576e:	59 e2 fc ff 	st.w [%a14]-4,%d2

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
80005772:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
80005776:	c2 32       	add %d2,3
80005778:	37 02 70 20 	extr.u %d2,%d2,0,16
8000577c:	37 02 50 20 	extr %d2,%d2,0,16
80005780:	8f 32 c0 21 	andn %d2,%d2,3
80005784:	f9 e2 f4 ff 	st.h [%a14]-12,%d2

    fifo = malloc(size + sizeof(Ifx_Fifo) + 8); /* +8 because of padding in case the pointer is not aligned on 64 */
80005788:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12
8000578c:	1b 82 02 20 	addi %d2,%d2,40
80005790:	02 24       	mov %d4,%d2
80005792:	6d 01 84 12 	call 80027c9a <malloc>
80005796:	80 22       	mov.d %d2,%a2
80005798:	59 e2 fc ff 	st.w [%a14]-4,%d2

    if (IFX_VALIDATE(IFX_VERBOSE_LEVEL_ERROR, (fifo != NULL_PTR)))
8000579c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800057a0:	df 02 0e 00 	jeq %d2,0,800057bc <Ifx_Fifo_create+0x62>
    {
        fifo = Ifx_Fifo_init(fifo, size, elementSize);
800057a4:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12
800057a8:	c9 e3 f0 ff 	ld.h %d3,[%a14]-16
800057ac:	02 35       	mov %d5,%d3
800057ae:	02 24       	mov %d4,%d2
800057b0:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800057b4:	6d 00 08 00 	call 800057c4 <Ifx_Fifo_init>
800057b8:	b5 e2 fc ff 	st.a [%a14]-4,%a2
    }

    return fifo;
800057bc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
800057c0:	60 22       	mov.a %a2,%d2
800057c2:	00 90       	ret 

800057c4 <Ifx_Fifo_init>:
    free(fifo);
}


Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
800057c4:	40 ae       	mov.aa %a14,%sp
800057c6:	20 18       	sub.a %sp,24
800057c8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
800057cc:	02 42       	mov %d2,%d4
800057ce:	02 53       	mov %d3,%d5
800057d0:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
800057d4:	02 32       	mov %d2,%d3
800057d6:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    Ifx_Fifo *fifo = NULL_PTR;
800057da:	82 02       	mov %d2,0
800057dc:	59 e2 fc ff 	st.w [%a14]-4,%d2

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
800057e0:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
800057e4:	c2 32       	add %d2,3
800057e6:	37 02 70 20 	extr.u %d2,%d2,0,16
800057ea:	37 02 50 20 	extr %d2,%d2,0,16
800057ee:	8f 32 c0 21 	andn %d2,%d2,3
800057f2:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, elementSize <= size);
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
800057f6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800057fa:	59 e2 fc ff 	st.w [%a14]-4,%d2
        fifo->eventReader        = FALSE;
800057fe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005802:	82 02       	mov %d2,0
80005804:	e9 22 1c 00 	st.b [%a2]28,%d2
        fifo->eventWriter        = TRUE;
80005808:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000580c:	82 12       	mov %d2,1
8000580e:	e9 22 1d 00 	st.b [%a2]29,%d2
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
80005812:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80005816:	1b 72 02 20 	addi %d2,%d2,39
8000581a:	8f 72 c0 21 	andn %d2,%d2,7
8000581e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005822:	74 22       	st.w [%a2],%d2
        fifo->shared.count       = 0;
80005824:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005828:	82 02       	mov %d2,0
8000582a:	f9 22 04 00 	st.h [%a2]4,%d2
        fifo->shared.maxcount    = 0;
8000582e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005832:	82 02       	mov %d2,0
80005834:	f9 22 10 00 	st.h [%a2]16,%d2
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
80005838:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000583c:	82 02       	mov %d2,0
8000583e:	d9 22 0c 00 	lea %a2,[%a2]12
80005842:	74 22       	st.w [%a2],%d2
80005844:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005848:	d9 22 0c 00 	lea %a2,[%a2]12
8000584c:	54 22       	ld.w %d2,[%a2]
8000584e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005852:	d9 22 08 00 	lea %a2,[%a2]8
80005856:	74 22       	st.w [%a2],%d2
        fifo->startIndex         = fifo->endIndex = 0;
80005858:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000585c:	82 02       	mov %d2,0
8000585e:	f9 22 16 00 	st.h [%a2]22,%d2
80005862:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005866:	c9 22 16 00 	ld.h %d2,[%a2]22
8000586a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000586e:	f9 22 14 00 	st.h [%a2]20,%d2
        fifo->size               = size;
80005872:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005876:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
8000587a:	f9 22 18 00 	st.h [%a2]24,%d2
        fifo->elementSize        = elementSize;
8000587e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80005882:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
80005886:	f9 22 1a 00 	st.h [%a2]26,%d2
    }

    return fifo;
8000588a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8000588e:	60 22       	mov.a %a2,%d2
80005890:	00 90       	ret 

80005892 <Ifx_Fifo_beginRead>:

/**
 * param: count in bytes
 */
static Ifx_SizeT Ifx_Fifo_beginRead(Ifx_Fifo *fifo, Ifx_SizeT count)
{
80005892:	40 ae       	mov.aa %a14,%sp
80005894:	20 38       	sub.a %sp,56
80005896:	b5 e4 cc ff 	st.a [%a14]-52,%a4
8000589a:	02 42       	mov %d2,%d4
8000589c:	f9 e2 c8 ff 	st.h [%a14]-56,%d2
    reg.U = __mfcr(CPU_ICR);
800058a0:	4d c0 e2 2f 	mfcr %d2,$icr
800058a4:	59 e2 d8 ff 	st.w [%a14]-40,%d2
800058a8:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
800058ac:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    return reg.B.IE != 0;
800058b0:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
800058b4:	37 02 e1 27 	extr.u %d2,%d2,15,1
800058b8:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
800058bc:	e9 e2 d7 ff 	st.b [%a14]-41,%d2
    __disable();
800058c0:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
800058c4:	00 00       	nop 
    return enabled;
800058c6:	39 e2 d7 ff 	ld.bu %d2,[%a14]-41
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
800058ca:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
800058ce:	c9 e2 c8 ff 	ld.h %d2,[%a14]-56
800058d2:	19 e3 cc ff 	ld.w %d3,[%a14]-52
800058d6:	59 e3 dc ff 	st.w [%a14]-36,%d3
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
800058da:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800058de:	c9 23 04 00 	ld.h %d3,[%a2]4
800058e2:	59 e2 e8 ff 	st.w [%a14]-24,%d2
800058e6:	59 e3 e4 ff 	st.w [%a14]-28,%d3
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800058ea:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800058ee:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
800058f2:	0b 32 80 21 	min %d2,%d2,%d3
800058f6:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    return res;
800058fa:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800058fe:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    blockSize               -= blockSize % fifo->elementSize;
80005902:	b9 e4 fc ff 	ld.hu %d4,[%a14]-4
80005906:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
8000590a:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000590e:	c9 23 1a 00 	ld.h %d3,[%a2]26
80005912:	4b 32 01 22 	div %e2,%d2,%d3
80005916:	02 32       	mov %d2,%d3
80005918:	37 02 70 20 	extr.u %d2,%d2,0,16
8000591c:	0b 24 80 20 	sub %d2,%d4,%d2
80005920:	37 02 70 20 	extr.u %d2,%d2,0,16
80005924:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    fifo->eventReader        = FALSE;
80005928:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000592c:	82 02       	mov %d2,0
8000592e:	e9 22 1c 00 	st.b [%a2]28,%d2
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
80005932:	c9 e3 c8 ff 	ld.h %d3,[%a14]-56
80005936:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
8000593a:	a2 23       	sub %d3,%d2
8000593c:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80005940:	c9 22 18 00 	ld.h %d2,[%a2]24
80005944:	59 e3 f4 ff 	st.w [%a14]-12,%d3
80005948:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000594c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80005950:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
80005954:	0b 32 80 21 	min %d2,%d2,%d3
80005958:	59 e2 ec ff 	st.w [%a14]-20,%d2
    return res;
8000595c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80005960:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80005964:	d9 22 08 00 	lea %a2,[%a2]8
80005968:	74 22       	st.w [%a2],%d2
    IfxCpu_restoreInterrupts(interruptState);
8000596a:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8000596e:	e9 e2 fb ff 	st.b [%a14]-5,%d2
    if (enabled != FALSE)
80005972:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80005976:	df 02 04 00 	jeq %d2,0,8000597e <Ifx_Fifo_beginRead+0xec>
        __enable();
8000597a:	0d 00 00 03 	enable 

    return blockSize;
8000597e:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
}
80005982:	00 90       	ret 

80005984 <Ifx_Fifo_readEnd>:

/**
 * param: count in bytes
 */
static Ifx_SizeT Ifx_Fifo_readEnd(Ifx_Fifo *fifo, Ifx_SizeT count, Ifx_SizeT blockSize)
{
80005984:	40 ae       	mov.aa %a14,%sp
80005986:	20 20       	sub.a %sp,32
80005988:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000598c:	02 42       	mov %d2,%d4
8000598e:	02 53       	mov %d3,%d5
80005990:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
80005994:	02 32       	mov %d2,%d3
80005996:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
    reg.U = __mfcr(CPU_ICR);
8000599a:	4d c0 e2 2f 	mfcr %d2,$icr
8000599e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800059a2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800059a6:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return reg.B.IE != 0;
800059aa:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800059ae:	37 02 e1 27 	extr.u %d2,%d2,15,1
800059b2:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
800059b6:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
    __disable();
800059ba:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
800059be:	00 00       	nop 
    return enabled;
800059c0:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
    boolean interruptState;

    /* Set the shared values */
    interruptState      = IfxCpu_disableInterrupts();
800059c4:	e9 e2 ff ff 	st.b [%a14]-1,%d2

    fifo->shared.count -= blockSize;
800059c8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800059cc:	c9 22 04 00 	ld.h %d2,[%a2]4
800059d0:	37 02 70 30 	extr.u %d3,%d2,0,16
800059d4:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
800059d8:	0b 23 80 20 	sub %d2,%d3,%d2
800059dc:	37 02 70 20 	extr.u %d2,%d2,0,16
800059e0:	37 02 50 20 	extr %d2,%d2,0,16
800059e4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800059e8:	f9 22 04 00 	st.h [%a2]4,%d2

    if (fifo->shared.writerWaitx != 0)
800059ec:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800059f0:	d9 22 0c 00 	lea %a2,[%a2]12
800059f4:	54 22       	ld.w %d2,[%a2]
800059f6:	df 02 22 00 	jeq %d2,0,80005a3a <Ifx_Fifo_readEnd+0xb6>
    {
        fifo->shared.writerWaitx -= blockSize;
800059fa:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800059fe:	d9 22 0c 00 	lea %a2,[%a2]12
80005a02:	54 23       	ld.w %d3,[%a2]
80005a04:	c9 e2 e4 ff 	ld.h %d2,[%a14]-28
80005a08:	0b 23 80 20 	sub %d2,%d3,%d2
80005a0c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80005a10:	d9 22 0c 00 	lea %a2,[%a2]12
80005a14:	74 22       	st.w [%a2],%d2

        if (fifo->shared.writerWaitx <= 0)
80005a16:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80005a1a:	d9 22 0c 00 	lea %a2,[%a2]12
80005a1e:	54 22       	ld.w %d2,[%a2]
80005a20:	ff 12 0d 00 	jge %d2,1,80005a3a <Ifx_Fifo_readEnd+0xb6>
        {
            fifo->shared.writerWaitx = 0;
80005a24:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80005a28:	82 02       	mov %d2,0
80005a2a:	d9 22 0c 00 	lea %a2,[%a2]12
80005a2e:	74 22       	st.w [%a2],%d2
            fifo->eventWriter        = TRUE; /* Signal the writer */
80005a30:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80005a34:	82 12       	mov %d2,1
80005a36:	e9 22 1d 00 	st.b [%a2]29,%d2
        }
    }

    IfxCpu_restoreInterrupts(interruptState);
80005a3a:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80005a3e:	e9 e2 f6 ff 	st.b [%a14]-10,%d2
    if (enabled != FALSE)
80005a42:	39 e2 f6 ff 	ld.bu %d2,[%a14]-10
80005a46:	df 02 04 00 	jeq %d2,0,80005a4e <Ifx_Fifo_readEnd+0xca>
        __enable();
80005a4a:	0d 00 00 03 	enable 

    return count - blockSize;
80005a4e:	b9 e3 e8 ff 	ld.hu %d3,[%a14]-24
80005a52:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
80005a56:	0b 23 80 20 	sub %d2,%d3,%d2
80005a5a:	37 02 70 20 	extr.u %d2,%d2,0,16
80005a5e:	37 02 50 20 	extr %d2,%d2,0,16
}
80005a62:	00 90       	ret 

80005a64 <Ifx_Fifo_read>:


Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
80005a64:	40 ae       	mov.aa %a14,%sp
80005a66:	20 d8       	sub.a %sp,216
80005a68:	b5 e4 cc df 	st.a [%a14]-180,%a4
80005a6c:	b5 e5 c8 df 	st.a [%a14]-184,%a5
80005a70:	89 e6 7c c9 	st.d [%a14]-196,%e6
80005a74:	f9 e4 c4 df 	st.h [%a14]-188,%d4
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
80005a78:	82 04       	mov %d4,0
80005a7a:	e9 e4 ff ff 	st.b [%a14]-1,%d4

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
80005a7e:	c9 e4 c4 df 	ld.h %d4,[%a14]-188
80005a82:	df 04 dd 01 	jeq %d4,0,80005e3c <Ifx_Fifo_read+0x3d8>
    {
        buffer.base   = fifo->buffer;
80005a86:	99 e2 cc df 	ld.a %a2,[%a14]-180
80005a8a:	54 24       	ld.w %d4,[%a2]
80005a8c:	59 e4 e0 df 	st.w [%a14]-160,%d4
        buffer.length = (uint16)fifo->size;         /* size always fit into 16 bit */
80005a90:	99 e2 cc df 	ld.a %a2,[%a14]-180
80005a94:	c9 24 18 00 	ld.h %d4,[%a2]24
80005a98:	37 04 70 40 	extr.u %d4,%d4,0,16
80005a9c:	f9 e4 e6 df 	st.h [%a14]-154,%d4
        buffer.index  = (uint16)fifo->startIndex;   /* startIndex always fit into size */
80005aa0:	99 e2 cc df 	ld.a %a2,[%a14]-180
80005aa4:	c9 24 14 00 	ld.h %d4,[%a2]20
80005aa8:	37 04 70 40 	extr.u %d4,%d4,0,16
80005aac:	f9 e4 e4 df 	st.h [%a14]-156,%d4
80005ab0:	09 e2 fc c9 	ld.da %a2,[%a14]-196
80005ab4:	89 e2 e8 f9 	st.da [%a14]-24,%a2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80005ab8:	09 e4 68 f9 	ld.d %e4,[%a14]-24
80005abc:	82 f6       	mov %d6,-1
80005abe:	06 f6       	sh %d6,-1
80005ac0:	0b 65 10 61 	ne %d6,%d5,%d6
80005ac4:	8b f4 1f 65 	or.ne %d6,%d4,-1
80005ac8:	df 06 0b 80 	jne %d6,0,80005ade <Ifx_Fifo_read+0x7a>
    {
        deadLine = TIME_INFINITE;
80005acc:	a0 02       	mov.a %a2,0
80005ace:	b0 f2       	add.a %a2,-1
80005ad0:	c5 83 00 00 	lea %a3,80000000 <LCF_STARTPTR_CPU0>
80005ad4:	b0 f3       	add.a %a3,-1
80005ad6:	89 e2 e0 f9 	st.da [%a14]-32,%a2
80005ada:	1d 00 63 00 	j 80005ba0 <Ifx_Fifo_read+0x13c>
    reg.U = __mfcr(CPU_ICR);
80005ade:	4d c0 e2 4f 	mfcr %d4,$icr
80005ae2:	59 e4 dc ff 	st.w [%a14]-36,%d4
80005ae6:	19 e4 dc ff 	ld.w %d4,[%a14]-36
80005aea:	59 e4 d4 df 	st.w [%a14]-172,%d4
    return reg.B.IE != 0;
80005aee:	19 e4 d4 df 	ld.w %d4,[%a14]-172
80005af2:	37 04 e1 47 	extr.u %d4,%d4,15,1
80005af6:	8f f4 0f 41 	and %d4,%d4,255
    enabled = IfxCpu_areInterruptsEnabled();
80005afa:	e9 e4 db ff 	st.b [%a14]-37,%d4
    __disable();
80005afe:	0d 00 40 03 	disable 
80005b02:	00 00       	nop 
    return enabled;
80005b04:	39 e4 db ff 	ld.bu %d4,[%a14]-37
    interruptState = IfxCpu_disableInterrupts();
80005b08:	e9 e4 da ff 	st.b [%a14]-38,%d4
80005b0c:	7b 00 00 4f 	movh %d4,61440
80005b10:	1b 04 00 41 	addi %d4,%d4,4096
80005b14:	59 e4 d4 ff 	st.w [%a14]-44,%d4
    result  = stm->TIM0.U;
80005b18:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80005b1c:	d9 22 10 00 	lea %a2,[%a2]16
80005b20:	54 24       	ld.w %d4,[%a2]
80005b22:	02 44       	mov %d4,%d4
80005b24:	82 05       	mov %d5,0
80005b26:	89 e4 4c f9 	st.d [%a14]-52,%e4
    result |= ((uint64)stm->CAP.U) << 32;
80005b2a:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80005b2e:	d9 22 2c 00 	lea %a2,[%a2]44
80005b32:	54 24       	ld.w %d4,[%a2]
80005b34:	02 44       	mov %d4,%d4
80005b36:	82 05       	mov %d5,0
80005b38:	59 e4 f8 cf 	st.w [%a14]-200,%d4
80005b3c:	82 04       	mov %d4,0
80005b3e:	59 e4 f4 cf 	st.w [%a14]-204,%d4
80005b42:	19 e4 cc ff 	ld.w %d4,[%a14]-52
80005b46:	09 e6 74 c9 	ld.d %e6,[%a14]-204
80005b4a:	02 65       	mov %d5,%d6
80005b4c:	0f 54 a0 20 	or %d2,%d4,%d5
80005b50:	19 e4 d0 ff 	ld.w %d4,[%a14]-48
80005b54:	02 75       	mov %d5,%d7
80005b56:	a6 45       	or %d5,%d4
80005b58:	02 53       	mov %d3,%d5
80005b5a:	89 e2 4c f9 	st.d [%a14]-52,%e2
    return result;
80005b5e:	09 e2 cc f9 	ld.da %a2,[%a14]-52
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005b62:	80 22       	mov.d %d2,%a2
80005b64:	80 33       	mov.d %d3,%a3
80005b66:	02 24       	mov %d4,%d2
80005b68:	59 e4 c4 ff 	st.w [%a14]-60,%d4
80005b6c:	82 f4       	mov %d4,-1
80005b6e:	06 f4       	sh %d4,-1
80005b70:	0f 43 80 20 	and %d2,%d3,%d4
80005b74:	59 e2 c8 ff 	st.w [%a14]-56,%d2
    IfxCpu_restoreInterrupts(interruptState);
80005b78:	39 e2 da ff 	ld.bu %d2,[%a14]-38
80005b7c:	e9 e2 c3 ff 	st.b [%a14]-61,%d2
    if (enabled != FALSE)
80005b80:	39 e2 c3 ff 	ld.bu %d2,[%a14]-61
80005b84:	df 02 04 00 	jeq %d2,0,80005b8c <Ifx_Fifo_read+0x128>
        __enable();
80005b88:	0d 00 00 03 	enable 
    return stmNow;
80005b8c:	09 e4 44 f9 	ld.d %e4,[%a14]-60
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80005b90:	09 e2 68 f9 	ld.d %e2,[%a14]-24
80005b94:	0b 42 40 00 	addx %d0,%d2,%d4
80005b98:	0b 53 50 10 	addc %d1,%d3,%d5
80005b9c:	89 e0 60 f9 	st.d [%a14]-32,%e0
    }

    return deadLine;
80005ba0:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
        DeadLine      = IfxStm_getDeadLine(timeout);
80005ba4:	89 e2 f4 f9 	st.da [%a14]-12,%a2

        do
        {
            blockSize = Ifx_Fifo_beginRead(fifo, count);
80005ba8:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
80005bac:	02 24       	mov %d4,%d2
80005bae:	99 e4 cc df 	ld.a %a4,[%a14]-180
80005bb2:	6d ff 70 fe 	call 80005892 <Ifx_Fifo_beginRead>
80005bb6:	f9 e2 f2 ff 	st.h [%a14]-14,%d2

            if (blockSize != 0)
80005bba:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80005bbe:	df 02 1a 00 	jeq %d2,0,80005bf2 <Ifx_Fifo_read+0x18e>
            {
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
80005bc2:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80005bc6:	d9 e2 e0 df 	lea %a2,[%a14]-160
80005bca:	02 24       	mov %d4,%d2
80005bcc:	99 e5 c8 df 	ld.a %a5,[%a14]-184
80005bd0:	40 24       	mov.aa %a4,%a2
80005bd2:	6d ff 2e fd 	call 8000562e <Ifx_CircularBuffer_read8>
80005bd6:	b5 e2 c8 df 	st.a [%a14]-184,%a2
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
80005bda:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
80005bde:	c9 e3 f2 ff 	ld.h %d3,[%a14]-14
80005be2:	02 35       	mov %d5,%d3
80005be4:	02 24       	mov %d4,%d2
80005be6:	99 e4 cc df 	ld.a %a4,[%a14]-180
80005bea:	6d ff cd fe 	call 80005984 <Ifx_Fifo_readEnd>
80005bee:	f9 e2 c4 df 	st.h [%a14]-188,%d2
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80005bf2:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80005bf6:	df 02 7b 80 	jne %d2,0,80005cec <Ifx_Fifo_read+0x288>
80005bfa:	09 e2 f4 f9 	ld.da %a2,[%a14]-12
80005bfe:	89 e2 f8 e9 	st.da [%a14]-72,%a2

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80005c02:	09 e2 78 e9 	ld.d %e2,[%a14]-72
80005c06:	82 f4       	mov %d4,-1
80005c08:	06 f4       	sh %d4,-1
80005c0a:	0b 43 10 41 	ne %d4,%d3,%d4
80005c0e:	8b f2 1f 45 	or.ne %d4,%d2,-1
80005c12:	df 04 07 80 	jne %d4,0,80005c20 <Ifx_Fifo_read+0x1bc>
    {
        result = FALSE;
80005c16:	82 02       	mov %d2,0
80005c18:	e9 e2 f7 ef 	st.b [%a14]-73,%d2
80005c1c:	1d 00 64 00 	j 80005ce4 <Ifx_Fifo_read+0x280>
    reg.U = __mfcr(CPU_ICR);
80005c20:	4d c0 e2 2f 	mfcr %d2,$icr
80005c24:	59 e2 f0 ef 	st.w [%a14]-80,%d2
80005c28:	19 e2 f0 ef 	ld.w %d2,[%a14]-80
80005c2c:	59 e2 d8 df 	st.w [%a14]-168,%d2
    return reg.B.IE != 0;
80005c30:	19 e2 d8 df 	ld.w %d2,[%a14]-168
80005c34:	37 02 e1 27 	extr.u %d2,%d2,15,1
80005c38:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
80005c3c:	e9 e2 ef ef 	st.b [%a14]-81,%d2
    __disable();
80005c40:	0d 00 40 03 	disable 
80005c44:	00 00       	nop 
    return enabled;
80005c46:	39 e2 ef ef 	ld.bu %d2,[%a14]-81
    interruptState = IfxCpu_disableInterrupts();
80005c4a:	e9 e2 ee ef 	st.b [%a14]-82,%d2
80005c4e:	7b 00 00 2f 	movh %d2,61440
80005c52:	1b 02 00 21 	addi %d2,%d2,4096
80005c56:	59 e2 e8 ef 	st.w [%a14]-88,%d2
    result  = stm->TIM0.U;
80005c5a:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
80005c5e:	d9 22 10 00 	lea %a2,[%a2]16
80005c62:	54 22       	ld.w %d2,[%a2]
80005c64:	02 22       	mov %d2,%d2
80005c66:	82 03       	mov %d3,0
80005c68:	89 e2 60 e9 	st.d [%a14]-96,%e2
    result |= ((uint64)stm->CAP.U) << 32;
80005c6c:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
80005c70:	d9 22 2c 00 	lea %a2,[%a2]44
80005c74:	54 22       	ld.w %d2,[%a2]
80005c76:	02 22       	mov %d2,%d2
80005c78:	82 03       	mov %d3,0
80005c7a:	02 2d       	mov %d13,%d2
80005c7c:	82 0c       	mov %d12,0
80005c7e:	19 e2 e0 ef 	ld.w %d2,[%a14]-96
80005c82:	0f c2 a0 80 	or %d8,%d2,%d12
80005c86:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
80005c8a:	0f d2 a0 90 	or %d9,%d2,%d13
80005c8e:	89 e8 60 e9 	st.d [%a14]-96,%e8
    return result;
80005c92:	09 e2 e0 e9 	ld.da %a2,[%a14]-96
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005c96:	80 22       	mov.d %d2,%a2
80005c98:	80 33       	mov.d %d3,%a3
80005c9a:	02 24       	mov %d4,%d2
80005c9c:	59 e4 d8 ef 	st.w [%a14]-104,%d4
80005ca0:	82 f4       	mov %d4,-1
80005ca2:	06 f4       	sh %d4,-1
80005ca4:	0f 43 80 20 	and %d2,%d3,%d4
80005ca8:	59 e2 dc ef 	st.w [%a14]-100,%d2
    IfxCpu_restoreInterrupts(interruptState);
80005cac:	39 e2 ee ef 	ld.bu %d2,[%a14]-82
80005cb0:	e9 e2 d7 ef 	st.b [%a14]-105,%d2
    if (enabled != FALSE)
80005cb4:	39 e2 d7 ef 	ld.bu %d2,[%a14]-105
80005cb8:	df 02 04 00 	jeq %d2,0,80005cc0 <Ifx_Fifo_read+0x25c>
        __enable();
80005cbc:	0d 00 00 03 	enable 
    return stmNow;
80005cc0:	09 e6 58 e9 	ld.d %e6,[%a14]-104
    }
    else
    {
        result = IfxStm_now() >= deadLine;
80005cc4:	09 e2 78 e9 	ld.d %e2,[%a14]-72
80005cc8:	02 74       	mov %d4,%d7
80005cca:	0b 43 00 41 	eq %d4,%d3,%d4
80005cce:	02 25       	mov %d5,%d2
80005cd0:	0b 56 50 42 	and.ge.u %d4,%d6,%d5
80005cd4:	02 75       	mov %d5,%d7
80005cd6:	0b 53 90 42 	or.lt %d4,%d3,%d5
80005cda:	02 42       	mov %d2,%d4
80005cdc:	8f f2 0f 21 	and %d2,%d2,255
80005ce0:	e9 e2 f7 ef 	st.b [%a14]-73,%d2
    }

    return result;
80005ce4:	39 e2 f7 ef 	ld.bu %d2,[%a14]-73
80005ce8:	df 02 0a 00 	jeq %d2,0,80005cfc <Ifx_Fifo_read+0x298>
            {
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
80005cec:	99 e2 cc df 	ld.a %a2,[%a14]-180
80005cf0:	82 02       	mov %d2,0
80005cf2:	d9 22 08 00 	lea %a2,[%a2]8
80005cf6:	74 22       	st.w [%a2],%d2
                break;
80005cf8:	1d 00 9a 00 	j 80005e2c <Ifx_Fifo_read+0x3c8>
            }

            if (count != 0)
80005cfc:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
80005d00:	df 02 92 00 	jeq %d2,0,80005e24 <Ifx_Fifo_read+0x3c0>
            {
                while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80005d04:	99 e2 cc df 	ld.a %a2,[%a14]-180
80005d08:	39 22 1c 00 	ld.bu %d2,[%a2]28
80005d0c:	df 02 82 80 	jne %d2,0,80005e10 <Ifx_Fifo_read+0x3ac>
80005d10:	09 e2 f4 f9 	ld.da %a2,[%a14]-12
80005d14:	89 e2 cc e9 	st.da [%a14]-116,%a2
    if (deadLine == TIME_INFINITE)
80005d18:	09 e2 4c e9 	ld.d %e2,[%a14]-116
80005d1c:	82 f4       	mov %d4,-1
80005d1e:	06 f4       	sh %d4,-1
80005d20:	0b 43 10 41 	ne %d4,%d3,%d4
80005d24:	8b f2 1f 45 	or.ne %d4,%d2,-1
80005d28:	df 04 07 80 	jne %d4,0,80005d36 <Ifx_Fifo_read+0x2d2>
        result = FALSE;
80005d2c:	82 02       	mov %d2,0
80005d2e:	e9 e2 cb ef 	st.b [%a14]-117,%d2
80005d32:	1d 00 6b 00 	j 80005e08 <Ifx_Fifo_read+0x3a4>
    reg.U = __mfcr(CPU_ICR);
80005d36:	4d c0 e2 2f 	mfcr %d2,$icr
80005d3a:	59 e2 c4 ef 	st.w [%a14]-124,%d2
80005d3e:	19 e2 c4 ef 	ld.w %d2,[%a14]-124
80005d42:	59 e2 dc df 	st.w [%a14]-164,%d2
    return reg.B.IE != 0;
80005d46:	19 e2 dc df 	ld.w %d2,[%a14]-164
80005d4a:	37 02 e1 27 	extr.u %d2,%d2,15,1
80005d4e:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
80005d52:	e9 e2 c3 ef 	st.b [%a14]-125,%d2
    __disable();
80005d56:	0d 00 40 03 	disable 
80005d5a:	00 00       	nop 
    return enabled;
80005d5c:	39 e2 c3 ef 	ld.bu %d2,[%a14]-125
    interruptState = IfxCpu_disableInterrupts();
80005d60:	e9 e2 c2 ef 	st.b [%a14]-126,%d2
80005d64:	7b 00 00 2f 	movh %d2,61440
80005d68:	1b 02 00 21 	addi %d2,%d2,4096
80005d6c:	59 e2 fc df 	st.w [%a14]-132,%d2
    result  = stm->TIM0.U;
80005d70:	99 e2 fc df 	ld.a %a2,[%a14]-132
80005d74:	d9 22 10 00 	lea %a2,[%a2]16
80005d78:	54 22       	ld.w %d2,[%a2]
80005d7a:	02 22       	mov %d2,%d2
80005d7c:	82 03       	mov %d3,0
80005d7e:	89 e2 74 d9 	st.d [%a14]-140,%e2
    result |= ((uint64)stm->CAP.U) << 32;
80005d82:	99 e2 fc df 	ld.a %a2,[%a14]-132
80005d86:	d9 22 2c 00 	lea %a2,[%a2]44
80005d8a:	54 22       	ld.w %d2,[%a2]
80005d8c:	02 22       	mov %d2,%d2
80005d8e:	82 03       	mov %d3,0
80005d90:	59 e2 f0 cf 	st.w [%a14]-208,%d2
80005d94:	82 02       	mov %d2,0
80005d96:	59 e2 ec cf 	st.w [%a14]-212,%d2
80005d9a:	19 e2 f4 df 	ld.w %d2,[%a14]-140
80005d9e:	09 e4 6c c9 	ld.d %e4,[%a14]-212
80005da2:	02 43       	mov %d3,%d4
80005da4:	0f 32 a0 a0 	or %d10,%d2,%d3
80005da8:	19 e2 f8 df 	ld.w %d2,[%a14]-136
80005dac:	02 53       	mov %d3,%d5
80005dae:	0f 32 a0 b0 	or %d11,%d2,%d3
80005db2:	89 ea 74 d9 	st.d [%a14]-140,%e10
    return result;
80005db6:	09 e2 f4 d9 	ld.da %a2,[%a14]-140
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005dba:	80 22       	mov.d %d2,%a2
80005dbc:	80 33       	mov.d %d3,%a3
80005dbe:	02 24       	mov %d4,%d2
80005dc0:	59 e4 ec df 	st.w [%a14]-148,%d4
80005dc4:	82 f4       	mov %d4,-1
80005dc6:	06 f4       	sh %d4,-1
80005dc8:	0f 43 80 20 	and %d2,%d3,%d4
80005dcc:	59 e2 f0 df 	st.w [%a14]-144,%d2
    IfxCpu_restoreInterrupts(interruptState);
80005dd0:	39 e2 c2 ef 	ld.bu %d2,[%a14]-126
80005dd4:	e9 e2 eb df 	st.b [%a14]-149,%d2
    if (enabled != FALSE)
80005dd8:	39 e2 eb df 	ld.bu %d2,[%a14]-149
80005ddc:	df 02 04 00 	jeq %d2,0,80005de4 <Ifx_Fifo_read+0x380>
        __enable();
80005de0:	0d 00 00 03 	enable 
    return stmNow;
80005de4:	09 e6 6c d9 	ld.d %e6,[%a14]-148
        result = IfxStm_now() >= deadLine;
80005de8:	09 e2 4c e9 	ld.d %e2,[%a14]-116
80005dec:	02 74       	mov %d4,%d7
80005dee:	0b 43 00 41 	eq %d4,%d3,%d4
80005df2:	02 25       	mov %d5,%d2
80005df4:	0b 56 50 42 	and.ge.u %d4,%d6,%d5
80005df8:	02 75       	mov %d5,%d7
80005dfa:	0b 53 90 42 	or.lt %d4,%d3,%d5
80005dfe:	02 42       	mov %d2,%d4
80005e00:	8f f2 0f 21 	and %d2,%d2,255
80005e04:	e9 e2 cb ef 	st.b [%a14]-117,%d2
    return result;
80005e08:	39 e2 cb ef 	ld.bu %d2,[%a14]-117
80005e0c:	df 02 7c 7f 	jeq %d2,0,80005d04 <Ifx_Fifo_read+0x2a0>
                {}

                Stop = (fifo->eventReader == FALSE);    /* If the function timeout, the maximum number of characters are read before returning */
80005e10:	99 e2 cc df 	ld.a %a2,[%a14]-180
80005e14:	39 22 1c 00 	ld.bu %d2,[%a2]28
80005e18:	8b 02 00 22 	eq %d2,%d2,0
80005e1c:	8f f2 0f 21 	and %d2,%d2,255
80005e20:	e9 e2 ff ff 	st.b [%a14]-1,%d2
            }
        } while (count != 0);
80005e24:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
80005e28:	df 02 c0 fe 	jne %d2,0,80005ba8 <Ifx_Fifo_read+0x144>

        fifo->startIndex = buffer.index;
80005e2c:	b9 e2 e4 df 	ld.hu %d2,[%a14]-156
80005e30:	37 02 50 20 	extr %d2,%d2,0,16
80005e34:	99 e2 cc df 	ld.a %a2,[%a14]-180
80005e38:	f9 22 14 00 	st.h [%a2]20,%d2
    }

    return count;
80005e3c:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
}
80005e40:	00 90       	ret 

80005e42 <Ifx_Fifo_beginWrite>:
    IfxCpu_restoreInterrupts(interruptState);
}


static Ifx_SizeT Ifx_Fifo_beginWrite(Ifx_Fifo *fifo, Ifx_SizeT count)
{
80005e42:	40 ae       	mov.aa %a14,%sp
80005e44:	20 38       	sub.a %sp,56
80005e46:	b5 e4 cc ff 	st.a [%a14]-52,%a4
80005e4a:	02 42       	mov %d2,%d4
80005e4c:	f9 e2 c8 ff 	st.h [%a14]-56,%d2
    reg.U = __mfcr(CPU_ICR);
80005e50:	4d c0 e2 2f 	mfcr %d2,$icr
80005e54:	59 e2 d8 ff 	st.w [%a14]-40,%d2
80005e58:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80005e5c:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    return reg.B.IE != 0;
80005e60:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
80005e64:	37 02 e1 27 	extr.u %d2,%d2,15,1
80005e68:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
80005e6c:	e9 e2 d7 ff 	st.b [%a14]-41,%d2
    __disable();
80005e70:	0d 00 40 03 	disable 
80005e74:	00 00       	nop 
    return enabled;
80005e76:	39 e2 d7 ff 	ld.bu %d2,[%a14]-41
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
80005e7a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
80005e7e:	c9 e2 c8 ff 	ld.h %d2,[%a14]-56
80005e82:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80005e86:	c9 23 18 00 	ld.h %d3,[%a2]24
80005e8a:	02 34       	mov %d4,%d3
80005e8c:	19 e3 cc ff 	ld.w %d3,[%a14]-52
80005e90:	59 e3 dc ff 	st.w [%a14]-36,%d3
80005e94:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005e98:	c9 23 04 00 	ld.h %d3,[%a2]4
80005e9c:	0b 34 80 30 	sub %d3,%d4,%d3
80005ea0:	59 e2 e8 ff 	st.w [%a14]-24,%d2
80005ea4:	59 e3 e4 ff 	st.w [%a14]-28,%d3
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80005ea8:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80005eac:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
80005eb0:	0b 32 80 21 	min %d2,%d2,%d3
80005eb4:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    return res;
80005eb8:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80005ebc:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    blockSize               -= blockSize % fifo->elementSize;
80005ec0:	b9 e4 fc ff 	ld.hu %d4,[%a14]-4
80005ec4:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80005ec8:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80005ecc:	c9 23 1a 00 	ld.h %d3,[%a2]26
80005ed0:	4b 32 01 22 	div %e2,%d2,%d3
80005ed4:	02 32       	mov %d2,%d3
80005ed6:	37 02 70 20 	extr.u %d2,%d2,0,16
80005eda:	0b 24 80 20 	sub %d2,%d4,%d2
80005ede:	37 02 70 20 	extr.u %d2,%d2,0,16
80005ee2:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    fifo->eventWriter        = FALSE;
80005ee6:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80005eea:	82 02       	mov %d2,0
80005eec:	e9 22 1d 00 	st.b [%a2]29,%d2
    fifo->shared.writerWaitx = __min(count - blockSize, fifo->size);
80005ef0:	c9 e3 c8 ff 	ld.h %d3,[%a14]-56
80005ef4:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80005ef8:	a2 23       	sub %d3,%d2
80005efa:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80005efe:	c9 22 18 00 	ld.h %d2,[%a2]24
80005f02:	59 e3 f4 ff 	st.w [%a14]-12,%d3
80005f06:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80005f0a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80005f0e:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
80005f12:	0b 32 80 21 	min %d2,%d2,%d3
80005f16:	59 e2 ec ff 	st.w [%a14]-20,%d2
    return res;
80005f1a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80005f1e:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80005f22:	d9 22 0c 00 	lea %a2,[%a2]12
80005f26:	74 22       	st.w [%a2],%d2
    IfxCpu_restoreInterrupts(interruptState);
80005f28:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80005f2c:	e9 e2 fb ff 	st.b [%a14]-5,%d2
    if (enabled != FALSE)
80005f30:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80005f34:	df 02 04 00 	jeq %d2,0,80005f3c <Ifx_Fifo_beginWrite+0xfa>
        __enable();
80005f38:	0d 00 00 03 	enable 

    return blockSize;
80005f3c:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
}
80005f40:	00 90       	ret 

80005f42 <Ifx_Fifo_endWrite>:

    return result;
}

static Ifx_SizeT Ifx_Fifo_endWrite(Ifx_Fifo *fifo, Ifx_SizeT count, Ifx_SizeT blockSize)
{
80005f42:	40 ae       	mov.aa %a14,%sp
80005f44:	20 30       	sub.a %sp,48
80005f46:	b5 e4 dc ff 	st.a [%a14]-36,%a4
80005f4a:	02 42       	mov %d2,%d4
80005f4c:	02 53       	mov %d3,%d5
80005f4e:	f9 e2 d8 ff 	st.h [%a14]-40,%d2
80005f52:	02 32       	mov %d2,%d3
80005f54:	f9 e2 d4 ff 	st.h [%a14]-44,%d2
    reg.U = __mfcr(CPU_ICR);
80005f58:	4d c0 e2 2f 	mfcr %d2,$icr
80005f5c:	59 e2 ec ff 	st.w [%a14]-20,%d2
80005f60:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80005f64:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return reg.B.IE != 0;
80005f68:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80005f6c:	37 02 e1 27 	extr.u %d2,%d2,15,1
80005f70:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
80005f74:	e9 e2 eb ff 	st.b [%a14]-21,%d2
    __disable();
80005f78:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
80005f7c:	00 00       	nop 
    return enabled;
80005f7e:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();
80005f82:	e9 e2 ff ff 	st.b [%a14]-1,%d2

    fifo->shared.count   += blockSize;
80005f86:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005f8a:	c9 22 04 00 	ld.h %d2,[%a2]4
80005f8e:	37 02 70 30 	extr.u %d3,%d2,0,16
80005f92:	b9 e2 d4 ff 	ld.hu %d2,[%a14]-44
80005f96:	42 32       	add %d2,%d3
80005f98:	37 02 70 20 	extr.u %d2,%d2,0,16
80005f9c:	37 02 50 20 	extr %d2,%d2,0,16
80005fa0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005fa4:	f9 22 04 00 	st.h [%a2]4,%d2
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
80005fa8:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005fac:	c9 22 10 00 	ld.h %d2,[%a2]16
80005fb0:	02 23       	mov %d3,%d2
80005fb2:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005fb6:	c9 22 04 00 	ld.h %d2,[%a2]4
80005fba:	59 e3 f8 ff 	st.w [%a14]-8,%d3
80005fbe:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80005fc2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80005fc6:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80005fca:	0b 32 a0 21 	max %d2,%d2,%d3
80005fce:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return res;
80005fd2:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80005fd6:	37 02 50 20 	extr %d2,%d2,0,16
80005fda:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005fde:	f9 22 10 00 	st.h [%a2]16,%d2

    if (fifo->shared.readerWaitx != 0)
80005fe2:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005fe6:	d9 22 08 00 	lea %a2,[%a2]8
80005fea:	54 22       	ld.w %d2,[%a2]
80005fec:	df 02 22 00 	jeq %d2,0,80006030 <Ifx_Fifo_endWrite+0xee>
    {
        fifo->shared.readerWaitx -= blockSize;
80005ff0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80005ff4:	d9 22 08 00 	lea %a2,[%a2]8
80005ff8:	54 23       	ld.w %d3,[%a2]
80005ffa:	c9 e2 d4 ff 	ld.h %d2,[%a14]-44
80005ffe:	0b 23 80 20 	sub %d2,%d3,%d2
80006002:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80006006:	d9 22 08 00 	lea %a2,[%a2]8
8000600a:	74 22       	st.w [%a2],%d2

        if (fifo->shared.readerWaitx <= 0)
8000600c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80006010:	d9 22 08 00 	lea %a2,[%a2]8
80006014:	54 22       	ld.w %d2,[%a2]
80006016:	ff 12 0d 00 	jge %d2,1,80006030 <Ifx_Fifo_endWrite+0xee>
        {
            fifo->shared.readerWaitx = 0;
8000601a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000601e:	82 02       	mov %d2,0
80006020:	d9 22 08 00 	lea %a2,[%a2]8
80006024:	74 22       	st.w [%a2],%d2
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
80006026:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000602a:	82 12       	mov %d2,1
8000602c:	e9 22 1c 00 	st.b [%a2]28,%d2
        }
    }

    IfxCpu_restoreInterrupts(interruptState);
80006030:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80006034:	e9 e2 ea ff 	st.b [%a14]-22,%d2
    if (enabled != FALSE)
80006038:	39 e2 ea ff 	ld.bu %d2,[%a14]-22
8000603c:	df 02 04 00 	jeq %d2,0,80006044 <Ifx_Fifo_endWrite+0x102>
        __enable();
80006040:	0d 00 00 03 	enable 

    return count - blockSize;
80006044:	b9 e3 d8 ff 	ld.hu %d3,[%a14]-40
80006048:	b9 e2 d4 ff 	ld.hu %d2,[%a14]-44
8000604c:	0b 23 80 20 	sub %d2,%d3,%d2
80006050:	37 02 70 20 	extr.u %d2,%d2,0,16
80006054:	37 02 50 20 	extr %d2,%d2,0,16
}
80006058:	00 90       	ret 

8000605a <Ifx_Fifo_write>:



Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
8000605a:	40 ae       	mov.aa %a14,%sp
8000605c:	20 d8       	sub.a %sp,216
8000605e:	b5 e4 cc df 	st.a [%a14]-180,%a4
80006062:	b5 e5 c8 df 	st.a [%a14]-184,%a5
80006066:	89 e6 7c c9 	st.d [%a14]-196,%e6
8000606a:	f9 e4 c4 df 	st.h [%a14]-188,%d4
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
8000606e:	82 04       	mov %d4,0
80006070:	e9 e4 ff ff 	st.b [%a14]-1,%d4

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
80006074:	c9 e4 c4 df 	ld.h %d4,[%a14]-188
80006078:	df 04 dd 01 	jeq %d4,0,80006432 <Ifx_Fifo_write+0x3d8>
    {
        buffer.base   = fifo->buffer;
8000607c:	99 e2 cc df 	ld.a %a2,[%a14]-180
80006080:	54 24       	ld.w %d4,[%a2]
80006082:	59 e4 e0 df 	st.w [%a14]-160,%d4
        buffer.length = (uint16)fifo->size;     /* size always fit into 16 bit */
80006086:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000608a:	c9 24 18 00 	ld.h %d4,[%a2]24
8000608e:	37 04 70 40 	extr.u %d4,%d4,0,16
80006092:	f9 e4 e6 df 	st.h [%a14]-154,%d4
        buffer.index  = (uint16)fifo->endIndex; /* startIndex always fit into size */
80006096:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000609a:	c9 24 16 00 	ld.h %d4,[%a2]22
8000609e:	37 04 70 40 	extr.u %d4,%d4,0,16
800060a2:	f9 e4 e4 df 	st.h [%a14]-156,%d4
800060a6:	09 e2 fc c9 	ld.da %a2,[%a14]-196
800060aa:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    if (timeout == TIME_INFINITE)
800060ae:	09 e4 68 f9 	ld.d %e4,[%a14]-24
800060b2:	82 f6       	mov %d6,-1
800060b4:	06 f6       	sh %d6,-1
800060b6:	0b 65 10 61 	ne %d6,%d5,%d6
800060ba:	8b f4 1f 65 	or.ne %d6,%d4,-1
800060be:	df 06 0b 80 	jne %d6,0,800060d4 <Ifx_Fifo_write+0x7a>
        deadLine = TIME_INFINITE;
800060c2:	a0 02       	mov.a %a2,0
800060c4:	b0 f2       	add.a %a2,-1
800060c6:	c5 83 00 00 	lea %a3,80000000 <LCF_STARTPTR_CPU0>
800060ca:	b0 f3       	add.a %a3,-1
800060cc:	89 e2 e0 f9 	st.da [%a14]-32,%a2
800060d0:	1d 00 63 00 	j 80006196 <Ifx_Fifo_write+0x13c>
    reg.U = __mfcr(CPU_ICR);
800060d4:	4d c0 e2 4f 	mfcr %d4,$icr
800060d8:	59 e4 dc ff 	st.w [%a14]-36,%d4
800060dc:	19 e4 dc ff 	ld.w %d4,[%a14]-36
800060e0:	59 e4 d4 df 	st.w [%a14]-172,%d4
    return reg.B.IE != 0;
800060e4:	19 e4 d4 df 	ld.w %d4,[%a14]-172
800060e8:	37 04 e1 47 	extr.u %d4,%d4,15,1
800060ec:	8f f4 0f 41 	and %d4,%d4,255
    enabled = IfxCpu_areInterruptsEnabled();
800060f0:	e9 e4 db ff 	st.b [%a14]-37,%d4
    __disable();
800060f4:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
800060f8:	00 00       	nop 
    return enabled;
800060fa:	39 e4 db ff 	ld.bu %d4,[%a14]-37
    interruptState = IfxCpu_disableInterrupts();
800060fe:	e9 e4 da ff 	st.b [%a14]-38,%d4
80006102:	7b 00 00 4f 	movh %d4,61440
80006106:	1b 04 00 41 	addi %d4,%d4,4096
8000610a:	59 e4 d4 ff 	st.w [%a14]-44,%d4
    result  = stm->TIM0.U;
8000610e:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80006112:	d9 22 10 00 	lea %a2,[%a2]16
80006116:	54 24       	ld.w %d4,[%a2]
80006118:	02 44       	mov %d4,%d4
8000611a:	82 05       	mov %d5,0
8000611c:	89 e4 4c f9 	st.d [%a14]-52,%e4
    result |= ((uint64)stm->CAP.U) << 32;
80006120:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80006124:	d9 22 2c 00 	lea %a2,[%a2]44
80006128:	54 24       	ld.w %d4,[%a2]
8000612a:	02 44       	mov %d4,%d4
8000612c:	82 05       	mov %d5,0
8000612e:	59 e4 f8 cf 	st.w [%a14]-200,%d4
80006132:	82 04       	mov %d4,0
80006134:	59 e4 f4 cf 	st.w [%a14]-204,%d4
80006138:	19 e4 cc ff 	ld.w %d4,[%a14]-52
8000613c:	09 e6 74 c9 	ld.d %e6,[%a14]-204
80006140:	02 65       	mov %d5,%d6
80006142:	0f 54 a0 20 	or %d2,%d4,%d5
80006146:	19 e4 d0 ff 	ld.w %d4,[%a14]-48
8000614a:	02 75       	mov %d5,%d7
8000614c:	a6 45       	or %d5,%d4
8000614e:	02 53       	mov %d3,%d5
80006150:	89 e2 4c f9 	st.d [%a14]-52,%e2
    return result;
80006154:	09 e2 cc f9 	ld.da %a2,[%a14]-52
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80006158:	80 22       	mov.d %d2,%a2
8000615a:	80 33       	mov.d %d3,%a3
8000615c:	02 24       	mov %d4,%d2
8000615e:	59 e4 c4 ff 	st.w [%a14]-60,%d4
80006162:	82 f4       	mov %d4,-1
80006164:	06 f4       	sh %d4,-1
80006166:	0f 43 80 20 	and %d2,%d3,%d4
8000616a:	59 e2 c8 ff 	st.w [%a14]-56,%d2
    IfxCpu_restoreInterrupts(interruptState);
8000616e:	39 e2 da ff 	ld.bu %d2,[%a14]-38
80006172:	e9 e2 c3 ff 	st.b [%a14]-61,%d2
    if (enabled != FALSE)
80006176:	39 e2 c3 ff 	ld.bu %d2,[%a14]-61
8000617a:	df 02 04 00 	jeq %d2,0,80006182 <Ifx_Fifo_write+0x128>
        __enable();
8000617e:	0d 00 00 03 	enable 
    return stmNow;
80006182:	09 e4 44 f9 	ld.d %e4,[%a14]-60
        deadLine = IfxStm_now() + timeout;
80006186:	09 e2 68 f9 	ld.d %e2,[%a14]-24
8000618a:	0b 42 40 00 	addx %d0,%d2,%d4
8000618e:	0b 53 50 10 	addc %d1,%d3,%d5
80006192:	89 e0 60 f9 	st.d [%a14]-32,%e0
    return deadLine;
80006196:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
        DeadLine      = IfxStm_getDeadLine(timeout);
8000619a:	89 e2 f4 f9 	st.da [%a14]-12,%a2

        do
        {
            blockSize = Ifx_Fifo_beginWrite(fifo, count);
8000619e:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
800061a2:	02 24       	mov %d4,%d2
800061a4:	99 e4 cc df 	ld.a %a4,[%a14]-180
800061a8:	6d ff 4d fe 	call 80005e42 <Ifx_Fifo_beginWrite>
800061ac:	f9 e2 f2 ff 	st.h [%a14]-14,%d2

            if (blockSize != 0)
800061b0:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
800061b4:	df 02 1a 00 	jeq %d2,0,800061e8 <Ifx_Fifo_write+0x18e>
            {
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
800061b8:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
800061bc:	d9 e2 e0 df 	lea %a2,[%a14]-160
800061c0:	02 24       	mov %d4,%d2
800061c2:	99 e5 c8 df 	ld.a %a5,[%a14]-184
800061c6:	40 24       	mov.aa %a4,%a2
800061c8:	6d ff 7e fa 	call 800056c4 <Ifx_CircularBuffer_write8>
800061cc:	b5 e2 c8 df 	st.a [%a14]-184,%a2
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
800061d0:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
800061d4:	c9 e3 f2 ff 	ld.h %d3,[%a14]-14
800061d8:	02 35       	mov %d5,%d3
800061da:	02 24       	mov %d4,%d2
800061dc:	99 e4 cc df 	ld.a %a4,[%a14]-180
800061e0:	6d ff b1 fe 	call 80005f42 <Ifx_Fifo_endWrite>
800061e4:	f9 e2 c4 df 	st.h [%a14]-188,%d2
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
800061e8:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
800061ec:	df 02 7b 80 	jne %d2,0,800062e2 <Ifx_Fifo_write+0x288>
800061f0:	09 e2 f4 f9 	ld.da %a2,[%a14]-12
800061f4:	89 e2 f8 e9 	st.da [%a14]-72,%a2
    if (deadLine == TIME_INFINITE)
800061f8:	09 e2 78 e9 	ld.d %e2,[%a14]-72
800061fc:	82 f4       	mov %d4,-1
800061fe:	06 f4       	sh %d4,-1
80006200:	0b 43 10 41 	ne %d4,%d3,%d4
80006204:	8b f2 1f 45 	or.ne %d4,%d2,-1
80006208:	df 04 07 80 	jne %d4,0,80006216 <Ifx_Fifo_write+0x1bc>
        result = FALSE;
8000620c:	82 02       	mov %d2,0
8000620e:	e9 e2 f7 ef 	st.b [%a14]-73,%d2
80006212:	1d 00 64 00 	j 800062da <Ifx_Fifo_write+0x280>
    reg.U = __mfcr(CPU_ICR);
80006216:	4d c0 e2 2f 	mfcr %d2,$icr
8000621a:	59 e2 f0 ef 	st.w [%a14]-80,%d2
8000621e:	19 e2 f0 ef 	ld.w %d2,[%a14]-80
80006222:	59 e2 d8 df 	st.w [%a14]-168,%d2
    return reg.B.IE != 0;
80006226:	19 e2 d8 df 	ld.w %d2,[%a14]-168
8000622a:	37 02 e1 27 	extr.u %d2,%d2,15,1
8000622e:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
80006232:	e9 e2 ef ef 	st.b [%a14]-81,%d2
    __disable();
80006236:	0d 00 40 03 	disable 
8000623a:	00 00       	nop 
    return enabled;
8000623c:	39 e2 ef ef 	ld.bu %d2,[%a14]-81
    interruptState = IfxCpu_disableInterrupts();
80006240:	e9 e2 ee ef 	st.b [%a14]-82,%d2
80006244:	7b 00 00 2f 	movh %d2,61440
80006248:	1b 02 00 21 	addi %d2,%d2,4096
8000624c:	59 e2 e8 ef 	st.w [%a14]-88,%d2
    result  = stm->TIM0.U;
80006250:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
80006254:	d9 22 10 00 	lea %a2,[%a2]16
80006258:	54 22       	ld.w %d2,[%a2]
8000625a:	02 22       	mov %d2,%d2
8000625c:	82 03       	mov %d3,0
8000625e:	89 e2 60 e9 	st.d [%a14]-96,%e2
    result |= ((uint64)stm->CAP.U) << 32;
80006262:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
80006266:	d9 22 2c 00 	lea %a2,[%a2]44
8000626a:	54 22       	ld.w %d2,[%a2]
8000626c:	02 22       	mov %d2,%d2
8000626e:	82 03       	mov %d3,0
80006270:	02 2d       	mov %d13,%d2
80006272:	82 0c       	mov %d12,0
80006274:	19 e2 e0 ef 	ld.w %d2,[%a14]-96
80006278:	0f c2 a0 80 	or %d8,%d2,%d12
8000627c:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
80006280:	0f d2 a0 90 	or %d9,%d2,%d13
80006284:	89 e8 60 e9 	st.d [%a14]-96,%e8
    return result;
80006288:	09 e2 e0 e9 	ld.da %a2,[%a14]-96
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000628c:	80 22       	mov.d %d2,%a2
8000628e:	80 33       	mov.d %d3,%a3
80006290:	02 24       	mov %d4,%d2
80006292:	59 e4 d8 ef 	st.w [%a14]-104,%d4
80006296:	82 f4       	mov %d4,-1
80006298:	06 f4       	sh %d4,-1
8000629a:	0f 43 80 20 	and %d2,%d3,%d4
8000629e:	59 e2 dc ef 	st.w [%a14]-100,%d2
    IfxCpu_restoreInterrupts(interruptState);
800062a2:	39 e2 ee ef 	ld.bu %d2,[%a14]-82
800062a6:	e9 e2 d7 ef 	st.b [%a14]-105,%d2
    if (enabled != FALSE)
800062aa:	39 e2 d7 ef 	ld.bu %d2,[%a14]-105
800062ae:	df 02 04 00 	jeq %d2,0,800062b6 <Ifx_Fifo_write+0x25c>
        __enable();
800062b2:	0d 00 00 03 	enable 
    return stmNow;
800062b6:	09 e6 58 e9 	ld.d %e6,[%a14]-104
        result = IfxStm_now() >= deadLine;
800062ba:	09 e2 78 e9 	ld.d %e2,[%a14]-72
800062be:	02 74       	mov %d4,%d7
800062c0:	0b 43 00 41 	eq %d4,%d3,%d4
800062c4:	02 25       	mov %d5,%d2
800062c6:	0b 56 50 42 	and.ge.u %d4,%d6,%d5
800062ca:	02 75       	mov %d5,%d7
800062cc:	0b 53 90 42 	or.lt %d4,%d3,%d5
800062d0:	02 42       	mov %d2,%d4
800062d2:	8f f2 0f 21 	and %d2,%d2,255
800062d6:	e9 e2 f7 ef 	st.b [%a14]-73,%d2
    return result;
800062da:	39 e2 f7 ef 	ld.bu %d2,[%a14]-73
800062de:	df 02 0a 00 	jeq %d2,0,800062f2 <Ifx_Fifo_write+0x298>
            {
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
800062e2:	99 e2 cc df 	ld.a %a2,[%a14]-180
800062e6:	82 02       	mov %d2,0
800062e8:	d9 22 0c 00 	lea %a2,[%a2]12
800062ec:	74 22       	st.w [%a2],%d2
                break;
800062ee:	1d 00 9a 00 	j 80006422 <Ifx_Fifo_write+0x3c8>
            }

            if (count != 0)
800062f2:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
800062f6:	df 02 92 00 	jeq %d2,0,8000641a <Ifx_Fifo_write+0x3c0>
            {
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800062fa:	99 e2 cc df 	ld.a %a2,[%a14]-180
800062fe:	39 22 1d 00 	ld.bu %d2,[%a2]29
80006302:	df 02 82 80 	jne %d2,0,80006406 <Ifx_Fifo_write+0x3ac>
80006306:	09 e2 f4 f9 	ld.da %a2,[%a14]-12
8000630a:	89 e2 cc e9 	st.da [%a14]-116,%a2
    if (deadLine == TIME_INFINITE)
8000630e:	09 e2 4c e9 	ld.d %e2,[%a14]-116
80006312:	82 f4       	mov %d4,-1
80006314:	06 f4       	sh %d4,-1
80006316:	0b 43 10 41 	ne %d4,%d3,%d4
8000631a:	8b f2 1f 45 	or.ne %d4,%d2,-1
8000631e:	df 04 07 80 	jne %d4,0,8000632c <Ifx_Fifo_write+0x2d2>
        result = FALSE;
80006322:	82 02       	mov %d2,0
80006324:	e9 e2 cb ef 	st.b [%a14]-117,%d2
80006328:	1d 00 6b 00 	j 800063fe <Ifx_Fifo_write+0x3a4>
    reg.U = __mfcr(CPU_ICR);
8000632c:	4d c0 e2 2f 	mfcr %d2,$icr
80006330:	59 e2 c4 ef 	st.w [%a14]-124,%d2
80006334:	19 e2 c4 ef 	ld.w %d2,[%a14]-124
80006338:	59 e2 dc df 	st.w [%a14]-164,%d2
    return reg.B.IE != 0;
8000633c:	19 e2 dc df 	ld.w %d2,[%a14]-164
80006340:	37 02 e1 27 	extr.u %d2,%d2,15,1
80006344:	8f f2 0f 21 	and %d2,%d2,255
    enabled = IfxCpu_areInterruptsEnabled();
80006348:	e9 e2 c3 ef 	st.b [%a14]-125,%d2
    __disable();
8000634c:	0d 00 40 03 	disable 
80006350:	00 00       	nop 
    return enabled;
80006352:	39 e2 c3 ef 	ld.bu %d2,[%a14]-125
    interruptState = IfxCpu_disableInterrupts();
80006356:	e9 e2 c2 ef 	st.b [%a14]-126,%d2
8000635a:	7b 00 00 2f 	movh %d2,61440
8000635e:	1b 02 00 21 	addi %d2,%d2,4096
80006362:	59 e2 fc df 	st.w [%a14]-132,%d2
    result  = stm->TIM0.U;
80006366:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000636a:	d9 22 10 00 	lea %a2,[%a2]16
8000636e:	54 22       	ld.w %d2,[%a2]
80006370:	02 22       	mov %d2,%d2
80006372:	82 03       	mov %d3,0
80006374:	89 e2 74 d9 	st.d [%a14]-140,%e2
    result |= ((uint64)stm->CAP.U) << 32;
80006378:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000637c:	d9 22 2c 00 	lea %a2,[%a2]44
80006380:	54 22       	ld.w %d2,[%a2]
80006382:	02 22       	mov %d2,%d2
80006384:	82 03       	mov %d3,0
80006386:	59 e2 f0 cf 	st.w [%a14]-208,%d2
8000638a:	82 02       	mov %d2,0
8000638c:	59 e2 ec cf 	st.w [%a14]-212,%d2
80006390:	19 e2 f4 df 	ld.w %d2,[%a14]-140
80006394:	09 e4 6c c9 	ld.d %e4,[%a14]-212
80006398:	02 43       	mov %d3,%d4
8000639a:	0f 32 a0 a0 	or %d10,%d2,%d3
8000639e:	19 e2 f8 df 	ld.w %d2,[%a14]-136
800063a2:	02 53       	mov %d3,%d5
800063a4:	0f 32 a0 b0 	or %d11,%d2,%d3
800063a8:	89 ea 74 d9 	st.d [%a14]-140,%e10
    return result;
800063ac:	09 e2 f4 d9 	ld.da %a2,[%a14]-140
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800063b0:	80 22       	mov.d %d2,%a2
800063b2:	80 33       	mov.d %d3,%a3
800063b4:	02 24       	mov %d4,%d2
800063b6:	59 e4 ec df 	st.w [%a14]-148,%d4
800063ba:	82 f4       	mov %d4,-1
800063bc:	06 f4       	sh %d4,-1
800063be:	0f 43 80 20 	and %d2,%d3,%d4
800063c2:	59 e2 f0 df 	st.w [%a14]-144,%d2
    IfxCpu_restoreInterrupts(interruptState);
800063c6:	39 e2 c2 ef 	ld.bu %d2,[%a14]-126
800063ca:	e9 e2 eb df 	st.b [%a14]-149,%d2
    if (enabled != FALSE)
800063ce:	39 e2 eb df 	ld.bu %d2,[%a14]-149
800063d2:	df 02 04 00 	jeq %d2,0,800063da <Ifx_Fifo_write+0x380>
        __enable();
800063d6:	0d 00 00 03 	enable 
    return stmNow;
800063da:	09 e6 6c d9 	ld.d %e6,[%a14]-148
        result = IfxStm_now() >= deadLine;
800063de:	09 e2 4c e9 	ld.d %e2,[%a14]-116
800063e2:	02 74       	mov %d4,%d7
800063e4:	0b 43 00 41 	eq %d4,%d3,%d4
800063e8:	02 25       	mov %d5,%d2
800063ea:	0b 56 50 42 	and.ge.u %d4,%d6,%d5
800063ee:	02 75       	mov %d5,%d7
800063f0:	0b 53 90 42 	or.lt %d4,%d3,%d5
800063f4:	02 42       	mov %d2,%d4
800063f6:	8f f2 0f 21 	and %d2,%d2,255
800063fa:	e9 e2 cb ef 	st.b [%a14]-117,%d2
    return result;
800063fe:	39 e2 cb ef 	ld.bu %d2,[%a14]-117
80006402:	df 02 7c 7f 	jeq %d2,0,800062fa <Ifx_Fifo_write+0x2a0>
                {}

                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
80006406:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000640a:	39 22 1d 00 	ld.bu %d2,[%a2]29
8000640e:	8b 02 00 22 	eq %d2,%d2,0
80006412:	8f f2 0f 21 	and %d2,%d2,255
80006416:	e9 e2 ff ff 	st.b [%a14]-1,%d2
            }
        } while (count != 0);
8000641a:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
8000641e:	df 02 c0 fe 	jne %d2,0,8000619e <Ifx_Fifo_write+0x144>

        fifo->endIndex = buffer.index;
80006422:	b9 e2 e4 df 	ld.hu %d2,[%a14]-156
80006426:	37 02 50 20 	extr %d2,%d2,0,16
8000642a:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000642e:	f9 22 16 00 	st.h [%a2]22,%d2
    }

    return count;
80006432:	c9 e2 c4 df 	ld.h %d2,[%a14]-188
}
80006436:	00 90       	ret 

80006438 <IfxStm_clearCompareFlag>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxStm_clearCompareFlag(Ifx_STM *stm, IfxStm_Comparator comparator)
{
80006438:	40 ae       	mov.aa %a14,%sp
8000643a:	20 08       	sub.a %sp,8
8000643c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80006440:	59 e4 f8 ff 	st.w [%a14]-8,%d4
    if (comparator == IfxStm_Comparator_0)
80006444:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80006448:	df 02 0e 80 	jne %d2,0,80006464 <IfxStm_clearCompareFlag+0x2c>
    {
        stm->ISCR.B.CMP0IRR = 1U;
8000644c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006450:	d9 23 00 10 	lea %a3,[%a2]64
80006454:	54 32       	ld.w %d2,[%a3]
80006456:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000645a:	d9 22 00 10 	lea %a2,[%a2]64
8000645e:	74 22       	st.w [%a2],%d2
    }
    else if (comparator == IfxStm_Comparator_1)
    {
        stm->ISCR.B.CMP1IRR = 1U;
    }
}
80006460:	1d 00 10 00 	j 80006480 <IfxStm_clearCompareFlag+0x48>
    else if (comparator == IfxStm_Comparator_1)
80006464:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80006468:	df 12 0c 80 	jne %d2,1,80006480 <IfxStm_clearCompareFlag+0x48>
        stm->ISCR.B.CMP1IRR = 1U;
8000646c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006470:	d9 23 00 10 	lea %a3,[%a2]64
80006474:	54 32       	ld.w %d2,[%a3]
80006476:	b7 12 01 21 	insert %d2,%d2,1,2,1
8000647a:	d9 22 00 10 	lea %a2,[%a2]64
8000647e:	74 22       	st.w [%a2],%d2
}
80006480:	00 00       	nop 
80006482:	00 90       	ret 

80006484 <IfxStm_enableComparatorInterrupt>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxStm_enableComparatorInterrupt(Ifx_STM *stm, IfxStm_Comparator comparator)
{
80006484:	40 ae       	mov.aa %a14,%sp
80006486:	20 08       	sub.a %sp,8
80006488:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8000648c:	59 e4 f8 ff 	st.w [%a14]-8,%d4
    if (comparator == IfxStm_Comparator_0)
80006490:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80006494:	df 02 0e 80 	jne %d2,0,800064b0 <IfxStm_enableComparatorInterrupt+0x2c>
    {
        stm->ICR.B.CMP0EN = 1U;
80006498:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000649c:	d9 23 3c 00 	lea %a3,[%a2]60
800064a0:	54 32       	ld.w %d2,[%a3]
800064a2:	b7 12 01 20 	insert %d2,%d2,1,0,1
800064a6:	d9 22 3c 00 	lea %a2,[%a2]60
800064aa:	74 22       	st.w [%a2],%d2
    }
    else if (comparator == IfxStm_Comparator_1)
    {
        stm->ICR.B.CMP1EN = 1U;
    }
}
800064ac:	1d 00 10 00 	j 800064cc <IfxStm_enableComparatorInterrupt+0x48>
    else if (comparator == IfxStm_Comparator_1)
800064b0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800064b4:	df 12 0c 80 	jne %d2,1,800064cc <IfxStm_enableComparatorInterrupt+0x48>
        stm->ICR.B.CMP1EN = 1U;
800064b8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800064bc:	d9 23 3c 00 	lea %a3,[%a2]60
800064c0:	54 32       	ld.w %d2,[%a3]
800064c2:	b7 12 01 22 	insert %d2,%d2,1,4,1
800064c6:	d9 22 3c 00 	lea %a2,[%a2]60
800064ca:	74 22       	st.w [%a2],%d2
}
800064cc:	00 00       	nop 
800064ce:	00 90       	ret 

800064d0 <IfxStm_getIndex>:
    return module;
}


IfxStm_Index IfxStm_getIndex(Ifx_STM *stm)
{
800064d0:	40 ae       	mov.aa %a14,%sp
800064d2:	20 10       	sub.a %sp,16
800064d4:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
    uint32       index;
    IfxStm_Index result;

    result = IfxStm_Index_none;
800064d8:	82 f2       	mov %d2,-1
800064da:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
800064de:	82 02       	mov %d2,0
800064e0:	59 e2 fc ff 	st.w [%a14]-4,%d2
800064e4:	1d 00 26 00 	j 80006530 <IfxStm_getIndex+0x60>
    {
        if (IfxStm_cfg_indexMap[index].module == stm)
800064e8:	91 00 00 28 	movh.a %a2,32768
800064ec:	d9 22 18 74 	lea %a2,[%a2]16856 <800041d8 <IfxStm_cfg_indexMap>>
800064f0:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <800041d8 <IfxStm_cfg_indexMap>>
800064f4:	06 32       	sh %d2,3
800064f6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800064fa:	54 22       	ld.w %d2,[%a2]
800064fc:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80006500:	5f 23 13 80 	jne %d3,%d2,80006526 <IfxStm_getIndex+0x56>
        {
            result = (IfxStm_Index)IfxStm_cfg_indexMap[index].index;
80006504:	91 00 00 28 	movh.a %a2,32768
80006508:	d9 22 18 74 	lea %a2,[%a2]16856 <800041d8 <IfxStm_cfg_indexMap>>
8000650c:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <800041d8 <IfxStm_cfg_indexMap>>
80006510:	06 32       	sh %d2,3
80006512:	80 23       	mov.d %d3,%a2
80006514:	42 23       	add %d3,%d2
80006516:	02 32       	mov %d2,%d3
80006518:	60 22       	mov.a %a2,%d2
8000651a:	b0 42       	add.a %a2,4
8000651c:	54 22       	ld.w %d2,[%a2]
8000651e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
            break;
80006522:	1d 00 0b 00 	j 80006538 <IfxStm_getIndex+0x68>
    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
80006526:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000652a:	c2 12       	add %d2,1
8000652c:	59 e2 fc ff 	st.w [%a14]-4,%d2
80006530:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80006534:	bf 62 da ff 	jlt.u %d2,6,800064e8 <IfxStm_getIndex+0x18>
        }
    }

    return result;
80006538:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
}
8000653c:	00 90       	ret 

8000653e <IfxStm_initCompare>:
    return comparator == IfxStm_Comparator_0 ? &MODULE_SRC.STM.STM[index].SR[0] : &MODULE_SRC.STM.STM[index].SR[1];
}


boolean IfxStm_initCompare(Ifx_STM *stm, const IfxStm_CompareConfig *config)
{
8000653e:	40 ae       	mov.aa %a14,%sp
80006540:	20 80       	sub.a %sp,128
80006542:	b5 e4 dc ef 	st.a [%a14]-100,%a4
80006546:	b5 e5 d8 ef 	st.a [%a14]-104,%a5
    sint32        index;
    boolean       result;
    Ifx_STM_CMCON comcon = stm->CMCON;
8000654a:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000654e:	d9 22 38 00 	lea %a2,[%a2]56
80006552:	54 22       	ld.w %d2,[%a2]
80006554:	59 e2 e4 ef 	st.w [%a14]-92,%d2
    Ifx_STM_ICR   icr    = stm->ICR;
80006558:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000655c:	d9 22 3c 00 	lea %a2,[%a2]60
80006560:	54 22       	ld.w %d2,[%a2]
80006562:	59 e2 e0 ef 	st.w [%a14]-96,%d2

    if (config->comparator == 0)
80006566:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
8000656a:	54 22       	ld.w %d2,[%a2]
8000656c:	df 02 33 80 	jne %d2,0,800065d2 <IfxStm_initCompare+0x94>
    {
        comcon.B.MSIZE0  = config->compareSize;
80006570:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
80006574:	d9 22 0c 00 	lea %a2,[%a2]12
80006578:	54 22       	ld.w %d2,[%a2]
8000657a:	8f f2 01 21 	and %d2,%d2,31
8000657e:	8f f2 0f 31 	and %d3,%d2,255
80006582:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
80006586:	37 32 05 20 	insert %d2,%d2,%d3,0,5
8000658a:	59 e2 e4 ef 	st.w [%a14]-92,%d2
        comcon.B.MSTART0 = config->compareOffset;
8000658e:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
80006592:	d9 22 08 00 	lea %a2,[%a2]8
80006596:	54 22       	ld.w %d2,[%a2]
80006598:	8f f2 01 21 	and %d2,%d2,31
8000659c:	8f f2 0f 31 	and %d3,%d2,255
800065a0:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
800065a4:	37 32 05 24 	insert %d2,%d2,%d3,8,5
800065a8:	59 e2 e4 ef 	st.w [%a14]-92,%d2
        icr.B.CMP0OS     = config->comparatorInterrupt;
800065ac:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800065b0:	b0 42       	add.a %a2,4
800065b2:	54 22       	ld.w %d2,[%a2]
800065b4:	8f 12 00 21 	and %d2,%d2,1
800065b8:	8f f2 0f 31 	and %d3,%d2,255
800065bc:	19 e2 e0 ef 	ld.w %d2,[%a14]-96
800065c0:	67 32 02 20 	ins.t %d2,%d2,2,%d3,0
800065c4:	59 e2 e0 ef 	st.w [%a14]-96,%d2
        result           = TRUE;
800065c8:	82 12       	mov %d2,1
800065ca:	e9 e2 ff ff 	st.b [%a14]-1,%d2
800065ce:	1d 00 3b 00 	j 80006644 <IfxStm_initCompare+0x106>
    }
    else if (config->comparator == 1)
800065d2:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800065d6:	54 22       	ld.w %d2,[%a2]
800065d8:	df 12 33 80 	jne %d2,1,8000663e <IfxStm_initCompare+0x100>
    {
        comcon.B.MSIZE1  = config->compareSize;
800065dc:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800065e0:	d9 22 0c 00 	lea %a2,[%a2]12
800065e4:	54 22       	ld.w %d2,[%a2]
800065e6:	8f f2 01 21 	and %d2,%d2,31
800065ea:	8f f2 0f 31 	and %d3,%d2,255
800065ee:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
800065f2:	37 32 05 28 	insert %d2,%d2,%d3,16,5
800065f6:	59 e2 e4 ef 	st.w [%a14]-92,%d2
        comcon.B.MSTART1 = config->compareOffset;
800065fa:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800065fe:	d9 22 08 00 	lea %a2,[%a2]8
80006602:	54 22       	ld.w %d2,[%a2]
80006604:	8f f2 01 21 	and %d2,%d2,31
80006608:	8f f2 0f 31 	and %d3,%d2,255
8000660c:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
80006610:	37 32 05 2c 	insert %d2,%d2,%d3,24,5
80006614:	59 e2 e4 ef 	st.w [%a14]-92,%d2
        icr.B.CMP1OS     = config->comparatorInterrupt;
80006618:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
8000661c:	b0 42       	add.a %a2,4
8000661e:	54 22       	ld.w %d2,[%a2]
80006620:	8f 12 00 21 	and %d2,%d2,1
80006624:	8f f2 0f 31 	and %d3,%d2,255
80006628:	19 e2 e0 ef 	ld.w %d2,[%a14]-96
8000662c:	67 32 06 20 	ins.t %d2,%d2,6,%d3,0
80006630:	59 e2 e0 ef 	st.w [%a14]-96,%d2
        result           = TRUE;
80006634:	82 12       	mov %d2,1
80006636:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000663a:	1d 00 05 00 	j 80006644 <IfxStm_initCompare+0x106>
    }
    else
    {
        /*Invalid value */
        result = FALSE;
8000663e:	82 02       	mov %d2,0
80006640:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    }

    stm->ICR.U   = icr.U;
80006644:	19 e2 e0 ef 	ld.w %d2,[%a14]-96
80006648:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000664c:	d9 22 3c 00 	lea %a2,[%a2]60
80006650:	74 22       	st.w [%a2],%d2
    stm->CMCON.U = comcon.U;
80006652:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
80006656:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000665a:	d9 22 38 00 	lea %a2,[%a2]56
8000665e:	74 22       	st.w [%a2],%d2

    /* configure interrupt */
    index = IfxStm_getIndex(stm);
80006660:	99 e4 dc ef 	ld.a %a4,[%a14]-100
80006664:	6d ff 36 ff 	call 800064d0 <IfxStm_getIndex>
80006668:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    if (config->triggerPriority > 0)
8000666c:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
80006670:	b9 22 14 00 	ld.hu %d2,[%a2]20
80006674:	df 02 5b 00 	jeq %d2,0,8000672a <IfxStm_initCompare+0x1ec>
    {
        volatile Ifx_SRC_SRCR *srcr;

        if (config->comparatorInterrupt == IfxStm_ComparatorInterrupt_ir0)
80006678:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
8000667c:	b0 42       	add.a %a2,4
8000667e:	54 22       	ld.w %d2,[%a2]
80006680:	df 02 0d 80 	jne %d2,0,8000669a <IfxStm_initCompare+0x15c>
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR[0]);
80006684:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80006688:	06 32       	sh %d2,3
8000668a:	1b 02 30 28 	addi %d2,%d2,-32000
8000668e:	9b 42 00 2f 	addih %d2,%d2,61444
80006692:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80006696:	1d 00 0c 00 	j 800066ae <IfxStm_initCompare+0x170>
        }
        else
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR[1]);
8000669a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000669e:	06 32       	sh %d2,3
800066a0:	c2 42       	add %d2,4
800066a2:	1b 02 30 28 	addi %d2,%d2,-32000
800066a6:	9b 42 00 2f 	addih %d2,%d2,61444
800066aa:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        }

        IfxSrc_init(srcr, config->typeOfService, config->triggerPriority);
800066ae:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800066b2:	d9 22 18 00 	lea %a2,[%a2]24
800066b6:	54 23       	ld.w %d3,[%a2]
800066b8:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800066bc:	b9 22 14 00 	ld.hu %d2,[%a2]20
800066c0:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
800066c4:	59 e4 ec ff 	st.w [%a14]-20,%d4
800066c8:	59 e3 e8 ff 	st.w [%a14]-24,%d3
800066cc:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800066d0:	c9 e2 e6 ff 	ld.h %d2,[%a14]-26
800066d4:	8f f2 0f 31 	and %d3,%d2,255
800066d8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800066dc:	54 22       	ld.w %d2,[%a2]
800066de:	37 32 08 20 	insert %d2,%d2,%d3,0,8
800066e2:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800066e4:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800066e8:	8f 72 00 21 	and %d2,%d2,7
800066ec:	8f f2 0f 31 	and %d3,%d2,255
800066f0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800066f4:	54 22       	ld.w %d2,[%a2]
800066f6:	37 32 83 25 	insert %d2,%d2,%d3,11,3
800066fa:	74 22       	st.w [%a2],%d2
800066fc:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80006700:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    src->B.CLRR = 1;
80006704:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80006708:	54 22       	ld.w %d2,[%a2]
8000670a:	b7 12 81 2c 	insert %d2,%d2,1,25,1
8000670e:	74 22       	st.w [%a2],%d2
}
80006710:	00 00       	nop 
    IfxSrc_clearRequest(src);
}
80006712:	00 00       	nop 
80006714:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80006718:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    src->B.SRE = 1;
8000671c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80006720:	54 22       	ld.w %d2,[%a2]
80006722:	b7 12 01 25 	insert %d2,%d2,1,10,1
80006726:	74 22       	st.w [%a2],%d2
}
80006728:	00 00       	nop 
        IfxSrc_enable(srcr);
    }

    /*Configure the comparator ticks to current value to avoid any wrong triggering*/
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset);
8000672a:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
8000672e:	d9 22 08 00 	lea %a2,[%a2]8
80006732:	54 22       	ld.w %d2,[%a2]
80006734:	8f f2 0f 21 	and %d2,%d2,255
80006738:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
8000673c:	54 27       	ld.w %d7,[%a2]
8000673e:	19 e3 dc ef 	ld.w %d3,[%a14]-100
80006742:	59 e3 c0 ff 	st.w [%a14]-64,%d3
80006746:	e9 e2 ff ef 	st.b [%a14]-65,%d2
8000674a:	19 e2 c0 ff 	ld.w %d2,[%a14]-64
8000674e:	59 e2 f8 ef 	st.w [%a14]-72,%d2

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80006752:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80006756:	d9 22 10 00 	lea %a2,[%a2]16
8000675a:	54 22       	ld.w %d2,[%a2]
8000675c:	02 22       	mov %d2,%d2
8000675e:	82 03       	mov %d3,0
80006760:	89 e2 70 e9 	st.d [%a14]-80,%e2
    result |= ((uint64)stm->CAP.U) << 32;
80006764:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80006768:	d9 22 2c 00 	lea %a2,[%a2]44
8000676c:	54 22       	ld.w %d2,[%a2]
8000676e:	02 22       	mov %d2,%d2
80006770:	82 03       	mov %d3,0
80006772:	59 e2 cc ef 	st.w [%a14]-116,%d2
80006776:	82 0e       	mov %d14,0
80006778:	59 ee c8 ef 	st.w [%a14]-120,%d14
8000677c:	19 e2 f0 ef 	ld.w %d2,[%a14]-80
80006780:	09 e4 48 e9 	ld.d %e4,[%a14]-120
80006784:	02 43       	mov %d3,%d4
80006786:	a6 32       	or %d2,%d3
80006788:	59 e2 c0 ef 	st.w [%a14]-128,%d2
8000678c:	19 e2 f4 ef 	ld.w %d2,[%a14]-76
80006790:	02 53       	mov %d3,%d5
80006792:	a6 23       	or %d3,%d2
80006794:	59 e3 c4 ef 	st.w [%a14]-124,%d3
80006798:	09 e2 40 e9 	ld.d %e2,[%a14]-128
8000679c:	89 e2 70 e9 	st.d [%a14]-80,%e2

    return result;
800067a0:	09 e2 f0 e9 	ld.da %a2,[%a14]-80

IFX_INLINE uint32 IfxStm_getOffsetTimer(Ifx_STM *stm, uint8 offset)
{
    uint64 now;

    now = IfxStm_get(stm);
800067a4:	89 e2 e8 e9 	st.da [%a14]-88,%a2

    return (uint32)(now >> offset);
800067a8:	39 e6 ff ef 	ld.bu %d6,[%a14]-65
800067ac:	09 e2 68 e9 	ld.d %e2,[%a14]-88
800067b0:	8b 06 82 42 	ge %d4,%d6,32
800067b4:	2b 32 50 54 	seln %d5,%d4,%d2,%d3
800067b8:	ab 03 a0 24 	seln %d2,%d4,%d3,0
800067bc:	8f f6 01 41 	and %d4,%d6,31
800067c0:	8b 04 02 31 	rsub %d3,%d4,32
800067c4:	17 52 80 a3 	dextr %d10,%d2,%d5,%d3
800067c8:	2b 5a 40 a4 	sel %d10,%d4,%d10,%d5
800067cc:	8b 04 00 31 	rsub %d3,%d4,0
800067d0:	0f 32 00 b0 	sh %d11,%d2,%d3
800067d4:	60 a2       	mov.a %a2,%d10
800067d6:	60 b3       	mov.a %a3,%d11
800067d8:	80 24       	mov.d %d4,%a2
800067da:	19 e3 dc ef 	ld.w %d3,[%a14]-100
800067de:	1b c7 00 20 	addi %d2,%d7,12
800067e2:	06 22       	sh %d2,2
800067e4:	60 32       	mov.a %a2,%d3
800067e6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800067ea:	74 24       	st.w [%a2],%d4

    /* clear the interrupt flag of the selected comparator before enabling the interrupt */
    /* this is to avaoid the unneccesary interrupt for the compare match of reset values of the registers */
    IfxStm_clearCompareFlag(stm, config->comparator);
800067ec:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800067f0:	54 22       	ld.w %d2,[%a2]
800067f2:	02 24       	mov %d4,%d2
800067f4:	99 e4 dc ef 	ld.a %a4,[%a14]-100
800067f8:	6d ff 20 fe 	call 80006438 <IfxStm_clearCompareFlag>
    /* enable the interrupt for the selected comparator */
    IfxStm_enableComparatorInterrupt(stm, config->comparator);
800067fc:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
80006800:	54 22       	ld.w %d2,[%a2]
80006802:	02 24       	mov %d4,%d2
80006804:	99 e4 dc ef 	ld.a %a4,[%a14]-100
80006808:	6d ff 3e fe 	call 80006484 <IfxStm_enableComparatorInterrupt>

    /*Configure the comparator ticks */
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset) + config->ticks;
8000680c:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
80006810:	d9 22 08 00 	lea %a2,[%a2]8
80006814:	54 22       	ld.w %d2,[%a2]
80006816:	8f f2 0f 21 	and %d2,%d2,255
8000681a:	19 e3 dc ef 	ld.w %d3,[%a14]-100
8000681e:	59 e3 dc ff 	st.w [%a14]-36,%d3
80006822:	e9 e2 db ff 	st.b [%a14]-37,%d2
80006826:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000682a:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    result  = stm->TIM0.U;
8000682e:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80006832:	d9 22 10 00 	lea %a2,[%a2]16
80006836:	54 22       	ld.w %d2,[%a2]
80006838:	02 22       	mov %d2,%d2
8000683a:	82 03       	mov %d3,0
8000683c:	89 e2 4c f9 	st.d [%a14]-52,%e2
    result |= ((uint64)stm->CAP.U) << 32;
80006840:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80006844:	d9 22 2c 00 	lea %a2,[%a2]44
80006848:	54 22       	ld.w %d2,[%a2]
8000684a:	02 22       	mov %d2,%d2
8000684c:	82 03       	mov %d3,0
8000684e:	59 e2 d4 ef 	st.w [%a14]-108,%d2
80006852:	59 ee d0 ef 	st.w [%a14]-112,%d14
80006856:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8000685a:	09 e4 50 e9 	ld.d %e4,[%a14]-112
8000685e:	02 43       	mov %d3,%d4
80006860:	0f 32 a0 c0 	or %d12,%d2,%d3
80006864:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
80006868:	02 53       	mov %d3,%d5
8000686a:	a6 23       	or %d3,%d2
8000686c:	02 3d       	mov %d13,%d3
8000686e:	89 ec 4c f9 	st.d [%a14]-52,%e12
    return result;
80006872:	09 e2 cc f9 	ld.da %a2,[%a14]-52
    now = IfxStm_get(stm);
80006876:	89 e2 c4 f9 	st.da [%a14]-60,%a2
    return (uint32)(now >> offset);
8000687a:	39 e6 db ff 	ld.bu %d6,[%a14]-37
8000687e:	09 e2 44 f9 	ld.d %e2,[%a14]-60
80006882:	8b 06 82 42 	ge %d4,%d6,32
80006886:	2b 32 50 54 	seln %d5,%d4,%d2,%d3
8000688a:	ab 03 a0 24 	seln %d2,%d4,%d3,0
8000688e:	8f f6 01 41 	and %d4,%d6,31
80006892:	8b 04 02 31 	rsub %d3,%d4,32
80006896:	17 52 80 83 	dextr %d8,%d2,%d5,%d3
8000689a:	2b 58 40 84 	sel %d8,%d4,%d8,%d5
8000689e:	8b 04 00 31 	rsub %d3,%d4,0
800068a2:	0f 32 00 90 	sh %d9,%d2,%d3
800068a6:	60 82       	mov.a %a2,%d8
800068a8:	60 93       	mov.a %a3,%d9
800068aa:	80 24       	mov.d %d4,%a2
800068ac:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800068b0:	d9 22 10 00 	lea %a2,[%a2]16
800068b4:	54 23       	ld.w %d3,[%a2]
800068b6:	99 e2 d8 ef 	ld.a %a2,[%a14]-104
800068ba:	54 22       	ld.w %d2,[%a2]
800068bc:	42 43       	add %d3,%d4
800068be:	19 e4 dc ef 	ld.w %d4,[%a14]-100
800068c2:	1b c2 00 20 	addi %d2,%d2,12
800068c6:	06 22       	sh %d2,2
800068c8:	60 42       	mov.a %a2,%d4
800068ca:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800068ce:	74 23       	st.w [%a2],%d3

    return result;
800068d0:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
}
800068d4:	00 90       	ret 

800068d6 <IfxStm_initCompareConfig>:


void IfxStm_initCompareConfig(IfxStm_CompareConfig *config)
{
800068d6:	40 ae       	mov.aa %a14,%sp
800068d8:	20 08       	sub.a %sp,8
800068da:	b5 e4 fc ff 	st.a [%a14]-4,%a4
    config->comparator          = IfxStm_Comparator_0;
800068de:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800068e2:	82 02       	mov %d2,0
800068e4:	74 22       	st.w [%a2],%d2
    config->compareOffset       = IfxStm_ComparatorOffset_0;
800068e6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800068ea:	82 02       	mov %d2,0
800068ec:	d9 22 08 00 	lea %a2,[%a2]8
800068f0:	74 22       	st.w [%a2],%d2
    config->compareSize         = IfxStm_ComparatorSize_32Bits;
800068f2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800068f6:	3b f0 01 20 	mov %d2,31
800068fa:	d9 22 0c 00 	lea %a2,[%a2]12
800068fe:	74 22       	st.w [%a2],%d2
    config->comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;     /*User must select the interrupt output */
80006900:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006904:	82 02       	mov %d2,0
80006906:	b0 42       	add.a %a2,4
80006908:	74 22       	st.w [%a2],%d2
    config->ticks               = 0xFFFFFFFF;
8000690a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000690e:	82 f2       	mov %d2,-1
80006910:	d9 22 10 00 	lea %a2,[%a2]16
80006914:	74 22       	st.w [%a2],%d2
    config->triggerPriority     = 0;
80006916:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000691a:	82 02       	mov %d2,0
8000691c:	f9 22 14 00 	st.h [%a2]20,%d2
    config->typeOfService       = IfxSrc_Tos_cpu0;
80006920:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006924:	82 02       	mov %d2,0
80006926:	d9 22 18 00 	lea %a2,[%a2]24
8000692a:	74 22       	st.w [%a2],%d2
}
8000692c:	00 00       	nop 
8000692e:	00 90       	ret 

80006930 <IfxScuCcu_calRGainParameters>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuCcu_calRGainParameters(IfxScuCcu_ModulationAmplitude modamp, IfxScuCcu_RGain_Values *RGain_P)
{
80006930:	40 ae       	mov.aa %a14,%sp
80006932:	20 28       	sub.a %sp,40
80006934:	59 e4 dc ff 	st.w [%a14]-36,%d4
80006938:	b5 e4 d8 ff 	st.a [%a14]-40,%a4
    float32  mod_amp       = IfxScuCcu_MA_percent[modamp];
8000693c:	91 00 00 28 	movh.a %a2,32768
80006940:	d9 22 28 84 	lea %a2,[%a2]16936 <80004228 <IfxScuCcu_MA_percent>>
80006944:	19 e2 dc ff 	ld.w %d2,[%a14]-36 <80004228 <IfxScuCcu_MA_percent>>
80006948:	06 22       	sh %d2,2
8000694a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000694e:	54 22       	ld.w %d2,[%a2]
80006950:	59 e2 fc ff 	st.w [%a14]-4,%d2
    float32 *RGainNom_Temp = &(RGain_P->RGainNom);
80006954:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80006958:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    uint16  *RGain_Temp    = &(RGain_P->RGainHex);
8000695c:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80006960:	c2 42       	add %d2,4
80006962:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    Ifx_SCU *scu           = &MODULE_SCU;
80006966:	7b 30 00 2f 	movh %d2,61443
8000696a:	1b 02 00 26 	addi %d2,%d2,24576
8000696e:	59 e2 f0 ff 	st.w [%a14]-16,%d2

IFX_INLINE float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
80006972:	91 30 00 2f 	movh.a %a2,61443
80006976:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
8000697a:	54 22       	ld.w %d2,[%a2]
8000697c:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006980:	8f f2 0f 21 	and %d2,%d2,255
80006984:	df 02 0a 80 	jne %d2,0,80006998 <IfxScuCcu_calRGainParameters+0x68>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80006988:	7b f0 cb 24 	movh %d2,19647
8000698c:	1b 02 c2 2b 	addi %d2,%d2,-17376
80006990:	59 e2 e4 ff 	st.w [%a14]-28,%d2
80006994:	1d 00 2b 00 	j 800069ea <IfxScuCcu_calRGainParameters+0xba>
    }
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
80006998:	91 30 00 2f 	movh.a %a2,61443
8000699c:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
800069a0:	54 22       	ld.w %d2,[%a2]
800069a2:	37 02 62 2f 	extr.u %d2,%d2,30,2
800069a6:	8f f2 0f 21 	and %d2,%d2,255
800069aa:	df 12 0a 80 	jne %d2,1,800069be <IfxScuCcu_calRGainParameters+0x8e>
    {
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
800069ae:	7b 90 b9 24 	movh %d2,19353
800069b2:	1b 02 68 29 	addi %d2,%d2,-27008
800069b6:	59 e2 e4 ff 	st.w [%a14]-28,%d2
800069ba:	1d 00 18 00 	j 800069ea <IfxScuCcu_calRGainParameters+0xba>
    }
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
800069be:	91 30 00 2f 	movh.a %a2,61443
800069c2:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
800069c6:	54 22       	ld.w %d2,[%a2]
800069c8:	37 02 62 2f 	extr.u %d2,%d2,30,2
800069cc:	8f f2 0f 21 	and %d2,%d2,255
800069d0:	df 22 0a 80 	jne %d2,2,800069e4 <IfxScuCcu_calRGainParameters+0xb4>
    {
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
800069d4:	7b 90 b9 24 	movh %d2,19353
800069d8:	1b 02 68 29 	addi %d2,%d2,-27008
800069dc:	59 e2 e4 ff 	st.w [%a14]-28,%d2
800069e0:	1d 00 05 00 	j 800069ea <IfxScuCcu_calRGainParameters+0xba>
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
800069e4:	82 02       	mov %d2,0
800069e6:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    }

    return freq;
800069ea:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
    float32  Fosc_Hz       = IfxScuCcu_getOscFrequency();
800069ee:	59 e2 ec ff 	st.w [%a14]-20,%d2
    float32  Fdco_hz       = (Fosc_Hz * (scu->SYSPLLCON0.B.NDIV + 1)) / (scu->SYSPLLCON0.B.PDIV + 1);
800069f2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800069f6:	d9 22 18 00 	lea %a2,[%a2]24
800069fa:	54 22       	ld.w %d2,[%a2]
800069fc:	37 02 e7 24 	extr.u %d2,%d2,9,7
80006a00:	8f f2 0f 21 	and %d2,%d2,255
80006a04:	c2 12       	add %d2,1
80006a06:	4b 02 41 31 	itof %d3,%d2
80006a0a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80006a0e:	4b 23 41 30 	mul.f %d3,%d3,%d2
80006a12:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80006a16:	d9 22 18 00 	lea %a2,[%a2]24
80006a1a:	54 22       	ld.w %d2,[%a2]
80006a1c:	37 02 63 2c 	extr.u %d2,%d2,24,3
80006a20:	8f f2 0f 21 	and %d2,%d2,255
80006a24:	c2 12       	add %d2,1
80006a26:	4b 02 41 21 	itof %d2,%d2
80006a2a:	4b 23 51 20 	div.f %d2,%d3,%d2
80006a2e:	59 e2 e8 ff 	st.w [%a14]-24,%d2

    *RGainNom_Temp = IFXSCUCCU_GET_RGAIN_NOM(mod_amp, Fdco_hz);
80006a32:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80006a36:	7b 80 2c 34 	movh %d3,17096
80006a3a:	4b 32 51 20 	div.f %d2,%d2,%d3
80006a3e:	6b 02 21 32 	add.f %d3,%d2,%d2
80006a42:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80006a46:	7b c0 a5 44 	movh %d4,19036
80006a4a:	1b 04 a0 4b 	addi %d4,%d4,-17920
80006a4e:	4b 42 51 20 	div.f %d2,%d2,%d4
80006a52:	4b 23 41 20 	mul.f %d2,%d3,%d2
80006a56:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006a5a:	74 22       	st.w [%a2],%d2
    *RGain_Temp    = IFXSCUCCU_GET_RGAIN_HEX(*RGainNom_Temp);
80006a5c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006a60:	54 22       	ld.w %d2,[%a2]
80006a62:	7b 00 20 34 	movh %d3,16896
80006a66:	4b 32 41 20 	mul.f %d2,%d2,%d3
80006a6a:	7b 00 f0 33 	movh %d3,16128
80006a6e:	6b 03 21 22 	add.f %d2,%d2,%d3
80006a72:	4b 02 71 21 	ftouz %d2,%d2
80006a76:	37 02 70 20 	extr.u %d2,%d2,0,16
80006a7a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80006a7e:	b4 22       	st.h [%a2],%d2
}
80006a80:	00 00       	nop 
80006a82:	00 90       	ret 

80006a84 <IfxScuCcu_getAsclinSFrequency>:
    IfxScuCcu_distributeClockInline(clockDistributionConfig);
}


float32 IfxScuCcu_getAsclinSFrequency(void)
{
80006a84:	40 ae       	mov.aa %a14,%sp
80006a86:	20 18       	sub.a %sp,24
    float32 freq          = 0;
80006a88:	82 02       	mov %d2,0
80006a8a:	59 e2 fc ff 	st.w [%a14]-4,%d2
    float32 source        = 0;
80006a8e:	82 02       	mov %d2,0
80006a90:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    uint8   asclindiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
80006a94:	91 00 00 28 	movh.a %a2,32768
80006a98:	d9 23 b8 40 	lea %a3,[%a2]2360 <80000938 <IfxCpu_Trap_vectorTable0_end+0x744>>
80006a9c:	d9 e2 e8 ff 	lea %a2,[%a14]-24 <80000938 <IfxCpu_Trap_vectorTable0_end+0x744>>
80006aa0:	04 32       	ld.bu %d2,[%a3+]
80006aa2:	24 22       	st.b [%a2+],%d2
80006aa4:	04 32       	ld.bu %d2,[%a3+]
80006aa6:	24 22       	st.b [%a2+],%d2
80006aa8:	04 32       	ld.bu %d2,[%a3+]
80006aaa:	24 22       	st.b [%a2+],%d2
80006aac:	04 32       	ld.bu %d2,[%a3+]
80006aae:	24 22       	st.b [%a2+],%d2
80006ab0:	04 32       	ld.bu %d2,[%a3+]
80006ab2:	24 22       	st.b [%a2+],%d2
80006ab4:	04 32       	ld.bu %d2,[%a3+]
80006ab6:	24 22       	st.b [%a2+],%d2
80006ab8:	04 32       	ld.bu %d2,[%a3+]
80006aba:	24 22       	st.b [%a2+],%d2
80006abc:	04 32       	ld.bu %d2,[%a3+]
80006abe:	24 22       	st.b [%a2+],%d2
80006ac0:	04 32       	ld.bu %d2,[%a3+]
80006ac2:	24 22       	st.b [%a2+],%d2
80006ac4:	04 32       	ld.bu %d2,[%a3+]
80006ac6:	24 22       	st.b [%a2+],%d2
80006ac8:	04 32       	ld.bu %d2,[%a3+]
80006aca:	24 22       	st.b [%a2+],%d2
80006acc:	04 32       	ld.bu %d2,[%a3+]
80006ace:	24 22       	st.b [%a2+],%d2
80006ad0:	04 32       	ld.bu %d2,[%a3+]
80006ad2:	24 22       	st.b [%a2+],%d2
80006ad4:	04 32       	ld.bu %d2,[%a3+]
80006ad6:	24 22       	st.b [%a2+],%d2
80006ad8:	04 32       	ld.bu %d2,[%a3+]
80006ada:	24 22       	st.b [%a2+],%d2
80006adc:	04 32       	ld.bu %d2,[%a3+]
80006ade:	24 22       	st.b [%a2+],%d2

    switch (SCU_CCUCON2.B.CLKSELASCLINS)
80006ae0:	91 30 00 2f 	movh.a %a2,61443
80006ae4:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80006ae8:	54 22       	ld.w %d2,[%a2]
80006aea:	37 02 62 26 	extr.u %d2,%d2,12,2
80006aee:	8f f2 0f 21 	and %d2,%d2,255
80006af2:	df 12 06 00 	jeq %d2,1,80006afe <IfxScuCcu_getAsclinSFrequency+0x7a>
80006af6:	df 22 2c 00 	jeq %d2,2,80006b4e <IfxScuCcu_getAsclinSFrequency+0xca>
    {
        freq = IfxScuCcu_getOsc0Frequency();
    }
    break;
    default:
        break;
80006afa:	1d 00 33 00 	j 80006b60 <IfxScuCcu_getAsclinSFrequency+0xdc>
        source = IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_1);
80006afe:	82 14       	mov %d4,1
80006b00:	6d 00 d8 01 	call 80006eb0 <IfxScuCcu_getSourceFrequency>
80006b04:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        if (SCU_CCUCON2.B.ASCLINSDIV)
80006b08:	91 30 00 2f 	movh.a %a2,61443
80006b0c:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80006b10:	54 22       	ld.w %d2,[%a2]
80006b12:	37 02 64 24 	extr.u %d2,%d2,8,4
80006b16:	8f f2 0f 21 	and %d2,%d2,255
80006b1a:	df 02 22 00 	jeq %d2,0,80006b5e <IfxScuCcu_getAsclinSFrequency+0xda>
            freq = source / asclindiv[SCU_CCUCON2.B.ASCLINSDIV];
80006b1e:	91 30 00 2f 	movh.a %a2,61443
80006b22:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80006b26:	54 22       	ld.w %d2,[%a2]
80006b28:	37 02 64 24 	extr.u %d2,%d2,8,4
80006b2c:	8f f2 0f 21 	and %d2,%d2,255
80006b30:	d9 e2 e8 ff 	lea %a2,[%a14]-24
80006b34:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80006b38:	14 22       	ld.bu %d2,[%a2]
80006b3a:	4b 02 41 21 	itof %d2,%d2
80006b3e:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80006b42:	4b 23 51 20 	div.f %d2,%d3,%d2
80006b46:	59 e2 fc ff 	st.w [%a14]-4,%d2
    break;
80006b4a:	1d 00 0a 00 	j 80006b5e <IfxScuCcu_getAsclinSFrequency+0xda>
    return (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
80006b4e:	7b 90 b9 24 	movh %d2,19353
80006b52:	1b 02 68 29 	addi %d2,%d2,-27008
        freq = IfxScuCcu_getOsc0Frequency();
80006b56:	59 e2 fc ff 	st.w [%a14]-4,%d2
    break;
80006b5a:	1d 00 03 00 	j 80006b60 <IfxScuCcu_getAsclinSFrequency+0xdc>
    break;
80006b5e:	00 00       	nop 
    }

    return freq;
80006b60:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
80006b64:	00 90       	ret 

80006b66 <IfxScuCcu_getPerPllFrequency1>:
    return mscFreq;
}


float32 IfxScuCcu_getPerPllFrequency1(void)
{
80006b66:	40 ae       	mov.aa %a14,%sp
80006b68:	20 10       	sub.a %sp,16
    Ifx_SCU *scu = &MODULE_SCU;
80006b6a:	7b 30 00 2f 	movh %d2,61443
80006b6e:	1b 02 00 26 	addi %d2,%d2,24576
80006b72:	59 e2 fc ff 	st.w [%a14]-4,%d2
    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
80006b76:	91 30 00 2f 	movh.a %a2,61443
80006b7a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006b7e:	54 22       	ld.w %d2,[%a2]
80006b80:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006b84:	8f f2 0f 21 	and %d2,%d2,255
80006b88:	df 02 0a 80 	jne %d2,0,80006b9c <IfxScuCcu_getPerPllFrequency1+0x36>
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80006b8c:	7b f0 cb 24 	movh %d2,19647
80006b90:	1b 02 c2 2b 	addi %d2,%d2,-17376
80006b94:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006b98:	1d 00 2b 00 	j 80006bee <IfxScuCcu_getPerPllFrequency1+0x88>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
80006b9c:	91 30 00 2f 	movh.a %a2,61443
80006ba0:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006ba4:	54 22       	ld.w %d2,[%a2]
80006ba6:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006baa:	8f f2 0f 21 	and %d2,%d2,255
80006bae:	df 12 0a 80 	jne %d2,1,80006bc2 <IfxScuCcu_getPerPllFrequency1+0x5c>
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
80006bb2:	7b 90 b9 24 	movh %d2,19353
80006bb6:	1b 02 68 29 	addi %d2,%d2,-27008
80006bba:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006bbe:	1d 00 18 00 	j 80006bee <IfxScuCcu_getPerPllFrequency1+0x88>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
80006bc2:	91 30 00 2f 	movh.a %a2,61443
80006bc6:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006bca:	54 22       	ld.w %d2,[%a2]
80006bcc:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006bd0:	8f f2 0f 21 	and %d2,%d2,255
80006bd4:	df 22 0a 80 	jne %d2,2,80006be8 <IfxScuCcu_getPerPllFrequency1+0x82>
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
80006bd8:	7b 90 b9 24 	movh %d2,19353
80006bdc:	1b 02 68 29 	addi %d2,%d2,-27008
80006be0:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006be4:	1d 00 05 00 	j 80006bee <IfxScuCcu_getPerPllFrequency1+0x88>
        freq = 0.0f;
80006be8:	82 02       	mov %d2,0
80006bea:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return freq;
80006bee:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
    float32  pllFrequency1;
    float32  oscFreq;
    oscFreq       = IfxScuCcu_getOscFrequency();
80006bf2:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    pllFrequency1 = (oscFreq * (scu->PERPLLCON0.B.NDIV + 1)) / ((scu->PERPLLCON0.B.PDIV + 1) * (scu->PERPLLCON1.B.K2DIV + 1));
80006bf6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006bfa:	d9 22 28 00 	lea %a2,[%a2]40
80006bfe:	54 22       	ld.w %d2,[%a2]
80006c00:	37 02 e7 24 	extr.u %d2,%d2,9,7
80006c04:	8f f2 0f 21 	and %d2,%d2,255
80006c08:	c2 12       	add %d2,1
80006c0a:	4b 02 41 31 	itof %d3,%d2
80006c0e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80006c12:	4b 23 41 30 	mul.f %d3,%d3,%d2
80006c16:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006c1a:	d9 22 28 00 	lea %a2,[%a2]40
80006c1e:	54 22       	ld.w %d2,[%a2]
80006c20:	37 02 63 2c 	extr.u %d2,%d2,24,3
80006c24:	8f f2 0f 21 	and %d2,%d2,255
80006c28:	1b 12 00 40 	addi %d4,%d2,1
80006c2c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006c30:	d9 22 2c 00 	lea %a2,[%a2]44
80006c34:	54 22       	ld.w %d2,[%a2]
80006c36:	37 02 63 20 	extr.u %d2,%d2,0,3
80006c3a:	8f f2 0f 21 	and %d2,%d2,255
80006c3e:	c2 12       	add %d2,1
80006c40:	e2 42       	mul %d2,%d4
80006c42:	4b 02 41 21 	itof %d2,%d2
80006c46:	4b 23 51 20 	div.f %d2,%d3,%d2
80006c4a:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    return pllFrequency1;
80006c4e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
}
80006c52:	00 90       	ret 

80006c54 <IfxScuCcu_getPerPllFrequency2>:


float32 IfxScuCcu_getPerPllFrequency2(void)
{
80006c54:	40 ae       	mov.aa %a14,%sp
80006c56:	20 10       	sub.a %sp,16
    Ifx_SCU *scu = &MODULE_SCU;
80006c58:	7b 30 00 2f 	movh %d2,61443
80006c5c:	1b 02 00 26 	addi %d2,%d2,24576
80006c60:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
80006c64:	91 30 00 2f 	movh.a %a2,61443
80006c68:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006c6c:	54 22       	ld.w %d2,[%a2]
80006c6e:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006c72:	8f f2 0f 21 	and %d2,%d2,255
80006c76:	df 02 0a 80 	jne %d2,0,80006c8a <IfxScuCcu_getPerPllFrequency2+0x36>
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80006c7a:	7b f0 cb 24 	movh %d2,19647
80006c7e:	1b 02 c2 2b 	addi %d2,%d2,-17376
80006c82:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006c86:	1d 00 2b 00 	j 80006cdc <IfxScuCcu_getPerPllFrequency2+0x88>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
80006c8a:	91 30 00 2f 	movh.a %a2,61443
80006c8e:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006c92:	54 22       	ld.w %d2,[%a2]
80006c94:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006c98:	8f f2 0f 21 	and %d2,%d2,255
80006c9c:	df 12 0a 80 	jne %d2,1,80006cb0 <IfxScuCcu_getPerPllFrequency2+0x5c>
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
80006ca0:	7b 90 b9 24 	movh %d2,19353
80006ca4:	1b 02 68 29 	addi %d2,%d2,-27008
80006ca8:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006cac:	1d 00 18 00 	j 80006cdc <IfxScuCcu_getPerPllFrequency2+0x88>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
80006cb0:	91 30 00 2f 	movh.a %a2,61443
80006cb4:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006cb8:	54 22       	ld.w %d2,[%a2]
80006cba:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006cbe:	8f f2 0f 21 	and %d2,%d2,255
80006cc2:	df 22 0a 80 	jne %d2,2,80006cd6 <IfxScuCcu_getPerPllFrequency2+0x82>
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
80006cc6:	7b 90 b9 24 	movh %d2,19353
80006cca:	1b 02 68 29 	addi %d2,%d2,-27008
80006cce:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006cd2:	1d 00 05 00 	j 80006cdc <IfxScuCcu_getPerPllFrequency2+0x88>
        freq = 0.0f;
80006cd6:	82 02       	mov %d2,0
80006cd8:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return freq;
80006cdc:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
    float32  pllFrequency2;
    float32  oscFreq;
    oscFreq = IfxScuCcu_getOscFrequency();
80006ce0:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    if (!(scu->PERPLLCON0.B.DIVBY))
80006ce4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006ce8:	d9 22 28 00 	lea %a2,[%a2]40
80006cec:	54 22       	ld.w %d2,[%a2]
80006cee:	37 02 61 20 	extr.u %d2,%d2,0,1
80006cf2:	8f f2 0f 21 	and %d2,%d2,255
80006cf6:	df 02 36 80 	jne %d2,0,80006d62 <IfxScuCcu_getPerPllFrequency2+0x10e>
    {
        pllFrequency2 = (oscFreq * (scu->PERPLLCON0.B.NDIV + 1)) / ((scu->PERPLLCON0.B.PDIV + 1) * (scu->PERPLLCON1.B.K3DIV + 1) * 1.6f);
80006cfa:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006cfe:	d9 22 28 00 	lea %a2,[%a2]40
80006d02:	54 22       	ld.w %d2,[%a2]
80006d04:	37 02 e7 24 	extr.u %d2,%d2,9,7
80006d08:	8f f2 0f 21 	and %d2,%d2,255
80006d0c:	c2 12       	add %d2,1
80006d0e:	4b 02 41 31 	itof %d3,%d2
80006d12:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80006d16:	4b 23 41 30 	mul.f %d3,%d3,%d2
80006d1a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006d1e:	d9 22 28 00 	lea %a2,[%a2]40
80006d22:	54 22       	ld.w %d2,[%a2]
80006d24:	37 02 63 2c 	extr.u %d2,%d2,24,3
80006d28:	8f f2 0f 21 	and %d2,%d2,255
80006d2c:	1b 12 00 40 	addi %d4,%d2,1
80006d30:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006d34:	d9 22 2c 00 	lea %a2,[%a2]44
80006d38:	54 22       	ld.w %d2,[%a2]
80006d3a:	37 02 63 24 	extr.u %d2,%d2,8,3
80006d3e:	8f f2 0f 21 	and %d2,%d2,255
80006d42:	c2 12       	add %d2,1
80006d44:	e2 42       	mul %d2,%d4
80006d46:	4b 02 41 21 	itof %d2,%d2
80006d4a:	7b d0 fc 43 	movh %d4,16333
80006d4e:	1b d4 cc 4c 	addi %d4,%d4,-13107
80006d52:	4b 42 41 20 	mul.f %d2,%d2,%d4
80006d56:	4b 23 51 20 	div.f %d2,%d3,%d2
80006d5a:	59 e2 fc ff 	st.w [%a14]-4,%d2
80006d5e:	1d 00 2f 00 	j 80006dbc <IfxScuCcu_getPerPllFrequency2+0x168>
    }
    else
    {
        pllFrequency2 = (oscFreq * (scu->PERPLLCON0.B.NDIV + 1)) / ((scu->PERPLLCON0.B.PDIV + 1) * (scu->PERPLLCON1.B.K3DIV + 1) * 2);
80006d62:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006d66:	d9 22 28 00 	lea %a2,[%a2]40
80006d6a:	54 22       	ld.w %d2,[%a2]
80006d6c:	37 02 e7 24 	extr.u %d2,%d2,9,7
80006d70:	8f f2 0f 21 	and %d2,%d2,255
80006d74:	c2 12       	add %d2,1
80006d76:	4b 02 41 31 	itof %d3,%d2
80006d7a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80006d7e:	4b 23 41 30 	mul.f %d3,%d3,%d2
80006d82:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006d86:	d9 22 28 00 	lea %a2,[%a2]40
80006d8a:	54 22       	ld.w %d2,[%a2]
80006d8c:	37 02 63 2c 	extr.u %d2,%d2,24,3
80006d90:	8f f2 0f 21 	and %d2,%d2,255
80006d94:	1b 12 00 40 	addi %d4,%d2,1
80006d98:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006d9c:	d9 22 2c 00 	lea %a2,[%a2]44
80006da0:	54 22       	ld.w %d2,[%a2]
80006da2:	37 02 63 24 	extr.u %d2,%d2,8,3
80006da6:	8f f2 0f 21 	and %d2,%d2,255
80006daa:	c2 12       	add %d2,1
80006dac:	e2 42       	mul %d2,%d4
80006dae:	06 12       	sh %d2,1
80006db0:	4b 02 41 21 	itof %d2,%d2
80006db4:	4b 23 51 20 	div.f %d2,%d3,%d2
80006db8:	59 e2 fc ff 	st.w [%a14]-4,%d2
    }

    return pllFrequency2;
80006dbc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
80006dc0:	00 90       	ret 

80006dc2 <IfxScuCcu_getPllFrequency>:


float32 IfxScuCcu_getPllFrequency(void)
{
80006dc2:	40 ae       	mov.aa %a14,%sp
80006dc4:	20 10       	sub.a %sp,16
    Ifx_SCU *scu = &MODULE_SCU;
80006dc6:	7b 30 00 2f 	movh %d2,61443
80006dca:	1b 02 00 26 	addi %d2,%d2,24576
80006dce:	59 e2 fc ff 	st.w [%a14]-4,%d2
    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
80006dd2:	91 30 00 2f 	movh.a %a2,61443
80006dd6:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006dda:	54 22       	ld.w %d2,[%a2]
80006ddc:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006de0:	8f f2 0f 21 	and %d2,%d2,255
80006de4:	df 02 0a 80 	jne %d2,0,80006df8 <IfxScuCcu_getPllFrequency+0x36>
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80006de8:	7b f0 cb 24 	movh %d2,19647
80006dec:	1b 02 c2 2b 	addi %d2,%d2,-17376
80006df0:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006df4:	1d 00 2b 00 	j 80006e4a <IfxScuCcu_getPllFrequency+0x88>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
80006df8:	91 30 00 2f 	movh.a %a2,61443
80006dfc:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006e00:	54 22       	ld.w %d2,[%a2]
80006e02:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006e06:	8f f2 0f 21 	and %d2,%d2,255
80006e0a:	df 12 0a 80 	jne %d2,1,80006e1e <IfxScuCcu_getPllFrequency+0x5c>
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
80006e0e:	7b 90 b9 24 	movh %d2,19353
80006e12:	1b 02 68 29 	addi %d2,%d2,-27008
80006e16:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006e1a:	1d 00 18 00 	j 80006e4a <IfxScuCcu_getPllFrequency+0x88>
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
80006e1e:	91 30 00 2f 	movh.a %a2,61443
80006e22:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80006e26:	54 22       	ld.w %d2,[%a2]
80006e28:	37 02 62 2f 	extr.u %d2,%d2,30,2
80006e2c:	8f f2 0f 21 	and %d2,%d2,255
80006e30:	df 22 0a 80 	jne %d2,2,80006e44 <IfxScuCcu_getPllFrequency+0x82>
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
80006e34:	7b 90 b9 24 	movh %d2,19353
80006e38:	1b 02 68 29 	addi %d2,%d2,-27008
80006e3c:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80006e40:	1d 00 05 00 	j 80006e4a <IfxScuCcu_getPllFrequency+0x88>
        freq = 0.0f;
80006e44:	82 02       	mov %d2,0
80006e46:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return freq;
80006e4a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80006e4e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    freq    = (oscFreq * (scu->SYSPLLCON0.B.NDIV + 1)) / ((scu->SYSPLLCON1.B.K2DIV + 1) * (scu->SYSPLLCON0.B.PDIV + 1));
80006e52:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006e56:	d9 22 18 00 	lea %a2,[%a2]24
80006e5a:	54 22       	ld.w %d2,[%a2]
80006e5c:	37 02 e7 24 	extr.u %d2,%d2,9,7
80006e60:	8f f2 0f 21 	and %d2,%d2,255
80006e64:	c2 12       	add %d2,1
80006e66:	4b 02 41 31 	itof %d3,%d2
80006e6a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80006e6e:	4b 23 41 30 	mul.f %d3,%d3,%d2
80006e72:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006e76:	d9 22 1c 00 	lea %a2,[%a2]28
80006e7a:	54 22       	ld.w %d2,[%a2]
80006e7c:	37 02 63 20 	extr.u %d2,%d2,0,3
80006e80:	8f f2 0f 21 	and %d2,%d2,255
80006e84:	1b 12 00 40 	addi %d4,%d2,1
80006e88:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006e8c:	d9 22 18 00 	lea %a2,[%a2]24
80006e90:	54 22       	ld.w %d2,[%a2]
80006e92:	37 02 63 2c 	extr.u %d2,%d2,24,3
80006e96:	8f f2 0f 21 	and %d2,%d2,255
80006e9a:	c2 12       	add %d2,1
80006e9c:	e2 42       	mul %d2,%d4
80006e9e:	4b 02 41 21 	itof %d2,%d2
80006ea2:	4b 23 51 20 	div.f %d2,%d3,%d2
80006ea6:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    return freq;
80006eaa:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
}
80006eae:	00 90       	ret 

80006eb0 <IfxScuCcu_getSourceFrequency>:
    return freq;
}


float32 IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource fsource)
{
80006eb0:	40 ae       	mov.aa %a14,%sp
80006eb2:	20 10       	sub.a %sp,16
80006eb4:	59 e4 f4 ff 	st.w [%a14]-12,%d4
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80006eb8:	91 30 00 2f 	movh.a %a2,61443
80006ebc:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80006ec0:	54 22       	ld.w %d2,[%a2]
80006ec2:	37 02 62 2e 	extr.u %d2,%d2,28,2
80006ec6:	8f f2 0f 21 	and %d2,%d2,255
80006eca:	df 02 06 00 	jeq %d2,0,80006ed6 <IfxScuCcu_getSourceFrequency+0x26>
80006ece:	df 12 0c 00 	jeq %d2,1,80006ee6 <IfxScuCcu_getSourceFrequency+0x36>
80006ed2:	1d 00 49 00 	j 80006f64 <IfxScuCcu_getSourceFrequency+0xb4>
    return IFXSCU_EVR_OSC_FREQUENCY;
80006ed6:	7b f0 cb 24 	movh %d2,19647
80006eda:	1b 02 c2 2b 	addi %d2,%d2,-17376
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80006ede:	59 e2 fc ff 	st.w [%a14]-4,%d2
        break;
80006ee2:	1d 00 45 00 	j 80006f6c <IfxScuCcu_getSourceFrequency+0xbc>
80006ee6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80006eea:	df 22 2f 00 	jeq %d2,2,80006f48 <IfxScuCcu_getSourceFrequency+0x98>
80006eee:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80006ef2:	ff 32 31 80 	jge.u %d2,3,80006f54 <IfxScuCcu_getSourceFrequency+0xa4>
80006ef6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80006efa:	df 02 08 00 	jeq %d2,0,80006f0a <IfxScuCcu_getSourceFrequency+0x5a>
80006efe:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80006f02:	df 12 0a 00 	jeq %d2,1,80006f16 <IfxScuCcu_getSourceFrequency+0x66>
80006f06:	1d 00 27 00 	j 80006f54 <IfxScuCcu_getSourceFrequency+0xa4>
    case IfxScu_CCUCON0_CLKSEL_fPll:

        switch (fsource)
        {
        case IfxScuCcu_Fsource_0:
            sourcefreq = IfxScuCcu_getPllFrequency();
80006f0a:	6d ff 5c ff 	call 80006dc2 <IfxScuCcu_getPllFrequency>
80006f0e:	59 e2 fc ff 	st.w [%a14]-4,%d2
            break;
80006f12:	1d 00 27 00 	j 80006f60 <IfxScuCcu_getSourceFrequency+0xb0>
        case IfxScuCcu_Fsource_1:
            sourcefreq = IfxScuCcu_getPerPllFrequency1();
80006f16:	6d ff 28 fe 	call 80006b66 <IfxScuCcu_getPerPllFrequency1>
80006f1a:	59 e2 fc ff 	st.w [%a14]-4,%d2

            if (SCU_CCUCON1.B.PLL1DIVDIS == 0)
80006f1e:	91 30 00 2f 	movh.a %a2,61443
80006f22:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80006f26:	54 22       	ld.w %d2,[%a2]
80006f28:	37 02 e1 23 	extr.u %d2,%d2,7,1
80006f2c:	8f f2 0f 21 	and %d2,%d2,255
80006f30:	df 02 17 80 	jne %d2,0,80006f5e <IfxScuCcu_getSourceFrequency+0xae>
            {
                sourcefreq = sourcefreq / 2.0f;
80006f34:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80006f38:	7b 00 00 34 	movh %d3,16384
80006f3c:	4b 32 51 20 	div.f %d2,%d2,%d3
80006f40:	59 e2 fc ff 	st.w [%a14]-4,%d2
            }

            break;
80006f44:	1d 00 0d 00 	j 80006f5e <IfxScuCcu_getSourceFrequency+0xae>
        case IfxScuCcu_Fsource_2:
            sourcefreq = IfxScuCcu_getPerPllFrequency2();
80006f48:	6d ff 86 fe 	call 80006c54 <IfxScuCcu_getPerPllFrequency2>
80006f4c:	59 e2 fc ff 	st.w [%a14]-4,%d2
            break;
80006f50:	1d 00 08 00 	j 80006f60 <IfxScuCcu_getSourceFrequency+0xb0>
        default:
            sourcefreq = 0;
80006f54:	82 02       	mov %d2,0
80006f56:	59 e2 fc ff 	st.w [%a14]-4,%d2
            break;
80006f5a:	1d 00 03 00 	j 80006f60 <IfxScuCcu_getSourceFrequency+0xb0>
            break;
80006f5e:	00 00       	nop 
        }

        break;
80006f60:	1d 00 06 00 	j 80006f6c <IfxScuCcu_getSourceFrequency+0xbc>
    default:
        sourcefreq = 0;
80006f64:	82 02       	mov %d2,0
80006f66:	59 e2 fc ff 	st.w [%a14]-4,%d2
        break;
80006f6a:	00 00       	nop 
    }

    return sourcefreq;
80006f6c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
80006f70:	00 90       	ret 

80006f72 <IfxScuCcu_init>:
    return sriFrequency;
}


boolean IfxScuCcu_init(const IfxScuCcu_Config *config)
{
80006f72:	40 ae       	mov.aa %a14,%sp
80006f74:	20 b0       	sub.a %sp,176
80006f76:	b5 e4 d4 df 	st.a [%a14]-172,%a4
    boolean status = 0;
80006f7a:	82 02       	mov %d2,0
80006f7c:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    status = IfxScuCcu_configureCcuInitialStep(&config->pllInitialStepConfig);
80006f80:	19 e2 d4 df 	ld.w %d2,[%a14]-172
80006f84:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    uint8                                initError = 0;
80006f88:	82 02       	mov %d2,0
80006f8a:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
    pllsParamCfg   = &pllInitStepCfg->pllsParameters;
80006f8e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80006f92:	59 e2 f0 ff 	st.w [%a14]-16,%d2


IFX_INLINE uint16 IfxScuWdt_getSafetyWatchdogPasswordInline(void)
{
    uint16        password;
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;
80006f96:	7b 30 00 2f 	movh %d2,61443
80006f9a:	1b 82 2a 26 	addi %d2,%d2,25256
80006f9e:	59 e2 ec ff 	st.w [%a14]-20,%d2

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
80006fa2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80006fa6:	54 22       	ld.w %d2,[%a2]
80006fa8:	37 02 6e 21 	extr.u %d2,%d2,2,14
80006fac:	37 02 70 20 	extr.u %d2,%d2,0,16
80006fb0:	f9 e2 ea ff 	st.h [%a14]-22,%d2
    password ^= 0x003F;
80006fb4:	c9 e2 ea ff 	ld.h %d2,[%a14]-22
80006fb8:	8f f2 83 21 	xor %d2,%d2,63
80006fbc:	f9 e2 ea ff 	st.h [%a14]-22,%d2

    return password;
80006fc0:	b9 e2 ea ff 	ld.hu %d2,[%a14]-22
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();
80006fc4:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);
80006fc8:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
80006fcc:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
    if (SCU_WDTS_CON0.B.LCK)
80006fd0:	91 30 00 2f 	movh.a %a2,61443
80006fd4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80006fd8:	54 22       	ld.w %d2,[%a2]
80006fda:	37 02 e1 20 	extr.u %d2,%d2,1,1
80006fde:	8f f2 0f 21 	and %d2,%d2,255
80006fe2:	df 02 18 00 	jeq %d2,0,80007012 <IfxScuCcu_init+0xa0>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80006fe6:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
80006fea:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80006fec:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80006ff0:	91 30 00 2f 	movh.a %a2,61443
80006ff4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80006ff8:	54 22       	ld.w %d2,[%a2]
80006ffa:	37 02 70 28 	extr.u %d2,%d2,16,16
80006ffe:	37 02 70 20 	extr.u %d2,%d2,0,16
80007002:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007006:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007008:	91 30 00 2f 	movh.a %a2,61443
8000700c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007010:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007012:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007016:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80007018:	8f 22 40 31 	or %d3,%d2,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000701c:	91 30 00 2f 	movh.a %a2,61443
80007020:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007024:	54 22       	ld.w %d2,[%a2]
80007026:	37 02 70 28 	extr.u %d2,%d2,16,16
8000702a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000702e:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007032:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007034:	91 30 00 2f 	movh.a %a2,61443
80007038:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000703c:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000703e:	00 00       	nop 
80007040:	91 30 00 2f 	movh.a %a2,61443
80007044:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007048:	54 22       	ld.w %d2,[%a2]
8000704a:	37 02 61 20 	extr.u %d2,%d2,0,1
8000704e:	8f f2 0f 21 	and %d2,%d2,255
80007052:	df 12 f7 7f 	jeq %d2,1,80007040 <IfxScuCcu_init+0xce>
}
80007056:	00 00       	nop 
    timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007058:	3b 00 00 21 	mov %d2,4096
8000705c:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    while (SCU_CCUCON0.B.LCK != 0U)
80007060:	1d 00 10 00 	j 80007080 <IfxScuCcu_init+0x10e>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007064:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80007068:	c2 f2       	add %d2,-1
8000706a:	59 e2 e0 ff 	st.w [%a14]-32,%d2
8000706e:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80007072:	ff 12 07 00 	jge %d2,1,80007080 <IfxScuCcu_init+0x10e>
80007076:	82 12       	mov %d2,1
80007078:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
8000707c:	1d 00 0d 00 	j 80007096 <IfxScuCcu_init+0x124>
    while (SCU_CCUCON0.B.LCK != 0U)
80007080:	91 30 00 2f 	movh.a %a2,61443
80007084:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80007088:	54 22       	ld.w %d2,[%a2]
8000708a:	37 02 e1 2f 	extr.u %d2,%d2,31,1
8000708e:	8f f2 0f 21 	and %d2,%d2,255
80007092:	df 02 e9 ff 	jne %d2,0,80007064 <IfxScuCcu_init+0xf2>
        scuCcucon0.U        = SCU_CCUCON0.U;
80007096:	91 30 00 2f 	movh.a %a2,61443
8000709a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000709e:	54 22       	ld.w %d2,[%a2]
800070a0:	59 e2 ec df 	st.w [%a14]-148 <f0036030 <bmhd_3_copy+0x40c34a30>>,%d2
        scuCcucon0.B.CLKSEL = 0; /*Select the EVR as fsource0/1/2 for the clock distribution */
800070a4:	19 e2 ec df 	ld.w %d2,[%a14]-148 <f0036030 <bmhd_3_copy+0x40c34a30>>
800070a8:	7b 00 00 3d 	movh %d3,53248
800070ac:	c2 f3       	add %d3,-1
800070ae:	26 32       	and %d2,%d3
800070b0:	59 e2 ec df 	st.w [%a14]-148,%d2
        scuCcucon0.B.UP     = 1; /*Update the ccucon0 register */
800070b4:	19 e2 ec df 	ld.w %d2,[%a14]-148
800070b8:	b7 12 01 2f 	insert %d2,%d2,1,30,1
800070bc:	59 e2 ec df 	st.w [%a14]-148,%d2
        SCU_CCUCON0.U       = scuCcucon0.U;
800070c0:	91 30 00 2f 	movh.a %a2,61443
800070c4:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800070c8:	19 e2 ec df 	ld.w %d2,[%a14]-148 <f0036030 <bmhd_3_copy+0x40c34a30>>
800070cc:	74 22       	st.w [%a2],%d2
    timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800070ce:	3b 00 00 21 	mov %d2,4096
800070d2:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    while (SCU_CCUCON0.B.LCK != 0U)
800070d6:	1d 00 10 00 	j 800070f6 <IfxScuCcu_init+0x184>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800070da:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800070de:	c2 f2       	add %d2,-1
800070e0:	59 e2 e0 ff 	st.w [%a14]-32,%d2
800070e4:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800070e8:	ff 12 07 00 	jge %d2,1,800070f6 <IfxScuCcu_init+0x184>
800070ec:	82 12       	mov %d2,1
800070ee:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
800070f2:	1d 00 0d 00 	j 8000710c <IfxScuCcu_init+0x19a>
    while (SCU_CCUCON0.B.LCK != 0U)
800070f6:	91 30 00 2f 	movh.a %a2,61443
800070fa:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800070fe:	54 22       	ld.w %d2,[%a2]
80007100:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007104:	8f f2 0f 21 	and %d2,%d2,255
80007108:	df 02 e9 ff 	jne %d2,0,800070da <IfxScuCcu_init+0x168>
        SMU_KEYS.U    = (uint32)0xBCU;        /* Enable access to SMU registers */
8000710c:	91 30 00 2f 	movh.a %a2,61443
80007110:	d9 22 b4 06 	lea %a2,[%a2]26676 <f0036834 <bmhd_3_copy+0x40c35234>>
80007114:	3b c0 0b 20 	mov %d2,188
80007118:	74 22       	st.w [%a2],%d2
        SMU_AG8CF0.U &= ~IFXSCUCCU_SMUALARM_MASK;
8000711a:	91 30 00 2f 	movh.a %a2,61443
8000711e:	d9 22 a0 56 	lea %a2,[%a2]26976 <f0036960 <bmhd_3_copy+0x40c35360>>
80007122:	54 22       	ld.w %d2,[%a2]
80007124:	91 30 00 2f 	movh.a %a2,61443
80007128:	d9 22 a0 56 	lea %a2,[%a2]26976 <f0036960 <bmhd_3_copy+0x40c35360>>
8000712c:	8f d2 c1 21 	andn %d2,%d2,29
80007130:	74 22       	st.w [%a2],%d2
        SMU_AG8CF1.U &= ~IFXSCUCCU_SMUALARM_MASK;
80007132:	91 30 00 2f 	movh.a %a2,61443
80007136:	d9 22 a4 56 	lea %a2,[%a2]26980 <f0036964 <bmhd_3_copy+0x40c35364>>
8000713a:	54 22       	ld.w %d2,[%a2]
8000713c:	91 30 00 2f 	movh.a %a2,61443
80007140:	d9 22 a4 56 	lea %a2,[%a2]26980 <f0036964 <bmhd_3_copy+0x40c35364>>
80007144:	8f d2 c1 21 	andn %d2,%d2,29
80007148:	74 22       	st.w [%a2],%d2
        SMU_AG8CF2.U &= ~IFXSCUCCU_SMUALARM_MASK;
8000714a:	91 30 00 2f 	movh.a %a2,61443
8000714e:	d9 22 a8 56 	lea %a2,[%a2]26984 <f0036968 <bmhd_3_copy+0x40c35368>>
80007152:	54 22       	ld.w %d2,[%a2]
80007154:	91 30 00 2f 	movh.a %a2,61443
80007158:	d9 22 a8 56 	lea %a2,[%a2]26984 <f0036968 <bmhd_3_copy+0x40c35368>>
8000715c:	8f d2 c1 21 	andn %d2,%d2,29
80007160:	74 22       	st.w [%a2],%d2
        SMU_KEYS.U    = (uint32)0U;
80007162:	91 30 00 2f 	movh.a %a2,61443
80007166:	d9 22 b4 06 	lea %a2,[%a2]26676 <f0036834 <bmhd_3_copy+0x40c35234>>
8000716a:	82 02       	mov %d2,0
8000716c:	74 22       	st.w [%a2],%d2
    SCU_SYSPLLCON0.B.PLLPWD = 0;
8000716e:	91 30 00 2f 	movh.a %a2,61443
80007172:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80007176:	54 22       	ld.w %d2,[%a2]
80007178:	7b f0 ff 3f 	movh %d3,65535
8000717c:	c2 f3       	add %d3,-1
8000717e:	26 32       	and %d2,%d3
80007180:	74 22       	st.w [%a2],%d2
    SCU_PERPLLCON0.B.PLLPWD = 0;
80007182:	91 30 00 2f 	movh.a %a2,61443
80007186:	d9 22 28 06 	lea %a2,[%a2]24616 <f0036028 <bmhd_3_copy+0x40c34a28>>
8000718a:	54 22       	ld.w %d2,[%a2]
8000718c:	7b f0 ff 3f 	movh %d3,65535
80007190:	c2 f3       	add %d3,-1
80007192:	26 32       	and %d2,%d3
80007194:	74 22       	st.w [%a2],%d2
    timeoutCycleCount       = IFXSCUCCU_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;
80007196:	3b 00 00 23 	mov %d2,12288
8000719a:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 0) || (SCU_PERPLLSTAT.B.PWDSTAT == 0))
8000719e:	1d 00 10 00 	j 800071be <IfxScuCcu_init+0x24c>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800071a2:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800071a6:	c2 f2       	add %d2,-1
800071a8:	59 e2 e0 ff 	st.w [%a14]-32,%d2
800071ac:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800071b0:	ff 12 07 00 	jge %d2,1,800071be <IfxScuCcu_init+0x24c>
800071b4:	82 12       	mov %d2,1
800071b6:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
800071ba:	1d 00 18 00 	j 800071ea <IfxScuCcu_init+0x278>
    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 0) || (SCU_PERPLLSTAT.B.PWDSTAT == 0))
800071be:	91 30 00 2f 	movh.a %a2,61443
800071c2:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
800071c6:	54 22       	ld.w %d2,[%a2]
800071c8:	37 02 e1 20 	extr.u %d2,%d2,1,1
800071cc:	8f f2 0f 21 	and %d2,%d2,255
800071d0:	df 02 e9 7f 	jeq %d2,0,800071a2 <IfxScuCcu_init+0x230>
800071d4:	91 30 00 2f 	movh.a %a2,61443
800071d8:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
800071dc:	54 22       	ld.w %d2,[%a2]
800071de:	37 02 e1 20 	extr.u %d2,%d2,1,1
800071e2:	8f f2 0f 21 	and %d2,%d2,255
800071e6:	df 02 de 7f 	jeq %d2,0,800071a2 <IfxScuCcu_init+0x230>
    if ((pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fOsc0) || (pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fSysclk))
800071ea:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800071ee:	b0 42       	add.a %a2,4
800071f0:	54 22       	ld.w %d2,[%a2]
800071f2:	df 12 08 00 	jeq %d2,1,80007202 <IfxScuCcu_init+0x290>
800071f6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800071fa:	b0 42       	add.a %a2,4
800071fc:	54 22       	ld.w %d2,[%a2]
800071fe:	df 22 31 80 	jne %d2,2,80007260 <IfxScuCcu_init+0x2ee>
        scuOsccon.U      = SCU_OSCCON.U;
80007202:	91 30 00 2f 	movh.a %a2,61443
80007206:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <bmhd_3_copy+0x40c34a10>>
8000720a:	54 22       	ld.w %d2,[%a2]
8000720c:	59 e2 e8 df 	st.w [%a14]-152 <f0036010 <bmhd_3_copy+0x40c34a10>>,%d2
        scuOsccon.B.MODE = 0U;
80007210:	19 e2 e8 df 	ld.w %d2,[%a14]-152 <f0036010 <bmhd_3_copy+0x40c34a10>>
80007214:	8f 02 c6 21 	andn %d2,%d2,96
80007218:	59 e2 e8 df 	st.w [%a14]-152,%d2
        scuOsccon.B.OSCVAL = (uint32)(pllsParamCfg->xtalFrequency / 1000000U) - 15; /*XTAL range 16MHz to 40MHz*/
8000721c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80007220:	54 22       	ld.w %d2,[%a2]
80007222:	7b c0 31 34 	movh %d3,17180
80007226:	1b 33 e8 3d 	addi %d3,%d3,-8573
8000722a:	73 32 68 20 	mul.u %e2,%d2,%d3
8000722e:	8f e3 1e 20 	sh %d2,%d3,-18
80007232:	8f f2 0f 21 	and %d2,%d2,255
80007236:	1b 12 ff 2f 	addi %d2,%d2,-15
8000723a:	8f f2 0f 21 	and %d2,%d2,255
8000723e:	8f f2 01 21 	and %d2,%d2,31
80007242:	8f f2 0f 31 	and %d3,%d2,255
80007246:	19 e2 e8 df 	ld.w %d2,[%a14]-152
8000724a:	37 32 05 28 	insert %d2,%d2,%d3,16,5
8000724e:	59 e2 e8 df 	st.w [%a14]-152,%d2
        SCU_OSCCON.U       = scuOsccon.U;
80007252:	91 30 00 2f 	movh.a %a2,61443
80007256:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <bmhd_3_copy+0x40c34a10>>
8000725a:	19 e2 e8 df 	ld.w %d2,[%a14]-152 <f0036010 <bmhd_3_copy+0x40c34a10>>
8000725e:	74 22       	st.w [%a2],%d2
        sysPllCon0.U       = SCU_SYSPLLCON0.U;
80007260:	91 30 00 2f 	movh.a %a2,61443
80007264:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80007268:	54 22       	ld.w %d2,[%a2]
8000726a:	59 e2 e4 df 	st.w [%a14]-156 <f0036018 <bmhd_3_copy+0x40c34a18>>,%d2
        sysPllCon0.B.PDIV  = pllsParamCfg->sysPllConfig.pDivider;
8000726e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16 <f0036018 <bmhd_3_copy+0x40c34a18>>
80007272:	39 22 08 00 	ld.bu %d2,[%a2]8 <f0036018 <bmhd_3_copy+0x40c34a18>>
80007276:	8f 72 00 21 	and %d2,%d2,7
8000727a:	8f f2 0f 31 	and %d3,%d2,255
8000727e:	19 e2 e4 df 	ld.w %d2,[%a14]-156
80007282:	37 32 03 2c 	insert %d2,%d2,%d3,24,3
80007286:	59 e2 e4 df 	st.w [%a14]-156,%d2
        sysPllCon0.B.NDIV  = pllsParamCfg->sysPllConfig.nDivider;
8000728a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000728e:	39 22 09 00 	ld.bu %d2,[%a2]9
80007292:	8f f2 07 21 	and %d2,%d2,127
80007296:	8f f2 0f 31 	and %d3,%d2,255
8000729a:	19 e2 e4 df 	ld.w %d2,[%a14]-156
8000729e:	37 32 87 24 	insert %d2,%d2,%d3,9,7
800072a2:	59 e2 e4 df 	st.w [%a14]-156,%d2
        sysPllCon0.B.INSEL = pllsParamCfg->pllInputClockSelection;
800072a6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800072aa:	b0 42       	add.a %a2,4
800072ac:	54 22       	ld.w %d2,[%a2]
800072ae:	8f 32 00 21 	and %d2,%d2,3
800072b2:	8f f2 0f 31 	and %d3,%d2,255
800072b6:	19 e2 e4 df 	ld.w %d2,[%a14]-156
800072ba:	37 32 02 2f 	insert %d2,%d2,%d3,30,2
800072be:	59 e2 e4 df 	st.w [%a14]-156,%d2
        SCU_SYSPLLCON0.U   = sysPllCon0.U;
800072c2:	91 30 00 2f 	movh.a %a2,61443
800072c6:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
800072ca:	19 e2 e4 df 	ld.w %d2,[%a14]-156 <f0036018 <bmhd_3_copy+0x40c34a18>>
800072ce:	74 22       	st.w [%a2],%d2
        scuPerPllCon0.U       = SCU_PERPLLCON0.U;
800072d0:	91 30 00 2f 	movh.a %a2,61443
800072d4:	d9 22 28 06 	lea %a2,[%a2]24616 <f0036028 <bmhd_3_copy+0x40c34a28>>
800072d8:	54 22       	ld.w %d2,[%a2]
800072da:	59 e2 e0 df 	st.w [%a14]-160 <f0036028 <bmhd_3_copy+0x40c34a28>>,%d2
        scuPerPllCon0.B.DIVBY = pllsParamCfg->perPllConfig.k3DividerBypass;
800072de:	99 e2 f0 ff 	ld.a %a2,[%a14]-16 <f0036028 <bmhd_3_copy+0x40c34a28>>
800072e2:	39 22 10 00 	ld.bu %d2,[%a2]16 <f0036028 <bmhd_3_copy+0x40c34a28>>
800072e6:	8f 12 00 21 	and %d2,%d2,1
800072ea:	8f f2 0f 31 	and %d3,%d2,255
800072ee:	19 e2 e0 df 	ld.w %d2,[%a14]-160
800072f2:	67 32 00 20 	ins.t %d2,%d2,0,%d3,0
800072f6:	59 e2 e0 df 	st.w [%a14]-160,%d2
        scuPerPllCon0.B.PDIV  = pllsParamCfg->perPllConfig.pDivider;
800072fa:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800072fe:	39 22 0c 00 	ld.bu %d2,[%a2]12
80007302:	8f 72 00 21 	and %d2,%d2,7
80007306:	8f f2 0f 31 	and %d3,%d2,255
8000730a:	19 e2 e0 df 	ld.w %d2,[%a14]-160
8000730e:	37 32 03 2c 	insert %d2,%d2,%d3,24,3
80007312:	59 e2 e0 df 	st.w [%a14]-160,%d2
        scuPerPllCon0.B.NDIV  = pllsParamCfg->perPllConfig.nDivider;
80007316:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000731a:	39 22 0d 00 	ld.bu %d2,[%a2]13
8000731e:	8f f2 07 21 	and %d2,%d2,127
80007322:	8f f2 0f 31 	and %d3,%d2,255
80007326:	19 e2 e0 df 	ld.w %d2,[%a14]-160
8000732a:	37 32 87 24 	insert %d2,%d2,%d3,9,7
8000732e:	59 e2 e0 df 	st.w [%a14]-160,%d2
        SCU_PERPLLCON0.U      = scuPerPllCon0.U;
80007332:	91 30 00 2f 	movh.a %a2,61443
80007336:	d9 22 28 06 	lea %a2,[%a2]24616 <f0036028 <bmhd_3_copy+0x40c34a28>>
8000733a:	19 e2 e0 df 	ld.w %d2,[%a14]-160 <f0036028 <bmhd_3_copy+0x40c34a28>>
8000733e:	74 22       	st.w [%a2],%d2
    SCU_SYSPLLCON0.B.PLLPWD = 1;
80007340:	91 30 00 2f 	movh.a %a2,61443
80007344:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
80007348:	54 22       	ld.w %d2,[%a2]
8000734a:	b7 12 01 28 	insert %d2,%d2,1,16,1
8000734e:	74 22       	st.w [%a2],%d2
    SCU_PERPLLCON0.B.PLLPWD = 1;
80007350:	91 30 00 2f 	movh.a %a2,61443
80007354:	d9 22 28 06 	lea %a2,[%a2]24616 <f0036028 <bmhd_3_copy+0x40c34a28>>
80007358:	54 22       	ld.w %d2,[%a2]
8000735a:	b7 12 01 28 	insert %d2,%d2,1,16,1
8000735e:	74 22       	st.w [%a2],%d2
    timeoutCycleCount       = IFXSCUCCU_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;
80007360:	3b 00 00 23 	mov %d2,12288
80007364:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 1) || (SCU_PERPLLSTAT.B.PWDSTAT == 1))
80007368:	1d 00 10 00 	j 80007388 <IfxScuCcu_init+0x416>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000736c:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80007370:	c2 f2       	add %d2,-1
80007372:	59 e2 e0 ff 	st.w [%a14]-32,%d2
80007376:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000737a:	ff 12 07 00 	jge %d2,1,80007388 <IfxScuCcu_init+0x416>
8000737e:	82 12       	mov %d2,1
80007380:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
80007384:	1d 00 18 00 	j 800073b4 <IfxScuCcu_init+0x442>
    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 1) || (SCU_PERPLLSTAT.B.PWDSTAT == 1))
80007388:	91 30 00 2f 	movh.a %a2,61443
8000738c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
80007390:	54 22       	ld.w %d2,[%a2]
80007392:	37 02 e1 20 	extr.u %d2,%d2,1,1
80007396:	8f f2 0f 21 	and %d2,%d2,255
8000739a:	df 12 e9 7f 	jeq %d2,1,8000736c <IfxScuCcu_init+0x3fa>
8000739e:	91 30 00 2f 	movh.a %a2,61443
800073a2:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
800073a6:	54 22       	ld.w %d2,[%a2]
800073a8:	37 02 e1 20 	extr.u %d2,%d2,1,1
800073ac:	8f f2 0f 21 	and %d2,%d2,255
800073b0:	df 12 de 7f 	jeq %d2,1,8000736c <IfxScuCcu_init+0x3fa>
    timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;
800073b4:	3b 00 00 26 	mov %d2,24576
800073b8:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
800073bc:	1d 00 10 00 	j 800073dc <IfxScuCcu_init+0x46a>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800073c0:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800073c4:	c2 f2       	add %d2,-1
800073c6:	59 e2 e0 ff 	st.w [%a14]-32,%d2
800073ca:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800073ce:	ff 12 07 00 	jge %d2,1,800073dc <IfxScuCcu_init+0x46a>
800073d2:	82 12       	mov %d2,1
800073d4:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
800073d8:	1d 00 23 00 	j 8000741e <IfxScuCcu_init+0x4ac>
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
800073dc:	91 30 00 2f 	movh.a %a2,61443
800073e0:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
800073e4:	54 22       	ld.w %d2,[%a2]
800073e6:	37 02 e1 22 	extr.u %d2,%d2,5,1
800073ea:	8f f2 0f 21 	and %d2,%d2,255
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
800073ee:	df 02 e9 7f 	jeq %d2,0,800073c0 <IfxScuCcu_init+0x44e>
800073f2:	91 30 00 2f 	movh.a %a2,61443
800073f6:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
800073fa:	54 22       	ld.w %d2,[%a2]
800073fc:	37 02 e1 22 	extr.u %d2,%d2,5,1
80007400:	8f f2 0f 21 	and %d2,%d2,255
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
80007404:	df 02 de 7f 	jeq %d2,0,800073c0 <IfxScuCcu_init+0x44e>
           (SCU_PERPLLSTAT.B.K3RDY == 0U))
80007408:	91 30 00 2f 	movh.a %a2,61443
8000740c:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
80007410:	54 22       	ld.w %d2,[%a2]
80007412:	37 02 61 22 	extr.u %d2,%d2,4,1
80007416:	8f f2 0f 21 	and %d2,%d2,255
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
8000741a:	df 02 d3 7f 	jeq %d2,0,800073c0 <IfxScuCcu_init+0x44e>
    SCU_SYSPLLCON1.B.K2DIV = pllsParamCfg->sysPllConfig.k2Divider;
8000741e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80007422:	39 22 0a 00 	ld.bu %d2,[%a2]10
80007426:	91 30 00 2f 	movh.a %a2,61443
8000742a:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <bmhd_3_copy+0x40c34a1c>>
8000742e:	8f 72 00 21 	and %d2,%d2,7
80007432:	8f f2 0f 31 	and %d3,%d2,255
80007436:	54 22       	ld.w %d2,[%a2]
80007438:	37 32 03 20 	insert %d2,%d2,%d3,0,3
8000743c:	74 22       	st.w [%a2],%d2
        scuPerPllCon1.U       = SCU_PERPLLCON1.U;
8000743e:	91 30 00 2f 	movh.a %a2,61443
80007442:	d9 22 2c 06 	lea %a2,[%a2]24620 <f003602c <bmhd_3_copy+0x40c34a2c>>
80007446:	54 22       	ld.w %d2,[%a2]
80007448:	59 e2 dc df 	st.w [%a14]-164 <f003602c <bmhd_3_copy+0x40c34a2c>>,%d2
        scuPerPllCon1.B.K2DIV = pllsParamCfg->perPllConfig.k2Divider;
8000744c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16 <f003602c <bmhd_3_copy+0x40c34a2c>>
80007450:	39 22 0e 00 	ld.bu %d2,[%a2]14 <f003602c <bmhd_3_copy+0x40c34a2c>>
80007454:	8f 72 00 21 	and %d2,%d2,7
80007458:	8f f2 0f 31 	and %d3,%d2,255
8000745c:	19 e2 dc df 	ld.w %d2,[%a14]-164
80007460:	37 32 03 20 	insert %d2,%d2,%d3,0,3
80007464:	59 e2 dc df 	st.w [%a14]-164,%d2
        scuPerPllCon1.B.K3DIV = pllsParamCfg->perPllConfig.k3Divider;
80007468:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000746c:	39 22 0f 00 	ld.bu %d2,[%a2]15
80007470:	8f 72 00 21 	and %d2,%d2,7
80007474:	8f f2 0f 31 	and %d3,%d2,255
80007478:	19 e2 dc df 	ld.w %d2,[%a14]-164
8000747c:	37 32 03 24 	insert %d2,%d2,%d3,8,3
80007480:	59 e2 dc df 	st.w [%a14]-164,%d2
        SCU_PERPLLCON1.U      = scuPerPllCon1.U;
80007484:	91 30 00 2f 	movh.a %a2,61443
80007488:	d9 22 2c 06 	lea %a2,[%a2]24620 <f003602c <bmhd_3_copy+0x40c34a2c>>
8000748c:	19 e2 dc df 	ld.w %d2,[%a14]-164 <f003602c <bmhd_3_copy+0x40c34a2c>>
80007490:	74 22       	st.w [%a2],%d2
    timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;
80007492:	3b 00 00 26 	mov %d2,24576
80007496:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
8000749a:	1d 00 10 00 	j 800074ba <IfxScuCcu_init+0x548>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000749e:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800074a2:	c2 f2       	add %d2,-1
800074a4:	59 e2 e0 ff 	st.w [%a14]-32,%d2
800074a8:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800074ac:	ff 12 07 00 	jge %d2,1,800074ba <IfxScuCcu_init+0x548>
800074b0:	82 12       	mov %d2,1
800074b2:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
800074b6:	1d 00 23 00 	j 800074fc <IfxScuCcu_init+0x58a>
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
800074ba:	91 30 00 2f 	movh.a %a2,61443
800074be:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
800074c2:	54 22       	ld.w %d2,[%a2]
800074c4:	37 02 e1 22 	extr.u %d2,%d2,5,1
800074c8:	8f f2 0f 21 	and %d2,%d2,255
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
800074cc:	df 02 e9 7f 	jeq %d2,0,8000749e <IfxScuCcu_init+0x52c>
800074d0:	91 30 00 2f 	movh.a %a2,61443
800074d4:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
800074d8:	54 22       	ld.w %d2,[%a2]
800074da:	37 02 e1 22 	extr.u %d2,%d2,5,1
800074de:	8f f2 0f 21 	and %d2,%d2,255
    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
800074e2:	df 02 de 7f 	jeq %d2,0,8000749e <IfxScuCcu_init+0x52c>
           (SCU_PERPLLSTAT.B.K3RDY == 0U))
800074e6:	91 30 00 2f 	movh.a %a2,61443
800074ea:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
800074ee:	54 22       	ld.w %d2,[%a2]
800074f0:	37 02 61 22 	extr.u %d2,%d2,4,1
800074f4:	8f f2 0f 21 	and %d2,%d2,255
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
800074f8:	df 02 d3 7f 	jeq %d2,0,8000749e <IfxScuCcu_init+0x52c>
    timeoutCycleCount = IFXSCUCCU_OSCCON_PLLLV_OR_HV_TIMEOUT_COUNT;
800074fc:	7b 50 00 20 	movh %d2,5
80007500:	1b 02 3e 29 	addi %d2,%d2,-27680
80007504:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    while ((SCU_OSCCON.B.PLLLV == 0) && (SCU_OSCCON.B.PLLHV == 0))
80007508:	1d 00 10 00 	j 80007528 <IfxScuCcu_init+0x5b6>
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000750c:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80007510:	c2 f2       	add %d2,-1
80007512:	59 e2 e0 ff 	st.w [%a14]-32,%d2
80007516:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000751a:	ff 12 07 00 	jge %d2,1,80007528 <IfxScuCcu_init+0x5b6>
8000751e:	82 12       	mov %d2,1
80007520:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
80007524:	1d 00 18 00 	j 80007554 <IfxScuCcu_init+0x5e2>
    while ((SCU_OSCCON.B.PLLLV == 0) && (SCU_OSCCON.B.PLLHV == 0))
80007528:	91 30 00 2f 	movh.a %a2,61443
8000752c:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <bmhd_3_copy+0x40c34a10>>
80007530:	54 22       	ld.w %d2,[%a2]
80007532:	37 02 e1 20 	extr.u %d2,%d2,1,1
80007536:	8f f2 0f 21 	and %d2,%d2,255
8000753a:	df 02 0d 80 	jne %d2,0,80007554 <IfxScuCcu_init+0x5e2>
8000753e:	91 30 00 2f 	movh.a %a2,61443
80007542:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <bmhd_3_copy+0x40c34a10>>
80007546:	54 22       	ld.w %d2,[%a2]
80007548:	37 02 61 24 	extr.u %d2,%d2,8,1
8000754c:	8f f2 0f 21 	and %d2,%d2,255
80007550:	df 02 de 7f 	jeq %d2,0,8000750c <IfxScuCcu_init+0x59a>
        SCU_SYSPLLCON0.B.RESLD = 1;             /* Restart Sys PLL lock detection */
80007554:	91 30 00 2f 	movh.a %a2,61443
80007558:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
8000755c:	54 22       	ld.w %d2,[%a2]
8000755e:	b7 12 01 29 	insert %d2,%d2,1,18,1
80007562:	74 22       	st.w [%a2],%d2
        SCU_PERPLLCON0.B.RESLD = 1;             /* Restart Per PLL lock detection */
80007564:	91 30 00 2f 	movh.a %a2,61443
80007568:	d9 22 28 06 	lea %a2,[%a2]24616 <f0036028 <bmhd_3_copy+0x40c34a28>>
8000756c:	54 22       	ld.w %d2,[%a2]
8000756e:	b7 12 01 29 	insert %d2,%d2,1,18,1
80007572:	74 22       	st.w [%a2],%d2
        timeoutCycleCount      = IFXSCUCCU_PLL_LOCK_TIMEOUT_COUNT;
80007574:	3b 00 00 23 	mov %d2,12288
80007578:	59 e2 e0 ff 	st.w [%a14]-32,%d2
        while ((SCU_SYSPLLSTAT.B.LOCK == 0) || (SCU_PERPLLSTAT.B.LOCK == 0))
8000757c:	1d 00 10 00 	j 8000759c <IfxScuCcu_init+0x62a>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007580:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80007584:	c2 f2       	add %d2,-1
80007586:	59 e2 e0 ff 	st.w [%a14]-32,%d2
8000758a:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000758e:	ff 12 07 00 	jge %d2,1,8000759c <IfxScuCcu_init+0x62a>
80007592:	82 12       	mov %d2,1
80007594:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
80007598:	1d 00 18 00 	j 800075c8 <IfxScuCcu_init+0x656>
        while ((SCU_SYSPLLSTAT.B.LOCK == 0) || (SCU_PERPLLSTAT.B.LOCK == 0))
8000759c:	91 30 00 2f 	movh.a %a2,61443
800075a0:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
800075a4:	54 22       	ld.w %d2,[%a2]
800075a6:	37 02 61 21 	extr.u %d2,%d2,2,1
800075aa:	8f f2 0f 21 	and %d2,%d2,255
800075ae:	df 02 e9 7f 	jeq %d2,0,80007580 <IfxScuCcu_init+0x60e>
800075b2:	91 30 00 2f 	movh.a %a2,61443
800075b6:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <bmhd_3_copy+0x40c34a24>>
800075ba:	54 22       	ld.w %d2,[%a2]
800075bc:	37 02 61 21 	extr.u %d2,%d2,2,1
800075c0:	8f f2 0f 21 	and %d2,%d2,255
800075c4:	df 02 de 7f 	jeq %d2,0,80007580 <IfxScuCcu_init+0x60e>
        SMU_KEYS.U = (uint32)0xBCU;           /* Enable access to SMU registers */
800075c8:	91 30 00 2f 	movh.a %a2,61443
800075cc:	d9 22 b4 06 	lea %a2,[%a2]26676 <f0036834 <bmhd_3_copy+0x40c35234>>
800075d0:	3b c0 0b 20 	mov %d2,188
800075d4:	74 22       	st.w [%a2],%d2
        SMU_CMD.U  = (uint32)0x00000005;
800075d6:	91 30 00 2f 	movh.a %a2,61443
800075da:	d9 22 a0 06 	lea %a2,[%a2]26656 <f0036820 <bmhd_3_copy+0x40c35220>>
800075de:	82 52       	mov %d2,5
800075e0:	74 22       	st.w [%a2],%d2
        SMU_AG8.U  = IFXSCUCCU_SMUALARM_MASK; /* Clear SMU Alarms*/
800075e2:	91 30 00 2f 	movh.a %a2,61443
800075e6:	d9 22 a0 76 	lea %a2,[%a2]27104 <f00369e0 <bmhd_3_copy+0x40c353e0>>
800075ea:	3b d0 01 20 	mov %d2,29
800075ee:	74 22       	st.w [%a2],%d2
        SMU_KEYS.U = (uint32)0U;
800075f0:	91 30 00 2f 	movh.a %a2,61443
800075f4:	d9 22 b4 06 	lea %a2,[%a2]26676 <f0036834 <bmhd_3_copy+0x40c35234>>
800075f8:	82 02       	mov %d2,0
800075fa:	74 22       	st.w [%a2],%d2
        scu_ccucon0.U        = SCU_CCUCON0.U;
800075fc:	91 30 00 2f 	movh.a %a2,61443
80007600:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80007604:	54 22       	ld.w %d2,[%a2]
80007606:	59 e2 d8 df 	st.w [%a14]-168 <f0036030 <bmhd_3_copy+0x40c34a30>>,%d2
        scu_ccucon0.B.CLKSEL = 1; /*Select the PLLs for fsource0/1/2 */
8000760a:	19 e2 d8 df 	ld.w %d2,[%a14]-168 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000760e:	b7 12 02 2e 	insert %d2,%d2,1,28,2
80007612:	59 e2 d8 df 	st.w [%a14]-168,%d2
        scu_ccucon0.B.UP     = 1; /*Update the ccucon0 register */
80007616:	19 e2 d8 df 	ld.w %d2,[%a14]-168
8000761a:	b7 12 01 2f 	insert %d2,%d2,1,30,1
8000761e:	59 e2 d8 df 	st.w [%a14]-168,%d2
        timeoutCycleCount    = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007622:	3b 00 00 21 	mov %d2,4096
80007626:	59 e2 e0 ff 	st.w [%a14]-32,%d2
        while (SCU_CCUCON0.B.LCK != 0U)
8000762a:	1d 00 10 00 	j 8000764a <IfxScuCcu_init+0x6d8>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000762e:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80007632:	c2 f2       	add %d2,-1
80007634:	59 e2 e0 ff 	st.w [%a14]-32,%d2
80007638:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000763c:	ff 12 07 00 	jge %d2,1,8000764a <IfxScuCcu_init+0x6d8>
80007640:	82 12       	mov %d2,1
80007642:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
80007646:	1d 00 0d 00 	j 80007660 <IfxScuCcu_init+0x6ee>
        while (SCU_CCUCON0.B.LCK != 0U)
8000764a:	91 30 00 2f 	movh.a %a2,61443
8000764e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80007652:	54 22       	ld.w %d2,[%a2]
80007654:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007658:	8f f2 0f 21 	and %d2,%d2,255
8000765c:	df 02 e9 ff 	jne %d2,0,8000762e <IfxScuCcu_init+0x6bc>
        SCU_CCUCON0.U     = scu_ccucon0.U;
80007660:	91 30 00 2f 	movh.a %a2,61443
80007664:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80007668:	19 e2 d8 df 	ld.w %d2,[%a14]-168 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000766c:	74 22       	st.w [%a2],%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
8000766e:	3b 00 00 21 	mov %d2,4096
80007672:	59 e2 e0 ff 	st.w [%a14]-32,%d2
        while (SCU_CCUCON0.B.LCK != 0U)
80007676:	1d 00 10 00 	j 80007696 <IfxScuCcu_init+0x724>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
8000767a:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000767e:	c2 f2       	add %d2,-1
80007680:	59 e2 e0 ff 	st.w [%a14]-32,%d2
80007684:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80007688:	ff 12 07 00 	jge %d2,1,80007696 <IfxScuCcu_init+0x724>
8000768c:	82 12       	mov %d2,1
8000768e:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
80007692:	1d 00 0d 00 	j 800076ac <IfxScuCcu_init+0x73a>
        while (SCU_CCUCON0.B.LCK != 0U)
80007696:	91 30 00 2f 	movh.a %a2,61443
8000769a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000769e:	54 22       	ld.w %d2,[%a2]
800076a0:	37 02 e1 2f 	extr.u %d2,%d2,31,1
800076a4:	8f f2 0f 21 	and %d2,%d2,255
800076a8:	df 02 e9 ff 	jne %d2,0,8000767a <IfxScuCcu_init+0x708>
    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
800076ac:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
800076b0:	f9 e2 de ff 	st.h [%a14]-34,%d2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800076b4:	91 30 00 2f 	movh.a %a2,61443
800076b8:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800076bc:	54 22       	ld.w %d2,[%a2]
800076be:	37 02 e1 20 	extr.u %d2,%d2,1,1
800076c2:	8f f2 0f 21 	and %d2,%d2,255
800076c6:	df 02 18 00 	jeq %d2,0,800076f6 <IfxScuCcu_init+0x784>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800076ca:	b9 e2 de ff 	ld.hu %d2,[%a14]-34
800076ce:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800076d0:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800076d4:	91 30 00 2f 	movh.a %a2,61443
800076d8:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800076dc:	54 22       	ld.w %d2,[%a2]
800076de:	37 02 70 28 	extr.u %d2,%d2,16,16
800076e2:	37 02 70 20 	extr.u %d2,%d2,0,16
800076e6:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800076ea:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800076ec:	91 30 00 2f 	movh.a %a2,61443
800076f0:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800076f4:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800076f6:	b9 e2 de ff 	ld.hu %d2,[%a14]-34 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800076fa:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800076fc:	8f 32 40 31 	or %d3,%d2,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007700:	91 30 00 2f 	movh.a %a2,61443
80007704:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007708:	54 22       	ld.w %d2,[%a2]
8000770a:	37 02 70 28 	extr.u %d2,%d2,16,16
8000770e:	37 02 70 20 	extr.u %d2,%d2,0,16
80007712:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007716:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007718:	91 30 00 2f 	movh.a %a2,61443
8000771c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007720:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80007722:	00 00       	nop 
80007724:	91 30 00 2f 	movh.a %a2,61443
80007728:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000772c:	54 22       	ld.w %d2,[%a2]
8000772e:	37 02 61 20 	extr.u %d2,%d2,0,1
80007732:	8f f2 0f 21 	and %d2,%d2,255
80007736:	df 02 f7 7f 	jeq %d2,0,80007724 <IfxScuCcu_init+0x7b2>
    {}
}
8000773a:	00 00       	nop 
    return (boolean)initError;
8000773c:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
80007740:	e9 e2 ff ff 	st.b [%a14]-1,%d2

    if (!status)
80007744:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80007748:	df 02 0a 80 	jne %d2,0,8000775c <IfxScuCcu_init+0x7ea>
    {
        IfxScuCcu_modulation_init(config->modulationConfig);  /* initialize modulation */
8000774c:	99 e2 d4 df 	ld.a %a2,[%a14]-172
80007750:	d9 22 34 10 	lea %a2,[%a2]116
80007754:	54 22       	ld.w %d2,[%a2]
80007756:	60 24       	mov.a %a4,%d2
80007758:	6d 00 72 05 	call 8000823c <IfxScuCcu_modulation_init>
    }

    if (!status)
8000775c:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80007760:	df 02 32 84 	jne %d2,0,80007fc4 <IfxScuCcu_init+0x1052>
    {
        status = IfxScuCcu_distributeClockInline(&config->clockDistribution);
80007764:	19 e2 d4 df 	ld.w %d2,[%a14]-172
80007768:	1b 02 02 20 	addi %d2,%d2,32
8000776c:	59 e2 d8 ff 	st.w [%a14]-40,%d2
    uint32 initError = 0;
80007770:	82 02       	mov %d2,0
80007772:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;
80007776:	7b 30 00 2f 	movh %d2,61443
8000777a:	1b 82 2a 26 	addi %d2,%d2,25256
8000777e:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    password  = watchdog->CON0.B.PW;
80007782:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
80007786:	54 22       	ld.w %d2,[%a2]
80007788:	37 02 6e 21 	extr.u %d2,%d2,2,14
8000778c:	37 02 70 20 	extr.u %d2,%d2,0,16
80007790:	f9 e2 ce ff 	st.h [%a14]-50,%d2
    password ^= 0x003F;
80007794:	c9 e2 ce ff 	ld.h %d2,[%a14]-50
80007798:	8f f2 83 21 	xor %d2,%d2,63
8000779c:	f9 e2 ce ff 	st.h [%a14]-50,%d2
    return password;
800077a0:	b9 e2 ce ff 	ld.hu %d2,[%a14]-50
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();
800077a4:	f9 e2 cc ff 	st.h [%a14]-52,%d2
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);
800077a8:	b9 e2 cc ff 	ld.hu %d2,[%a14]-52
800077ac:	f9 e2 ca ff 	st.h [%a14]-54,%d2
    if (SCU_WDTS_CON0.B.LCK)
800077b0:	91 30 00 2f 	movh.a %a2,61443
800077b4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800077b8:	54 22       	ld.w %d2,[%a2]
800077ba:	37 02 e1 20 	extr.u %d2,%d2,1,1
800077be:	8f f2 0f 21 	and %d2,%d2,255
800077c2:	df 02 18 00 	jeq %d2,0,800077f2 <IfxScuCcu_init+0x880>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800077c6:	b9 e2 ca ff 	ld.hu %d2,[%a14]-54
800077ca:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800077cc:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800077d0:	91 30 00 2f 	movh.a %a2,61443
800077d4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800077d8:	54 22       	ld.w %d2,[%a2]
800077da:	37 02 70 28 	extr.u %d2,%d2,16,16
800077de:	37 02 70 20 	extr.u %d2,%d2,0,16
800077e2:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800077e6:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800077e8:	91 30 00 2f 	movh.a %a2,61443
800077ec:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800077f0:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800077f2:	b9 e2 ca ff 	ld.hu %d2,[%a14]-54 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800077f6:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800077f8:	8f 22 40 31 	or %d3,%d2,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800077fc:	91 30 00 2f 	movh.a %a2,61443
80007800:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007804:	54 22       	ld.w %d2,[%a2]
80007806:	37 02 70 28 	extr.u %d2,%d2,16,16
8000780a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000780e:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007812:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007814:	91 30 00 2f 	movh.a %a2,61443
80007818:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000781c:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000781e:	00 00       	nop 
80007820:	91 30 00 2f 	movh.a %a2,61443
80007824:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007828:	54 22       	ld.w %d2,[%a2]
8000782a:	37 02 61 20 	extr.u %d2,%d2,0,1
8000782e:	8f f2 0f 21 	and %d2,%d2,255
80007832:	df 12 f7 7f 	jeq %d2,1,80007820 <IfxScuCcu_init+0x8ae>
}
80007836:	00 00       	nop 
        ccucon0.U         = SCU_CCUCON0.U & ~clockDistributionConfig->ccucon0.mask;
80007838:	91 30 00 2f 	movh.a %a2,61443
8000783c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
80007840:	54 23       	ld.w %d3,[%a2]
80007842:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036030 <bmhd_3_copy+0x40c34a30>>
80007846:	b0 42       	add.a %a2,4
80007848:	54 22       	ld.w %d2,[%a2]
8000784a:	46 02       	not %d2
8000784c:	26 32       	and %d2,%d3
8000784e:	59 e2 d4 ef 	st.w [%a14]-108,%d2
        ccucon0.U        |= (clockDistributionConfig->ccucon0.mask & clockDistributionConfig->ccucon0.value);
80007852:	19 e3 d4 ef 	ld.w %d3,[%a14]-108
80007856:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000785a:	b0 42       	add.a %a2,4
8000785c:	54 24       	ld.w %d4,[%a2]
8000785e:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007862:	54 22       	ld.w %d2,[%a2]
80007864:	26 42       	and %d2,%d4
80007866:	a6 32       	or %d2,%d3
80007868:	59 e2 d4 ef 	st.w [%a14]-108,%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
8000786c:	3b 00 00 21 	mov %d2,4096
80007870:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        while (SCU_CCUCON0.B.LCK != 0U)
80007874:	1d 00 10 00 	j 80007894 <IfxScuCcu_init+0x922>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007878:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000787c:	c2 f2       	add %d2,-1
8000787e:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007882:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007886:	ff 12 07 00 	jge %d2,1,80007894 <IfxScuCcu_init+0x922>
8000788a:	82 12       	mov %d2,1
8000788c:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007890:	1d 00 0d 00 	j 800078aa <IfxScuCcu_init+0x938>
        while (SCU_CCUCON0.B.LCK != 0U)
80007894:	91 30 00 2f 	movh.a %a2,61443
80007898:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000789c:	54 22       	ld.w %d2,[%a2]
8000789e:	37 02 e1 2f 	extr.u %d2,%d2,31,1
800078a2:	8f f2 0f 21 	and %d2,%d2,255
800078a6:	df 02 e9 ff 	jne %d2,0,80007878 <IfxScuCcu_init+0x906>
        SCU_CCUCON0.U     = ccucon0.U;      /*Set update bit explicitly to make above configurations effective */
800078aa:	91 30 00 2f 	movh.a %a2,61443
800078ae:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800078b2:	19 e2 d4 ef 	ld.w %d2,[%a14]-108 <f0036030 <bmhd_3_copy+0x40c34a30>>
800078b6:	74 22       	st.w [%a2],%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800078b8:	3b 00 00 21 	mov %d2,4096
800078bc:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        while (SCU_CCUCON0.B.LCK != 0U)
800078c0:	1d 00 10 00 	j 800078e0 <IfxScuCcu_init+0x96e>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800078c4:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
800078c8:	c2 f2       	add %d2,-1
800078ca:	59 e2 c4 ff 	st.w [%a14]-60,%d2
800078ce:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
800078d2:	ff 12 07 00 	jge %d2,1,800078e0 <IfxScuCcu_init+0x96e>
800078d6:	82 12       	mov %d2,1
800078d8:	59 e2 d4 ff 	st.w [%a14]-44,%d2
800078dc:	1d 00 0d 00 	j 800078f6 <IfxScuCcu_init+0x984>
        while (SCU_CCUCON0.B.LCK != 0U)
800078e0:	91 30 00 2f 	movh.a %a2,61443
800078e4:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800078e8:	54 22       	ld.w %d2,[%a2]
800078ea:	37 02 e1 2f 	extr.u %d2,%d2,31,1
800078ee:	8f f2 0f 21 	and %d2,%d2,255
800078f2:	df 02 e9 ff 	jne %d2,0,800078c4 <IfxScuCcu_init+0x952>
        ccucon1.U = SCU_CCUCON1.U;
800078f6:	91 30 00 2f 	movh.a %a2,61443
800078fa:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
800078fe:	54 22       	ld.w %d2,[%a2]
80007900:	59 e2 d0 ef 	st.w [%a14]-112 <f0036034 <bmhd_3_copy+0x40c34a34>>,%d2
        if (ccucon1.B.CLKSELMCAN
80007904:	19 e2 d0 ef 	ld.w %d2,[%a14]-112 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007908:	8f 02 03 21 	and %d2,%d2,48
8000790c:	df 02 10 80 	jne %d2,0,8000792c <IfxScuCcu_init+0x9ba>
            || ccucon1.B.CLKSELMSC
80007910:	19 e2 d0 ef 	ld.w %d2,[%a14]-112
80007914:	7b 00 03 30 	movh %d3,48
80007918:	26 32       	and %d2,%d3
8000791a:	df 02 09 80 	jne %d2,0,8000792c <IfxScuCcu_init+0x9ba>
            || ccucon1.B.CLKSELQSPI)
8000791e:	19 e2 d0 ef 	ld.w %d2,[%a14]-112
80007922:	7b 00 00 33 	movh %d3,12288
80007926:	26 32       	and %d2,%d3
80007928:	df 02 7b 00 	jeq %d2,0,80007a1e <IfxScuCcu_init+0xaac>
            ccucon1.U  = SCU_CCUCON1.U & ~clockDistributionConfig->ccucon1.mask;
8000792c:	91 30 00 2f 	movh.a %a2,61443
80007930:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007934:	54 23       	ld.w %d3,[%a2]
80007936:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036034 <bmhd_3_copy+0x40c34a34>>
8000793a:	d9 22 0c 00 	lea %a2,[%a2]12 <f0036034 <bmhd_3_copy+0x40c34a34>>
8000793e:	54 22       	ld.w %d2,[%a2]
80007940:	46 02       	not %d2
80007942:	26 32       	and %d2,%d3
80007944:	59 e2 d0 ef 	st.w [%a14]-112,%d2
            ccucon1.U |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);
80007948:	19 e3 d0 ef 	ld.w %d3,[%a14]-112
8000794c:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007950:	d9 22 0c 00 	lea %a2,[%a2]12
80007954:	54 24       	ld.w %d4,[%a2]
80007956:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000795a:	d9 22 08 00 	lea %a2,[%a2]8
8000795e:	54 22       	ld.w %d2,[%a2]
80007960:	26 42       	and %d2,%d4
80007962:	a6 32       	or %d2,%d3
80007964:	59 e2 d0 ef 	st.w [%a14]-112,%d2
            ccucon1.B.CLKSELMCAN = (uint32)0;
80007968:	19 e2 d0 ef 	ld.w %d2,[%a14]-112
8000796c:	8f 02 c3 21 	andn %d2,%d2,48
80007970:	59 e2 d0 ef 	st.w [%a14]-112,%d2
            ccucon1.B.CLKSELMSC  = (uint32)0;
80007974:	19 e2 d0 ef 	ld.w %d2,[%a14]-112
80007978:	7b 00 fd 3f 	movh %d3,65488
8000797c:	c2 f3       	add %d3,-1
8000797e:	26 32       	and %d2,%d3
80007980:	59 e2 d0 ef 	st.w [%a14]-112,%d2
            ccucon1.B.CLKSELQSPI = (uint32)0;
80007984:	19 e2 d0 ef 	ld.w %d2,[%a14]-112
80007988:	7b 00 00 3d 	movh %d3,53248
8000798c:	c2 f3       	add %d3,-1
8000798e:	26 32       	and %d2,%d3
80007990:	59 e2 d0 ef 	st.w [%a14]-112,%d2
            timeoutCycleCount    = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007994:	3b 00 00 21 	mov %d2,4096
80007998:	59 e2 c4 ff 	st.w [%a14]-60,%d2
            while (SCU_CCUCON1.B.LCK != 0U)
8000799c:	1d 00 10 00 	j 800079bc <IfxScuCcu_init+0xa4a>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800079a0:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
800079a4:	c2 f2       	add %d2,-1
800079a6:	59 e2 c4 ff 	st.w [%a14]-60,%d2
800079aa:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
800079ae:	ff 12 07 00 	jge %d2,1,800079bc <IfxScuCcu_init+0xa4a>
800079b2:	82 12       	mov %d2,1
800079b4:	59 e2 d4 ff 	st.w [%a14]-44,%d2
800079b8:	1d 00 0d 00 	j 800079d2 <IfxScuCcu_init+0xa60>
            while (SCU_CCUCON1.B.LCK != 0U)
800079bc:	91 30 00 2f 	movh.a %a2,61443
800079c0:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
800079c4:	54 22       	ld.w %d2,[%a2]
800079c6:	37 02 e1 2f 	extr.u %d2,%d2,31,1
800079ca:	8f f2 0f 21 	and %d2,%d2,255
800079ce:	df 02 e9 ff 	jne %d2,0,800079a0 <IfxScuCcu_init+0xa2e>
            SCU_CCUCON1.U     = ccucon1.U;
800079d2:	91 30 00 2f 	movh.a %a2,61443
800079d6:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
800079da:	19 e2 d0 ef 	ld.w %d2,[%a14]-112 <f0036034 <bmhd_3_copy+0x40c34a34>>
800079de:	74 22       	st.w [%a2],%d2
            timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
800079e0:	3b 00 00 21 	mov %d2,4096
800079e4:	59 e2 c4 ff 	st.w [%a14]-60,%d2
            while (SCU_CCUCON1.B.LCK != 0U)
800079e8:	1d 00 10 00 	j 80007a08 <IfxScuCcu_init+0xa96>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800079ec:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
800079f0:	c2 f2       	add %d2,-1
800079f2:	59 e2 c4 ff 	st.w [%a14]-60,%d2
800079f6:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
800079fa:	ff 12 07 00 	jge %d2,1,80007a08 <IfxScuCcu_init+0xa96>
800079fe:	82 12       	mov %d2,1
80007a00:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007a04:	1d 00 0d 00 	j 80007a1e <IfxScuCcu_init+0xaac>
            while (SCU_CCUCON1.B.LCK != 0U)
80007a08:	91 30 00 2f 	movh.a %a2,61443
80007a0c:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007a10:	54 22       	ld.w %d2,[%a2]
80007a12:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007a16:	8f f2 0f 21 	and %d2,%d2,255
80007a1a:	df 02 e9 ff 	jne %d2,0,800079ec <IfxScuCcu_init+0xa7a>
        ccucon1.U         = SCU_CCUCON1.U & ~clockDistributionConfig->ccucon1.mask;
80007a1e:	91 30 00 2f 	movh.a %a2,61443
80007a22:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007a26:	54 23       	ld.w %d3,[%a2]
80007a28:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007a2c:	d9 22 0c 00 	lea %a2,[%a2]12 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007a30:	54 22       	ld.w %d2,[%a2]
80007a32:	46 02       	not %d2
80007a34:	26 32       	and %d2,%d3
80007a36:	59 e2 d0 ef 	st.w [%a14]-112,%d2
        ccucon1.U        |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);
80007a3a:	19 e3 d0 ef 	ld.w %d3,[%a14]-112
80007a3e:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007a42:	d9 22 0c 00 	lea %a2,[%a2]12
80007a46:	54 24       	ld.w %d4,[%a2]
80007a48:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007a4c:	d9 22 08 00 	lea %a2,[%a2]8
80007a50:	54 22       	ld.w %d2,[%a2]
80007a52:	26 42       	and %d2,%d4
80007a54:	a6 32       	or %d2,%d3
80007a56:	59 e2 d0 ef 	st.w [%a14]-112,%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007a5a:	3b 00 00 21 	mov %d2,4096
80007a5e:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        while (SCU_CCUCON1.B.LCK != 0U)
80007a62:	1d 00 10 00 	j 80007a82 <IfxScuCcu_init+0xb10>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007a66:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007a6a:	c2 f2       	add %d2,-1
80007a6c:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007a70:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007a74:	ff 12 07 00 	jge %d2,1,80007a82 <IfxScuCcu_init+0xb10>
80007a78:	82 12       	mov %d2,1
80007a7a:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007a7e:	1d 00 0d 00 	j 80007a98 <IfxScuCcu_init+0xb26>
        while (SCU_CCUCON1.B.LCK != 0U)
80007a82:	91 30 00 2f 	movh.a %a2,61443
80007a86:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007a8a:	54 22       	ld.w %d2,[%a2]
80007a8c:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007a90:	8f f2 0f 21 	and %d2,%d2,255
80007a94:	df 02 e9 ff 	jne %d2,0,80007a66 <IfxScuCcu_init+0xaf4>
        SCU_CCUCON1.U     = ccucon1.U;
80007a98:	91 30 00 2f 	movh.a %a2,61443
80007a9c:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007aa0:	19 e2 d0 ef 	ld.w %d2,[%a14]-112 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007aa4:	74 22       	st.w [%a2],%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007aa6:	3b 00 00 21 	mov %d2,4096
80007aaa:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        while (SCU_CCUCON1.B.LCK != 0U)
80007aae:	1d 00 10 00 	j 80007ace <IfxScuCcu_init+0xb5c>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007ab2:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007ab6:	c2 f2       	add %d2,-1
80007ab8:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007abc:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007ac0:	ff 12 07 00 	jge %d2,1,80007ace <IfxScuCcu_init+0xb5c>
80007ac4:	82 12       	mov %d2,1
80007ac6:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007aca:	1d 00 0d 00 	j 80007ae4 <IfxScuCcu_init+0xb72>
        while (SCU_CCUCON1.B.LCK != 0U)
80007ace:	91 30 00 2f 	movh.a %a2,61443
80007ad2:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <bmhd_3_copy+0x40c34a34>>
80007ad6:	54 22       	ld.w %d2,[%a2]
80007ad8:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007adc:	8f f2 0f 21 	and %d2,%d2,255
80007ae0:	df 02 e9 ff 	jne %d2,0,80007ab2 <IfxScuCcu_init+0xb40>
        ccucon2.U = SCU_CCUCON2.U;
80007ae4:	91 30 00 2f 	movh.a %a2,61443
80007ae8:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007aec:	54 22       	ld.w %d2,[%a2]
80007aee:	59 e2 cc ef 	st.w [%a14]-116 <f0036040 <bmhd_3_copy+0x40c34a40>>,%d2
        if (ccucon2.B.CLKSELASCLINS)
80007af2:	19 e2 cc ef 	ld.w %d2,[%a14]-116 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007af6:	3b 00 00 33 	mov %d3,12288
80007afa:	26 32       	and %d2,%d3
80007afc:	df 02 6c 00 	jeq %d2,0,80007bd4 <IfxScuCcu_init+0xc62>
            ccucon2.U               = SCU_CCUCON2.U & ~clockDistributionConfig->ccucon2.mask;
80007b00:	91 30 00 2f 	movh.a %a2,61443
80007b04:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007b08:	54 23       	ld.w %d3,[%a2]
80007b0a:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007b0e:	d9 22 14 00 	lea %a2,[%a2]20 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007b12:	54 22       	ld.w %d2,[%a2]
80007b14:	46 02       	not %d2
80007b16:	26 32       	and %d2,%d3
80007b18:	59 e2 cc ef 	st.w [%a14]-116,%d2
            ccucon2.U              |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);
80007b1c:	19 e3 cc ef 	ld.w %d3,[%a14]-116
80007b20:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007b24:	d9 22 14 00 	lea %a2,[%a2]20
80007b28:	54 24       	ld.w %d4,[%a2]
80007b2a:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007b2e:	d9 22 10 00 	lea %a2,[%a2]16
80007b32:	54 22       	ld.w %d2,[%a2]
80007b34:	26 42       	and %d2,%d4
80007b36:	a6 32       	or %d2,%d3
80007b38:	59 e2 cc ef 	st.w [%a14]-116,%d2
            ccucon2.B.CLKSELASCLINS = (uint32)0;
80007b3c:	19 e2 cc ef 	ld.w %d2,[%a14]-116
80007b40:	3b f0 ff 3c 	mov %d3,-12289
80007b44:	26 32       	and %d2,%d3
80007b46:	59 e2 cc ef 	st.w [%a14]-116,%d2
            timeoutCycleCount       = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007b4a:	3b 00 00 21 	mov %d2,4096
80007b4e:	59 e2 c4 ff 	st.w [%a14]-60,%d2
            while (SCU_CCUCON2.B.LCK != 0U)
80007b52:	1d 00 10 00 	j 80007b72 <IfxScuCcu_init+0xc00>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007b56:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007b5a:	c2 f2       	add %d2,-1
80007b5c:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007b60:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007b64:	ff 12 07 00 	jge %d2,1,80007b72 <IfxScuCcu_init+0xc00>
80007b68:	82 12       	mov %d2,1
80007b6a:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007b6e:	1d 00 0d 00 	j 80007b88 <IfxScuCcu_init+0xc16>
            while (SCU_CCUCON2.B.LCK != 0U)
80007b72:	91 30 00 2f 	movh.a %a2,61443
80007b76:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007b7a:	54 22       	ld.w %d2,[%a2]
80007b7c:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007b80:	8f f2 0f 21 	and %d2,%d2,255
80007b84:	df 02 e9 ff 	jne %d2,0,80007b56 <IfxScuCcu_init+0xbe4>
            SCU_CCUCON2.U     = ccucon2.U;
80007b88:	91 30 00 2f 	movh.a %a2,61443
80007b8c:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007b90:	19 e2 cc ef 	ld.w %d2,[%a14]-116 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007b94:	74 22       	st.w [%a2],%d2
            timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007b96:	3b 00 00 21 	mov %d2,4096
80007b9a:	59 e2 c4 ff 	st.w [%a14]-60,%d2
            while (SCU_CCUCON2.B.LCK != 0U)
80007b9e:	1d 00 10 00 	j 80007bbe <IfxScuCcu_init+0xc4c>
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007ba2:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007ba6:	c2 f2       	add %d2,-1
80007ba8:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007bac:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007bb0:	ff 12 07 00 	jge %d2,1,80007bbe <IfxScuCcu_init+0xc4c>
80007bb4:	82 12       	mov %d2,1
80007bb6:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007bba:	1d 00 0d 00 	j 80007bd4 <IfxScuCcu_init+0xc62>
            while (SCU_CCUCON2.B.LCK != 0U)
80007bbe:	91 30 00 2f 	movh.a %a2,61443
80007bc2:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007bc6:	54 22       	ld.w %d2,[%a2]
80007bc8:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007bcc:	8f f2 0f 21 	and %d2,%d2,255
80007bd0:	df 02 e9 ff 	jne %d2,0,80007ba2 <IfxScuCcu_init+0xc30>
        ccucon2.U         = SCU_CCUCON2.U & ~clockDistributionConfig->ccucon2.mask;
80007bd4:	91 30 00 2f 	movh.a %a2,61443
80007bd8:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007bdc:	54 23       	ld.w %d3,[%a2]
80007bde:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007be2:	d9 22 14 00 	lea %a2,[%a2]20 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007be6:	54 22       	ld.w %d2,[%a2]
80007be8:	46 02       	not %d2
80007bea:	26 32       	and %d2,%d3
80007bec:	59 e2 cc ef 	st.w [%a14]-116,%d2
        ccucon2.U        |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);
80007bf0:	19 e3 cc ef 	ld.w %d3,[%a14]-116
80007bf4:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007bf8:	d9 22 14 00 	lea %a2,[%a2]20
80007bfc:	54 24       	ld.w %d4,[%a2]
80007bfe:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007c02:	d9 22 10 00 	lea %a2,[%a2]16
80007c06:	54 22       	ld.w %d2,[%a2]
80007c08:	26 42       	and %d2,%d4
80007c0a:	a6 32       	or %d2,%d3
80007c0c:	59 e2 cc ef 	st.w [%a14]-116,%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007c10:	3b 00 00 21 	mov %d2,4096
80007c14:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        while (SCU_CCUCON2.B.LCK != 0U)
80007c18:	1d 00 10 00 	j 80007c38 <IfxScuCcu_init+0xcc6>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007c1c:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007c20:	c2 f2       	add %d2,-1
80007c22:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007c26:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007c2a:	ff 12 07 00 	jge %d2,1,80007c38 <IfxScuCcu_init+0xcc6>
80007c2e:	82 12       	mov %d2,1
80007c30:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007c34:	1d 00 0d 00 	j 80007c4e <IfxScuCcu_init+0xcdc>
        while (SCU_CCUCON2.B.LCK != 0U)
80007c38:	91 30 00 2f 	movh.a %a2,61443
80007c3c:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007c40:	54 22       	ld.w %d2,[%a2]
80007c42:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007c46:	8f f2 0f 21 	and %d2,%d2,255
80007c4a:	df 02 e9 ff 	jne %d2,0,80007c1c <IfxScuCcu_init+0xcaa>
        SCU_CCUCON2.U     = ccucon2.U;
80007c4e:	91 30 00 2f 	movh.a %a2,61443
80007c52:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007c56:	19 e2 cc ef 	ld.w %d2,[%a14]-116 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007c5a:	74 22       	st.w [%a2],%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007c5c:	3b 00 00 21 	mov %d2,4096
80007c60:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        while (SCU_CCUCON2.B.LCK != 0U)
80007c64:	1d 00 10 00 	j 80007c84 <IfxScuCcu_init+0xd12>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007c68:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007c6c:	c2 f2       	add %d2,-1
80007c6e:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007c72:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007c76:	ff 12 07 00 	jge %d2,1,80007c84 <IfxScuCcu_init+0xd12>
80007c7a:	82 12       	mov %d2,1
80007c7c:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007c80:	1d 00 0d 00 	j 80007c9a <IfxScuCcu_init+0xd28>
        while (SCU_CCUCON2.B.LCK != 0U)
80007c84:	91 30 00 2f 	movh.a %a2,61443
80007c88:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
80007c8c:	54 22       	ld.w %d2,[%a2]
80007c8e:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007c92:	8f f2 0f 21 	and %d2,%d2,255
80007c96:	df 02 e9 ff 	jne %d2,0,80007c68 <IfxScuCcu_init+0xcf6>
        ccucon5.U         = SCU_CCUCON5.U & ~clockDistributionConfig->ccucon5.mask;
80007c9a:	91 30 00 2f 	movh.a %a2,61443
80007c9e:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <bmhd_3_copy+0x40c34a4c>>
80007ca2:	54 23       	ld.w %d3,[%a2]
80007ca4:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f003604c <bmhd_3_copy+0x40c34a4c>>
80007ca8:	d9 22 1c 00 	lea %a2,[%a2]28 <f003604c <bmhd_3_copy+0x40c34a4c>>
80007cac:	54 22       	ld.w %d2,[%a2]
80007cae:	46 02       	not %d2
80007cb0:	26 32       	and %d2,%d3
80007cb2:	59 e2 c8 ef 	st.w [%a14]-120,%d2
        ccucon5.U        |= (clockDistributionConfig->ccucon5.mask & clockDistributionConfig->ccucon5.value);
80007cb6:	19 e3 c8 ef 	ld.w %d3,[%a14]-120
80007cba:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007cbe:	d9 22 1c 00 	lea %a2,[%a2]28
80007cc2:	54 24       	ld.w %d4,[%a2]
80007cc4:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007cc8:	d9 22 18 00 	lea %a2,[%a2]24
80007ccc:	54 22       	ld.w %d2,[%a2]
80007cce:	26 42       	and %d2,%d4
80007cd0:	a6 32       	or %d2,%d3
80007cd2:	59 e2 c8 ef 	st.w [%a14]-120,%d2
        ccucon5.B.UP      = 1;
80007cd6:	19 e2 c8 ef 	ld.w %d2,[%a14]-120
80007cda:	b7 12 01 2f 	insert %d2,%d2,1,30,1
80007cde:	59 e2 c8 ef 	st.w [%a14]-120,%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007ce2:	3b 00 00 21 	mov %d2,4096
80007ce6:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        while (SCU_CCUCON5.B.LCK != 0U)
80007cea:	1d 00 10 00 	j 80007d0a <IfxScuCcu_init+0xd98>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007cee:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007cf2:	c2 f2       	add %d2,-1
80007cf4:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007cf8:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007cfc:	ff 12 07 00 	jge %d2,1,80007d0a <IfxScuCcu_init+0xd98>
80007d00:	82 12       	mov %d2,1
80007d02:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007d06:	1d 00 0d 00 	j 80007d20 <IfxScuCcu_init+0xdae>
        while (SCU_CCUCON5.B.LCK != 0U)
80007d0a:	91 30 00 2f 	movh.a %a2,61443
80007d0e:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <bmhd_3_copy+0x40c34a4c>>
80007d12:	54 22       	ld.w %d2,[%a2]
80007d14:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007d18:	8f f2 0f 21 	and %d2,%d2,255
80007d1c:	df 02 e9 ff 	jne %d2,0,80007cee <IfxScuCcu_init+0xd7c>
        SCU_CCUCON5.U     = ccucon5.U;
80007d20:	91 30 00 2f 	movh.a %a2,61443
80007d24:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <bmhd_3_copy+0x40c34a4c>>
80007d28:	19 e2 c8 ef 	ld.w %d2,[%a14]-120 <f003604c <bmhd_3_copy+0x40c34a4c>>
80007d2c:	74 22       	st.w [%a2],%d2
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;
80007d2e:	3b 00 00 21 	mov %d2,4096
80007d32:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        while (SCU_CCUCON5.B.LCK != 0U)
80007d36:	1d 00 10 00 	j 80007d56 <IfxScuCcu_init+0xde4>
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
80007d3a:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007d3e:	c2 f2       	add %d2,-1
80007d40:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80007d44:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80007d48:	ff 12 07 00 	jge %d2,1,80007d56 <IfxScuCcu_init+0xde4>
80007d4c:	82 12       	mov %d2,1
80007d4e:	59 e2 d4 ff 	st.w [%a14]-44,%d2
80007d52:	1d 00 0d 00 	j 80007d6c <IfxScuCcu_init+0xdfa>
        while (SCU_CCUCON5.B.LCK != 0U)
80007d56:	91 30 00 2f 	movh.a %a2,61443
80007d5a:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <bmhd_3_copy+0x40c34a4c>>
80007d5e:	54 22       	ld.w %d2,[%a2]
80007d60:	37 02 e1 2f 	extr.u %d2,%d2,31,1
80007d64:	8f f2 0f 21 	and %d2,%d2,255
80007d68:	df 02 e9 ff 	jne %d2,0,80007d3a <IfxScuCcu_init+0xdc8>
        ccucon6.U     = SCU_CCUCON6.U & ~clockDistributionConfig->ccucon6.mask;
80007d6c:	91 30 00 2f 	movh.a %a2,61443
80007d70:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <bmhd_3_copy+0x40c34a80>>
80007d74:	54 23       	ld.w %d3,[%a2]
80007d76:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036080 <bmhd_3_copy+0x40c34a80>>
80007d7a:	d9 22 24 00 	lea %a2,[%a2]36 <f0036080 <bmhd_3_copy+0x40c34a80>>
80007d7e:	54 22       	ld.w %d2,[%a2]
80007d80:	46 02       	not %d2
80007d82:	26 32       	and %d2,%d3
80007d84:	59 e2 c4 ef 	st.w [%a14]-124,%d2
        ccucon6.U    |= (clockDistributionConfig->ccucon6.mask & clockDistributionConfig->ccucon6.value);
80007d88:	19 e3 c4 ef 	ld.w %d3,[%a14]-124
80007d8c:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007d90:	d9 22 24 00 	lea %a2,[%a2]36
80007d94:	54 24       	ld.w %d4,[%a2]
80007d96:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007d9a:	d9 22 20 00 	lea %a2,[%a2]32
80007d9e:	54 22       	ld.w %d2,[%a2]
80007da0:	26 42       	and %d2,%d4
80007da2:	a6 32       	or %d2,%d3
80007da4:	59 e2 c4 ef 	st.w [%a14]-124,%d2
        SCU_CCUCON6.U = ccucon6.U;
80007da8:	91 30 00 2f 	movh.a %a2,61443
80007dac:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <bmhd_3_copy+0x40c34a80>>
80007db0:	19 e2 c4 ef 	ld.w %d2,[%a14]-124 <f0036080 <bmhd_3_copy+0x40c34a80>>
80007db4:	74 22       	st.w [%a2],%d2
        ccucon7.U     = SCU_CCUCON7.U & ~clockDistributionConfig->ccucon7.mask;
80007db6:	91 30 00 2f 	movh.a %a2,61443
80007dba:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <bmhd_3_copy+0x40c34a84>>
80007dbe:	54 23       	ld.w %d3,[%a2]
80007dc0:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036084 <bmhd_3_copy+0x40c34a84>>
80007dc4:	d9 22 2c 00 	lea %a2,[%a2]44 <f0036084 <bmhd_3_copy+0x40c34a84>>
80007dc8:	54 22       	ld.w %d2,[%a2]
80007dca:	46 02       	not %d2
80007dcc:	26 32       	and %d2,%d3
80007dce:	59 e2 c0 ef 	st.w [%a14]-128,%d2
        ccucon7.U    |= (clockDistributionConfig->ccucon7.mask & clockDistributionConfig->ccucon7.value);
80007dd2:	19 e3 c0 ef 	ld.w %d3,[%a14]-128
80007dd6:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007dda:	d9 22 2c 00 	lea %a2,[%a2]44
80007dde:	54 24       	ld.w %d4,[%a2]
80007de0:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007de4:	d9 22 28 00 	lea %a2,[%a2]40
80007de8:	54 22       	ld.w %d2,[%a2]
80007dea:	26 42       	and %d2,%d4
80007dec:	a6 32       	or %d2,%d3
80007dee:	59 e2 c0 ef 	st.w [%a14]-128,%d2
        SCU_CCUCON7.U = ccucon7.U;
80007df2:	91 30 00 2f 	movh.a %a2,61443
80007df6:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <bmhd_3_copy+0x40c34a84>>
80007dfa:	19 e2 c0 ef 	ld.w %d2,[%a14]-128 <f0036084 <bmhd_3_copy+0x40c34a84>>
80007dfe:	74 22       	st.w [%a2],%d2
        ccucon8.U     = SCU_CCUCON8.U & ~clockDistributionConfig->ccucon8.mask;
80007e00:	91 30 00 2f 	movh.a %a2,61443
80007e04:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <bmhd_3_copy+0x40c34a88>>
80007e08:	54 23       	ld.w %d3,[%a2]
80007e0a:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036088 <bmhd_3_copy+0x40c34a88>>
80007e0e:	d9 22 34 00 	lea %a2,[%a2]52 <f0036088 <bmhd_3_copy+0x40c34a88>>
80007e12:	54 22       	ld.w %d2,[%a2]
80007e14:	46 02       	not %d2
80007e16:	26 32       	and %d2,%d3
80007e18:	59 e2 fc df 	st.w [%a14]-132,%d2
        ccucon8.U    |= (clockDistributionConfig->ccucon8.mask & clockDistributionConfig->ccucon8.value);
80007e1c:	19 e3 fc df 	ld.w %d3,[%a14]-132
80007e20:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007e24:	d9 22 34 00 	lea %a2,[%a2]52
80007e28:	54 24       	ld.w %d4,[%a2]
80007e2a:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007e2e:	d9 22 30 00 	lea %a2,[%a2]48
80007e32:	54 22       	ld.w %d2,[%a2]
80007e34:	26 42       	and %d2,%d4
80007e36:	a6 32       	or %d2,%d3
80007e38:	59 e2 fc df 	st.w [%a14]-132,%d2
        SCU_CCUCON8.U = ccucon8.U;
80007e3c:	91 30 00 2f 	movh.a %a2,61443
80007e40:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <bmhd_3_copy+0x40c34a88>>
80007e44:	19 e2 fc df 	ld.w %d2,[%a14]-132 <f0036088 <bmhd_3_copy+0x40c34a88>>
80007e48:	74 22       	st.w [%a2],%d2
        ccucon9.U     = SCU_CCUCON9.U & ~clockDistributionConfig->ccucon9.mask;
80007e4a:	91 30 00 2f 	movh.a %a2,61443
80007e4e:	d9 22 0c 26 	lea %a2,[%a2]24716 <f003608c <bmhd_3_copy+0x40c34a8c>>
80007e52:	54 23       	ld.w %d3,[%a2]
80007e54:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f003608c <bmhd_3_copy+0x40c34a8c>>
80007e58:	d9 22 3c 00 	lea %a2,[%a2]60 <f003608c <bmhd_3_copy+0x40c34a8c>>
80007e5c:	54 22       	ld.w %d2,[%a2]
80007e5e:	46 02       	not %d2
80007e60:	26 32       	and %d2,%d3
80007e62:	59 e2 f8 df 	st.w [%a14]-136,%d2
        ccucon9.U    |= (clockDistributionConfig->ccucon9.mask & clockDistributionConfig->ccucon9.value);
80007e66:	19 e3 f8 df 	ld.w %d3,[%a14]-136
80007e6a:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007e6e:	d9 22 3c 00 	lea %a2,[%a2]60
80007e72:	54 24       	ld.w %d4,[%a2]
80007e74:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007e78:	d9 22 38 00 	lea %a2,[%a2]56
80007e7c:	54 22       	ld.w %d2,[%a2]
80007e7e:	26 42       	and %d2,%d4
80007e80:	a6 32       	or %d2,%d3
80007e82:	59 e2 f8 df 	st.w [%a14]-136,%d2
        SCU_CCUCON9.U = ccucon9.U;
80007e86:	91 30 00 2f 	movh.a %a2,61443
80007e8a:	d9 22 0c 26 	lea %a2,[%a2]24716 <f003608c <bmhd_3_copy+0x40c34a8c>>
80007e8e:	19 e2 f8 df 	ld.w %d2,[%a14]-136 <f003608c <bmhd_3_copy+0x40c34a8c>>
80007e92:	74 22       	st.w [%a2],%d2
        ccucon10.U     = SCU_CCUCON10.U & ~clockDistributionConfig->ccucon10.mask;
80007e94:	91 30 00 2f 	movh.a %a2,61443
80007e98:	d9 22 10 26 	lea %a2,[%a2]24720 <f0036090 <bmhd_3_copy+0x40c34a90>>
80007e9c:	54 23       	ld.w %d3,[%a2]
80007e9e:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036090 <bmhd_3_copy+0x40c34a90>>
80007ea2:	d9 22 04 10 	lea %a2,[%a2]68 <f0036090 <bmhd_3_copy+0x40c34a90>>
80007ea6:	54 22       	ld.w %d2,[%a2]
80007ea8:	46 02       	not %d2
80007eaa:	26 32       	and %d2,%d3
80007eac:	59 e2 f4 df 	st.w [%a14]-140,%d2
        ccucon10.U    |= (clockDistributionConfig->ccucon10.mask & clockDistributionConfig->ccucon10.value);
80007eb0:	19 e3 f4 df 	ld.w %d3,[%a14]-140
80007eb4:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007eb8:	d9 22 04 10 	lea %a2,[%a2]68
80007ebc:	54 24       	ld.w %d4,[%a2]
80007ebe:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007ec2:	d9 22 00 10 	lea %a2,[%a2]64
80007ec6:	54 22       	ld.w %d2,[%a2]
80007ec8:	26 42       	and %d2,%d4
80007eca:	a6 32       	or %d2,%d3
80007ecc:	59 e2 f4 df 	st.w [%a14]-140,%d2
        SCU_CCUCON10.U = ccucon10.U;
80007ed0:	91 30 00 2f 	movh.a %a2,61443
80007ed4:	d9 22 10 26 	lea %a2,[%a2]24720 <f0036090 <bmhd_3_copy+0x40c34a90>>
80007ed8:	19 e2 f4 df 	ld.w %d2,[%a14]-140 <f0036090 <bmhd_3_copy+0x40c34a90>>
80007edc:	74 22       	st.w [%a2],%d2
        ccucon11.U     = SCU_CCUCON11.U & ~clockDistributionConfig->ccucon11.mask;
80007ede:	91 30 00 2f 	movh.a %a2,61443
80007ee2:	d9 22 14 26 	lea %a2,[%a2]24724 <f0036094 <bmhd_3_copy+0x40c34a94>>
80007ee6:	54 23       	ld.w %d3,[%a2]
80007ee8:	99 e2 d8 ff 	ld.a %a2,[%a14]-40 <f0036094 <bmhd_3_copy+0x40c34a94>>
80007eec:	d9 22 0c 10 	lea %a2,[%a2]76 <f0036094 <bmhd_3_copy+0x40c34a94>>
80007ef0:	54 22       	ld.w %d2,[%a2]
80007ef2:	46 02       	not %d2
80007ef4:	26 32       	and %d2,%d3
80007ef6:	59 e2 f0 df 	st.w [%a14]-144,%d2
        ccucon11.U    |= (clockDistributionConfig->ccucon11.mask & clockDistributionConfig->ccucon11.value);
80007efa:	19 e3 f0 df 	ld.w %d3,[%a14]-144
80007efe:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007f02:	d9 22 0c 10 	lea %a2,[%a2]76
80007f06:	54 24       	ld.w %d4,[%a2]
80007f08:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80007f0c:	d9 22 08 10 	lea %a2,[%a2]72
80007f10:	54 22       	ld.w %d2,[%a2]
80007f12:	26 42       	and %d2,%d4
80007f14:	a6 32       	or %d2,%d3
80007f16:	59 e2 f0 df 	st.w [%a14]-144,%d2
        SCU_CCUCON11.U = ccucon11.U;
80007f1a:	91 30 00 2f 	movh.a %a2,61443
80007f1e:	d9 22 14 26 	lea %a2,[%a2]24724 <f0036094 <bmhd_3_copy+0x40c34a94>>
80007f22:	19 e2 f0 df 	ld.w %d2,[%a14]-144 <f0036094 <bmhd_3_copy+0x40c34a94>>
80007f26:	74 22       	st.w [%a2],%d2
    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
80007f28:	b9 e2 cc ff 	ld.hu %d2,[%a14]-52 <f0036094 <bmhd_3_copy+0x40c34a94>>
80007f2c:	f9 e2 c2 ff 	st.h [%a14]-62 <f0036094 <bmhd_3_copy+0x40c34a94>>,%d2
    if (SCU_WDTS_CON0.B.LCK)
80007f30:	91 30 00 2f 	movh.a %a2,61443
80007f34:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007f38:	54 22       	ld.w %d2,[%a2]
80007f3a:	37 02 e1 20 	extr.u %d2,%d2,1,1
80007f3e:	8f f2 0f 21 	and %d2,%d2,255
80007f42:	df 02 18 00 	jeq %d2,0,80007f72 <IfxScuCcu_init+0x1000>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007f46:	b9 e2 c2 ff 	ld.hu %d2,[%a14]-62
80007f4a:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80007f4c:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007f50:	91 30 00 2f 	movh.a %a2,61443
80007f54:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007f58:	54 22       	ld.w %d2,[%a2]
80007f5a:	37 02 70 28 	extr.u %d2,%d2,16,16
80007f5e:	37 02 70 20 	extr.u %d2,%d2,0,16
80007f62:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007f66:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007f68:	91 30 00 2f 	movh.a %a2,61443
80007f6c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007f70:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007f72:	b9 e2 c2 ff 	ld.hu %d2,[%a14]-62 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007f76:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80007f78:	8f 32 40 31 	or %d3,%d2,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007f7c:	91 30 00 2f 	movh.a %a2,61443
80007f80:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007f84:	54 22       	ld.w %d2,[%a2]
80007f86:	37 02 70 28 	extr.u %d2,%d2,16,16
80007f8a:	37 02 70 20 	extr.u %d2,%d2,0,16
80007f8e:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007f92:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007f94:	91 30 00 2f 	movh.a %a2,61443
80007f98:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007f9c:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80007f9e:	00 00       	nop 
80007fa0:	91 30 00 2f 	movh.a %a2,61443
80007fa4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80007fa8:	54 22       	ld.w %d2,[%a2]
80007faa:	37 02 61 20 	extr.u %d2,%d2,0,1
80007fae:	8f f2 0f 21 	and %d2,%d2,255
80007fb2:	df 02 f7 7f 	jeq %d2,0,80007fa0 <IfxScuCcu_init+0x102e>
}
80007fb6:	00 00       	nop 
    return (boolean)initError;
80007fb8:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
80007fbc:	8f f2 0f 21 	and %d2,%d2,255
80007fc0:	e9 e2 ff ff 	st.b [%a14]-1,%d2
        IfxScuWdt_setCpuEndinit(endInitPW);
    }

#endif

    if (!status)
80007fc4:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80007fc8:	df 02 37 81 	jne %d2,0,80008236 <_SMALL_DATA2_+0x236>
    {
        status = IfxScuCcu_throttleSysPllClockInline(&config->sysPllThrottleConfig);
80007fcc:	19 e2 d4 df 	ld.w %d2,[%a14]-172
80007fd0:	1b 82 01 20 	addi %d2,%d2,24
80007fd4:	59 e2 fc ef 	st.w [%a14]-68,%d2
}


IFX_INLINE boolean IfxScuCcu_throttleSysPllClockInline(const IfxScuCcu_PllThrottleConfig *pllThrottleConfig)
{
    uint8  initError = 0;
80007fd8:	82 02       	mov %d2,0
80007fda:	e9 e2 fb ef 	st.b [%a14]-69,%d2
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;
80007fde:	7b 30 00 2f 	movh %d2,61443
80007fe2:	1b 82 2a 26 	addi %d2,%d2,25256
80007fe6:	59 e2 f4 ef 	st.w [%a14]-76,%d2
    password  = watchdog->CON0.B.PW;
80007fea:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80007fee:	54 22       	ld.w %d2,[%a2]
80007ff0:	37 02 6e 21 	extr.u %d2,%d2,2,14
80007ff4:	37 02 70 20 	extr.u %d2,%d2,0,16
80007ff8:	f9 e2 f2 ef 	st.h [%a14]-78,%d2
    password ^= 0x003F;
80007ffc:	c9 e2 f2 ef 	ld.h %d2,[%a14]-78
80008000:	8f f2 83 21 	xor %d2,%d2,63
80008004:	f9 e2 f2 ef 	st.h [%a14]-78,%d2
    return password;
80008008:	b9 e2 f2 ef 	ld.hu %d2,[%a14]-78
    uint8  pllStepsCount;
    uint16 endinitSfty_pw;
    uint32 timeoutCycleCount;

    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();
8000800c:	f9 e2 f0 ef 	st.h [%a14]-80,%d2

    /*Start Pll ramp up sequence */
    for (pllStepsCount = 0; pllStepsCount < pllThrottleConfig->numOfSteps; pllStepsCount++)
80008010:	82 02       	mov %d2,0
80008012:	e9 e2 ef ef 	st.b [%a14]-81,%d2
80008016:	1d 00 05 01 	j 80008220 <_SMALL_DATA2_+0x220>
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);
8000801a:	b9 e2 f0 ef 	ld.hu %d2,[%a14]-80
8000801e:	f9 e2 ec ef 	st.h [%a14]-84,%d2
    if (SCU_WDTS_CON0.B.LCK)
80008022:	91 30 00 2f 	movh.a %a2,61443
80008026:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000802a:	54 22       	ld.w %d2,[%a2]
8000802c:	37 02 e1 20 	extr.u %d2,%d2,1,1
80008030:	8f f2 0f 21 	and %d2,%d2,255
80008034:	df 02 18 00 	jeq %d2,0,80008064 <_SMALL_DATA2_+0x64>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008038:	b9 e2 ec ef 	ld.hu %d2,[%a14]-84
8000803c:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000803e:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80008042:	91 30 00 2f 	movh.a %a2,61443
80008046:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000804a:	54 22       	ld.w %d2,[%a2]
8000804c:	37 02 70 28 	extr.u %d2,%d2,16,16
80008050:	37 02 70 20 	extr.u %d2,%d2,0,16
80008054:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008058:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000805a:	91 30 00 2f 	movh.a %a2,61443
8000805e:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008062:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008064:	b9 e2 ec ef 	ld.hu %d2,[%a14]-84 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008068:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000806a:	8f 22 40 31 	or %d3,%d2,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000806e:	91 30 00 2f 	movh.a %a2,61443
80008072:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008076:	54 22       	ld.w %d2,[%a2]
80008078:	37 02 70 28 	extr.u %d2,%d2,16,16
8000807c:	37 02 70 20 	extr.u %d2,%d2,0,16
80008080:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008084:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80008086:	91 30 00 2f 	movh.a %a2,61443
8000808a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000808e:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80008090:	00 00       	nop 
80008092:	91 30 00 2f 	movh.a %a2,61443
80008096:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000809a:	54 22       	ld.w %d2,[%a2]
8000809c:	37 02 61 20 	extr.u %d2,%d2,0,1
800080a0:	8f f2 0f 21 	and %d2,%d2,255
800080a4:	df 12 f7 7f 	jeq %d2,1,80008092 <_SMALL_DATA2_+0x92>
}
800080a8:	00 00       	nop 

            /*Configure K2 divider */
            timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;
800080aa:	3b 00 00 26 	mov %d2,24576
800080ae:	59 e2 e8 ef 	st.w [%a14]-88,%d2

            while (SCU_SYSPLLSTAT.B.K2RDY == 0U)
800080b2:	1d 00 10 00 	j 800080d2 <_SMALL_DATA2_+0xd2>
            {
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
800080b6:	19 e2 e8 ef 	ld.w %d2,[%a14]-88
800080ba:	c2 f2       	add %d2,-1
800080bc:	59 e2 e8 ef 	st.w [%a14]-88,%d2
800080c0:	19 e2 e8 ef 	ld.w %d2,[%a14]-88
800080c4:	ff 12 07 00 	jge %d2,1,800080d2 <_SMALL_DATA2_+0xd2>
800080c8:	82 12       	mov %d2,1
800080ca:	e9 e2 fb ef 	st.b [%a14]-69,%d2
800080ce:	1d 00 0d 00 	j 800080e8 <_SMALL_DATA2_+0xe8>
            while (SCU_SYSPLLSTAT.B.K2RDY == 0U)
800080d2:	91 30 00 2f 	movh.a %a2,61443
800080d6:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <bmhd_3_copy+0x40c34a14>>
800080da:	54 22       	ld.w %d2,[%a2]
800080dc:	37 02 e1 22 	extr.u %d2,%d2,5,1
800080e0:	8f f2 0f 21 	and %d2,%d2,255
800080e4:	df 02 e9 7f 	jeq %d2,0,800080b6 <_SMALL_DATA2_+0xb6>
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_SYSPLLCON1.B.K2DIV = pllThrottleConfig->pllSteps[pllStepsCount].k2Step;
800080e8:	99 e2 fc ef 	ld.a %a2,[%a14]-68
800080ec:	b0 42       	add.a %a2,4
800080ee:	54 23       	ld.w %d3,[%a2]
800080f0:	39 e2 ef ef 	ld.bu %d2,[%a14]-81
800080f4:	06 32       	sh %d2,3
800080f6:	60 32       	mov.a %a2,%d3
800080f8:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800080fc:	14 22       	ld.bu %d2,[%a2]
800080fe:	91 30 00 2f 	movh.a %a2,61443
80008102:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <bmhd_3_copy+0x40c34a1c>>
80008106:	8f 72 00 21 	and %d2,%d2,7
8000810a:	8f f2 0f 31 	and %d3,%d2,255
8000810e:	54 22       	ld.w %d2,[%a2]
80008110:	37 32 03 20 	insert %d2,%d2,%d3,0,3
80008114:	74 22       	st.w [%a2],%d2
            IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
80008116:	b9 e2 f0 ef 	ld.hu %d2,[%a14]-80
8000811a:	f9 e2 e6 ef 	st.h [%a14]-90,%d2
    if (SCU_WDTS_CON0.B.LCK)
8000811e:	91 30 00 2f 	movh.a %a2,61443
80008122:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008126:	54 22       	ld.w %d2,[%a2]
80008128:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000812c:	8f f2 0f 21 	and %d2,%d2,255
80008130:	df 02 18 00 	jeq %d2,0,80008160 <_SMALL_DATA2_+0x160>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008134:	b9 e2 e6 ef 	ld.hu %d2,[%a14]-90
80008138:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000813a:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000813e:	91 30 00 2f 	movh.a %a2,61443
80008142:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008146:	54 22       	ld.w %d2,[%a2]
80008148:	37 02 70 28 	extr.u %d2,%d2,16,16
8000814c:	37 02 70 20 	extr.u %d2,%d2,0,16
80008150:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008154:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80008156:	91 30 00 2f 	movh.a %a2,61443
8000815a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000815e:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008160:	b9 e2 e6 ef 	ld.hu %d2,[%a14]-90 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008164:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80008166:	8f 32 40 31 	or %d3,%d2,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000816a:	91 30 00 2f 	movh.a %a2,61443
8000816e:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008172:	54 22       	ld.w %d2,[%a2]
80008174:	37 02 70 28 	extr.u %d2,%d2,16,16
80008178:	37 02 70 20 	extr.u %d2,%d2,0,16
8000817c:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008180:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80008182:	91 30 00 2f 	movh.a %a2,61443
80008186:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000818a:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000818c:	00 00       	nop 
8000818e:	91 30 00 2f 	movh.a %a2,61443
80008192:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008196:	54 22       	ld.w %d2,[%a2]
80008198:	37 02 61 20 	extr.u %d2,%d2,0,1
8000819c:	8f f2 0f 21 	and %d2,%d2,255
800081a0:	df 02 f7 7f 	jeq %d2,0,8000818e <_SMALL_DATA2_+0x18e>
}
800081a4:	00 00       	nop 
        }

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(pllThrottleConfig->pllSteps[pllStepsCount].waitTime);
800081a6:	99 e2 fc ef 	ld.a %a2,[%a14]-68
800081aa:	b0 42       	add.a %a2,4
800081ac:	54 23       	ld.w %d3,[%a2]
800081ae:	39 e2 ef ef 	ld.bu %d2,[%a14]-81
800081b2:	06 32       	sh %d2,3
800081b4:	60 32       	mov.a %a2,%d3
800081b6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800081ba:	b0 42       	add.a %a2,4
800081bc:	54 22       	ld.w %d2,[%a2]
800081be:	59 e2 e0 ef 	st.w [%a14]-96,%d2
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / SCU_CCUCON0.B.STMDIV;
800081c2:	82 04       	mov %d4,0
800081c4:	6d ff 76 f6 	call 80006eb0 <IfxScuCcu_getSourceFrequency>
800081c8:	02 23       	mov %d3,%d2
800081ca:	91 30 00 2f 	movh.a %a2,61443
800081ce:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
800081d2:	54 22       	ld.w %d2,[%a2]
800081d4:	37 02 64 20 	extr.u %d2,%d2,0,4
800081d8:	8f f2 0f 21 	and %d2,%d2,255
800081dc:	4b 02 41 21 	itof %d2,%d2
800081e0:	4b 23 51 30 	div.f %d3,%d3,%d2
}


IFX_INLINE void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
800081e4:	19 e2 e0 ef 	ld.w %d2,[%a14]-96
800081e8:	4b 23 41 20 	mul.f %d2,%d3,%d2
800081ec:	4b 02 71 21 	ftouz %d2,%d2
800081f0:	59 e2 dc ef 	st.w [%a14]-100,%d2
    uint32 stmCountBegin = STM0_TIM0.U;
800081f4:	c5 f2 10 01 	lea %a2,f0001010 <bmhd_3_copy+0x40bffa10>
800081f8:	54 22       	ld.w %d2,[%a2]
800081fa:	59 e2 d8 ef 	st.w [%a14]-104,%d2

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
800081fe:	00 00       	nop 
80008200:	c5 f2 10 01 	lea %a2,f0001010 <bmhd_3_copy+0x40bffa10>
80008204:	54 23       	ld.w %d3,[%a2]
80008206:	19 e2 d8 ef 	ld.w %d2,[%a14]-104
8000820a:	a2 23       	sub %d3,%d2
8000820c:	19 e2 dc ef 	ld.w %d2,[%a14]-100
80008210:	3f 23 f8 ff 	jlt.u %d3,%d2,80008200 <_SMALL_DATA2_+0x200>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
80008214:	00 00       	nop 
    for (pllStepsCount = 0; pllStepsCount < pllThrottleConfig->numOfSteps; pllStepsCount++)
80008216:	39 e2 ef ef 	ld.bu %d2,[%a14]-81
8000821a:	c2 12       	add %d2,1
8000821c:	e9 e2 ef ef 	st.b [%a14]-81,%d2
80008220:	99 e2 fc ef 	ld.a %a2,[%a14]-68
80008224:	14 22       	ld.bu %d2,[%a2]
80008226:	39 e3 ef ef 	ld.bu %d3,[%a14]-81
8000822a:	3f 23 f8 fe 	jlt.u %d3,%d2,8000801a <_SMALL_DATA2_+0x1a>
    return (boolean)initError;
8000822e:	39 e2 fb ef 	ld.bu %d2,[%a14]-69
80008232:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    }

    return status;
80008236:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
}
8000823a:	00 90       	ret 

8000823c <IfxScuCcu_modulation_init>:
    *cfg = IfxScuCcu_defaultClockConfig;
}


void IfxScuCcu_modulation_init(const IfxScuCcu_Mod_Config *Mod_Cfg)
{
8000823c:	40 ae       	mov.aa %a14,%sp
8000823e:	20 28       	sub.a %sp,40
80008240:	b5 e4 dc ff 	st.a [%a14]-36,%a4
    uint16                        endinitSfty_pw;
    IfxScuCcu_RGain_Values        RGain_P;
    IfxScuCcu_ModEn               mod_enable = Mod_Cfg->Mod_Enable;
80008244:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80008248:	54 22       	ld.w %d2,[%a2]
8000824a:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxScuCcu_ModulationAmplitude Mod_Amp    = Mod_Cfg->Mod_Amp;
8000824e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80008252:	b0 42       	add.a %a2,4
80008254:	54 22       	ld.w %d2,[%a2]
80008256:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    Ifx_SCU_SYSPLLCON0            syspllcon0;
    Ifx_SCU_SYSPLLCON2            syspllcon2;

    if (mod_enable == IfxScuCcu_ModEn_enabled)  /* do this only if modulation is enabled */
8000825a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000825e:	df 12 42 80 	jne %d2,1,800082e2 <IfxScuCcu_modulation_init+0xa6>
    {
        /* Get the parameters */
        IfxScuCcu_calRGainParameters(Mod_Amp, &RGain_P);
80008262:	d9 e2 ec ff 	lea %a2,[%a14]-20
80008266:	40 24       	mov.aa %a4,%a2
80008268:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
8000826c:	6d ff 62 f3 	call 80006930 <IfxScuCcu_calRGainParameters>

        /* clear endinit protection */
        endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80008270:	6d 00 68 02 	call 80008740 <IfxScuWdt_getSafetyWatchdogPassword>
80008274:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80008278:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10
8000827c:	02 24       	mov %d4,%d2
8000827e:	6d 00 95 00 	call 800083a8 <IfxScuWdt_clearSafetyEndinit>

        /* write all registers here */

        /* Write SYSPLLCON2 with RGain */
        syspllcon2.U        = SCU_SYSPLLCON2.U;
80008282:	91 30 00 2f 	movh.a %a2,61443
80008286:	d9 22 20 06 	lea %a2,[%a2]24608 <f0036020 <bmhd_3_copy+0x40c34a20>>
8000828a:	54 22       	ld.w %d2,[%a2]
8000828c:	59 e2 e4 ff 	st.w [%a14]-28 <f0036020 <bmhd_3_copy+0x40c34a20>>,%d2
        syspllcon2.B.MODCFG = IFXSCUCCU_GET_MODCFG(RGain_P.RGainHex);
80008290:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16 <f0036020 <bmhd_3_copy+0x40c34a20>>
80008294:	3b 00 40 3f 	mov %d3,-3072
80008298:	a6 32       	or %d2,%d3
8000829a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000829e:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
        SCU_SYSPLLCON2.U    = syspllcon2.U;
800082a2:	91 30 00 2f 	movh.a %a2,61443
800082a6:	d9 22 20 06 	lea %a2,[%a2]24608 <f0036020 <bmhd_3_copy+0x40c34a20>>
800082aa:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <f0036020 <bmhd_3_copy+0x40c34a20>>
800082ae:	74 22       	st.w [%a2],%d2

        /* enable modulation now */
        syspllcon0.U       = SCU_SYSPLLCON0.U;
800082b0:	91 30 00 2f 	movh.a %a2,61443
800082b4:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
800082b8:	54 22       	ld.w %d2,[%a2]
800082ba:	59 e2 e8 ff 	st.w [%a14]-24 <f0036018 <bmhd_3_copy+0x40c34a18>>,%d2
        syspllcon0.B.MODEN = (uint32)IfxScuCcu_ModEn_enabled;
800082be:	19 e2 e8 ff 	ld.w %d2,[%a14]-24 <f0036018 <bmhd_3_copy+0x40c34a18>>
800082c2:	b7 12 01 21 	insert %d2,%d2,1,2,1
800082c6:	59 e2 e8 ff 	st.w [%a14]-24,%d2
        SCU_SYSPLLCON0.U   = syspllcon0.U;
800082ca:	91 30 00 2f 	movh.a %a2,61443
800082ce:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
800082d2:	19 e2 e8 ff 	ld.w %d2,[%a14]-24 <f0036018 <bmhd_3_copy+0x40c34a18>>
800082d6:	74 22       	st.w [%a2],%d2

        /* set the endinit protection again */
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800082d8:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10 <f0036018 <bmhd_3_copy+0x40c34a18>>
800082dc:	02 24       	mov %d4,%d2
800082de:	6d 00 ac 02 	call 80008836 <IfxScuWdt_setSafetyEndinit>
    }
}
800082e2:	00 00       	nop 
800082e4:	00 90       	ret 

800082e6 <IfxScuWdt_clearCpuEndinit>:
    {}
}


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
800082e6:	40 ae       	mov.aa %a14,%sp
800082e8:	20 28       	sub.a %sp,40
800082ea:	02 42       	mov %d2,%d4
800082ec:	f9 e2 dc ff 	st.h [%a14]-36,%d2
    reg = __mfcr(CPU_CORE_ID);
800082f0:	4d c0 e1 2f 	mfcr %d2,$core_id
800082f4:	59 e2 f4 ff 	st.w [%a14]-12,%d2
800082f8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800082fc:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80008300:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80008304:	59 e2 ec ff 	st.w [%a14]-20,%d2
80008308:	82 52       	mov %d2,5
8000830a:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000830e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80008312:	19 e3 e8 ff 	ld.w %d3,[%a14]-24
80008316:	0b 32 90 21 	min.u %d2,%d2,%d3
8000831a:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return res;
8000831e:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80008322:	53 c2 20 20 	mul %d2,%d2,12
80008326:	1b c2 24 36 	addi %d3,%d2,25164
8000832a:	9b 33 00 3f 	addih %d3,%d3,61443
8000832e:	b9 e2 dc ff 	ld.hu %d2,[%a14]-36
80008332:	59 e3 fc ff 	st.w [%a14]-4,%d3
80008336:	f9 e2 fa ff 	st.h [%a14]-6,%d2
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000833a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000833e:	54 22       	ld.w %d2,[%a2]
80008340:	37 02 e1 20 	extr.u %d2,%d2,1,1
80008344:	8f f2 0f 21 	and %d2,%d2,255
80008348:	df 02 14 00 	jeq %d2,0,80008370 <IfxScuWdt_clearCpuEndinit+0x8a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000834c:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80008350:	06 22       	sh %d2,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80008352:	8f 12 40 31 	or %d3,%d2,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80008356:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000835a:	54 22       	ld.w %d2,[%a2]
8000835c:	37 02 70 28 	extr.u %d2,%d2,16,16
80008360:	37 02 70 20 	extr.u %d2,%d2,0,16
80008364:	8f 02 01 20 	sh %d2,%d2,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80008368:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000836a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000836e:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80008370:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80008374:	06 22       	sh %d2,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80008376:	8f 22 40 31 	or %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000837a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000837e:	54 22       	ld.w %d2,[%a2]
80008380:	37 02 70 28 	extr.u %d2,%d2,16,16
80008384:	37 02 70 20 	extr.u %d2,%d2,0,16
80008388:	8f 02 01 20 	sh %d2,%d2,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000838c:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000838e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008392:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80008394:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008398:	54 22       	ld.w %d2,[%a2]
8000839a:	37 02 61 20 	extr.u %d2,%d2,0,1
8000839e:	8f f2 0f 21 	and %d2,%d2,255
800083a2:	df 12 f9 7f 	jeq %d2,1,80008394 <IfxScuWdt_clearCpuEndinit+0xae>
}
800083a6:	00 90       	ret 

800083a8 <IfxScuWdt_clearSafetyEndinit>:
    {}
}


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
800083a8:	40 ae       	mov.aa %a14,%sp
800083aa:	20 10       	sub.a %sp,16
800083ac:	02 42       	mov %d2,%d4
800083ae:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    IfxScuWdt_clearSafetyEndinitInline(password);
800083b2:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
800083b6:	f9 e2 fe ff 	st.h [%a14]-2,%d2
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800083ba:	91 30 00 2f 	movh.a %a2,61443
800083be:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800083c2:	54 22       	ld.w %d2,[%a2]
800083c4:	37 02 e1 20 	extr.u %d2,%d2,1,1
800083c8:	8f f2 0f 21 	and %d2,%d2,255
800083cc:	df 02 18 00 	jeq %d2,0,800083fc <IfxScuWdt_clearSafetyEndinit+0x54>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800083d0:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800083d4:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800083d6:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800083da:	91 30 00 2f 	movh.a %a2,61443
800083de:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800083e2:	54 22       	ld.w %d2,[%a2]
800083e4:	37 02 70 28 	extr.u %d2,%d2,16,16
800083e8:	37 02 70 20 	extr.u %d2,%d2,0,16
800083ec:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800083f0:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800083f2:	91 30 00 2f 	movh.a %a2,61443
800083f6:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800083fa:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800083fc:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008400:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80008402:	8f 22 40 31 	or %d3,%d2,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80008406:	91 30 00 2f 	movh.a %a2,61443
8000840a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000840e:	54 22       	ld.w %d2,[%a2]
80008410:	37 02 70 28 	extr.u %d2,%d2,16,16
80008414:	37 02 70 20 	extr.u %d2,%d2,0,16
80008418:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000841c:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000841e:	91 30 00 2f 	movh.a %a2,61443
80008422:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008426:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80008428:	91 30 00 2f 	movh.a %a2,61443
8000842c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008430:	54 22       	ld.w %d2,[%a2]
80008432:	37 02 61 20 	extr.u %d2,%d2,0,1
80008436:	8f f2 0f 21 	and %d2,%d2,255
8000843a:	df 12 f7 7f 	jeq %d2,1,80008428 <IfxScuWdt_clearSafetyEndinit+0x80>
}
8000843e:	00 90       	ret 

80008440 <IfxScuWdt_disableCpuWatchdog>:


void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
80008440:	40 ae       	mov.aa %a14,%sp
80008442:	20 38       	sub.a %sp,56
80008444:	02 42       	mov %d2,%d4
80008446:	f9 e2 cc ff 	st.h [%a14]-52,%d2
8000844a:	4d c0 e1 2f 	mfcr %d2,$core_id
8000844e:	59 e2 e4 ff 	st.w [%a14]-28,%d2
80008452:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80008456:	59 e2 e0 ff 	st.w [%a14]-32,%d2
8000845a:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000845e:	59 e2 dc ff 	st.w [%a14]-36,%d2
80008462:	82 52       	mov %d2,5
80008464:	59 e2 d8 ff 	st.w [%a14]-40,%d2
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008468:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000846c:	19 e3 d8 ff 	ld.w %d3,[%a14]-40
80008470:	0b 32 90 21 	min.u %d2,%d2,%d3
80008474:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    return res;
80008478:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
8000847c:	59 e2 fc ff 	st.w [%a14]-4,%d2
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80008480:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008484:	53 c2 20 20 	mul %d2,%d2,12
80008488:	1b c2 24 26 	addi %d2,%d2,25164
8000848c:	9b 32 00 2f 	addih %d2,%d2,61443
80008490:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
80008494:	b9 e2 cc ff 	ld.hu %d2,[%a14]-52
80008498:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000849c:	59 e3 ec ff 	st.w [%a14]-20,%d3
800084a0:	f9 e2 ea ff 	st.h [%a14]-22,%d2
    if (watchdog->CON0.B.LCK)
800084a4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800084a8:	54 22       	ld.w %d2,[%a2]
800084aa:	37 02 e1 20 	extr.u %d2,%d2,1,1
800084ae:	8f f2 0f 21 	and %d2,%d2,255
800084b2:	df 02 14 00 	jeq %d2,0,800084da <IfxScuWdt_disableCpuWatchdog+0x9a>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800084b6:	b9 e2 ea ff 	ld.hu %d2,[%a14]-22
800084ba:	06 22       	sh %d2,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800084bc:	8f 12 40 31 	or %d3,%d2,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800084c0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800084c4:	54 22       	ld.w %d2,[%a2]
800084c6:	37 02 70 28 	extr.u %d2,%d2,16,16
800084ca:	37 02 70 20 	extr.u %d2,%d2,0,16
800084ce:	8f 02 01 20 	sh %d2,%d2,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800084d2:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800084d4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800084d8:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800084da:	b9 e2 ea ff 	ld.hu %d2,[%a14]-22
800084de:	06 22       	sh %d2,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800084e0:	8f 22 40 31 	or %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800084e4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800084e8:	54 22       	ld.w %d2,[%a2]
800084ea:	37 02 70 28 	extr.u %d2,%d2,16,16
800084ee:	37 02 70 20 	extr.u %d2,%d2,0,16
800084f2:	8f 02 01 20 	sh %d2,%d2,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800084f6:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800084f8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800084fc:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800084fe:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80008502:	54 22       	ld.w %d2,[%a2]
80008504:	37 02 61 20 	extr.u %d2,%d2,0,1
80008508:	8f f2 0f 21 	and %d2,%d2,255
8000850c:	df 12 f9 7f 	jeq %d2,1,800084fe <IfxScuWdt_disableCpuWatchdog+0xbe>
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
80008510:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80008514:	d9 23 04 00 	lea %a3,[%a2]4
80008518:	54 32       	ld.w %d2,[%a3]
8000851a:	b7 12 81 21 	insert %d2,%d2,1,3,1
8000851e:	b0 42       	add.a %a2,4
80008520:	74 22       	st.w [%a2],%d2
    IfxScuWdt_setCpuEndinitInline(wdt, password);
80008522:	b9 e2 cc ff 	ld.hu %d2,[%a14]-52
80008526:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000852a:	59 e3 f4 ff 	st.w [%a14]-12,%d3
8000852e:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80008532:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008536:	54 22       	ld.w %d2,[%a2]
80008538:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000853c:	8f f2 0f 21 	and %d2,%d2,255
80008540:	df 02 14 00 	jeq %d2,0,80008568 <IfxScuWdt_disableCpuWatchdog+0x128>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80008544:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
80008548:	06 22       	sh %d2,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
8000854a:	8f 12 40 31 	or %d3,%d2,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000854e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008552:	54 22       	ld.w %d2,[%a2]
80008554:	37 02 70 28 	extr.u %d2,%d2,16,16
80008558:	37 02 70 20 	extr.u %d2,%d2,0,16
8000855c:	8f 02 01 20 	sh %d2,%d2,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80008560:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80008562:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008566:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80008568:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
8000856c:	06 22       	sh %d2,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
8000856e:	8f 32 40 31 	or %d3,%d2,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80008572:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008576:	54 22       	ld.w %d2,[%a2]
80008578:	37 02 70 28 	extr.u %d2,%d2,16,16
8000857c:	37 02 70 20 	extr.u %d2,%d2,0,16
80008580:	8f 02 01 20 	sh %d2,%d2,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80008584:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80008586:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000858a:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000858c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008590:	54 22       	ld.w %d2,[%a2]
80008592:	37 02 61 20 	extr.u %d2,%d2,0,1
80008596:	8f f2 0f 21 	and %d2,%d2,255
8000859a:	df 02 f9 7f 	jeq %d2,0,8000858c <IfxScuWdt_disableCpuWatchdog+0x14c>
}
8000859e:	00 90       	ret 

800085a0 <IfxScuWdt_disableSafetyWatchdog>:


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
800085a0:	40 ae       	mov.aa %a14,%sp
800085a2:	20 10       	sub.a %sp,16
800085a4:	02 42       	mov %d2,%d4
800085a6:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    IfxScuWdt_clearSafetyEndinitInline(password);
800085aa:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
800085ae:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    if (SCU_WDTS_CON0.B.LCK)
800085b2:	91 30 00 2f 	movh.a %a2,61443
800085b6:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800085ba:	54 22       	ld.w %d2,[%a2]
800085bc:	37 02 e1 20 	extr.u %d2,%d2,1,1
800085c0:	8f f2 0f 21 	and %d2,%d2,255
800085c4:	df 02 18 00 	jeq %d2,0,800085f4 <IfxScuWdt_disableSafetyWatchdog+0x54>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800085c8:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800085cc:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800085ce:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800085d2:	91 30 00 2f 	movh.a %a2,61443
800085d6:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800085da:	54 22       	ld.w %d2,[%a2]
800085dc:	37 02 70 28 	extr.u %d2,%d2,16,16
800085e0:	37 02 70 20 	extr.u %d2,%d2,0,16
800085e4:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800085e8:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800085ea:	91 30 00 2f 	movh.a %a2,61443
800085ee:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800085f2:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800085f4:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800085f8:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800085fa:	8f 22 40 31 	or %d3,%d2,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800085fe:	91 30 00 2f 	movh.a %a2,61443
80008602:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008606:	54 22       	ld.w %d2,[%a2]
80008608:	37 02 70 28 	extr.u %d2,%d2,16,16
8000860c:	37 02 70 20 	extr.u %d2,%d2,0,16
80008610:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008614:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80008616:	91 30 00 2f 	movh.a %a2,61443
8000861a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000861e:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80008620:	91 30 00 2f 	movh.a %a2,61443
80008624:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008628:	54 22       	ld.w %d2,[%a2]
8000862a:	37 02 61 20 	extr.u %d2,%d2,0,1
8000862e:	8f f2 0f 21 	and %d2,%d2,255
80008632:	df 12 f7 7f 	jeq %d2,1,80008620 <IfxScuWdt_disableSafetyWatchdog+0x80>
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
80008636:	91 30 00 2f 	movh.a %a2,61443
8000863a:	d9 22 2c a6 	lea %a2,[%a2]25260 <f00362ac <bmhd_3_copy+0x40c34cac>>
8000863e:	54 22       	ld.w %d2,[%a2]
80008640:	b7 12 81 21 	insert %d2,%d2,1,3,1
80008644:	74 22       	st.w [%a2],%d2
    IfxScuWdt_setSafetyEndinitInline(password);
80008646:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8000864a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000864e:	91 30 00 2f 	movh.a %a2,61443
80008652:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008656:	54 22       	ld.w %d2,[%a2]
80008658:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000865c:	8f f2 0f 21 	and %d2,%d2,255
80008660:	df 02 18 00 	jeq %d2,0,80008690 <IfxScuWdt_disableSafetyWatchdog+0xf0>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008664:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80008668:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000866a:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000866e:	91 30 00 2f 	movh.a %a2,61443
80008672:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008676:	54 22       	ld.w %d2,[%a2]
80008678:	37 02 70 28 	extr.u %d2,%d2,16,16
8000867c:	37 02 70 20 	extr.u %d2,%d2,0,16
80008680:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008684:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80008686:	91 30 00 2f 	movh.a %a2,61443
8000868a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000868e:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80008690:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008694:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80008696:	8f 32 40 31 	or %d3,%d2,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000869a:	91 30 00 2f 	movh.a %a2,61443
8000869e:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800086a2:	54 22       	ld.w %d2,[%a2]
800086a4:	37 02 70 28 	extr.u %d2,%d2,16,16
800086a8:	37 02 70 20 	extr.u %d2,%d2,0,16
800086ac:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800086b0:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800086b2:	91 30 00 2f 	movh.a %a2,61443
800086b6:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800086ba:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800086bc:	91 30 00 2f 	movh.a %a2,61443
800086c0:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800086c4:	54 22       	ld.w %d2,[%a2]
800086c6:	37 02 61 20 	extr.u %d2,%d2,0,1
800086ca:	8f f2 0f 21 	and %d2,%d2,255
800086ce:	df 02 f7 7f 	jeq %d2,0,800086bc <IfxScuWdt_disableSafetyWatchdog+0x11c>
}
800086d2:	00 90       	ret 

800086d4 <IfxScuWdt_getCpuWatchdogPassword>:
    IfxScuWdt_setSafetyEndinitInline(password);
}


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
800086d4:	40 ae       	mov.aa %a14,%sp
800086d6:	20 20       	sub.a %sp,32
800086d8:	4d c0 e1 2f 	mfcr %d2,$core_id
800086dc:	59 e2 f4 ff 	st.w [%a14]-12,%d2
800086e0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800086e4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
800086e8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800086ec:	59 e2 ec ff 	st.w [%a14]-20,%d2
800086f0:	82 52       	mov %d2,5
800086f2:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800086f6:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800086fa:	19 e3 e8 ff 	ld.w %d3,[%a14]-24
800086fe:	0b 32 90 21 	min.u %d2,%d2,%d3
80008702:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return res;
80008706:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
    return (IfxCpu_ResourceCpu)__minu(reg, 5);
8000870a:	00 00       	nop 
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
8000870c:	53 c2 20 20 	mul %d2,%d2,12
80008710:	1b c2 24 26 	addi %d2,%d2,25164
80008714:	9b 32 00 2f 	addih %d2,%d2,61443
80008718:	59 e2 fc ff 	st.w [%a14]-4,%d2
    password  = watchdog->CON0.B.PW;
8000871c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008720:	54 22       	ld.w %d2,[%a2]
80008722:	37 02 6e 21 	extr.u %d2,%d2,2,14
80008726:	37 02 70 20 	extr.u %d2,%d2,0,16
8000872a:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    password ^= 0x003F;
8000872e:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
80008732:	8f f2 83 21 	xor %d2,%d2,63
80008736:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    return password;
8000873a:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
}
8000873e:	00 90       	ret 

80008740 <IfxScuWdt_getSafetyWatchdogPassword>:
    return password;
}


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
80008740:	40 ae       	mov.aa %a14,%sp
80008742:	20 08       	sub.a %sp,8
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;
80008744:	7b 30 00 2f 	movh %d2,61443
80008748:	1b 82 2a 26 	addi %d2,%d2,25256
8000874c:	59 e2 fc ff 	st.w [%a14]-4,%d2
    password  = watchdog->CON0.B.PW;
80008750:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008754:	54 22       	ld.w %d2,[%a2]
80008756:	37 02 6e 21 	extr.u %d2,%d2,2,14
8000875a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000875e:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    password ^= 0x003F;
80008762:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
80008766:	8f f2 83 21 	xor %d2,%d2,63
8000876a:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    return password;
8000876e:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
80008772:	00 90       	ret 

80008774 <IfxScuWdt_setCpuEndinit>:
    IfxScuWdt_setSafetyEndinit(password);
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
80008774:	40 ae       	mov.aa %a14,%sp
80008776:	20 28       	sub.a %sp,40
80008778:	02 42       	mov %d2,%d4
8000877a:	f9 e2 dc ff 	st.h [%a14]-36,%d2
    reg = __mfcr(CPU_CORE_ID);
8000877e:	4d c0 e1 2f 	mfcr %d2,$core_id
80008782:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80008786:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000878a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000878e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80008792:	59 e2 ec ff 	st.w [%a14]-20,%d2
80008796:	82 52       	mov %d2,5
80008798:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000879c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800087a0:	19 e3 e8 ff 	ld.w %d3,[%a14]-24
800087a4:	0b 32 90 21 	min.u %d2,%d2,%d3
800087a8:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return res;
800087ac:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
800087b0:	53 c2 20 20 	mul %d2,%d2,12
800087b4:	1b c2 24 36 	addi %d3,%d2,25164
800087b8:	9b 33 00 3f 	addih %d3,%d3,61443
800087bc:	b9 e2 dc ff 	ld.hu %d2,[%a14]-36
800087c0:	59 e3 fc ff 	st.w [%a14]-4,%d3
800087c4:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    if (watchdog->CON0.B.LCK)
800087c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800087cc:	54 22       	ld.w %d2,[%a2]
800087ce:	37 02 e1 20 	extr.u %d2,%d2,1,1
800087d2:	8f f2 0f 21 	and %d2,%d2,255
800087d6:	df 02 14 00 	jeq %d2,0,800087fe <IfxScuWdt_setCpuEndinit+0x8a>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800087da:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
800087de:	06 22       	sh %d2,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800087e0:	8f 12 40 31 	or %d3,%d2,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800087e4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800087e8:	54 22       	ld.w %d2,[%a2]
800087ea:	37 02 70 28 	extr.u %d2,%d2,16,16
800087ee:	37 02 70 20 	extr.u %d2,%d2,0,16
800087f2:	8f 02 01 20 	sh %d2,%d2,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800087f6:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800087f8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800087fc:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800087fe:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80008802:	06 22       	sh %d2,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80008804:	8f 32 40 31 	or %d3,%d2,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80008808:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000880c:	54 22       	ld.w %d2,[%a2]
8000880e:	37 02 70 28 	extr.u %d2,%d2,16,16
80008812:	37 02 70 20 	extr.u %d2,%d2,0,16
80008816:	8f 02 01 20 	sh %d2,%d2,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000881a:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000881c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008820:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80008822:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008826:	54 22       	ld.w %d2,[%a2]
80008828:	37 02 61 20 	extr.u %d2,%d2,0,1
8000882c:	8f f2 0f 21 	and %d2,%d2,255
80008830:	df 02 f9 7f 	jeq %d2,0,80008822 <IfxScuWdt_setCpuEndinit+0xae>
}
80008834:	00 90       	ret 

80008836 <IfxScuWdt_setSafetyEndinit>:
    {}
}


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
80008836:	40 ae       	mov.aa %a14,%sp
80008838:	20 10       	sub.a %sp,16
8000883a:	02 42       	mov %d2,%d4
8000883c:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    IfxScuWdt_setSafetyEndinitInline(password);
80008840:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
80008844:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    if (SCU_WDTS_CON0.B.LCK)
80008848:	91 30 00 2f 	movh.a %a2,61443
8000884c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008850:	54 22       	ld.w %d2,[%a2]
80008852:	37 02 e1 20 	extr.u %d2,%d2,1,1
80008856:	8f f2 0f 21 	and %d2,%d2,255
8000885a:	df 02 18 00 	jeq %d2,0,8000888a <IfxScuWdt_setSafetyEndinit+0x54>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000885e:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80008862:	06 22       	sh %d2,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80008864:	8f 12 40 31 	or %d3,%d2,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80008868:	91 30 00 2f 	movh.a %a2,61443
8000886c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008870:	54 22       	ld.w %d2,[%a2]
80008872:	37 02 70 28 	extr.u %d2,%d2,16,16
80008876:	37 02 70 20 	extr.u %d2,%d2,0,16
8000887a:	8f 02 01 20 	sh %d2,%d2,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000887e:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80008880:	91 30 00 2f 	movh.a %a2,61443
80008884:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
80008888:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000888a:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000888e:	06 22       	sh %d2,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80008890:	8f 32 40 31 	or %d3,%d2,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80008894:	91 30 00 2f 	movh.a %a2,61443
80008898:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000889c:	54 22       	ld.w %d2,[%a2]
8000889e:	37 02 70 28 	extr.u %d2,%d2,16,16
800088a2:	37 02 70 20 	extr.u %d2,%d2,0,16
800088a6:	8f 02 01 20 	sh %d2,%d2,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800088aa:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800088ac:	91 30 00 2f 	movh.a %a2,61443
800088b0:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800088b4:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800088b6:	91 30 00 2f 	movh.a %a2,61443
800088ba:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
800088be:	54 22       	ld.w %d2,[%a2]
800088c0:	37 02 61 20 	extr.u %d2,%d2,0,1
800088c4:	8f f2 0f 21 	and %d2,%d2,255
800088c8:	df 02 f7 7f 	jeq %d2,0,800088b6 <IfxScuWdt_setSafetyEndinit+0x80>
}
800088cc:	00 90       	ret 

800088ce <IfxPort_setPinMode>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
800088ce:	40 ae       	mov.aa %a14,%sp
800088d0:	20 28       	sub.a %sp,40
800088d2:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
800088d6:	02 42       	mov %d2,%d4
800088d8:	59 e5 dc ff 	st.w [%a14]-36,%d5
800088dc:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
800088e0:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800088e4:	1b 02 01 20 	addi %d2,%d2,16
800088e8:	59 e2 fc ff 	st.w [%a14]-4,%d2
    uint8                 iocrIndex = (pinIndex / 4);
800088ec:	39 e2 e0 ff 	ld.bu %d2,[%a14]-32
800088f0:	06 e2       	sh %d2,-2
800088f2:	e9 e2 fb ff 	st.b [%a14]-5,%d2
    uint8                 shift     = (pinIndex & 0x3U) * 8;
800088f6:	79 e2 e0 ff 	ld.b %d2,[%a14]-32
800088fa:	8f 32 00 21 	and %d2,%d2,3
800088fe:	8f f2 0f 21 	and %d2,%d2,255
80008902:	06 32       	sh %d2,3
80008904:	e9 e2 fa ff 	st.b [%a14]-6,%d2

    if ((port == &MODULE_P40) || (port == &MODULE_P41))
80008908:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000890c:	7b 40 00 3f 	movh %d3,61444
80008910:	1b 03 80 3c 	addi %d3,%d3,-14336
80008914:	5f 32 0a 00 	jeq %d2,%d3,80008928 <IfxPort_setPinMode+0x5a>
80008918:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000891c:	7b 40 00 3f 	movh %d3,61444
80008920:	1b 03 90 3c 	addi %d3,%d3,-14080
80008924:	5f 32 21 80 	jne %d2,%d3,80008966 <IfxPort_setPinMode+0x98>
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80008928:	6d ff d6 fe 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
8000892c:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80008930:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80008934:	02 24       	mov %d4,%d2
80008936:	6d ff d8 fc 	call 800082e6 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
8000893a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000893e:	d9 22 20 10 	lea %a2,[%a2]96
80008942:	54 23       	ld.w %d3,[%a2]
80008944:	39 e2 e0 ff 	ld.bu %d2,[%a14]-32
80008948:	82 14       	mov %d4,1
8000894a:	0f 24 00 20 	sh %d2,%d4,%d2
8000894e:	46 02       	not %d2
80008950:	26 32       	and %d2,%d3
80008952:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80008956:	d9 22 20 10 	lea %a2,[%a2]96
8000895a:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(passwd);
8000895c:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80008960:	02 24       	mov %d4,%d2
80008962:	6d ff 09 ff 	call 80008774 <IfxScuWdt_setCpuEndinit>
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80008966:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
8000896a:	06 22       	sh %d2,2
8000896c:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80008970:	42 32       	add %d2,%d3
80008972:	02 25       	mov %d5,%d2
80008974:	39 e2 fa ff 	ld.bu %d2,[%a14]-6
80008978:	3b f0 0f 30 	mov %d3,255
8000897c:	0f 23 00 30 	sh %d3,%d3,%d2
80008980:	39 e2 fa ff 	ld.bu %d2,[%a14]-6
80008984:	19 e4 dc ff 	ld.w %d4,[%a14]-36
80008988:	0f 24 00 20 	sh %d2,%d4,%d2
8000898c:	59 e5 f4 ff 	st.w [%a14]-12,%d5
80008990:	59 e3 f0 ff 	st.w [%a14]-16,%d3
80008994:	59 e2 ec ff 	st.w [%a14]-20,%d2
                     ::"a"(address), "d"(mask), "d"((long long)value));
80008998:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000899c:	02 22       	mov %d2,%d2
8000899e:	82 03       	mov %d3,0
    __asm__ volatile("mov %H2,%1 \n\
800089a0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800089a4:	19 e4 f0 ff 	ld.w %d4,[%a14]-16
800089a8:	02 43       	mov %d3,%d4
800089aa:	49 22 40 08 	ldmst [%a2]0,%e2
}
800089ae:	00 00       	nop 
800089b0:	00 90       	ret 

800089b2 <IfxPort_setPinPadDriver>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
800089b2:	40 ae       	mov.aa %a14,%sp
800089b4:	20 28       	sub.a %sp,40
800089b6:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
800089ba:	02 42       	mov %d2,%d4
800089bc:	59 e5 dc ff 	st.w [%a14]-36,%d5
800089c0:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800089c4:	6d ff 88 fe 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
800089c8:	f9 e2 fe ff 	st.h [%a14]-2,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800089cc:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800089d0:	02 24       	mov %d4,%d2
800089d2:	6d ff 8a fc 	call 800082e6 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
800089d6:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800089da:	1b 02 04 20 	addi %d2,%d2,64
800089de:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        uint8            pdrIndex = (pinIndex / 8);
800089e2:	39 e2 e0 ff 	ld.bu %d2,[%a14]-32
800089e6:	06 d2       	sh %d2,-3
800089e8:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
        uint8            shift    = (pinIndex & 0x7U) * 4;
800089ec:	79 e2 e0 ff 	ld.b %d2,[%a14]-32
800089f0:	8f 72 00 21 	and %d2,%d2,7
800089f4:	8f f2 0f 21 	and %d2,%d2,255
800089f8:	06 22       	sh %d2,2
800089fa:	e9 e2 f6 ff 	st.b [%a14]-10,%d2
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
800089fe:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
80008a02:	06 22       	sh %d2,2
80008a04:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008a08:	0b 23 00 50 	add %d5,%d3,%d2
80008a0c:	39 e2 f6 ff 	ld.bu %d2,[%a14]-10
80008a10:	3b f0 00 30 	mov %d3,15
80008a14:	0f 23 00 30 	sh %d3,%d3,%d2
80008a18:	39 e2 f6 ff 	ld.bu %d2,[%a14]-10
80008a1c:	19 e4 dc ff 	ld.w %d4,[%a14]-36
80008a20:	0f 24 00 20 	sh %d2,%d4,%d2
80008a24:	59 e5 f0 ff 	st.w [%a14]-16,%d5
80008a28:	59 e3 ec ff 	st.w [%a14]-20,%d3
80008a2c:	59 e2 e8 ff 	st.w [%a14]-24,%d2
                     ::"a"(address), "d"(mask), "d"((long long)value));
80008a30:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80008a34:	02 22       	mov %d2,%d2
80008a36:	82 03       	mov %d3,0
    __asm__ volatile("mov %H2,%1 \n\
80008a38:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80008a3c:	19 e4 ec ff 	ld.w %d4,[%a14]-20
80008a40:	02 43       	mov %d3,%d4
80008a42:	49 22 40 08 	ldmst [%a2]0,%e2
    }
    IfxScuWdt_setCpuEndinit(passwd);
80008a46:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80008a4a:	02 24       	mov %d4,%d2
80008a4c:	6d ff 94 fe 	call 80008774 <IfxScuWdt_setCpuEndinit>
}
80008a50:	00 00       	nop 
80008a52:	00 90       	ret 

80008a54 <IfxPort_setPinControllerSelection>:


void IfxPort_setPinControllerSelection(Ifx_P *port, uint8 pinIndex)
{
80008a54:	40 ae       	mov.aa %a14,%sp
80008a56:	20 08       	sub.a %sp,8
80008a58:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80008a5c:	02 42       	mov %d2,%d4
80008a5e:	e9 e2 f8 ff 	st.b [%a14]-8,%d2
    IfxPort_modifyPinControllerSelection(port, pinIndex, TRUE);
80008a62:	39 e2 f8 ff 	ld.bu %d2,[%a14]-8
80008a66:	82 15       	mov %d5,1
80008a68:	02 24       	mov %d4,%d2
80008a6a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80008a6e:	6d 00 04 00 	call 80008a76 <IfxPort_modifyPinControllerSelection>
}
80008a72:	00 00       	nop 
80008a74:	00 90       	ret 

80008a76 <IfxPort_modifyPinControllerSelection>:
    IfxPort_modifyPinControllerSelection(port, pinIndex, FALSE);
}


void IfxPort_modifyPinControllerSelection(Ifx_P *port, uint8 pinIndex, boolean mode)
{
80008a76:	40 ae       	mov.aa %a14,%sp
80008a78:	20 20       	sub.a %sp,32
80008a7a:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80008a7e:	02 42       	mov %d2,%d4
80008a80:	02 53       	mov %d3,%d5
80008a82:	e9 e2 e8 ff 	st.b [%a14]-24,%d2
80008a86:	02 32       	mov %d2,%d3
80008a88:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80008a8c:	6d ff 5a fe 	call 80008740 <IfxScuWdt_getSafetyWatchdogPassword>
80008a90:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80008a94:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80008a98:	02 24       	mov %d4,%d2
80008a9a:	6d ff 87 fc 	call 800083a8 <IfxScuWdt_clearSafetyEndinit>
    __ldmst(&port->PCSR.U, 1U << pinIndex, mode << pinIndex);
80008a9e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80008aa2:	1b 42 06 50 	addi %d5,%d2,100
80008aa6:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
80008aaa:	82 13       	mov %d3,1
80008aac:	0f 23 00 40 	sh %d4,%d3,%d2
80008ab0:	39 e3 e4 ff 	ld.bu %d3,[%a14]-28
80008ab4:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
80008ab8:	0f 23 00 20 	sh %d2,%d3,%d2
80008abc:	59 e5 f8 ff 	st.w [%a14]-8,%d5
80008ac0:	59 e4 f4 ff 	st.w [%a14]-12,%d4
80008ac4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
                     ::"a"(address), "d"(mask), "d"((long long)value));
80008ac8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80008acc:	02 22       	mov %d2,%d2
80008ace:	82 03       	mov %d3,0
    __asm__ volatile("mov %H2,%1 \n\
80008ad0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80008ad4:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
80008ad8:	02 43       	mov %d3,%d4
80008ada:	49 22 40 08 	ldmst [%a2]0,%e2
    IfxScuWdt_setSafetyEndinit(passwd);
80008ade:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80008ae2:	02 24       	mov %d4,%d2
80008ae4:	6d ff a9 fe 	call 80008836 <IfxScuWdt_setSafetyEndinit>
}
80008ae8:	00 00       	nop 
80008aea:	00 90       	ret 

80008aec <IfxGeth_enableModule>:
    IfxScuWdt_setCpuEndinit(psw);   /* sets the endinit protection back on*/
}


void IfxGeth_enableModule(Ifx_GETH *gethSFR)
{
80008aec:	40 ae       	mov.aa %a14,%sp
80008aee:	20 18       	sub.a %sp,24
80008af0:	b5 e4 ec ff 	st.a [%a14]-20,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80008af4:	6d ff f0 fd 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
80008af8:	f9 e2 fe ff 	st.h [%a14]-2,%d2
80008afc:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80008b00:	59 e2 f8 ff 	st.w [%a14]-8,%d2
}


IFX_INLINE boolean IfxGeth_isModuleEnabled(Ifx_GETH *gethSFR)
{
    return (gethSFR->CLC.B.DISS == 0) ? 1 : 0;
80008b04:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80008b08:	d9 22 00 02 	lea %a2,[%a2]8192
80008b0c:	54 22       	ld.w %d2,[%a2]
80008b0e:	37 02 e1 20 	extr.u %d2,%d2,1,1
80008b12:	8f f2 0f 21 	and %d2,%d2,255
80008b16:	8f 12 80 21 	xor %d2,%d2,1
80008b1a:	8f f2 0f 21 	and %d2,%d2,255

    if (IfxGeth_isModuleEnabled(gethSFR) != 1) /* if module is not enabled already */
80008b1e:	df 12 16 00 	jeq %d2,1,80008b4a <IfxGeth_enableModule+0x5e>
    {
        IfxScuWdt_clearCpuEndinit(psw);        /* clears the endinit protection*/
80008b22:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80008b26:	02 24       	mov %d4,%d2
80008b28:	6d ff df fb 	call 800082e6 <IfxScuWdt_clearCpuEndinit>
        gethSFR->CLC.B.DISR = 0;               /* set the enable request */
80008b2c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80008b30:	d9 23 00 02 	lea %a3,[%a2]8192
80008b34:	54 32       	ld.w %d2,[%a3]
80008b36:	8f 12 c0 21 	andn %d2,%d2,1
80008b3a:	d9 22 00 02 	lea %a2,[%a2]8192
80008b3e:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(psw);          /* sets the endinit protection back on*/
80008b40:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80008b44:	02 24       	mov %d4,%d2
80008b46:	6d ff 17 fe 	call 80008774 <IfxScuWdt_setCpuEndinit>
80008b4a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80008b4e:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80008b52:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008b56:	d9 22 00 02 	lea %a2,[%a2]8192
80008b5a:	54 22       	ld.w %d2,[%a2]
80008b5c:	37 02 e1 20 	extr.u %d2,%d2,1,1
    }

    IfxGeth_isModuleEnabled(gethSFR);          /* read back to ensure proper enabling */
}
80008b60:	00 00       	nop 
80008b62:	00 90       	ret 

80008b64 <IfxGeth_getSrcPointer>:


volatile Ifx_SRC_SRCR *IfxGeth_getSrcPointer(Ifx_GETH *gethSFR, IfxGeth_ServiceRequest serviceRequest)
{
80008b64:	40 ae       	mov.aa %a14,%sp
80008b66:	20 08       	sub.a %sp,8
80008b68:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80008b6c:	59 e4 f8 ff 	st.w [%a14]-8,%d4
    IFX_UNUSED_PARAMETER(gethSFR);
    return &MODULE_SRC.GETH.GETH[0].SR[serviceRequest];
80008b70:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80008b74:	06 22       	sh %d2,2
80008b76:	1b 02 58 28 	addi %d2,%d2,-31360
80008b7a:	9b 42 00 2f 	addih %d2,%d2,61444
}
80008b7e:	60 22       	mov.a %a2,%d2
80008b80:	00 90       	ret 

80008b82 <IfxGeth_getSrcPointer_end>:
	...

80008b84 <IfxGeth_mac_setLineSpeed>:


void IfxGeth_mac_setLineSpeed(Ifx_GETH *gethSFR, IfxGeth_LineSpeed speed)
{
80008b84:	40 ae       	mov.aa %a14,%sp
80008b86:	20 08       	sub.a %sp,8
80008b88:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80008b8c:	59 e4 f8 ff 	st.w [%a14]-8,%d4
    switch (speed)
80008b90:	91 10 00 28 	movh.a %a2,32769
80008b94:	d9 22 a8 e8 	lea %a2,[%a2]-29784 <80008ba8 <IfxGeth_mac_setLineSpeed+0x24>>
80008b98:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <80008ba8 <IfxGeth_mac_setLineSpeed+0x24>>
80008b9c:	ff 42 4e 80 	jge.u %d2,4,80008c38 <IfxGeth_mac_setLineSpeed+0xb4>
80008ba0:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80008ba4:	dc 02       	ji %a2
80008ba6:	00 00       	nop 
80008ba8:	1d 00 08 00 	j 80008bb8 <IfxGeth_mac_setLineSpeed+0x34>
80008bac:	1d 00 15 00 	j 80008bd6 <IfxGeth_mac_setLineSpeed+0x52>
80008bb0:	1d 00 21 00 	j 80008bf2 <IfxGeth_mac_setLineSpeed+0x6e>
80008bb4:	1d 00 31 00 	j 80008c16 <IfxGeth_mac_setLineSpeed+0x92>
    {
    case IfxGeth_LineSpeed_10Mbps:
        gethSFR->MAC_CONFIGURATION.B.PS  = 1;
80008bb8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008bbc:	54 22       	ld.w %d2,[%a2]
80008bbe:	b7 12 81 27 	insert %d2,%d2,1,15,1
80008bc2:	74 22       	st.w [%a2],%d2
        gethSFR->MAC_CONFIGURATION.B.FES = 0;
80008bc4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008bc8:	54 22       	ld.w %d2,[%a2]
80008bca:	3b f0 ff 3b 	mov %d3,-16385
80008bce:	26 32       	and %d2,%d3
80008bd0:	74 22       	st.w [%a2],%d2
        break;
80008bd2:	1d 00 34 00 	j 80008c3a <IfxGeth_mac_setLineSpeed+0xb6>
    case IfxGeth_LineSpeed_100Mbps:
        gethSFR->MAC_CONFIGURATION.B.PS  = 1;
80008bd6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008bda:	54 22       	ld.w %d2,[%a2]
80008bdc:	b7 12 81 27 	insert %d2,%d2,1,15,1
80008be0:	74 22       	st.w [%a2],%d2
        gethSFR->MAC_CONFIGURATION.B.FES = 1;
80008be2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008be6:	54 22       	ld.w %d2,[%a2]
80008be8:	b7 12 01 27 	insert %d2,%d2,1,14,1
80008bec:	74 22       	st.w [%a2],%d2
        break;
80008bee:	1d 00 26 00 	j 80008c3a <IfxGeth_mac_setLineSpeed+0xb6>
    case IfxGeth_LineSpeed_1000Mbps:
        gethSFR->MAC_CONFIGURATION.B.PS  = 0;
80008bf2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008bf6:	54 22       	ld.w %d2,[%a2]
80008bf8:	7b f0 ff 3f 	movh %d3,65535
80008bfc:	1b f3 ff 37 	addi %d3,%d3,32767
80008c00:	26 32       	and %d2,%d3
80008c02:	74 22       	st.w [%a2],%d2
        gethSFR->MAC_CONFIGURATION.B.FES = 0;
80008c04:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008c08:	54 22       	ld.w %d2,[%a2]
80008c0a:	3b f0 ff 3b 	mov %d3,-16385
80008c0e:	26 32       	and %d2,%d3
80008c10:	74 22       	st.w [%a2],%d2
        break;
80008c12:	1d 00 14 00 	j 80008c3a <IfxGeth_mac_setLineSpeed+0xb6>
    case IfxGeth_LineSpeed_2500Mbps:
        gethSFR->MAC_CONFIGURATION.B.PS  = 0;
80008c16:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008c1a:	54 22       	ld.w %d2,[%a2]
80008c1c:	7b f0 ff 3f 	movh %d3,65535
80008c20:	1b f3 ff 37 	addi %d3,%d3,32767
80008c24:	26 32       	and %d2,%d3
80008c26:	74 22       	st.w [%a2],%d2
        gethSFR->MAC_CONFIGURATION.B.FES = 1;
80008c28:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008c2c:	54 22       	ld.w %d2,[%a2]
80008c2e:	b7 12 01 27 	insert %d2,%d2,1,14,1
80008c32:	74 22       	st.w [%a2],%d2
        break;
80008c34:	1d 00 03 00 	j 80008c3a <IfxGeth_mac_setLineSpeed+0xb6>
    default:
        break;
80008c38:	00 00       	nop 
    }
}
80008c3a:	00 00       	nop 
80008c3c:	00 90       	ret 

80008c3e <IfxGeth_mac_setLineSpeed_end>:
	...

80008c40 <IfxGeth_mac_setMacAddress>:


void IfxGeth_mac_setMacAddress(Ifx_GETH *gethSFR, uint8 *macAddress)
{
80008c40:	40 ae       	mov.aa %a14,%sp
80008c42:	20 08       	sub.a %sp,8
80008c44:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80008c48:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
    gethSFR->MAC_ADDRESS_HIGH0.U = 0
                                   | ((uint32)macAddress[4] << 0U)
80008c4c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80008c50:	60 22       	mov.a %a2,%d2
80008c52:	b0 42       	add.a %a2,4
80008c54:	14 22       	ld.bu %d2,[%a2]
80008c56:	02 23       	mov %d3,%d2
                                   | ((uint32)macAddress[5] << 8U)
80008c58:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80008c5c:	60 22       	mov.a %a2,%d2
80008c5e:	b0 52       	add.a %a2,5
80008c60:	14 22       	ld.bu %d2,[%a2]
80008c62:	8f 82 00 20 	sh %d2,%d2,8
80008c66:	a6 32       	or %d2,%d3
                                   | 0x80000000U;
80008c68:	7b 00 00 38 	movh %d3,32768
80008c6c:	a6 32       	or %d2,%d3
    gethSFR->MAC_ADDRESS_HIGH0.U = 0
80008c6e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008c72:	d9 22 00 c0 	lea %a2,[%a2]768
80008c76:	74 22       	st.w [%a2],%d2

    gethSFR->MAC_ADDRESS_LOW0.U = 0
                                  | ((uint32)macAddress[0] << 0U)
80008c78:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80008c7c:	14 22       	ld.bu %d2,[%a2]
80008c7e:	02 23       	mov %d3,%d2
                                  | ((uint32)macAddress[1] << 8U)
80008c80:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80008c84:	60 22       	mov.a %a2,%d2
80008c86:	b0 12       	add.a %a2,1
80008c88:	14 22       	ld.bu %d2,[%a2]
80008c8a:	8f 82 00 20 	sh %d2,%d2,8
80008c8e:	a6 23       	or %d3,%d2
                                  | ((uint32)macAddress[2] << 16U)
80008c90:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80008c94:	60 22       	mov.a %a2,%d2
80008c96:	b0 22       	add.a %a2,2
80008c98:	14 22       	ld.bu %d2,[%a2]
80008c9a:	8f 02 01 20 	sh %d2,%d2,16
80008c9e:	a6 23       	or %d3,%d2
                                  | ((uint32)macAddress[3] << 24U);
80008ca0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80008ca4:	60 22       	mov.a %a2,%d2
80008ca6:	b0 32       	add.a %a2,3
80008ca8:	14 22       	ld.bu %d2,[%a2]
80008caa:	8f 82 01 20 	sh %d2,%d2,24
80008cae:	a6 32       	or %d2,%d3
    gethSFR->MAC_ADDRESS_LOW0.U = 0
80008cb0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008cb4:	d9 22 04 c0 	lea %a2,[%a2]772
80008cb8:	74 22       	st.w [%a2],%d2
}
80008cba:	00 00       	nop 
80008cbc:	00 90       	ret 

80008cbe <IfxGeth_mac_setMacAddress_end>:
	...

80008cc0 <IfxGeth_mtl_clearAllInterruptFlags>:


void IfxGeth_mtl_clearAllInterruptFlags(Ifx_GETH *gethSFR, IfxGeth_MtlQueue queueId)
{
80008cc0:	40 ae       	mov.aa %a14,%sp
80008cc2:	20 10       	sub.a %sp,16
80008cc4:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80008cc8:	59 e4 f0 ff 	st.w [%a14]-16,%d4
    uint32 value = (1 << IfxGeth_MtlInterruptFlag_txQueueUnderflow) | (1 << IfxGeth_MtlInterruptFlag_averageBitsPerSlot) | (1 << IfxGeth_MtlInterruptFlag_rxQueueOverflow);
80008ccc:	7b 10 00 20 	movh %d2,1
80008cd0:	c2 32       	add %d2,3
80008cd2:	59 e2 fc ff 	st.w [%a14]-4,%d2

    switch (queueId)
80008cd6:	91 10 00 28 	movh.a %a2,32769
80008cda:	d9 22 ec 38 	lea %a2,[%a2]-29460 <80008cec <IfxGeth_mtl_clearAllInterruptFlags+0x2c>>
80008cde:	19 e2 f0 ff 	ld.w %d2,[%a14]-16 <80008cec <IfxGeth_mtl_clearAllInterruptFlags+0x2c>>
80008ce2:	ff 42 48 80 	jge.u %d2,4,80008d72 <IfxGeth_mtl_clearAllInterruptFlags+0xb2>
80008ce6:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80008cea:	dc 02       	ji %a2
80008cec:	1d 00 08 00 	j 80008cfc <IfxGeth_mtl_clearAllInterruptFlags+0x3c>
80008cf0:	1d 00 15 00 	j 80008d1a <IfxGeth_mtl_clearAllInterruptFlags+0x5a>
80008cf4:	1d 00 22 00 	j 80008d38 <IfxGeth_mtl_clearAllInterruptFlags+0x78>
80008cf8:	1d 00 2f 00 	j 80008d56 <IfxGeth_mtl_clearAllInterruptFlags+0x96>
    {
    case IfxGeth_MtlQueue_0:
        gethSFR->MTL_Q0.INTERRUPT_CONTROL_STATUS.U |= value;
80008cfc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008d00:	d9 22 ec 40 	lea %a2,[%a2]3372
80008d04:	54 23       	ld.w %d3,[%a2]
80008d06:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008d0a:	a6 32       	or %d2,%d3
80008d0c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008d10:	d9 22 ec 40 	lea %a2,[%a2]3372
80008d14:	74 22       	st.w [%a2],%d2
        break;
80008d16:	1d 00 2e 00 	j 80008d72 <IfxGeth_mtl_clearAllInterruptFlags+0xb2>
    case IfxGeth_MtlQueue_1:
        gethSFR->MTL_Q1.INTERRUPT_CONTROL_STATUS.U |= value;
80008d1a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008d1e:	d9 22 ec 50 	lea %a2,[%a2]3436
80008d22:	54 23       	ld.w %d3,[%a2]
80008d24:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008d28:	a6 32       	or %d2,%d3
80008d2a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008d2e:	d9 22 ec 50 	lea %a2,[%a2]3436
80008d32:	74 22       	st.w [%a2],%d2
        break;
80008d34:	1d 00 1f 00 	j 80008d72 <IfxGeth_mtl_clearAllInterruptFlags+0xb2>
    case IfxGeth_MtlQueue_2:
        gethSFR->MTL_Q2.INTERRUPT_CONTROL_STATUS.U |= value;
80008d38:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008d3c:	d9 22 ec 60 	lea %a2,[%a2]3500
80008d40:	54 23       	ld.w %d3,[%a2]
80008d42:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008d46:	a6 32       	or %d2,%d3
80008d48:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008d4c:	d9 22 ec 60 	lea %a2,[%a2]3500
80008d50:	74 22       	st.w [%a2],%d2
        break;
80008d52:	1d 00 10 00 	j 80008d72 <IfxGeth_mtl_clearAllInterruptFlags+0xb2>
    case IfxGeth_MtlQueue_3:
        gethSFR->MTL_Q3.INTERRUPT_CONTROL_STATUS.U |= value;
80008d56:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008d5a:	d9 22 ec 70 	lea %a2,[%a2]3564
80008d5e:	54 23       	ld.w %d3,[%a2]
80008d60:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008d64:	a6 32       	or %d2,%d3
80008d66:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008d6a:	d9 22 ec 70 	lea %a2,[%a2]3564
80008d6e:	74 22       	st.w [%a2],%d2
        break;
80008d70:	00 00       	nop 
    }
}
80008d72:	00 00       	nop 
80008d74:	00 90       	ret 

80008d76 <IfxGeth_mtl_clearAllInterruptFlags_end>:
	...

80008d78 <IfxGeth_mtl_clearInterruptFlag>:


void IfxGeth_mtl_clearInterruptFlag(Ifx_GETH *gethSFR, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag)
{
80008d78:	40 ae       	mov.aa %a14,%sp
80008d7a:	20 18       	sub.a %sp,24
80008d7c:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80008d80:	59 e4 f0 ff 	st.w [%a14]-16,%d4
80008d84:	59 e5 ec ff 	st.w [%a14]-20,%d5
    uint32 mask  = ((1 << IfxGeth_MtlInterruptFlag_txQueueUnderflow) | (1 << IfxGeth_MtlInterruptFlag_averageBitsPerSlot) | (1 << IfxGeth_MtlInterruptFlag_rxQueueOverflow)) << 8;
80008d88:	7b 00 10 20 	movh %d2,256
80008d8c:	1b 02 30 20 	addi %d2,%d2,768
80008d90:	59 e2 fc ff 	st.w [%a14]-4,%d2
    uint32 value = (1 << flag);
80008d94:	82 13       	mov %d3,1
80008d96:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80008d9a:	0f 23 00 20 	sh %d2,%d3,%d2
80008d9e:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    switch (queueId)
80008da2:	91 10 00 28 	movh.a %a2,32769
80008da6:	d9 22 f8 68 	lea %a2,[%a2]-29256 <80008db8 <IfxGeth_mtl_clearInterruptFlag+0x40>>
80008daa:	19 e2 f0 ff 	ld.w %d2,[%a14]-16 <80008db8 <IfxGeth_mtl_clearInterruptFlag+0x40>>
80008dae:	ff 42 54 80 	jge.u %d2,4,80008e56 <IfxGeth_mtl_clearInterruptFlag+0xde>
80008db2:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80008db6:	dc 02       	ji %a2
80008db8:	1d 00 08 00 	j 80008dc8 <IfxGeth_mtl_clearInterruptFlag+0x50>
80008dbc:	1d 00 18 00 	j 80008dec <IfxGeth_mtl_clearInterruptFlag+0x74>
80008dc0:	1d 00 28 00 	j 80008e10 <IfxGeth_mtl_clearInterruptFlag+0x98>
80008dc4:	1d 00 38 00 	j 80008e34 <IfxGeth_mtl_clearInterruptFlag+0xbc>
    {
    case IfxGeth_MtlQueue_0:
        gethSFR->MTL_Q0.INTERRUPT_CONTROL_STATUS.U = (gethSFR->MTL_Q0.INTERRUPT_CONTROL_STATUS.U & mask) | value;
80008dc8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008dcc:	d9 22 ec 40 	lea %a2,[%a2]3372
80008dd0:	54 23       	ld.w %d3,[%a2]
80008dd2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008dd6:	26 32       	and %d2,%d3
80008dd8:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008ddc:	a6 32       	or %d2,%d3
80008dde:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008de2:	d9 22 ec 40 	lea %a2,[%a2]3372
80008de6:	74 22       	st.w [%a2],%d2
        break;
80008de8:	1d 00 37 00 	j 80008e56 <IfxGeth_mtl_clearInterruptFlag+0xde>
    case IfxGeth_MtlQueue_1:
        gethSFR->MTL_Q1.INTERRUPT_CONTROL_STATUS.U = (gethSFR->MTL_Q1.INTERRUPT_CONTROL_STATUS.U & mask) | value;
80008dec:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008df0:	d9 22 ec 50 	lea %a2,[%a2]3436
80008df4:	54 23       	ld.w %d3,[%a2]
80008df6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008dfa:	26 32       	and %d2,%d3
80008dfc:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008e00:	a6 32       	or %d2,%d3
80008e02:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008e06:	d9 22 ec 50 	lea %a2,[%a2]3436
80008e0a:	74 22       	st.w [%a2],%d2
        break;
80008e0c:	1d 00 25 00 	j 80008e56 <IfxGeth_mtl_clearInterruptFlag+0xde>
    case IfxGeth_MtlQueue_2:
        gethSFR->MTL_Q2.INTERRUPT_CONTROL_STATUS.U = (gethSFR->MTL_Q2.INTERRUPT_CONTROL_STATUS.U & mask) | value;
80008e10:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008e14:	d9 22 ec 60 	lea %a2,[%a2]3500
80008e18:	54 23       	ld.w %d3,[%a2]
80008e1a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008e1e:	26 32       	and %d2,%d3
80008e20:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008e24:	a6 32       	or %d2,%d3
80008e26:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008e2a:	d9 22 ec 60 	lea %a2,[%a2]3500
80008e2e:	74 22       	st.w [%a2],%d2
        break;
80008e30:	1d 00 13 00 	j 80008e56 <IfxGeth_mtl_clearInterruptFlag+0xde>
    case IfxGeth_MtlQueue_3:
        gethSFR->MTL_Q3.INTERRUPT_CONTROL_STATUS.U = (gethSFR->MTL_Q3.INTERRUPT_CONTROL_STATUS.U & mask) | value;
80008e34:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008e38:	d9 22 ec 70 	lea %a2,[%a2]3564
80008e3c:	54 23       	ld.w %d3,[%a2]
80008e3e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008e42:	26 32       	and %d2,%d3
80008e44:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008e48:	a6 32       	or %d2,%d3
80008e4a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008e4e:	d9 22 ec 70 	lea %a2,[%a2]3564
80008e52:	74 22       	st.w [%a2],%d2
        break;
80008e54:	00 00       	nop 
    }
}
80008e56:	00 00       	nop 
80008e58:	00 90       	ret 

80008e5a <IfxGeth_mtl_clearInterruptFlag_end>:
	...

80008e5c <IfxGeth_mtl_enableInterrupt>:
    }
}


void IfxGeth_mtl_enableInterrupt(Ifx_GETH *gethSFR, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag)
{
80008e5c:	40 ae       	mov.aa %a14,%sp
80008e5e:	20 18       	sub.a %sp,24
80008e60:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80008e64:	59 e4 f0 ff 	st.w [%a14]-16,%d4
80008e68:	59 e5 ec ff 	st.w [%a14]-20,%d5
    uint32 mask  = (1 << IfxGeth_MtlInterruptFlag_txQueueUnderflow) | (1 << IfxGeth_MtlInterruptFlag_averageBitsPerSlot) | (1 << IfxGeth_MtlInterruptFlag_rxQueueOverflow);
80008e6c:	7b 10 00 20 	movh %d2,1
80008e70:	c2 32       	add %d2,3
80008e72:	59 e2 fc ff 	st.w [%a14]-4,%d2
    uint32 value = (1 << (flag + 8));
80008e76:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80008e7a:	1b 82 00 20 	addi %d2,%d2,8
80008e7e:	82 13       	mov %d3,1
80008e80:	0f 23 00 20 	sh %d2,%d3,%d2
80008e84:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    switch (queueId)
80008e88:	91 10 00 28 	movh.a %a2,32769
80008e8c:	d9 22 e0 a8 	lea %a2,[%a2]-29024 <80008ea0 <IfxGeth_mtl_enableInterrupt+0x44>>
80008e90:	19 e2 f0 ff 	ld.w %d2,[%a14]-16 <80008ea0 <IfxGeth_mtl_enableInterrupt+0x44>>
80008e94:	ff 42 59 80 	jge.u %d2,4,80008f46 <IfxGeth_mtl_enableInterrupt+0xea>
80008e98:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80008e9c:	dc 02       	ji %a2
80008e9e:	00 00       	nop 
80008ea0:	1d 00 08 00 	j 80008eb0 <IfxGeth_mtl_enableInterrupt+0x54>
80008ea4:	1d 00 19 00 	j 80008ed6 <IfxGeth_mtl_enableInterrupt+0x7a>
80008ea8:	1d 00 2a 00 	j 80008efc <IfxGeth_mtl_enableInterrupt+0xa0>
80008eac:	1d 00 3b 00 	j 80008f22 <IfxGeth_mtl_enableInterrupt+0xc6>
    {
    case IfxGeth_MtlQueue_0:
        gethSFR->MTL_Q0.INTERRUPT_CONTROL_STATUS.U = (gethSFR->MTL_Q0.INTERRUPT_CONTROL_STATUS.U & ~mask) | value;
80008eb0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008eb4:	d9 22 ec 40 	lea %a2,[%a2]3372
80008eb8:	54 23       	ld.w %d3,[%a2]
80008eba:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008ebe:	46 02       	not %d2
80008ec0:	26 32       	and %d2,%d3
80008ec2:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008ec6:	a6 32       	or %d2,%d3
80008ec8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008ecc:	d9 22 ec 40 	lea %a2,[%a2]3372
80008ed0:	74 22       	st.w [%a2],%d2
        break;
80008ed2:	1d 00 3a 00 	j 80008f46 <IfxGeth_mtl_enableInterrupt+0xea>
    case IfxGeth_MtlQueue_1:
        gethSFR->MTL_Q1.INTERRUPT_CONTROL_STATUS.U = (gethSFR->MTL_Q1.INTERRUPT_CONTROL_STATUS.U & ~mask) | value;
80008ed6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008eda:	d9 22 ec 50 	lea %a2,[%a2]3436
80008ede:	54 23       	ld.w %d3,[%a2]
80008ee0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008ee4:	46 02       	not %d2
80008ee6:	26 32       	and %d2,%d3
80008ee8:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008eec:	a6 32       	or %d2,%d3
80008eee:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008ef2:	d9 22 ec 50 	lea %a2,[%a2]3436
80008ef6:	74 22       	st.w [%a2],%d2
        break;
80008ef8:	1d 00 27 00 	j 80008f46 <IfxGeth_mtl_enableInterrupt+0xea>
    case IfxGeth_MtlQueue_2:
        gethSFR->MTL_Q2.INTERRUPT_CONTROL_STATUS.U = (gethSFR->MTL_Q2.INTERRUPT_CONTROL_STATUS.U & ~mask) | value;
80008efc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008f00:	d9 22 ec 60 	lea %a2,[%a2]3500
80008f04:	54 23       	ld.w %d3,[%a2]
80008f06:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008f0a:	46 02       	not %d2
80008f0c:	26 32       	and %d2,%d3
80008f0e:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008f12:	a6 32       	or %d2,%d3
80008f14:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008f18:	d9 22 ec 60 	lea %a2,[%a2]3500
80008f1c:	74 22       	st.w [%a2],%d2
        break;
80008f1e:	1d 00 14 00 	j 80008f46 <IfxGeth_mtl_enableInterrupt+0xea>
    case IfxGeth_MtlQueue_3:
        gethSFR->MTL_Q3.INTERRUPT_CONTROL_STATUS.U = (gethSFR->MTL_Q3.INTERRUPT_CONTROL_STATUS.U & ~mask) | value;
80008f22:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008f26:	d9 22 ec 70 	lea %a2,[%a2]3564
80008f2a:	54 23       	ld.w %d3,[%a2]
80008f2c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80008f30:	46 02       	not %d2
80008f32:	26 32       	and %d2,%d3
80008f34:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80008f38:	a6 32       	or %d2,%d3
80008f3a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80008f3e:	d9 22 ec 70 	lea %a2,[%a2]3564
80008f42:	74 22       	st.w [%a2],%d2
        break;
80008f44:	00 00       	nop 
    }
}
80008f46:	00 00       	nop 
80008f48:	00 90       	ret 

80008f4a <IfxGeth_mtl_enableInterrupt_end>:
	...

80008f4c <IfxGeth_mtl_enableTxQueue>:


void IfxGeth_mtl_enableTxQueue(Ifx_GETH *gethSFR, IfxGeth_TxMtlQueue queueId)
{
80008f4c:	40 ae       	mov.aa %a14,%sp
80008f4e:	20 08       	sub.a %sp,8
80008f50:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80008f54:	59 e4 f8 ff 	st.w [%a14]-8,%d4
    switch (queueId)
80008f58:	91 10 00 28 	movh.a %a2,32769
80008f5c:	d9 22 f0 d8 	lea %a2,[%a2]-28816 <80008f70 <IfxGeth_mtl_enableTxQueue+0x24>>
80008f60:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <80008f70 <IfxGeth_mtl_enableTxQueue+0x24>>
80008f64:	ff 42 3d 80 	jge.u %d2,4,80008fde <IfxGeth_mtl_enableTxQueue+0x92>
80008f68:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80008f6c:	dc 02       	ji %a2
80008f6e:	00 00       	nop 
80008f70:	1d 00 08 00 	j 80008f80 <IfxGeth_mtl_enableTxQueue+0x34>
80008f74:	1d 00 12 00 	j 80008f98 <IfxGeth_mtl_enableTxQueue+0x4c>
80008f78:	1d 00 1c 00 	j 80008fb0 <IfxGeth_mtl_enableTxQueue+0x64>
80008f7c:	1d 00 26 00 	j 80008fc8 <IfxGeth_mtl_enableTxQueue+0x7c>
    {
    case IfxGeth_TxMtlQueue_0:
        gethSFR->MTL_TXQ0.OPERATION_MODE.B.TXQEN = 2;
80008f80:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008f84:	d9 23 c0 40 	lea %a3,[%a2]3328
80008f88:	54 32       	ld.w %d2,[%a3]
80008f8a:	b7 22 02 21 	insert %d2,%d2,2,2,2
80008f8e:	d9 22 c0 40 	lea %a2,[%a2]3328
80008f92:	74 22       	st.w [%a2],%d2
        break;
80008f94:	1d 00 25 00 	j 80008fde <IfxGeth_mtl_enableTxQueue+0x92>
    case IfxGeth_TxMtlQueue_1:
        gethSFR->MTL_TXQ1.OPERATION_MODE.B.TXQEN = 2;
80008f98:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008f9c:	d9 23 c0 50 	lea %a3,[%a2]3392
80008fa0:	54 32       	ld.w %d2,[%a3]
80008fa2:	b7 22 02 21 	insert %d2,%d2,2,2,2
80008fa6:	d9 22 c0 50 	lea %a2,[%a2]3392
80008faa:	74 22       	st.w [%a2],%d2
        break;
80008fac:	1d 00 19 00 	j 80008fde <IfxGeth_mtl_enableTxQueue+0x92>
    case IfxGeth_TxMtlQueue_2:
        gethSFR->MTL_TXQ2.OPERATION_MODE.B.TXQEN = 2;
80008fb0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008fb4:	d9 23 c0 60 	lea %a3,[%a2]3456
80008fb8:	54 32       	ld.w %d2,[%a3]
80008fba:	b7 22 02 21 	insert %d2,%d2,2,2,2
80008fbe:	d9 22 c0 60 	lea %a2,[%a2]3456
80008fc2:	74 22       	st.w [%a2],%d2
        break;
80008fc4:	1d 00 0d 00 	j 80008fde <IfxGeth_mtl_enableTxQueue+0x92>
    case IfxGeth_TxMtlQueue_3:
        gethSFR->MTL_TXQ3.OPERATION_MODE.B.TXQEN = 2;
80008fc8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80008fcc:	d9 23 c0 70 	lea %a3,[%a2]3520
80008fd0:	54 32       	ld.w %d2,[%a3]
80008fd2:	b7 22 02 21 	insert %d2,%d2,2,2,2
80008fd6:	d9 22 c0 70 	lea %a2,[%a2]3520
80008fda:	74 22       	st.w [%a2],%d2
        break;
80008fdc:	00 00       	nop 
    }
}
80008fde:	00 00       	nop 
80008fe0:	00 90       	ret 

80008fe2 <IfxGeth_mtl_enableTxQueue_end>:
	...

80008fe4 <IfxGeth_mtl_isInterruptFlagSet>:


boolean IfxGeth_mtl_isInterruptFlagSet(Ifx_GETH *gethSFR, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag)
{
80008fe4:	40 ae       	mov.aa %a14,%sp
80008fe6:	20 18       	sub.a %sp,24
80008fe8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80008fec:	59 e4 f0 ff 	st.w [%a14]-16,%d4
80008ff0:	59 e5 ec ff 	st.w [%a14]-20,%d5
    uint32  value  = (1 << flag);
80008ff4:	82 13       	mov %d3,1
80008ff6:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80008ffa:	0f 23 00 20 	sh %d2,%d3,%d2
80008ffe:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    boolean status = 0;
80009002:	82 02       	mov %d2,0
80009004:	e9 e2 ff ff 	st.b [%a14]-1,%d2

    switch (queueId)
80009008:	91 10 00 28 	movh.a %a2,32769
8000900c:	d9 22 20 09 	lea %a2,[%a2]-28640 <80009020 <IfxGeth_mtl_isInterruptFlagSet+0x3c>>
80009010:	19 e2 f0 ff 	ld.w %d2,[%a14]-16 <80009020 <IfxGeth_mtl_isInterruptFlagSet+0x3c>>
80009014:	ff 42 4d 80 	jge.u %d2,4,800090ae <IfxGeth_mtl_isInterruptFlagSet+0xca>
80009018:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
8000901c:	dc 02       	ji %a2
8000901e:	00 00       	nop 
80009020:	1d 00 08 00 	j 80009030 <IfxGeth_mtl_isInterruptFlagSet+0x4c>
80009024:	1d 00 16 00 	j 80009050 <IfxGeth_mtl_isInterruptFlagSet+0x6c>
80009028:	1d 00 24 00 	j 80009070 <IfxGeth_mtl_isInterruptFlagSet+0x8c>
8000902c:	1d 00 32 00 	j 80009090 <IfxGeth_mtl_isInterruptFlagSet+0xac>
    {
    case IfxGeth_MtlQueue_0:
        status = (gethSFR->MTL_Q0.INTERRUPT_CONTROL_STATUS.U & (Ifx_UReg_32Bit)value);
80009030:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80009034:	d9 22 ec 40 	lea %a2,[%a2]3372
80009038:	54 22       	ld.w %d2,[%a2]
8000903a:	8f f2 0f 31 	and %d3,%d2,255
8000903e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009042:	8f f2 0f 21 	and %d2,%d2,255
80009046:	26 32       	and %d2,%d3
80009048:	e9 e2 ff ff 	st.b [%a14]-1,%d2
        break;
8000904c:	1d 00 31 00 	j 800090ae <IfxGeth_mtl_isInterruptFlagSet+0xca>
    case IfxGeth_MtlQueue_1:
        status = (gethSFR->MTL_Q1.INTERRUPT_CONTROL_STATUS.U & (Ifx_UReg_32Bit)value);
80009050:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80009054:	d9 22 ec 50 	lea %a2,[%a2]3436
80009058:	54 22       	ld.w %d2,[%a2]
8000905a:	8f f2 0f 31 	and %d3,%d2,255
8000905e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009062:	8f f2 0f 21 	and %d2,%d2,255
80009066:	26 32       	and %d2,%d3
80009068:	e9 e2 ff ff 	st.b [%a14]-1,%d2
        break;
8000906c:	1d 00 21 00 	j 800090ae <IfxGeth_mtl_isInterruptFlagSet+0xca>
    case IfxGeth_MtlQueue_2:
        status = (gethSFR->MTL_Q2.INTERRUPT_CONTROL_STATUS.U & (Ifx_UReg_32Bit)value);
80009070:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80009074:	d9 22 ec 60 	lea %a2,[%a2]3500
80009078:	54 22       	ld.w %d2,[%a2]
8000907a:	8f f2 0f 31 	and %d3,%d2,255
8000907e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009082:	8f f2 0f 21 	and %d2,%d2,255
80009086:	26 32       	and %d2,%d3
80009088:	e9 e2 ff ff 	st.b [%a14]-1,%d2
        break;
8000908c:	1d 00 11 00 	j 800090ae <IfxGeth_mtl_isInterruptFlagSet+0xca>
    case IfxGeth_MtlQueue_3:
        status = (gethSFR->MTL_Q3.INTERRUPT_CONTROL_STATUS.U & (Ifx_UReg_32Bit)value);
80009090:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80009094:	d9 22 ec 70 	lea %a2,[%a2]3564
80009098:	54 22       	ld.w %d2,[%a2]
8000909a:	8f f2 0f 31 	and %d3,%d2,255
8000909e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800090a2:	8f f2 0f 21 	and %d2,%d2,255
800090a6:	26 32       	and %d2,%d3
800090a8:	e9 e2 ff ff 	st.b [%a14]-1,%d2
        break;
800090ac:	00 00       	nop 
    }

    return status ? 1 : 0;
800090ae:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
800090b2:	8b 02 20 22 	ne %d2,%d2,0
800090b6:	8f f2 0f 21 	and %d2,%d2,255
}
800090ba:	00 90       	ret 

800090bc <IfxGeth_mtl_setRxForwardErrorPacket>:


void IfxGeth_mtl_setRxForwardErrorPacket(Ifx_GETH *gethSFR, IfxGeth_RxMtlQueue queueId, boolean enabled)
{
800090bc:	40 ae       	mov.aa %a14,%sp
800090be:	20 10       	sub.a %sp,16
800090c0:	b5 e4 fc ff 	st.a [%a14]-4,%a4
800090c4:	59 e4 f8 ff 	st.w [%a14]-8,%d4
800090c8:	02 52       	mov %d2,%d5
800090ca:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
    switch (queueId)
800090ce:	91 10 00 28 	movh.a %a2,32769
800090d2:	d9 22 24 39 	lea %a2,[%a2]-28444 <800090e4 <IfxGeth_mtl_setRxForwardErrorPacket+0x28>>
800090d6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <800090e4 <IfxGeth_mtl_setRxForwardErrorPacket+0x28>>
800090da:	ff 42 53 80 	jge.u %d2,4,80009180 <IfxGeth_mtl_setRxForwardErrorPacket+0xc4>
800090de:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
800090e2:	dc 02       	ji %a2
800090e4:	1d 00 08 00 	j 800090f4 <IfxGeth_mtl_setRxForwardErrorPacket+0x38>
800090e8:	1d 00 18 00 	j 80009118 <IfxGeth_mtl_setRxForwardErrorPacket+0x5c>
800090ec:	1d 00 28 00 	j 8000913c <IfxGeth_mtl_setRxForwardErrorPacket+0x80>
800090f0:	1d 00 38 00 	j 80009160 <IfxGeth_mtl_setRxForwardErrorPacket+0xa4>
    {
    case IfxGeth_RxMtlQueue_0:
        gethSFR->MTL_RXQ0.OPERATION_MODE.B.FEP = enabled;
800090f4:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
800090f8:	8f 12 00 21 	and %d2,%d2,1
800090fc:	8f f2 0f 31 	and %d3,%d2,255
80009100:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009104:	d9 23 f0 40 	lea %a3,[%a2]3376
80009108:	54 32       	ld.w %d2,[%a3]
8000910a:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
8000910e:	d9 22 f0 40 	lea %a2,[%a2]3376
80009112:	74 22       	st.w [%a2],%d2
        break;
80009114:	1d 00 36 00 	j 80009180 <IfxGeth_mtl_setRxForwardErrorPacket+0xc4>
    case IfxGeth_RxMtlQueue_1:
        gethSFR->MTL_RXQ1.OPERATION_MODE.B.FEP = enabled;
80009118:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
8000911c:	8f 12 00 21 	and %d2,%d2,1
80009120:	8f f2 0f 31 	and %d3,%d2,255
80009124:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009128:	d9 23 f0 50 	lea %a3,[%a2]3440
8000912c:	54 32       	ld.w %d2,[%a3]
8000912e:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
80009132:	d9 22 f0 50 	lea %a2,[%a2]3440
80009136:	74 22       	st.w [%a2],%d2
        break;
80009138:	1d 00 24 00 	j 80009180 <IfxGeth_mtl_setRxForwardErrorPacket+0xc4>
    case IfxGeth_RxMtlQueue_2:
        gethSFR->MTL_RXQ2.OPERATION_MODE.B.FEP = enabled;
8000913c:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80009140:	8f 12 00 21 	and %d2,%d2,1
80009144:	8f f2 0f 31 	and %d3,%d2,255
80009148:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000914c:	d9 23 f0 60 	lea %a3,[%a2]3504
80009150:	54 32       	ld.w %d2,[%a3]
80009152:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
80009156:	d9 22 f0 60 	lea %a2,[%a2]3504
8000915a:	74 22       	st.w [%a2],%d2
        break;
8000915c:	1d 00 12 00 	j 80009180 <IfxGeth_mtl_setRxForwardErrorPacket+0xc4>
    case IfxGeth_RxMtlQueue_3:
        gethSFR->MTL_RXQ3.OPERATION_MODE.B.FEP = enabled;
80009160:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80009164:	8f 12 00 21 	and %d2,%d2,1
80009168:	8f f2 0f 31 	and %d3,%d2,255
8000916c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009170:	d9 23 f0 70 	lea %a3,[%a2]3568
80009174:	54 32       	ld.w %d2,[%a3]
80009176:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
8000917a:	d9 22 f0 70 	lea %a2,[%a2]3568
8000917e:	74 22       	st.w [%a2],%d2
        break;
    }
}
80009180:	00 90       	ret 

80009182 <IfxGeth_mtl_setRxForwardErrorPacket_end>:
	...

80009184 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket>:


void IfxGeth_mtl_setRxForwardUndersizedGoodPacket(Ifx_GETH *gethSFR, IfxGeth_RxMtlQueue queueId, boolean enabled)
{
80009184:	40 ae       	mov.aa %a14,%sp
80009186:	20 10       	sub.a %sp,16
80009188:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8000918c:	59 e4 f8 ff 	st.w [%a14]-8,%d4
80009190:	02 52       	mov %d2,%d5
80009192:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
    switch (queueId)
80009196:	91 10 00 28 	movh.a %a2,32769
8000919a:	d9 22 2c 69 	lea %a2,[%a2]-28244 <800091ac <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0x28>>
8000919e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <800091ac <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0x28>>
800091a2:	ff 42 53 80 	jge.u %d2,4,80009248 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0xc4>
800091a6:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
800091aa:	dc 02       	ji %a2
800091ac:	1d 00 08 00 	j 800091bc <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0x38>
800091b0:	1d 00 18 00 	j 800091e0 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0x5c>
800091b4:	1d 00 28 00 	j 80009204 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0x80>
800091b8:	1d 00 38 00 	j 80009228 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0xa4>
    {
    case IfxGeth_RxMtlQueue_0:
        gethSFR->MTL_RXQ0.OPERATION_MODE.B.FUP = enabled;
800091bc:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
800091c0:	8f 12 00 21 	and %d2,%d2,1
800091c4:	8f f2 0f 31 	and %d3,%d2,255
800091c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800091cc:	d9 23 f0 40 	lea %a3,[%a2]3376
800091d0:	54 32       	ld.w %d2,[%a3]
800091d2:	67 32 03 20 	ins.t %d2,%d2,3,%d3,0
800091d6:	d9 22 f0 40 	lea %a2,[%a2]3376
800091da:	74 22       	st.w [%a2],%d2
        break;
800091dc:	1d 00 36 00 	j 80009248 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0xc4>
    case IfxGeth_RxMtlQueue_1:
        gethSFR->MTL_RXQ1.OPERATION_MODE.B.FUP = enabled;
800091e0:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
800091e4:	8f 12 00 21 	and %d2,%d2,1
800091e8:	8f f2 0f 31 	and %d3,%d2,255
800091ec:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800091f0:	d9 23 f0 50 	lea %a3,[%a2]3440
800091f4:	54 32       	ld.w %d2,[%a3]
800091f6:	67 32 03 20 	ins.t %d2,%d2,3,%d3,0
800091fa:	d9 22 f0 50 	lea %a2,[%a2]3440
800091fe:	74 22       	st.w [%a2],%d2
        break;
80009200:	1d 00 24 00 	j 80009248 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0xc4>
    case IfxGeth_RxMtlQueue_2:
        gethSFR->MTL_RXQ2.OPERATION_MODE.B.FUP = enabled;
80009204:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80009208:	8f 12 00 21 	and %d2,%d2,1
8000920c:	8f f2 0f 31 	and %d3,%d2,255
80009210:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009214:	d9 23 f0 60 	lea %a3,[%a2]3504
80009218:	54 32       	ld.w %d2,[%a3]
8000921a:	67 32 03 20 	ins.t %d2,%d2,3,%d3,0
8000921e:	d9 22 f0 60 	lea %a2,[%a2]3504
80009222:	74 22       	st.w [%a2],%d2
        break;
80009224:	1d 00 12 00 	j 80009248 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket+0xc4>
    case IfxGeth_RxMtlQueue_3:
        gethSFR->MTL_RXQ3.OPERATION_MODE.B.FUP = enabled;
80009228:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
8000922c:	8f 12 00 21 	and %d2,%d2,1
80009230:	8f f2 0f 31 	and %d3,%d2,255
80009234:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009238:	d9 23 f0 70 	lea %a3,[%a2]3568
8000923c:	54 32       	ld.w %d2,[%a3]
8000923e:	67 32 03 20 	ins.t %d2,%d2,3,%d3,0
80009242:	d9 22 f0 70 	lea %a2,[%a2]3568
80009246:	74 22       	st.w [%a2],%d2
        break;
    }
}
80009248:	00 90       	ret 

8000924a <IfxGeth_mtl_setRxForwardUndersizedGoodPacket_end>:
	...

8000924c <IfxGeth_mtl_setRxQueueSize>:


void IfxGeth_mtl_setRxQueueSize(Ifx_GETH *gethSFR, IfxGeth_RxMtlQueue queueId, IfxGeth_QueueSize queueSize)
{
8000924c:	40 ae       	mov.aa %a14,%sp
8000924e:	20 10       	sub.a %sp,16
80009250:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80009254:	59 e4 f8 ff 	st.w [%a14]-8,%d4
80009258:	59 e5 f4 ff 	st.w [%a14]-12,%d5
    switch (queueId)
8000925c:	91 10 00 28 	movh.a %a2,32769
80009260:	d9 22 34 99 	lea %a2,[%a2]-28044 <80009274 <IfxGeth_mtl_setRxQueueSize+0x28>>
80009264:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <80009274 <IfxGeth_mtl_setRxQueueSize+0x28>>
80009268:	ff 42 55 80 	jge.u %d2,4,80009312 <IfxGeth_mtl_setRxQueueSize+0xc6>
8000926c:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80009270:	dc 02       	ji %a2
80009272:	00 00       	nop 
80009274:	1d 00 08 00 	j 80009284 <IfxGeth_mtl_setRxQueueSize+0x38>
80009278:	1d 00 18 00 	j 800092a8 <IfxGeth_mtl_setRxQueueSize+0x5c>
8000927c:	1d 00 28 00 	j 800092cc <IfxGeth_mtl_setRxQueueSize+0x80>
80009280:	1d 00 38 00 	j 800092f0 <IfxGeth_mtl_setRxQueueSize+0xa4>
    {
    case IfxGeth_RxMtlQueue_0:
        gethSFR->MTL_RXQ0.OPERATION_MODE.B.RQS = queueSize;
80009284:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009288:	8f f2 01 21 	and %d2,%d2,31
8000928c:	8f f2 0f 31 	and %d3,%d2,255
80009290:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009294:	d9 23 f0 40 	lea %a3,[%a2]3376
80009298:	54 32       	ld.w %d2,[%a3]
8000929a:	37 32 05 2a 	insert %d2,%d2,%d3,20,5
8000929e:	d9 22 f0 40 	lea %a2,[%a2]3376
800092a2:	74 22       	st.w [%a2],%d2
        break;
800092a4:	1d 00 37 00 	j 80009312 <IfxGeth_mtl_setRxQueueSize+0xc6>
    case IfxGeth_RxMtlQueue_1:
        gethSFR->MTL_RXQ1.OPERATION_MODE.B.RQS = queueSize;
800092a8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800092ac:	8f f2 01 21 	and %d2,%d2,31
800092b0:	8f f2 0f 31 	and %d3,%d2,255
800092b4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800092b8:	d9 23 f0 50 	lea %a3,[%a2]3440
800092bc:	54 32       	ld.w %d2,[%a3]
800092be:	37 32 05 2a 	insert %d2,%d2,%d3,20,5
800092c2:	d9 22 f0 50 	lea %a2,[%a2]3440
800092c6:	74 22       	st.w [%a2],%d2
        break;
800092c8:	1d 00 25 00 	j 80009312 <IfxGeth_mtl_setRxQueueSize+0xc6>
    case IfxGeth_RxMtlQueue_2:
        gethSFR->MTL_RXQ2.OPERATION_MODE.B.RQS = queueSize;
800092cc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800092d0:	8f f2 01 21 	and %d2,%d2,31
800092d4:	8f f2 0f 31 	and %d3,%d2,255
800092d8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800092dc:	d9 23 f0 60 	lea %a3,[%a2]3504
800092e0:	54 32       	ld.w %d2,[%a3]
800092e2:	37 32 05 2a 	insert %d2,%d2,%d3,20,5
800092e6:	d9 22 f0 60 	lea %a2,[%a2]3504
800092ea:	74 22       	st.w [%a2],%d2
        break;
800092ec:	1d 00 13 00 	j 80009312 <IfxGeth_mtl_setRxQueueSize+0xc6>
    case IfxGeth_RxMtlQueue_3:
        gethSFR->MTL_RXQ3.OPERATION_MODE.B.RQS = queueSize;
800092f0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800092f4:	8f f2 01 21 	and %d2,%d2,31
800092f8:	8f f2 0f 31 	and %d3,%d2,255
800092fc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009300:	d9 23 f0 70 	lea %a3,[%a2]3568
80009304:	54 32       	ld.w %d2,[%a3]
80009306:	37 32 05 2a 	insert %d2,%d2,%d3,20,5
8000930a:	d9 22 f0 70 	lea %a2,[%a2]3568
8000930e:	74 22       	st.w [%a2],%d2
        break;
80009310:	00 00       	nop 
    }
}
80009312:	00 00       	nop 
80009314:	00 90       	ret 

80009316 <IfxGeth_mtl_setRxQueueSize_end>:
	...

80009318 <IfxGeth_mtl_setRxStoreAndForward>:


void IfxGeth_mtl_setRxStoreAndForward(Ifx_GETH *gethSFR, IfxGeth_RxMtlQueue queueId, boolean enabled)
{
80009318:	40 ae       	mov.aa %a14,%sp
8000931a:	20 10       	sub.a %sp,16
8000931c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80009320:	59 e4 f8 ff 	st.w [%a14]-8,%d4
80009324:	02 52       	mov %d2,%d5
80009326:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
    switch (queueId)
8000932a:	91 10 00 28 	movh.a %a2,32769
8000932e:	d9 22 00 d9 	lea %a2,[%a2]-27840 <80009340 <IfxGeth_mtl_setRxStoreAndForward+0x28>>
80009332:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <80009340 <IfxGeth_mtl_setRxStoreAndForward+0x28>>
80009336:	ff 42 53 80 	jge.u %d2,4,800093dc <IfxGeth_mtl_setRxStoreAndForward+0xc4>
8000933a:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
8000933e:	dc 02       	ji %a2
80009340:	1d 00 08 00 	j 80009350 <IfxGeth_mtl_setRxStoreAndForward+0x38>
80009344:	1d 00 18 00 	j 80009374 <IfxGeth_mtl_setRxStoreAndForward+0x5c>
80009348:	1d 00 28 00 	j 80009398 <IfxGeth_mtl_setRxStoreAndForward+0x80>
8000934c:	1d 00 38 00 	j 800093bc <IfxGeth_mtl_setRxStoreAndForward+0xa4>
    {
    case IfxGeth_RxMtlQueue_0:
        gethSFR->MTL_RXQ0.OPERATION_MODE.B.RSF = enabled;
80009350:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80009354:	8f 12 00 21 	and %d2,%d2,1
80009358:	8f f2 0f 31 	and %d3,%d2,255
8000935c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009360:	d9 23 f0 40 	lea %a3,[%a2]3376
80009364:	54 32       	ld.w %d2,[%a3]
80009366:	67 32 05 20 	ins.t %d2,%d2,5,%d3,0
8000936a:	d9 22 f0 40 	lea %a2,[%a2]3376
8000936e:	74 22       	st.w [%a2],%d2
        break;
80009370:	1d 00 36 00 	j 800093dc <IfxGeth_mtl_setRxStoreAndForward+0xc4>
    case IfxGeth_RxMtlQueue_1:
        gethSFR->MTL_RXQ1.OPERATION_MODE.B.RSF = enabled;
80009374:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80009378:	8f 12 00 21 	and %d2,%d2,1
8000937c:	8f f2 0f 31 	and %d3,%d2,255
80009380:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009384:	d9 23 f0 50 	lea %a3,[%a2]3440
80009388:	54 32       	ld.w %d2,[%a3]
8000938a:	67 32 05 20 	ins.t %d2,%d2,5,%d3,0
8000938e:	d9 22 f0 50 	lea %a2,[%a2]3440
80009392:	74 22       	st.w [%a2],%d2
        break;
80009394:	1d 00 24 00 	j 800093dc <IfxGeth_mtl_setRxStoreAndForward+0xc4>
    case IfxGeth_RxMtlQueue_2:
        gethSFR->MTL_RXQ2.OPERATION_MODE.B.RSF = enabled;
80009398:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
8000939c:	8f 12 00 21 	and %d2,%d2,1
800093a0:	8f f2 0f 31 	and %d3,%d2,255
800093a4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800093a8:	d9 23 f0 60 	lea %a3,[%a2]3504
800093ac:	54 32       	ld.w %d2,[%a3]
800093ae:	67 32 05 20 	ins.t %d2,%d2,5,%d3,0
800093b2:	d9 22 f0 60 	lea %a2,[%a2]3504
800093b6:	74 22       	st.w [%a2],%d2
        break;
800093b8:	1d 00 12 00 	j 800093dc <IfxGeth_mtl_setRxStoreAndForward+0xc4>
    case IfxGeth_RxMtlQueue_3:
        gethSFR->MTL_RXQ3.OPERATION_MODE.B.RSF = enabled;
800093bc:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
800093c0:	8f 12 00 21 	and %d2,%d2,1
800093c4:	8f f2 0f 31 	and %d3,%d2,255
800093c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800093cc:	d9 23 f0 70 	lea %a3,[%a2]3568
800093d0:	54 32       	ld.w %d2,[%a3]
800093d2:	67 32 05 20 	ins.t %d2,%d2,5,%d3,0
800093d6:	d9 22 f0 70 	lea %a2,[%a2]3568
800093da:	74 22       	st.w [%a2],%d2
        break;
    }
}
800093dc:	00 90       	ret 

800093de <IfxGeth_mtl_setRxStoreAndForward_end>:
	...

800093e0 <IfxGeth_mtl_setTxQueueSize>:


void IfxGeth_mtl_setTxQueueSize(Ifx_GETH *gethSFR, IfxGeth_TxMtlQueue queueId, IfxGeth_QueueSize queueSize)
{
800093e0:	40 ae       	mov.aa %a14,%sp
800093e2:	20 10       	sub.a %sp,16
800093e4:	b5 e4 fc ff 	st.a [%a14]-4,%a4
800093e8:	59 e4 f8 ff 	st.w [%a14]-8,%d4
800093ec:	59 e5 f4 ff 	st.w [%a14]-12,%d5
    switch (queueId)
800093f0:	91 10 00 28 	movh.a %a2,32769
800093f4:	d9 22 48 09 	lea %a2,[%a2]-27640 <80009408 <IfxGeth_mtl_setTxQueueSize+0x28>>
800093f8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <80009408 <IfxGeth_mtl_setTxQueueSize+0x28>>
800093fc:	ff 42 55 80 	jge.u %d2,4,800094a6 <IfxGeth_mtl_setTxQueueSize+0xc6>
80009400:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80009404:	dc 02       	ji %a2
80009406:	00 00       	nop 
80009408:	1d 00 08 00 	j 80009418 <IfxGeth_mtl_setTxQueueSize+0x38>
8000940c:	1d 00 18 00 	j 8000943c <IfxGeth_mtl_setTxQueueSize+0x5c>
80009410:	1d 00 28 00 	j 80009460 <IfxGeth_mtl_setTxQueueSize+0x80>
80009414:	1d 00 38 00 	j 80009484 <IfxGeth_mtl_setTxQueueSize+0xa4>
    {
    case IfxGeth_TxMtlQueue_0:
        gethSFR->MTL_TXQ0.OPERATION_MODE.B.TQS = queueSize;
80009418:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000941c:	8f f2 00 21 	and %d2,%d2,15
80009420:	8f f2 0f 31 	and %d3,%d2,255
80009424:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009428:	d9 23 c0 40 	lea %a3,[%a2]3328
8000942c:	54 32       	ld.w %d2,[%a3]
8000942e:	37 32 04 28 	insert %d2,%d2,%d3,16,4
80009432:	d9 22 c0 40 	lea %a2,[%a2]3328
80009436:	74 22       	st.w [%a2],%d2
        break;
80009438:	1d 00 37 00 	j 800094a6 <IfxGeth_mtl_setTxQueueSize+0xc6>
    case IfxGeth_TxMtlQueue_1:
        gethSFR->MTL_TXQ1.OPERATION_MODE.B.TQS = queueSize;
8000943c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009440:	8f f2 00 21 	and %d2,%d2,15
80009444:	8f f2 0f 31 	and %d3,%d2,255
80009448:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000944c:	d9 23 c0 50 	lea %a3,[%a2]3392
80009450:	54 32       	ld.w %d2,[%a3]
80009452:	37 32 04 28 	insert %d2,%d2,%d3,16,4
80009456:	d9 22 c0 50 	lea %a2,[%a2]3392
8000945a:	74 22       	st.w [%a2],%d2
        break;
8000945c:	1d 00 25 00 	j 800094a6 <IfxGeth_mtl_setTxQueueSize+0xc6>
    case IfxGeth_TxMtlQueue_2:
        gethSFR->MTL_TXQ2.OPERATION_MODE.B.TQS = queueSize;
80009460:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009464:	8f f2 00 21 	and %d2,%d2,15
80009468:	8f f2 0f 31 	and %d3,%d2,255
8000946c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009470:	d9 23 c0 60 	lea %a3,[%a2]3456
80009474:	54 32       	ld.w %d2,[%a3]
80009476:	37 32 04 28 	insert %d2,%d2,%d3,16,4
8000947a:	d9 22 c0 60 	lea %a2,[%a2]3456
8000947e:	74 22       	st.w [%a2],%d2
        break;
80009480:	1d 00 13 00 	j 800094a6 <IfxGeth_mtl_setTxQueueSize+0xc6>
    case IfxGeth_TxMtlQueue_3:
        gethSFR->MTL_TXQ3.OPERATION_MODE.B.TQS = queueSize;
80009484:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009488:	8f f2 00 21 	and %d2,%d2,15
8000948c:	8f f2 0f 31 	and %d3,%d2,255
80009490:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009494:	d9 23 c0 70 	lea %a3,[%a2]3520
80009498:	54 32       	ld.w %d2,[%a3]
8000949a:	37 32 04 28 	insert %d2,%d2,%d3,16,4
8000949e:	d9 22 c0 70 	lea %a2,[%a2]3520
800094a2:	74 22       	st.w [%a2],%d2
        break;
800094a4:	00 00       	nop 
    }
}
800094a6:	00 00       	nop 
800094a8:	00 90       	ret 

800094aa <IfxGeth_mtl_setTxQueueSize_end>:
	...

800094ac <IfxGeth_mtl_setTxStoreAndForward>:


void IfxGeth_mtl_setTxStoreAndForward(Ifx_GETH *gethSFR, IfxGeth_TxMtlQueue queueId, boolean enabled)
{
800094ac:	40 ae       	mov.aa %a14,%sp
800094ae:	20 10       	sub.a %sp,16
800094b0:	b5 e4 fc ff 	st.a [%a14]-4,%a4
800094b4:	59 e4 f8 ff 	st.w [%a14]-8,%d4
800094b8:	02 52       	mov %d2,%d5
800094ba:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
    switch (queueId)
800094be:	91 10 00 28 	movh.a %a2,32769
800094c2:	d9 22 54 39 	lea %a2,[%a2]-27436 <800094d4 <IfxGeth_mtl_setTxStoreAndForward+0x28>>
800094c6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <800094d4 <IfxGeth_mtl_setTxStoreAndForward+0x28>>
800094ca:	ff 42 53 80 	jge.u %d2,4,80009570 <IfxGeth_mtl_setTxStoreAndForward+0xc4>
800094ce:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
800094d2:	dc 02       	ji %a2
800094d4:	1d 00 08 00 	j 800094e4 <IfxGeth_mtl_setTxStoreAndForward+0x38>
800094d8:	1d 00 18 00 	j 80009508 <IfxGeth_mtl_setTxStoreAndForward+0x5c>
800094dc:	1d 00 28 00 	j 8000952c <IfxGeth_mtl_setTxStoreAndForward+0x80>
800094e0:	1d 00 38 00 	j 80009550 <IfxGeth_mtl_setTxStoreAndForward+0xa4>
    {
    case IfxGeth_TxMtlQueue_0:
        gethSFR->MTL_TXQ0.OPERATION_MODE.B.TSF = enabled;
800094e4:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
800094e8:	8f 12 00 21 	and %d2,%d2,1
800094ec:	8f f2 0f 31 	and %d3,%d2,255
800094f0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800094f4:	d9 23 c0 40 	lea %a3,[%a2]3328
800094f8:	54 32       	ld.w %d2,[%a3]
800094fa:	67 32 01 20 	ins.t %d2,%d2,1,%d3,0
800094fe:	d9 22 c0 40 	lea %a2,[%a2]3328
80009502:	74 22       	st.w [%a2],%d2
        break;
80009504:	1d 00 36 00 	j 80009570 <IfxGeth_mtl_setTxStoreAndForward+0xc4>
    case IfxGeth_TxMtlQueue_1:
        gethSFR->MTL_TXQ1.OPERATION_MODE.B.TSF = enabled;
80009508:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
8000950c:	8f 12 00 21 	and %d2,%d2,1
80009510:	8f f2 0f 31 	and %d3,%d2,255
80009514:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009518:	d9 23 c0 50 	lea %a3,[%a2]3392
8000951c:	54 32       	ld.w %d2,[%a3]
8000951e:	67 32 01 20 	ins.t %d2,%d2,1,%d3,0
80009522:	d9 22 c0 50 	lea %a2,[%a2]3392
80009526:	74 22       	st.w [%a2],%d2
        break;
80009528:	1d 00 24 00 	j 80009570 <IfxGeth_mtl_setTxStoreAndForward+0xc4>
    case IfxGeth_TxMtlQueue_2:
        gethSFR->MTL_TXQ2.OPERATION_MODE.B.TSF = enabled;
8000952c:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80009530:	8f 12 00 21 	and %d2,%d2,1
80009534:	8f f2 0f 31 	and %d3,%d2,255
80009538:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000953c:	d9 23 c0 60 	lea %a3,[%a2]3456
80009540:	54 32       	ld.w %d2,[%a3]
80009542:	67 32 01 20 	ins.t %d2,%d2,1,%d3,0
80009546:	d9 22 c0 60 	lea %a2,[%a2]3456
8000954a:	74 22       	st.w [%a2],%d2
        break;
8000954c:	1d 00 12 00 	j 80009570 <IfxGeth_mtl_setTxStoreAndForward+0xc4>
    case IfxGeth_TxMtlQueue_3:
        gethSFR->MTL_TXQ3.OPERATION_MODE.B.TSF = enabled;
80009550:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80009554:	8f 12 00 21 	and %d2,%d2,1
80009558:	8f f2 0f 31 	and %d3,%d2,255
8000955c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80009560:	d9 23 c0 70 	lea %a3,[%a2]3520
80009564:	54 32       	ld.w %d2,[%a3]
80009566:	67 32 01 20 	ins.t %d2,%d2,1,%d3,0
8000956a:	d9 22 c0 70 	lea %a2,[%a2]3520
8000956e:	74 22       	st.w [%a2],%d2
        break;
    }
}
80009570:	00 90       	ret 

80009572 <IfxGeth_mtl_setTxStoreAndForward_end>:
	...

80009574 <IfxGeth_resetModule>:


void IfxGeth_resetModule(Ifx_GETH *gethSFR)
{
80009574:	40 ae       	mov.aa %a14,%sp
80009576:	20 10       	sub.a %sp,16
80009578:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000957c:	6d ff ac f8 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
80009580:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80009584:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80009588:	02 24       	mov %d4,%d2
8000958a:	6d ff ae f6 	call 800082e6 <IfxScuWdt_clearCpuEndinit>

    gethSFR->KRST0.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
8000958e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80009592:	d9 23 14 02 	lea %a3,[%a2]8212
80009596:	54 32       	ld.w %d2,[%a3]
80009598:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000959c:	d9 22 14 02 	lea %a2,[%a2]8212
800095a0:	74 22       	st.w [%a2],%d2
    gethSFR->KRST1.B.RST = 1;
800095a2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800095a6:	d9 23 18 02 	lea %a3,[%a2]8216
800095aa:	54 32       	ld.w %d2,[%a3]
800095ac:	b7 12 01 20 	insert %d2,%d2,1,0,1
800095b0:	d9 22 18 02 	lea %a2,[%a2]8216
800095b4:	74 22       	st.w [%a2],%d2
    IfxScuWdt_setCpuEndinit(passwd);
800095b6:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800095ba:	02 24       	mov %d4,%d2
800095bc:	6d ff dc f8 	call 80008774 <IfxScuWdt_setCpuEndinit>

    while (0 == gethSFR->KRST0.B.RSTSTAT)  /* Wait until reset is executed */
800095c0:	00 00       	nop 
800095c2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800095c6:	d9 22 14 02 	lea %a2,[%a2]8212
800095ca:	54 22       	ld.w %d2,[%a2]
800095cc:	37 02 e1 20 	extr.u %d2,%d2,1,1
800095d0:	8f f2 0f 21 	and %d2,%d2,255
800095d4:	df 02 f7 7f 	jeq %d2,0,800095c2 <IfxGeth_resetModule+0x4e>
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
800095d8:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800095dc:	02 24       	mov %d4,%d2
800095de:	6d ff 84 f6 	call 800082e6 <IfxScuWdt_clearCpuEndinit>
    gethSFR->KRSTCLR.B.CLR = 1;      /* Clear Kernel reset status bit */
800095e2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800095e6:	d9 23 1c 02 	lea %a3,[%a2]8220
800095ea:	54 32       	ld.w %d2,[%a3]
800095ec:	b7 12 01 20 	insert %d2,%d2,1,0,1
800095f0:	d9 22 1c 02 	lea %a2,[%a2]8220
800095f4:	74 22       	st.w [%a2],%d2

    IfxScuWdt_setCpuEndinit(passwd);
800095f6:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800095fa:	02 24       	mov %d4,%d2
800095fc:	6d ff bc f8 	call 80008774 <IfxScuWdt_setCpuEndinit>
}
80009600:	00 00       	nop 
80009602:	00 90       	ret 

80009604 <IfxGeth_mac_setMaxPacketSize>:
    IFXGETH_PHY_WAIT_GMII_READY();
}


void IfxGeth_mac_setMaxPacketSize(Ifx_GETH *gethSFR, uint16 maxPacketSize)
{
80009604:	40 ae       	mov.aa %a14,%sp
80009606:	20 10       	sub.a %sp,16
80009608:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8000960c:	02 42       	mov %d2,%d4
8000960e:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
    uint16                     maxSize;
    Ifx_GETH_MAC_CONFIGURATION macConfig;

    maxSize     = maxPacketSize;
80009612:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
80009616:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    macConfig.U = gethSFR->MAC_CONFIGURATION.U;
8000961a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000961e:	54 22       	ld.w %d2,[%a2]
80009620:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    if (maxSize == 1518)
80009624:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80009628:	3b e0 5e 30 	mov %d3,1518
8000962c:	5f 32 24 80 	jne %d2,%d3,80009674 <IfxGeth_mac_setMaxPacketSize+0x70>
    {
        macConfig.B.JE     = 0;
80009630:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009634:	7b f0 ff 3f 	movh %d3,65535
80009638:	c2 f3       	add %d3,-1
8000963a:	26 32       	and %d2,%d3
8000963c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.S2KP   = 0;
80009640:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009644:	7b 00 fc 3f 	movh %d3,65472
80009648:	c2 f3       	add %d3,-1
8000964a:	26 32       	and %d2,%d3
8000964c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.GPSLCE = 0;
80009650:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009654:	7b 00 f8 3f 	movh %d3,65408
80009658:	c2 f3       	add %d3,-1
8000965a:	26 32       	and %d2,%d3
8000965c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.JD     = 0;
80009660:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009664:	7b e0 ff 3f 	movh %d3,65534
80009668:	c2 f3       	add %d3,-1
8000966a:	26 32       	and %d2,%d3
8000966c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80009670:	1d 00 86 00 	j 8000977c <IfxGeth_mac_setMaxPacketSize+0x178>
    }
    else if (maxSize == 2000)
80009674:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80009678:	3b 00 7d 30 	mov %d3,2000
8000967c:	5f 32 22 80 	jne %d2,%d3,800096c0 <IfxGeth_mac_setMaxPacketSize+0xbc>
    {
        macConfig.B.JE     = 0;
80009680:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009684:	7b f0 ff 3f 	movh %d3,65535
80009688:	c2 f3       	add %d3,-1
8000968a:	26 32       	and %d2,%d3
8000968c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.S2KP   = 1;
80009690:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009694:	b7 12 01 2b 	insert %d2,%d2,1,22,1
80009698:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.GPSLCE = 0;
8000969c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800096a0:	7b 00 f8 3f 	movh %d3,65408
800096a4:	c2 f3       	add %d3,-1
800096a6:	26 32       	and %d2,%d3
800096a8:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.JD     = 0;
800096ac:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800096b0:	7b e0 ff 3f 	movh %d3,65534
800096b4:	c2 f3       	add %d3,-1
800096b6:	26 32       	and %d2,%d3
800096b8:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800096bc:	1d 00 60 00 	j 8000977c <IfxGeth_mac_setMaxPacketSize+0x178>
    }
    else if (maxSize == 9018)
800096c0:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800096c4:	3b a0 33 32 	mov %d3,9018
800096c8:	5f 32 1a 80 	jne %d2,%d3,800096fc <IfxGeth_mac_setMaxPacketSize+0xf8>
    {
        macConfig.B.JE     = 1;
800096cc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800096d0:	b7 12 01 28 	insert %d2,%d2,1,16,1
800096d4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.GPSLCE = 0;
800096d8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800096dc:	7b 00 f8 3f 	movh %d3,65408
800096e0:	c2 f3       	add %d3,-1
800096e2:	26 32       	and %d2,%d3
800096e4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.JD     = 0;
800096e8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800096ec:	7b e0 ff 3f 	movh %d3,65534
800096f0:	c2 f3       	add %d3,-1
800096f2:	26 32       	and %d2,%d3
800096f4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800096f8:	1d 00 42 00 	j 8000977c <IfxGeth_mac_setMaxPacketSize+0x178>
    }
    else
    {
        macConfig.B.JE                        = 0;
800096fc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009700:	7b f0 ff 3f 	movh %d3,65535
80009704:	c2 f3       	add %d3,-1
80009706:	26 32       	and %d2,%d3
80009708:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.S2KP                      = 0;
8000970c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009710:	7b 00 fc 3f 	movh %d3,65472
80009714:	c2 f3       	add %d3,-1
80009716:	26 32       	and %d2,%d3
80009718:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.GPSLCE                    = 1;
8000971c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009720:	b7 12 81 2b 	insert %d2,%d2,1,23,1
80009724:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        macConfig.B.JD                        = 1;
80009728:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000972c:	b7 12 81 28 	insert %d2,%d2,1,17,1
80009730:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        gethSFR->MAC_EXT_CONFIGURATION.B.GPSL = maxSize;
80009734:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80009738:	3b f0 ff 33 	mov %d3,16383
8000973c:	26 32       	and %d2,%d3
8000973e:	37 02 70 30 	extr.u %d3,%d2,0,16
80009742:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80009746:	d9 23 04 00 	lea %a3,[%a2]4
8000974a:	54 32       	ld.w %d2,[%a3]
8000974c:	37 32 0e 20 	insert %d2,%d2,%d3,0,14
80009750:	b0 42       	add.a %a2,4
80009752:	74 22       	st.w [%a2],%d2
        gethSFR->MAC_WATCHDOG_TIMEOUT.B.PWE   = 1;
80009754:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80009758:	d9 23 0c 00 	lea %a3,[%a2]12
8000975c:	54 32       	ld.w %d2,[%a3]
8000975e:	b7 12 01 24 	insert %d2,%d2,1,8,1
80009762:	d9 22 0c 00 	lea %a2,[%a2]12
80009766:	74 22       	st.w [%a2],%d2
        gethSFR->MAC_WATCHDOG_TIMEOUT.B.WTO   = 0x0e;
80009768:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000976c:	d9 23 0c 00 	lea %a3,[%a2]12
80009770:	54 32       	ld.w %d2,[%a3]
80009772:	b7 e2 04 20 	insert %d2,%d2,14,0,4
80009776:	d9 22 0c 00 	lea %a2,[%a2]12
8000977a:	74 22       	st.w [%a2],%d2
    }

    gethSFR->MAC_CONFIGURATION.U = macConfig.U;
8000977c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009780:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80009784:	74 22       	st.w [%a2],%d2
}
80009786:	00 00       	nop 
80009788:	00 90       	ret 

8000978a <IfxGeth_getIndex>:


IfxGeth_Index IfxGeth_getIndex(Ifx_GETH *geth)
{
8000978a:	40 ae       	mov.aa %a14,%sp
8000978c:	20 10       	sub.a %sp,16
8000978e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
    uint32        index;
    IfxGeth_Index result;

    result = IfxGeth_Index_none;
80009792:	82 f2       	mov %d2,-1
80009794:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    for (index = 0; index < IFXGETH_NUM_MODULES; index++)
80009798:	82 02       	mov %d2,0
8000979a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000979e:	1d 00 26 00 	j 800097ea <IfxGeth_getIndex+0x60>
    {
        if (IfxGeth_cfg_indexMap[index].module == geth)
800097a2:	91 00 00 28 	movh.a %a2,32768
800097a6:	d9 22 10 74 	lea %a2,[%a2]16848 <800041d0 <IfxGeth_cfg_indexMap>>
800097aa:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <800041d0 <IfxGeth_cfg_indexMap>>
800097ae:	06 32       	sh %d2,3
800097b0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800097b4:	54 22       	ld.w %d2,[%a2]
800097b6:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
800097ba:	5f 23 13 80 	jne %d3,%d2,800097e0 <IfxGeth_getIndex+0x56>
        {
            result = (IfxGeth_Index)IfxGeth_cfg_indexMap[index].index;
800097be:	91 00 00 28 	movh.a %a2,32768
800097c2:	d9 22 10 74 	lea %a2,[%a2]16848 <800041d0 <IfxGeth_cfg_indexMap>>
800097c6:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <800041d0 <IfxGeth_cfg_indexMap>>
800097ca:	06 32       	sh %d2,3
800097cc:	80 23       	mov.d %d3,%a2
800097ce:	42 23       	add %d3,%d2
800097d0:	02 32       	mov %d2,%d3
800097d2:	60 22       	mov.a %a2,%d2
800097d4:	b0 42       	add.a %a2,4
800097d6:	54 22       	ld.w %d2,[%a2]
800097d8:	59 e2 f8 ff 	st.w [%a14]-8,%d2
            break;
800097dc:	1d 00 0b 00 	j 800097f2 <IfxGeth_getIndex+0x68>
    for (index = 0; index < IFXGETH_NUM_MODULES; index++)
800097e0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800097e4:	c2 12       	add %d2,1
800097e6:	59 e2 fc ff 	st.w [%a14]-4,%d2
800097ea:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800097ee:	df 02 da 7f 	jeq %d2,0,800097a2 <IfxGeth_getIndex+0x18>
        }
    }

    return result;
800097f2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
}
800097f6:	00 90       	ret 

800097f8 <IfxGeth_Eth_configureDMA>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxGeth_Eth_configureDMA(IfxGeth_Eth *geth, IfxGeth_Eth_DmaConfig *dmaConfig)
{
800097f8:	40 ae       	mov.aa %a14,%sp
800097fa:	20 b0       	sub.a %sp,176
800097fc:	b5 e4 d4 df 	st.a [%a14]-172,%a4
80009800:	b5 e5 d0 df 	st.a [%a14]-176,%a5
    uint32 txChannelIndex, rxChannelIndex, channelIndex;
    uint32 numOfChannels = (dmaConfig->numOfTxChannels >= dmaConfig->numOfRxChannels) ? dmaConfig->numOfTxChannels : dmaConfig->numOfRxChannels;
80009804:	99 e2 d0 df 	ld.a %a2,[%a14]-176
80009808:	54 23       	ld.w %d3,[%a2]
8000980a:	99 e2 d0 df 	ld.a %a2,[%a14]-176
8000980e:	b0 42       	add.a %a2,4
80009810:	54 22       	ld.w %d2,[%a2]
80009812:	0b 23 b0 21 	max.u %d2,%d3,%d2
80009816:	59 e2 f0 ff 	st.w [%a14]-16,%d2

    /* DMA top level configuration */
    IfxGeth_dma_setAddressAlignedBeats(geth->gethSFR, dmaConfig->addressAlignedBeatsEnabled);
8000981a:	99 e2 d4 df 	ld.a %a2,[%a14]-172
8000981e:	54 23       	ld.w %d3,[%a2]
80009820:	99 e2 d0 df 	ld.a %a2,[%a14]-176
80009824:	39 22 08 00 	ld.bu %d2,[%a2]8
80009828:	59 e3 d4 ff 	st.w [%a14]-44,%d3
8000982c:	e9 e2 d3 ff 	st.b [%a14]-45,%d2
    gethSFR->DMA_SYSBUS_MODE.B.AAL = enabled;
80009830:	79 e2 d3 ff 	ld.b %d2,[%a14]-45
80009834:	8f 12 00 21 	and %d2,%d2,1
80009838:	8f f2 0f 31 	and %d3,%d2,255
8000983c:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80009840:	d9 23 04 01 	lea %a3,[%a2]4100
80009844:	54 32       	ld.w %d2,[%a3]
80009846:	67 32 0c 20 	ins.t %d2,%d2,12,%d3,0
8000984a:	d9 22 04 01 	lea %a2,[%a2]4100
8000984e:	74 22       	st.w [%a2],%d2
}
80009850:	00 00       	nop 
    IfxGeth_dma_setFixedBurst(geth->gethSFR, dmaConfig->fixedBurstEnabled);
80009852:	99 e2 d4 df 	ld.a %a2,[%a14]-172
80009856:	54 23       	ld.w %d3,[%a2]
80009858:	99 e2 d0 df 	ld.a %a2,[%a14]-176
8000985c:	39 22 09 00 	ld.bu %d2,[%a2]9
80009860:	59 e3 dc ff 	st.w [%a14]-36,%d3
80009864:	e9 e2 db ff 	st.b [%a14]-37,%d2
    gethSFR->DMA_SYSBUS_MODE.B.FB = enabled;
80009868:	79 e2 db ff 	ld.b %d2,[%a14]-37
8000986c:	8f 12 00 21 	and %d2,%d2,1
80009870:	8f f2 0f 31 	and %d3,%d2,255
80009874:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80009878:	d9 23 04 01 	lea %a3,[%a2]4100
8000987c:	54 32       	ld.w %d2,[%a3]
8000987e:	67 32 00 20 	ins.t %d2,%d2,0,%d3,0
80009882:	d9 22 04 01 	lea %a2,[%a2]4100
80009886:	74 22       	st.w [%a2],%d2
}
80009888:	00 00       	nop 
    IfxGeth_dma_setMixedBurst(geth->gethSFR, dmaConfig->mixedBurstEnabled);
8000988a:	99 e2 d4 df 	ld.a %a2,[%a14]-172
8000988e:	54 23       	ld.w %d3,[%a2]
80009890:	99 e2 d0 df 	ld.a %a2,[%a14]-176
80009894:	39 22 0a 00 	ld.bu %d2,[%a2]10
80009898:	59 e3 e4 ff 	st.w [%a14]-28,%d3
8000989c:	e9 e2 e3 ff 	st.b [%a14]-29,%d2
    gethSFR->DMA_SYSBUS_MODE.B.MB = enabled;
800098a0:	79 e2 e3 ff 	ld.b %d2,[%a14]-29
800098a4:	8f 12 00 21 	and %d2,%d2,1
800098a8:	8f f2 0f 31 	and %d3,%d2,255
800098ac:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800098b0:	d9 23 04 01 	lea %a3,[%a2]4100
800098b4:	54 32       	ld.w %d2,[%a3]
800098b6:	67 32 0e 20 	ins.t %d2,%d2,14,%d3,0
800098ba:	d9 22 04 01 	lea %a2,[%a2]4100
800098be:	74 22       	st.w [%a2],%d2
}
800098c0:	00 00       	nop 

    /* TX Channels(s) configuration */
    IfxGeth_Eth_stopTransmitters(geth, dmaConfig->numOfTxChannels);
800098c2:	99 e2 d0 df 	ld.a %a2,[%a14]-176
800098c6:	54 22       	ld.w %d2,[%a2]
800098c8:	02 24       	mov %d4,%d2
800098ca:	99 e4 d4 df 	ld.a %a4,[%a14]-172
800098ce:	6d 00 90 1c 	call 8000d1ee <IfxGeth_Eth_stopTransmitters>

    for (txChannelIndex = 0; txChannelIndex < dmaConfig->numOfTxChannels; txChannelIndex++)
800098d2:	82 02       	mov %d2,0
800098d4:	59 e2 fc ff 	st.w [%a14]-4,%d2
800098d8:	1d 00 7b 00 	j 800099ce <IfxGeth_Eth_configureDMA+0x1d6>
    {
        IfxGeth_dma_setTxMaxBurstLength(geth->gethSFR, dmaConfig->txChannel[txChannelIndex].channelId, dmaConfig->txChannel[txChannelIndex].maxBurstLength);
800098dc:	99 e2 d4 df 	ld.a %a2,[%a14]-172
800098e0:	54 24       	ld.w %d4,[%a2]
800098e2:	19 e3 d0 df 	ld.w %d3,[%a14]-176
800098e6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800098ea:	53 42 21 20 	mul %d2,%d2,20
800098ee:	42 32       	add %d2,%d3
800098f0:	60 22       	mov.a %a2,%d2
800098f2:	d9 22 0c 00 	lea %a2,[%a2]12
800098f6:	54 23       	ld.w %d3,[%a2]
800098f8:	19 e5 d0 df 	ld.w %d5,[%a14]-176
800098fc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80009900:	53 42 21 20 	mul %d2,%d2,20
80009904:	42 52       	add %d2,%d5
80009906:	60 22       	mov.a %a2,%d2
80009908:	d9 22 10 00 	lea %a2,[%a2]16
8000990c:	54 22       	ld.w %d2,[%a2]
8000990e:	59 e4 c0 ff 	st.w [%a14]-64,%d4
80009912:	59 e3 fc ef 	st.w [%a14]-68,%d3
80009916:	59 e2 f8 ef 	st.w [%a14]-72,%d2
    gethSFR->DMA_CH[channel].TX_CONTROL.B.TXPBL = length;
8000991a:	19 e2 f8 ef 	ld.w %d2,[%a14]-72
8000991e:	8f f2 03 21 	and %d2,%d2,63
80009922:	8f f2 0f 31 	and %d3,%d2,255
80009926:	19 e4 c0 ff 	ld.w %d4,[%a14]-64
8000992a:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000992e:	06 72       	sh %d2,7
80009930:	42 42       	add %d2,%d4
80009932:	60 22       	mov.a %a2,%d2
80009934:	d9 22 04 41 	lea %a2,[%a2]4356
80009938:	54 22       	ld.w %d2,[%a2]
8000993a:	37 32 06 28 	insert %d2,%d2,%d3,16,6
8000993e:	74 22       	st.w [%a2],%d2
}
80009940:	00 00       	nop 
        IfxGeth_dma_setTxOSF(geth->gethSFR, dmaConfig->txChannel[txChannelIndex].channelId, dmaConfig->txChannel[txChannelIndex].enableOSF);
80009942:	99 e2 d4 df 	ld.a %a2,[%a14]-172
80009946:	54 24       	ld.w %d4,[%a2]
80009948:	19 e3 d0 df 	ld.w %d3,[%a14]-176
8000994c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80009950:	53 42 21 20 	mul %d2,%d2,20
80009954:	42 32       	add %d2,%d3
80009956:	60 22       	mov.a %a2,%d2
80009958:	d9 22 0c 00 	lea %a2,[%a2]12
8000995c:	54 23       	ld.w %d3,[%a2]
8000995e:	19 e5 d0 df 	ld.w %d5,[%a14]-176
80009962:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80009966:	53 42 21 20 	mul %d2,%d2,20
8000996a:	42 52       	add %d2,%d5
8000996c:	60 22       	mov.a %a2,%d2
8000996e:	d9 22 1e 00 	lea %a2,[%a2]30
80009972:	14 22       	ld.bu %d2,[%a2]
80009974:	59 e4 cc ff 	st.w [%a14]-52,%d4
80009978:	59 e3 c8 ff 	st.w [%a14]-56,%d3
8000997c:	e9 e2 c7 ff 	st.b [%a14]-57,%d2
}


IFX_INLINE void IfxGeth_dma_setTxOSF(Ifx_GETH *gethSFR, IfxGeth_TxDmaChannel channel, boolean enable)
{
    gethSFR->DMA_CH[channel].TX_CONTROL.B.OSF = enable;
80009980:	79 e2 c7 ff 	ld.b %d2,[%a14]-57
80009984:	8f 12 00 21 	and %d2,%d2,1
80009988:	8f f2 0f 31 	and %d3,%d2,255
8000998c:	19 e4 cc ff 	ld.w %d4,[%a14]-52
80009990:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
80009994:	06 72       	sh %d2,7
80009996:	42 42       	add %d2,%d4
80009998:	60 22       	mov.a %a2,%d2
8000999a:	d9 22 04 41 	lea %a2,[%a2]4356
8000999e:	54 22       	ld.w %d2,[%a2]
800099a0:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
800099a4:	74 22       	st.w [%a2],%d2
}
800099a6:	00 00       	nop 
        IfxGeth_Eth_initTransmitDescriptors(geth, &dmaConfig->txChannel[txChannelIndex]);
800099a8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800099ac:	53 42 21 20 	mul %d2,%d2,20
800099b0:	1b c2 00 20 	addi %d2,%d2,12
800099b4:	19 e3 d0 df 	ld.w %d3,[%a14]-176
800099b8:	42 32       	add %d2,%d3
800099ba:	60 25       	mov.a %a5,%d2
800099bc:	99 e4 d4 df 	ld.a %a4,[%a14]-172
800099c0:	6d 00 57 0b 	call 8000b06e <IfxGeth_Eth_initTransmitDescriptors>
    for (txChannelIndex = 0; txChannelIndex < dmaConfig->numOfTxChannels; txChannelIndex++)
800099c4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800099c8:	c2 12       	add %d2,1
800099ca:	59 e2 fc ff 	st.w [%a14]-4,%d2
800099ce:	99 e2 d0 df 	ld.a %a2,[%a14]-176
800099d2:	54 22       	ld.w %d2,[%a2]
800099d4:	19 e3 fc ff 	ld.w %d3,[%a14]-4
800099d8:	3f 23 82 ff 	jlt.u %d3,%d2,800098dc <IfxGeth_Eth_configureDMA+0xe4>
    }

    /* RX Channels(s) configuration */
    for (rxChannelIndex = 0; rxChannelIndex < dmaConfig->numOfRxChannels; rxChannelIndex++)
800099dc:	82 02       	mov %d2,0
800099de:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800099e2:	1d 00 48 00 	j 80009a72 <IfxGeth_Eth_configureDMA+0x27a>
    {
        IfxGeth_dma_setRxMaxBurstLength(geth->gethSFR, dmaConfig->rxChannel[rxChannelIndex].channelId, dmaConfig->rxChannel[rxChannelIndex].maxBurstLength);
800099e6:	99 e2 d4 df 	ld.a %a2,[%a14]-172
800099ea:	54 24       	ld.w %d4,[%a2]
800099ec:	19 e3 d0 df 	ld.w %d3,[%a14]-176
800099f0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800099f4:	53 42 21 20 	mul %d2,%d2,20
800099f8:	42 32       	add %d2,%d3
800099fa:	60 22       	mov.a %a2,%d2
800099fc:	d9 22 1c 10 	lea %a2,[%a2]92
80009a00:	54 23       	ld.w %d3,[%a2]
80009a02:	19 e5 d0 df 	ld.w %d5,[%a14]-176
80009a06:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009a0a:	53 42 21 20 	mul %d2,%d2,20
80009a0e:	42 52       	add %d2,%d5
80009a10:	60 22       	mov.a %a2,%d2
80009a12:	d9 22 20 10 	lea %a2,[%a2]96
80009a16:	54 22       	ld.w %d2,[%a2]
80009a18:	59 e4 f4 ef 	st.w [%a14]-76,%d4
80009a1c:	59 e3 f0 ef 	st.w [%a14]-80,%d3
80009a20:	59 e2 ec ef 	st.w [%a14]-84,%d2
    gethSFR->DMA_CH[channel].RX_CONTROL.B.RXPBL = length;
80009a24:	19 e2 ec ef 	ld.w %d2,[%a14]-84
80009a28:	8f f2 03 21 	and %d2,%d2,63
80009a2c:	8f f2 0f 31 	and %d3,%d2,255
80009a30:	19 e4 f4 ef 	ld.w %d4,[%a14]-76
80009a34:	19 e2 f0 ef 	ld.w %d2,[%a14]-80
80009a38:	06 72       	sh %d2,7
80009a3a:	42 42       	add %d2,%d4
80009a3c:	60 22       	mov.a %a2,%d2
80009a3e:	d9 22 08 41 	lea %a2,[%a2]4360
80009a42:	54 22       	ld.w %d2,[%a2]
80009a44:	37 32 06 28 	insert %d2,%d2,%d3,16,6
80009a48:	74 22       	st.w [%a2],%d2
}
80009a4a:	00 00       	nop 
        IfxGeth_Eth_initReceiveDescriptors(geth, &dmaConfig->rxChannel[rxChannelIndex]);
80009a4c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009a50:	53 42 21 20 	mul %d2,%d2,20
80009a54:	1b c2 05 20 	addi %d2,%d2,92
80009a58:	19 e3 d0 df 	ld.w %d3,[%a14]-176
80009a5c:	42 32       	add %d2,%d3
80009a5e:	60 25       	mov.a %a5,%d2
80009a60:	99 e4 d4 df 	ld.a %a4,[%a14]-172
80009a64:	6d 00 be 09 	call 8000ade0 <IfxGeth_Eth_initReceiveDescriptors>
    for (rxChannelIndex = 0; rxChannelIndex < dmaConfig->numOfRxChannels; rxChannelIndex++)
80009a68:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009a6c:	c2 12       	add %d2,1
80009a6e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80009a72:	99 e2 d0 df 	ld.a %a2,[%a14]-176
80009a76:	b0 42       	add.a %a2,4
80009a78:	54 22       	ld.w %d2,[%a2]
80009a7a:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80009a7e:	3f 23 b4 ff 	jlt.u %d3,%d2,800099e6 <IfxGeth_Eth_configureDMA+0x1ee>
    }

    /* initialise the selected interrupts */
    for (channelIndex = 0; channelIndex < numOfChannels; channelIndex++)
80009a82:	82 02       	mov %d2,0
80009a84:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80009a88:	1d 00 85 01 	j 80009d92 <IfxGeth_Eth_configureDMA+0x59a>
    {
        IfxGeth_dma_clearAllInterruptFlags(geth->gethSFR, dmaConfig->txInterrupt[channelIndex].channelId);
80009a8c:	99 e2 d4 df 	ld.a %a2,[%a14]-172
80009a90:	54 23       	ld.w %d3,[%a2]
80009a92:	19 e4 d0 df 	ld.w %d4,[%a14]-176
80009a96:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009a9a:	53 c2 20 20 	mul %d2,%d2,12
80009a9e:	42 42       	add %d2,%d4
80009aa0:	60 22       	mov.a %a2,%d2
80009aa2:	d9 22 2c 20 	lea %a2,[%a2]172
80009aa6:	54 22       	ld.w %d2,[%a2]
80009aa8:	59 e3 e8 ef 	st.w [%a14]-88,%d3
80009aac:	59 e2 e4 ef 	st.w [%a14]-92,%d2
    gethSFR->DMA_CH[channelId].STATUS.U = 0;
80009ab0:	19 e3 e8 ef 	ld.w %d3,[%a14]-88
80009ab4:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
80009ab8:	06 72       	sh %d2,7
80009aba:	42 32       	add %d2,%d3
80009abc:	60 22       	mov.a %a2,%d2
80009abe:	d9 22 20 51 	lea %a2,[%a2]4448
80009ac2:	82 02       	mov %d2,0
80009ac4:	74 22       	st.w [%a2],%d2
}
80009ac6:	00 00       	nop 

        /* Transmit interrupts */
        if ((dmaConfig->txInterrupt[channelIndex].priority > 0) || (dmaConfig->txInterrupt[channelIndex].provider == IfxSrc_Tos_dma))
80009ac8:	19 e3 d0 df 	ld.w %d3,[%a14]-176
80009acc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009ad0:	53 c2 20 20 	mul %d2,%d2,12
80009ad4:	42 32       	add %d2,%d3
80009ad6:	60 22       	mov.a %a2,%d2
80009ad8:	d9 22 30 20 	lea %a2,[%a2]176
80009adc:	b9 22 00 00 	ld.hu %d2,[%a2]0
80009ae0:	df 02 0f 80 	jne %d2,0,80009afe <IfxGeth_Eth_configureDMA+0x306>
80009ae4:	19 e3 d0 df 	ld.w %d3,[%a14]-176
80009ae8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009aec:	53 c2 20 20 	mul %d2,%d2,12
80009af0:	42 32       	add %d2,%d3
80009af2:	60 22       	mov.a %a2,%d2
80009af4:	d9 22 34 20 	lea %a2,[%a2]180
80009af8:	54 22       	ld.w %d2,[%a2]
80009afa:	df 12 97 80 	jne %d2,1,80009c28 <IfxGeth_Eth_configureDMA+0x430>
        {
            IfxGeth_dma_enableInterrupt(geth->gethSFR, dmaConfig->txInterrupt[channelIndex].channelId, IfxGeth_DmaInterruptFlag_transmitInterrupt);
80009afe:	99 e2 d4 df 	ld.a %a2,[%a14]-172
80009b02:	54 23       	ld.w %d3,[%a2]
80009b04:	19 e4 d0 df 	ld.w %d4,[%a14]-176
80009b08:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009b0c:	53 c2 20 20 	mul %d2,%d2,12
80009b10:	42 42       	add %d2,%d4
80009b12:	60 22       	mov.a %a2,%d2
80009b14:	d9 22 2c 20 	lea %a2,[%a2]172
80009b18:	54 22       	ld.w %d2,[%a2]
80009b1a:	59 e3 cc ef 	st.w [%a14]-116,%d3
80009b1e:	59 e2 c8 ef 	st.w [%a14]-120,%d2
80009b22:	82 02       	mov %d2,0
80009b24:	59 e2 c4 ef 	st.w [%a14]-124,%d2
    uint32 value = (1 << flag);
80009b28:	82 13       	mov %d3,1
80009b2a:	19 e2 c4 ef 	ld.w %d2,[%a14]-124
80009b2e:	0f 23 00 20 	sh %d2,%d3,%d2
80009b32:	59 e2 c0 ef 	st.w [%a14]-128,%d2
    gethSFR->DMA_CH[channelId].INTERRUPT_ENABLE.U |= value;
80009b36:	19 e3 cc ef 	ld.w %d3,[%a14]-116
80009b3a:	19 e2 c8 ef 	ld.w %d2,[%a14]-120
80009b3e:	06 72       	sh %d2,7
80009b40:	42 32       	add %d2,%d3
80009b42:	60 22       	mov.a %a2,%d2
80009b44:	d9 22 34 41 	lea %a2,[%a2]4404
80009b48:	54 23       	ld.w %d3,[%a2]
80009b4a:	19 e2 c0 ef 	ld.w %d2,[%a14]-128
80009b4e:	a6 32       	or %d2,%d3
80009b50:	19 e4 cc ef 	ld.w %d4,[%a14]-116
80009b54:	19 e3 c8 ef 	ld.w %d3,[%a14]-120
80009b58:	06 73       	sh %d3,7
80009b5a:	42 43       	add %d3,%d4
80009b5c:	60 32       	mov.a %a2,%d3
80009b5e:	d9 22 34 41 	lea %a2,[%a2]4404
80009b62:	74 22       	st.w [%a2],%d2
}
80009b64:	00 00       	nop 

            volatile Ifx_SRC_SRCR *srcSFR;
            srcSFR = IfxGeth_getSrcPointer(geth->gethSFR, (IfxGeth_ServiceRequest)((uint32)IfxGeth_ServiceRequest_2 + (uint32)dmaConfig->txInterrupt[channelIndex].channelId));
80009b66:	99 e2 d4 df 	ld.a %a2,[%a14]-172
80009b6a:	54 23       	ld.w %d3,[%a2]
80009b6c:	19 e4 d0 df 	ld.w %d4,[%a14]-176
80009b70:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009b74:	53 c2 20 20 	mul %d2,%d2,12
80009b78:	42 42       	add %d2,%d4
80009b7a:	60 22       	mov.a %a2,%d2
80009b7c:	d9 22 2c 20 	lea %a2,[%a2]172
80009b80:	54 22       	ld.w %d2,[%a2]
80009b82:	c2 22       	add %d2,2
80009b84:	02 24       	mov %d4,%d2
80009b86:	60 34       	mov.a %a4,%d3
80009b88:	6d ff ee f7 	call 80008b64 <IfxGeth_getSrcPointer>
80009b8c:	b5 e2 ec ff 	st.a [%a14]-20,%a2
            IfxSrc_init(srcSFR, dmaConfig->txInterrupt[channelIndex].provider, dmaConfig->txInterrupt[channelIndex].priority);
80009b90:	19 e3 d0 df 	ld.w %d3,[%a14]-176
80009b94:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009b98:	53 c2 20 20 	mul %d2,%d2,12
80009b9c:	42 32       	add %d2,%d3
80009b9e:	60 22       	mov.a %a2,%d2
80009ba0:	d9 22 34 20 	lea %a2,[%a2]180
80009ba4:	54 23       	ld.w %d3,[%a2]
80009ba6:	19 e4 d0 df 	ld.w %d4,[%a14]-176
80009baa:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009bae:	53 c2 20 20 	mul %d2,%d2,12
80009bb2:	42 42       	add %d2,%d4
80009bb4:	60 22       	mov.a %a2,%d2
80009bb6:	d9 22 30 20 	lea %a2,[%a2]176
80009bba:	b9 22 00 00 	ld.hu %d2,[%a2]0
80009bbe:	19 e4 ec ff 	ld.w %d4,[%a14]-20
80009bc2:	59 e4 dc ef 	st.w [%a14]-100,%d4
80009bc6:	59 e3 d8 ef 	st.w [%a14]-104,%d3
80009bca:	f9 e2 d6 ef 	st.h [%a14]-106,%d2
    src->B.SRPN = priority;
80009bce:	c9 e2 d6 ef 	ld.h %d2,[%a14]-106
80009bd2:	8f f2 0f 31 	and %d3,%d2,255
80009bd6:	99 e2 dc ef 	ld.a %a2,[%a14]-100
80009bda:	54 22       	ld.w %d2,[%a2]
80009bdc:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80009be0:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80009be2:	19 e2 d8 ef 	ld.w %d2,[%a14]-104
80009be6:	8f 72 00 21 	and %d2,%d2,7
80009bea:	8f f2 0f 31 	and %d3,%d2,255
80009bee:	99 e2 dc ef 	ld.a %a2,[%a14]-100
80009bf2:	54 22       	ld.w %d2,[%a2]
80009bf4:	37 32 83 25 	insert %d2,%d2,%d3,11,3
80009bf8:	74 22       	st.w [%a2],%d2
80009bfa:	19 e2 dc ef 	ld.w %d2,[%a14]-100
80009bfe:	59 e2 d0 ef 	st.w [%a14]-112,%d2
    src->B.CLRR = 1;
80009c02:	99 e2 d0 ef 	ld.a %a2,[%a14]-112
80009c06:	54 22       	ld.w %d2,[%a2]
80009c08:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80009c0c:	74 22       	st.w [%a2],%d2
}
80009c0e:	00 00       	nop 
}
80009c10:	00 00       	nop 
80009c12:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80009c16:	59 e2 e0 ef 	st.w [%a14]-96,%d2
    src->B.SRE = 1;
80009c1a:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
80009c1e:	54 22       	ld.w %d2,[%a2]
80009c20:	b7 12 01 25 	insert %d2,%d2,1,10,1
80009c24:	74 22       	st.w [%a2],%d2
}
80009c26:	00 00       	nop 
            IfxSrc_enable(srcSFR);
        }

        /* Receive interrupts */
        if ((dmaConfig->rxInterrupt[channelIndex].priority > 0) || (dmaConfig->rxInterrupt[channelIndex].provider == IfxSrc_Tos_dma))
80009c28:	19 e3 d0 df 	ld.w %d3,[%a14]-176
80009c2c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009c30:	53 c2 20 20 	mul %d2,%d2,12
80009c34:	42 32       	add %d2,%d3
80009c36:	60 22       	mov.a %a2,%d2
80009c38:	d9 22 20 30 	lea %a2,[%a2]224
80009c3c:	b9 22 00 00 	ld.hu %d2,[%a2]0
80009c40:	df 02 0f 80 	jne %d2,0,80009c5e <IfxGeth_Eth_configureDMA+0x466>
80009c44:	19 e3 d0 df 	ld.w %d3,[%a14]-176
80009c48:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009c4c:	53 c2 20 20 	mul %d2,%d2,12
80009c50:	42 32       	add %d2,%d3
80009c52:	60 22       	mov.a %a2,%d2
80009c54:	d9 22 24 30 	lea %a2,[%a2]228
80009c58:	54 22       	ld.w %d2,[%a2]
80009c5a:	df 12 97 80 	jne %d2,1,80009d88 <IfxGeth_Eth_configureDMA+0x590>
        {
            IfxGeth_dma_enableInterrupt(geth->gethSFR, dmaConfig->rxInterrupt[channelIndex].channelId, IfxGeth_DmaInterruptFlag_receiveInterrupt);
80009c5e:	99 e2 d4 df 	ld.a %a2,[%a14]-172
80009c62:	54 23       	ld.w %d3,[%a2]
80009c64:	19 e4 d0 df 	ld.w %d4,[%a14]-176
80009c68:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009c6c:	53 c2 20 20 	mul %d2,%d2,12
80009c70:	42 42       	add %d2,%d4
80009c72:	60 22       	mov.a %a2,%d2
80009c74:	d9 22 1c 30 	lea %a2,[%a2]220
80009c78:	54 22       	ld.w %d2,[%a2]
80009c7a:	59 e3 e8 df 	st.w [%a14]-152,%d3
80009c7e:	59 e2 e4 df 	st.w [%a14]-156,%d2
80009c82:	82 62       	mov %d2,6
80009c84:	59 e2 e0 df 	st.w [%a14]-160,%d2
    uint32 value = (1 << flag);
80009c88:	82 13       	mov %d3,1
80009c8a:	19 e2 e0 df 	ld.w %d2,[%a14]-160
80009c8e:	0f 23 00 20 	sh %d2,%d3,%d2
80009c92:	59 e2 dc df 	st.w [%a14]-164,%d2
    gethSFR->DMA_CH[channelId].INTERRUPT_ENABLE.U |= value;
80009c96:	19 e3 e8 df 	ld.w %d3,[%a14]-152
80009c9a:	19 e2 e4 df 	ld.w %d2,[%a14]-156
80009c9e:	06 72       	sh %d2,7
80009ca0:	42 32       	add %d2,%d3
80009ca2:	60 22       	mov.a %a2,%d2
80009ca4:	d9 22 34 41 	lea %a2,[%a2]4404
80009ca8:	54 23       	ld.w %d3,[%a2]
80009caa:	19 e2 dc df 	ld.w %d2,[%a14]-164
80009cae:	a6 32       	or %d2,%d3
80009cb0:	19 e4 e8 df 	ld.w %d4,[%a14]-152
80009cb4:	19 e3 e4 df 	ld.w %d3,[%a14]-156
80009cb8:	06 73       	sh %d3,7
80009cba:	42 43       	add %d3,%d4
80009cbc:	60 32       	mov.a %a2,%d3
80009cbe:	d9 22 34 41 	lea %a2,[%a2]4404
80009cc2:	74 22       	st.w [%a2],%d2
}
80009cc4:	00 00       	nop 

            volatile Ifx_SRC_SRCR *srcSFR;
            srcSFR = IfxGeth_getSrcPointer(geth->gethSFR, (IfxGeth_ServiceRequest)((uint32)IfxGeth_ServiceRequest_6 + (uint32)dmaConfig->rxInterrupt[channelIndex].channelId));
80009cc6:	99 e2 d4 df 	ld.a %a2,[%a14]-172
80009cca:	54 23       	ld.w %d3,[%a2]
80009ccc:	19 e4 d0 df 	ld.w %d4,[%a14]-176
80009cd0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009cd4:	53 c2 20 20 	mul %d2,%d2,12
80009cd8:	42 42       	add %d2,%d4
80009cda:	60 22       	mov.a %a2,%d2
80009cdc:	d9 22 1c 30 	lea %a2,[%a2]220
80009ce0:	54 22       	ld.w %d2,[%a2]
80009ce2:	c2 62       	add %d2,6
80009ce4:	02 24       	mov %d4,%d2
80009ce6:	60 34       	mov.a %a4,%d3
80009ce8:	6d ff 3e f7 	call 80008b64 <IfxGeth_getSrcPointer>
80009cec:	b5 e2 e8 ff 	st.a [%a14]-24,%a2
            IfxSrc_init(srcSFR, dmaConfig->rxInterrupt[channelIndex].provider, dmaConfig->rxInterrupt[channelIndex].priority);
80009cf0:	19 e3 d0 df 	ld.w %d3,[%a14]-176
80009cf4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009cf8:	53 c2 20 20 	mul %d2,%d2,12
80009cfc:	42 32       	add %d2,%d3
80009cfe:	60 22       	mov.a %a2,%d2
80009d00:	d9 22 24 30 	lea %a2,[%a2]228
80009d04:	54 23       	ld.w %d3,[%a2]
80009d06:	19 e4 d0 df 	ld.w %d4,[%a14]-176
80009d0a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009d0e:	53 c2 20 20 	mul %d2,%d2,12
80009d12:	42 42       	add %d2,%d4
80009d14:	60 22       	mov.a %a2,%d2
80009d16:	d9 22 20 30 	lea %a2,[%a2]224
80009d1a:	b9 22 00 00 	ld.hu %d2,[%a2]0
80009d1e:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
80009d22:	59 e4 f8 df 	st.w [%a14]-136,%d4
80009d26:	59 e3 f4 df 	st.w [%a14]-140,%d3
80009d2a:	f9 e2 f2 df 	st.h [%a14]-142,%d2
    src->B.SRPN = priority;
80009d2e:	c9 e2 f2 df 	ld.h %d2,[%a14]-142
80009d32:	8f f2 0f 31 	and %d3,%d2,255
80009d36:	99 e2 f8 df 	ld.a %a2,[%a14]-136
80009d3a:	54 22       	ld.w %d2,[%a2]
80009d3c:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80009d40:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80009d42:	19 e2 f4 df 	ld.w %d2,[%a14]-140
80009d46:	8f 72 00 21 	and %d2,%d2,7
80009d4a:	8f f2 0f 31 	and %d3,%d2,255
80009d4e:	99 e2 f8 df 	ld.a %a2,[%a14]-136
80009d52:	54 22       	ld.w %d2,[%a2]
80009d54:	37 32 83 25 	insert %d2,%d2,%d3,11,3
80009d58:	74 22       	st.w [%a2],%d2
80009d5a:	19 e2 f8 df 	ld.w %d2,[%a14]-136
80009d5e:	59 e2 ec df 	st.w [%a14]-148,%d2
    src->B.CLRR = 1;
80009d62:	99 e2 ec df 	ld.a %a2,[%a14]-148
80009d66:	54 22       	ld.w %d2,[%a2]
80009d68:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80009d6c:	74 22       	st.w [%a2],%d2
}
80009d6e:	00 00       	nop 
}
80009d70:	00 00       	nop 
80009d72:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80009d76:	59 e2 fc df 	st.w [%a14]-132,%d2
    src->B.SRE = 1;
80009d7a:	99 e2 fc df 	ld.a %a2,[%a14]-132
80009d7e:	54 22       	ld.w %d2,[%a2]
80009d80:	b7 12 01 25 	insert %d2,%d2,1,10,1
80009d84:	74 22       	st.w [%a2],%d2
}
80009d86:	00 00       	nop 
    for (channelIndex = 0; channelIndex < numOfChannels; channelIndex++)
80009d88:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009d8c:	c2 12       	add %d2,1
80009d8e:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80009d92:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80009d96:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80009d9a:	3f 23 79 fe 	jlt.u %d3,%d2,80009a8c <IfxGeth_Eth_configureDMA+0x294>
            IfxSrc_enable(srcSFR);
        }
    }
}
80009d9e:	00 00       	nop 
80009da0:	00 00       	nop 
80009da2:	00 90       	ret 

80009da4 <IfxGeth_Eth_configureMTL>:


void IfxGeth_Eth_configureMTL(IfxGeth_Eth *geth, IfxGeth_Eth_MtlConfig *mtlConfig)
{
80009da4:	40 ae       	mov.aa %a14,%sp
80009da6:	20 60       	sub.a %sp,96
80009da8:	b5 e4 e4 ef 	st.a [%a14]-92,%a4
80009dac:	b5 e5 e0 ef 	st.a [%a14]-96,%a5
    uint32 txQueueIndex, rxQueueIndex, queueIndex;
    uint32 numOfQueues = (mtlConfig->numOfTxQueues >= mtlConfig->numOfRxQueues) ? mtlConfig->numOfTxQueues : mtlConfig->numOfRxQueues;
80009db0:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
80009db4:	54 23       	ld.w %d3,[%a2]
80009db6:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
80009dba:	d9 22 08 00 	lea %a2,[%a2]8
80009dbe:	54 22       	ld.w %d2,[%a2]
80009dc0:	0b 23 b0 21 	max.u %d2,%d3,%d2
80009dc4:	59 e2 f0 ff 	st.w [%a14]-16,%d2

    /* clear all flags */
    for (queueIndex = 0; queueIndex < numOfQueues; queueIndex++)
80009dc8:	82 02       	mov %d2,0
80009dca:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80009dce:	1d 00 0f 00 	j 80009dec <IfxGeth_Eth_configureMTL+0x48>
    {
        IfxGeth_mtl_clearAllInterruptFlags(geth->gethSFR, (IfxGeth_MtlQueue)queueIndex);
80009dd2:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009dd6:	54 22       	ld.w %d2,[%a2]
80009dd8:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
80009ddc:	60 24       	mov.a %a4,%d2
80009dde:	6d ff 71 f7 	call 80008cc0 <IfxGeth_mtl_clearAllInterruptFlags>
    for (queueIndex = 0; queueIndex < numOfQueues; queueIndex++)
80009de2:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80009de6:	c2 12       	add %d2,1
80009de8:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80009dec:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80009df0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80009df4:	3f 23 ef ff 	jlt.u %d3,%d2,80009dd2 <IfxGeth_Eth_configureMTL+0x2e>
    }

    /* TX Queue(s) configuration */
    if (mtlConfig->numOfTxQueues > 1)
80009df8:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
80009dfc:	54 22       	ld.w %d2,[%a2]
80009dfe:	bf 22 1e 80 	jlt.u %d2,2,80009e3a <IfxGeth_Eth_configureMTL+0x96>
    {
        IfxGeth_mtl_setTxSchedulingAlgorithm(geth->gethSFR, mtlConfig->txSchedulingAlgorithm);
80009e02:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009e06:	54 23       	ld.w %d3,[%a2]
80009e08:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
80009e0c:	b0 42       	add.a %a2,4
80009e0e:	54 22       	ld.w %d2,[%a2]
80009e10:	59 e3 e8 ff 	st.w [%a14]-24,%d3
80009e14:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    gethSFR->MTL_OPERATION_MODE.B.SCHALG = schedulingAlgorithm;
80009e18:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80009e1c:	8f 32 00 21 	and %d2,%d2,3
80009e20:	8f f2 0f 31 	and %d3,%d2,255
80009e24:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80009e28:	d9 23 c0 00 	lea %a3,[%a2]3072
80009e2c:	54 32       	ld.w %d2,[%a3]
80009e2e:	37 32 82 22 	insert %d2,%d2,%d3,5,2
80009e32:	d9 22 c0 00 	lea %a2,[%a2]3072
80009e36:	74 22       	st.w [%a2],%d2
}
80009e38:	00 00       	nop 
    }

    for (txQueueIndex = 0; txQueueIndex < mtlConfig->numOfTxQueues; txQueueIndex++)
80009e3a:	82 02       	mov %d2,0
80009e3c:	59 e2 fc ff 	st.w [%a14]-4,%d2
80009e40:	1d 00 4d 00 	j 80009eda <IfxGeth_Eth_configureMTL+0x136>
    {
        IfxGeth_mtl_setTxQueueSize(geth->gethSFR, (IfxGeth_TxMtlQueue)txQueueIndex, mtlConfig->txQueue[txQueueIndex].txQueueSize);
80009e44:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009e48:	54 23       	ld.w %d3,[%a2]
80009e4a:	19 e4 e0 ef 	ld.w %d4,[%a14]-96
80009e4e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80009e52:	53 c2 20 20 	mul %d2,%d2,12
80009e56:	42 42       	add %d2,%d4
80009e58:	60 22       	mov.a %a2,%d2
80009e5a:	d9 22 14 00 	lea %a2,[%a2]20
80009e5e:	54 22       	ld.w %d2,[%a2]
80009e60:	02 25       	mov %d5,%d2
80009e62:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80009e66:	60 34       	mov.a %a4,%d3
80009e68:	6d ff bc fa 	call 800093e0 <IfxGeth_mtl_setTxQueueSize>
        IfxGeth_mtl_setTxStoreAndForward(geth->gethSFR, (IfxGeth_TxMtlQueue)txQueueIndex, mtlConfig->txQueue[txQueueIndex].storeAndForward);
80009e6c:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009e70:	54 23       	ld.w %d3,[%a2]
80009e72:	19 e4 e0 ef 	ld.w %d4,[%a14]-96
80009e76:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80009e7a:	53 c2 20 20 	mul %d2,%d2,12
80009e7e:	42 42       	add %d2,%d4
80009e80:	60 22       	mov.a %a2,%d2
80009e82:	d9 22 10 00 	lea %a2,[%a2]16
80009e86:	14 22       	ld.bu %d2,[%a2]
80009e88:	02 25       	mov %d5,%d2
80009e8a:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80009e8e:	60 34       	mov.a %a4,%d3
80009e90:	6d ff 0e fb 	call 800094ac <IfxGeth_mtl_setTxStoreAndForward>
        IfxGeth_mtl_enableTxQueue(geth->gethSFR, (IfxGeth_TxMtlQueue)txQueueIndex);
80009e94:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009e98:	54 22       	ld.w %d2,[%a2]
80009e9a:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80009e9e:	60 24       	mov.a %a4,%d2
80009ea0:	6d ff 56 f8 	call 80008f4c <IfxGeth_mtl_enableTxQueue>

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
80009ea4:	19 e3 e0 ef 	ld.w %d3,[%a14]-96
80009ea8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80009eac:	53 c2 20 20 	mul %d2,%d2,12
80009eb0:	42 32       	add %d2,%d3
80009eb2:	60 22       	mov.a %a2,%d2
80009eb4:	d9 22 18 00 	lea %a2,[%a2]24
80009eb8:	14 22       	ld.bu %d2,[%a2]
80009eba:	df 02 0b 00 	jeq %d2,0,80009ed0 <IfxGeth_Eth_configureMTL+0x12c>
        {
            IfxGeth_mtl_enableInterrupt(geth->gethSFR, (IfxGeth_MtlQueue)txQueueIndex, IfxGeth_MtlInterruptFlag_txQueueUnderflow);
80009ebe:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009ec2:	54 22       	ld.w %d2,[%a2]
80009ec4:	82 05       	mov %d5,0
80009ec6:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80009eca:	60 24       	mov.a %a4,%d2
80009ecc:	6d ff c8 f7 	call 80008e5c <IfxGeth_mtl_enableInterrupt>
    for (txQueueIndex = 0; txQueueIndex < mtlConfig->numOfTxQueues; txQueueIndex++)
80009ed0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80009ed4:	c2 12       	add %d2,1
80009ed6:	59 e2 fc ff 	st.w [%a14]-4,%d2
80009eda:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
80009ede:	54 22       	ld.w %d2,[%a2]
80009ee0:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80009ee4:	3f 23 b0 ff 	jlt.u %d3,%d2,80009e44 <IfxGeth_Eth_configureMTL+0xa0>
        }
    }

    /* RX Queue(s) configuration */
    if (mtlConfig->numOfRxQueues > 1)
80009ee8:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
80009eec:	d9 22 08 00 	lea %a2,[%a2]8
80009ef0:	54 22       	ld.w %d2,[%a2]
80009ef2:	bf 22 1f 80 	jlt.u %d2,2,80009f30 <IfxGeth_Eth_configureMTL+0x18c>
    {
        IfxGeth_mtl_setRxArbitrationAlgorithm(geth->gethSFR, mtlConfig->rxArbitrationAlgorithm);
80009ef6:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009efa:	54 23       	ld.w %d3,[%a2]
80009efc:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
80009f00:	d9 22 0c 00 	lea %a2,[%a2]12
80009f04:	54 22       	ld.w %d2,[%a2]
80009f06:	59 e3 e0 ff 	st.w [%a14]-32,%d3
80009f0a:	59 e2 dc ff 	st.w [%a14]-36,%d2
    gethSFR->MTL_OPERATION_MODE.B.RAA = arbitrationAlgorithm;
80009f0e:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80009f12:	8f 12 00 21 	and %d2,%d2,1
80009f16:	8f f2 0f 31 	and %d3,%d2,255
80009f1a:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80009f1e:	d9 23 c0 00 	lea %a3,[%a2]3072
80009f22:	54 32       	ld.w %d2,[%a3]
80009f24:	67 32 02 20 	ins.t %d2,%d2,2,%d3,0
80009f28:	d9 22 c0 00 	lea %a2,[%a2]3072
80009f2c:	74 22       	st.w [%a2],%d2
}
80009f2e:	00 00       	nop 
    }

    for (rxQueueIndex = 0; rxQueueIndex < mtlConfig->numOfRxQueues; rxQueueIndex++)
80009f30:	82 02       	mov %d2,0
80009f32:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80009f36:	1d 00 e0 00 	j 8000a0f6 <IfxGeth_Eth_configureMTL+0x352>
    {
        IfxGeth_mtl_setRxQueueSize(geth->gethSFR, (IfxGeth_RxMtlQueue)rxQueueIndex, mtlConfig->rxQueue[rxQueueIndex].rxQueueSize);
80009f3a:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009f3e:	54 23       	ld.w %d3,[%a2]
80009f40:	19 e4 e0 ef 	ld.w %d4,[%a14]-96
80009f44:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009f48:	53 42 21 20 	mul %d2,%d2,20
80009f4c:	42 42       	add %d2,%d4
80009f4e:	60 22       	mov.a %a2,%d2
80009f50:	d9 22 04 10 	lea %a2,[%a2]68
80009f54:	54 22       	ld.w %d2,[%a2]
80009f56:	02 25       	mov %d5,%d2
80009f58:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
80009f5c:	60 34       	mov.a %a4,%d3
80009f5e:	6d ff 77 f9 	call 8000924c <IfxGeth_mtl_setRxQueueSize>
        IfxGeth_mtl_setRxStoreAndForward(geth->gethSFR, (IfxGeth_RxMtlQueue)rxQueueIndex, mtlConfig->rxQueue[rxQueueIndex].storeAndForward);
80009f62:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009f66:	54 23       	ld.w %d3,[%a2]
80009f68:	19 e4 e0 ef 	ld.w %d4,[%a14]-96
80009f6c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009f70:	53 42 21 20 	mul %d2,%d2,20
80009f74:	42 42       	add %d2,%d4
80009f76:	60 22       	mov.a %a2,%d2
80009f78:	d9 22 00 10 	lea %a2,[%a2]64
80009f7c:	14 22       	ld.bu %d2,[%a2]
80009f7e:	02 25       	mov %d5,%d2
80009f80:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
80009f84:	60 34       	mov.a %a4,%d3
80009f86:	6d ff c9 f9 	call 80009318 <IfxGeth_mtl_setRxStoreAndForward>
        IfxGeth_mtl_setRxForwardErrorPacket(geth->gethSFR, (IfxGeth_RxMtlQueue)rxQueueIndex, mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket);
80009f8a:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009f8e:	54 23       	ld.w %d3,[%a2]
80009f90:	19 e4 e0 ef 	ld.w %d4,[%a14]-96
80009f94:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009f98:	53 42 21 20 	mul %d2,%d2,20
80009f9c:	42 42       	add %d2,%d4
80009f9e:	60 22       	mov.a %a2,%d2
80009fa0:	d9 22 08 10 	lea %a2,[%a2]72
80009fa4:	14 22       	ld.bu %d2,[%a2]
80009fa6:	02 25       	mov %d5,%d2
80009fa8:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
80009fac:	60 34       	mov.a %a4,%d3
80009fae:	6d ff 87 f8 	call 800090bc <IfxGeth_mtl_setRxForwardErrorPacket>
        IfxGeth_mtl_setRxForwardUndersizedGoodPacket(geth->gethSFR, (IfxGeth_RxMtlQueue)rxQueueIndex, mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket);
80009fb2:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009fb6:	54 23       	ld.w %d3,[%a2]
80009fb8:	19 e4 e0 ef 	ld.w %d4,[%a14]-96
80009fbc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009fc0:	53 42 21 20 	mul %d2,%d2,20
80009fc4:	42 42       	add %d2,%d4
80009fc6:	60 22       	mov.a %a2,%d2
80009fc8:	d9 22 09 10 	lea %a2,[%a2]73
80009fcc:	14 22       	ld.bu %d2,[%a2]
80009fce:	02 25       	mov %d5,%d2
80009fd0:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
80009fd4:	60 34       	mov.a %a4,%d3
80009fd6:	6d ff d7 f8 	call 80009184 <IfxGeth_mtl_setRxForwardUndersizedGoodPacket>

        if (mtlConfig->rxQueue[rxQueueIndex].daBasedDmaChannelEnabled != 0)
80009fda:	19 e3 e0 ef 	ld.w %d3,[%a14]-96
80009fde:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80009fe2:	53 42 21 20 	mul %d2,%d2,20
80009fe6:	42 32       	add %d2,%d3
80009fe8:	60 22       	mov.a %a2,%d2
80009fea:	d9 22 0a 10 	lea %a2,[%a2]74
80009fee:	14 22       	ld.bu %d2,[%a2]
80009ff0:	df 02 23 00 	jeq %d2,0,8000a036 <IfxGeth_Eth_configureMTL+0x292>
        {
            IfxGeth_mtl_setRxQueueForDaBasedDmaChannel(geth->gethSFR, (IfxGeth_RxMtlQueue)rxQueueIndex, TRUE);
80009ff4:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
80009ff8:	54 22       	ld.w %d2,[%a2]
80009ffa:	59 e2 d8 ff 	st.w [%a14]-40,%d2
80009ffe:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000a002:	59 e2 d4 ff 	st.w [%a14]-44,%d2
8000a006:	82 12       	mov %d2,1
8000a008:	e9 e2 d3 ff 	st.b [%a14]-45,%d2
    gethSFR->MTL_RXQ_DMA_MAP0.U |= (enabled << ((queueId * 8) + 4));
8000a00c:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000a010:	d9 22 f0 00 	lea %a2,[%a2]3120
8000a014:	54 23       	ld.w %d3,[%a2]
8000a016:	39 e2 d3 ff 	ld.bu %d2,[%a14]-45
8000a01a:	19 e4 d4 ff 	ld.w %d4,[%a14]-44
8000a01e:	06 34       	sh %d4,3
8000a020:	c2 44       	add %d4,4
8000a022:	0f 42 00 20 	sh %d2,%d2,%d4
8000a026:	a6 32       	or %d2,%d3
8000a028:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000a02c:	d9 22 f0 00 	lea %a2,[%a2]3120
8000a030:	74 22       	st.w [%a2],%d2
}
8000a032:	1d 00 2b 00 	j 8000a088 <IfxGeth_Eth_configureMTL+0x2e4>
        }
        else
        {
            IfxGeth_mtl_setRxQueueDmaChannelMapping(geth->gethSFR, (IfxGeth_RxMtlQueue)rxQueueIndex, mtlConfig->rxQueue[rxQueueIndex].rxDmaChannelMap);
8000a036:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000a03a:	54 23       	ld.w %d3,[%a2]
8000a03c:	19 e4 e0 ef 	ld.w %d4,[%a14]-96
8000a040:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000a044:	53 42 21 20 	mul %d2,%d2,20
8000a048:	42 42       	add %d2,%d4
8000a04a:	60 22       	mov.a %a2,%d2
8000a04c:	d9 22 0c 10 	lea %a2,[%a2]76
8000a050:	54 22       	ld.w %d2,[%a2]
8000a052:	59 e3 cc ff 	st.w [%a14]-52,%d3
8000a056:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000a05a:	59 e3 c8 ff 	st.w [%a14]-56,%d3
8000a05e:	59 e2 c4 ff 	st.w [%a14]-60,%d2
    gethSFR->MTL_RXQ_DMA_MAP0.U |= (dmaChannel << (queueId * 8));
8000a062:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000a066:	d9 22 f0 00 	lea %a2,[%a2]3120
8000a06a:	54 23       	ld.w %d3,[%a2]
8000a06c:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000a070:	06 32       	sh %d2,3
8000a072:	19 e4 c4 ff 	ld.w %d4,[%a14]-60
8000a076:	0f 24 00 20 	sh %d2,%d4,%d2
8000a07a:	a6 32       	or %d2,%d3
8000a07c:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000a080:	d9 22 f0 00 	lea %a2,[%a2]3120
8000a084:	74 22       	st.w [%a2],%d2
}
8000a086:	00 00       	nop 
        }

        IfxGeth_mtl_enableRxQueue(geth->gethSFR, (IfxGeth_RxMtlQueue)rxQueueIndex);
8000a088:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000a08c:	54 22       	ld.w %d2,[%a2]
8000a08e:	59 e2 c0 ff 	st.w [%a14]-64,%d2
8000a092:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000a096:	59 e2 fc ef 	st.w [%a14]-68,%d2
    gethSFR->MAC_RXQ_CTRL0.U |= (2 << (queueId * 2));
8000a09a:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
8000a09e:	d9 22 20 20 	lea %a2,[%a2]160
8000a0a2:	54 23       	ld.w %d3,[%a2]
8000a0a4:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000a0a8:	06 12       	sh %d2,1
8000a0aa:	82 24       	mov %d4,2
8000a0ac:	0f 24 00 20 	sh %d2,%d4,%d2
8000a0b0:	a6 32       	or %d2,%d3
8000a0b2:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
8000a0b6:	d9 22 20 20 	lea %a2,[%a2]160
8000a0ba:	74 22       	st.w [%a2],%d2
}
8000a0bc:	00 00       	nop 

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
8000a0be:	19 e3 e0 ef 	ld.w %d3,[%a14]-96
8000a0c2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000a0c6:	53 42 21 20 	mul %d2,%d2,20
8000a0ca:	42 32       	add %d2,%d3
8000a0cc:	60 22       	mov.a %a2,%d2
8000a0ce:	d9 22 10 10 	lea %a2,[%a2]80
8000a0d2:	14 22       	ld.bu %d2,[%a2]
8000a0d4:	df 02 0c 00 	jeq %d2,0,8000a0ec <IfxGeth_Eth_configureMTL+0x348>
        {
            IfxGeth_mtl_enableInterrupt(geth->gethSFR, (IfxGeth_MtlQueue)rxQueueIndex, IfxGeth_MtlInterruptFlag_rxQueueOverflow);
8000a0d8:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000a0dc:	54 22       	ld.w %d2,[%a2]
8000a0de:	3b 00 01 50 	mov %d5,16
8000a0e2:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
8000a0e6:	60 24       	mov.a %a4,%d2
8000a0e8:	6d ff ba f6 	call 80008e5c <IfxGeth_mtl_enableInterrupt>
    for (rxQueueIndex = 0; rxQueueIndex < mtlConfig->numOfRxQueues; rxQueueIndex++)
8000a0ec:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000a0f0:	c2 12       	add %d2,1
8000a0f2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000a0f6:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000a0fa:	d9 22 08 00 	lea %a2,[%a2]8
8000a0fe:	54 22       	ld.w %d2,[%a2]
8000a100:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000a104:	3f 23 1b ff 	jlt.u %d3,%d2,80009f3a <IfxGeth_Eth_configureMTL+0x196>
        }
    }

    if (mtlConfig->interrupt.priority > 0)
8000a108:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000a10c:	b9 22 14 20 	ld.hu %d2,[%a2]148
8000a110:	df 02 4e 00 	jeq %d2,0,8000a1ac <IfxGeth_Eth_configureMTL+0x408>
    {
        volatile Ifx_SRC_SRCR *srcSFR;
        srcSFR = IfxGeth_getSrcPointer(geth->gethSFR, mtlConfig->interrupt.serviceRequest);
8000a114:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000a118:	54 22       	ld.w %d2,[%a2]
8000a11a:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000a11e:	d9 22 10 20 	lea %a2,[%a2]144
8000a122:	54 23       	ld.w %d3,[%a2]
8000a124:	02 34       	mov %d4,%d3
8000a126:	60 24       	mov.a %a4,%d2
8000a128:	6d ff 1e f5 	call 80008b64 <IfxGeth_getSrcPointer>
8000a12c:	b5 e2 ec ff 	st.a [%a14]-20,%a2
        IfxSrc_init(srcSFR, mtlConfig->interrupt.provider, mtlConfig->interrupt.priority);
8000a130:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000a134:	d9 22 18 20 	lea %a2,[%a2]152
8000a138:	54 23       	ld.w %d3,[%a2]
8000a13a:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000a13e:	b9 22 14 20 	ld.hu %d2,[%a2]148
8000a142:	19 e4 ec ff 	ld.w %d4,[%a14]-20
8000a146:	59 e4 f4 ef 	st.w [%a14]-76,%d4
8000a14a:	59 e3 f0 ef 	st.w [%a14]-80,%d3
8000a14e:	f9 e2 ee ef 	st.h [%a14]-82,%d2
    src->B.SRPN = priority;
8000a152:	c9 e2 ee ef 	ld.h %d2,[%a14]-82
8000a156:	8f f2 0f 31 	and %d3,%d2,255
8000a15a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8000a15e:	54 22       	ld.w %d2,[%a2]
8000a160:	37 32 08 20 	insert %d2,%d2,%d3,0,8
8000a164:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000a166:	19 e2 f0 ef 	ld.w %d2,[%a14]-80
8000a16a:	8f 72 00 21 	and %d2,%d2,7
8000a16e:	8f f2 0f 31 	and %d3,%d2,255
8000a172:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8000a176:	54 22       	ld.w %d2,[%a2]
8000a178:	37 32 83 25 	insert %d2,%d2,%d3,11,3
8000a17c:	74 22       	st.w [%a2],%d2
8000a17e:	19 e2 f4 ef 	ld.w %d2,[%a14]-76
8000a182:	59 e2 e8 ef 	st.w [%a14]-88,%d2
    src->B.CLRR = 1;
8000a186:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
8000a18a:	54 22       	ld.w %d2,[%a2]
8000a18c:	b7 12 81 2c 	insert %d2,%d2,1,25,1
8000a190:	74 22       	st.w [%a2],%d2
}
8000a192:	00 00       	nop 
}
8000a194:	00 00       	nop 
8000a196:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000a19a:	59 e2 f8 ef 	st.w [%a14]-72,%d2
    src->B.SRE = 1;
8000a19e:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a1a2:	54 22       	ld.w %d2,[%a2]
8000a1a4:	b7 12 01 25 	insert %d2,%d2,1,10,1
8000a1a8:	74 22       	st.w [%a2],%d2
}
8000a1aa:	00 00       	nop 
        IfxSrc_enable(srcSFR);
    }
}
8000a1ac:	00 00       	nop 
8000a1ae:	00 90       	ret 

8000a1b0 <IfxGeth_Eth_configureMacCore>:


void IfxGeth_Eth_configureMacCore(IfxGeth_Eth *geth, IfxGeth_Eth_MacConfig *macConfig)
{
8000a1b0:	40 ae       	mov.aa %a14,%sp
8000a1b2:	20 40       	sub.a %sp,64
8000a1b4:	b5 e4 c4 ff 	st.a [%a14]-60,%a4
8000a1b8:	b5 e5 c0 ff 	st.a [%a14]-64,%a5
    /* MAC configuration */
    IfxGeth_mac_setDuplexMode(geth->gethSFR, macConfig->duplexMode);
8000a1bc:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a1c0:	54 23       	ld.w %d3,[%a2]
8000a1c2:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
8000a1c6:	54 22       	ld.w %d2,[%a2]
8000a1c8:	59 e3 cc ff 	st.w [%a14]-52,%d3
8000a1cc:	59 e2 c8 ff 	st.w [%a14]-56,%d2
    gethSFR->MAC_CONFIGURATION.B.DM = mode;
8000a1d0:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000a1d4:	8f 12 00 21 	and %d2,%d2,1
8000a1d8:	8f f2 0f 31 	and %d3,%d2,255
8000a1dc:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000a1e0:	54 22       	ld.w %d2,[%a2]
8000a1e2:	67 32 0d 20 	ins.t %d2,%d2,13,%d3,0
8000a1e6:	74 22       	st.w [%a2],%d2
}
8000a1e8:	00 00       	nop 
    IfxGeth_mac_setLineSpeed(geth->gethSFR, macConfig->lineSpeed);
8000a1ea:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a1ee:	54 22       	ld.w %d2,[%a2]
8000a1f0:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
8000a1f4:	b0 42       	add.a %a2,4
8000a1f6:	54 23       	ld.w %d3,[%a2]
8000a1f8:	02 34       	mov %d4,%d3
8000a1fa:	60 24       	mov.a %a4,%d2
8000a1fc:	6d ff c4 f4 	call 80008b84 <IfxGeth_mac_setLineSpeed>
    IfxGeth_mac_setPreambleLength(geth->gethSFR, IfxGeth_PreambleLength_7Bytes);
8000a200:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a204:	54 22       	ld.w %d2,[%a2]
8000a206:	59 e2 d4 ff 	st.w [%a14]-44,%d2
8000a20a:	82 02       	mov %d2,0
8000a20c:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    gethSFR->MAC_CONFIGURATION.B.PRELEN = length;
8000a210:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000a214:	8f 32 00 21 	and %d2,%d2,3
8000a218:	8f f2 0f 31 	and %d3,%d2,255
8000a21c:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
8000a220:	54 22       	ld.w %d2,[%a2]
8000a222:	37 32 02 21 	insert %d2,%d2,%d3,2,2
8000a226:	74 22       	st.w [%a2],%d2
}
8000a228:	00 00       	nop 

    IfxGeth_mac_setMaxPacketSize(geth->gethSFR, macConfig->maxPacketSize);
8000a22a:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a22e:	54 22       	ld.w %d2,[%a2]
8000a230:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
8000a234:	b9 23 12 00 	ld.hu %d3,[%a2]18
8000a238:	02 34       	mov %d4,%d3
8000a23a:	60 24       	mov.a %a4,%d2
8000a23c:	6d ff e4 f9 	call 80009604 <IfxGeth_mac_setMaxPacketSize>

    IfxGeth_mac_setCrcStripping(geth->gethSFR, FALSE, FALSE);
8000a240:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a244:	54 22       	ld.w %d2,[%a2]
8000a246:	59 e2 dc ff 	st.w [%a14]-36,%d2
8000a24a:	82 02       	mov %d2,0
8000a24c:	e9 e2 db ff 	st.b [%a14]-37,%d2
8000a250:	82 02       	mov %d2,0
8000a252:	e9 e2 da ff 	st.b [%a14]-38,%d2
    gethSFR->MAC_CONFIGURATION.B.ACS = ((acsEnabled == 1) ? 1 : 0);
8000a256:	39 e2 db ff 	ld.bu %d2,[%a14]-37
8000a25a:	8b 12 00 22 	eq %d2,%d2,1
8000a25e:	8f f2 0f 31 	and %d3,%d2,255
8000a262:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000a266:	54 22       	ld.w %d2,[%a2]
8000a268:	67 32 14 20 	ins.t %d2,%d2,20,%d3,0
8000a26c:	74 22       	st.w [%a2],%d2
    gethSFR->MAC_CONFIGURATION.B.CST = ((cstEnabled == 1) ? 1 : 0);
8000a26e:	39 e2 da ff 	ld.bu %d2,[%a14]-38
8000a272:	8b 12 00 22 	eq %d2,%d2,1
8000a276:	8f f2 0f 31 	and %d3,%d2,255
8000a27a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000a27e:	54 22       	ld.w %d2,[%a2]
8000a280:	67 32 15 20 	ins.t %d2,%d2,21,%d3,0
8000a284:	74 22       	st.w [%a2],%d2
}
8000a286:	00 00       	nop 
    IfxGeth_mac_setCrcChecking(geth->gethSFR, FALSE);
8000a288:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a28c:	54 22       	ld.w %d2,[%a2]
8000a28e:	59 e2 e4 ff 	st.w [%a14]-28,%d2
8000a292:	82 02       	mov %d2,0
8000a294:	e9 e2 e3 ff 	st.b [%a14]-29,%d2
    gethSFR->MAC_EXT_CONFIGURATION.B.DCRCC = ((enabled == 1) ? 0 : 1);
8000a298:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
8000a29c:	8b 12 20 22 	ne %d2,%d2,1
8000a2a0:	8f f2 0f 31 	and %d3,%d2,255
8000a2a4:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000a2a8:	d9 23 04 00 	lea %a3,[%a2]4
8000a2ac:	54 32       	ld.w %d2,[%a3]
8000a2ae:	67 32 10 20 	ins.t %d2,%d2,16,%d3,0
8000a2b2:	b0 42       	add.a %a2,4
8000a2b4:	74 22       	st.w [%a2],%d2
}
8000a2b6:	00 00       	nop 

    IfxGeth_mac_setLoopbackMode(geth->gethSFR, macConfig->loopbackMode);
8000a2b8:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a2bc:	54 23       	ld.w %d3,[%a2]
8000a2be:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
8000a2c2:	d9 22 08 00 	lea %a2,[%a2]8
8000a2c6:	54 22       	ld.w %d2,[%a2]
8000a2c8:	59 e3 ec ff 	st.w [%a14]-20,%d3
8000a2cc:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    gethSFR->MAC_CONFIGURATION.B.LM = mode;
8000a2d0:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000a2d4:	8f 12 00 21 	and %d2,%d2,1
8000a2d8:	8f f2 0f 31 	and %d3,%d2,255
8000a2dc:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000a2e0:	54 22       	ld.w %d2,[%a2]
8000a2e2:	67 32 0c 20 	ins.t %d2,%d2,12,%d3,0
8000a2e6:	74 22       	st.w [%a2],%d2
}
8000a2e8:	00 00       	nop 

    /* packet Filter Configuration */
    IfxGeth_mac_setPromiscuousMode(geth->gethSFR, FALSE);
8000a2ea:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a2ee:	54 22       	ld.w %d2,[%a2]
8000a2f0:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000a2f4:	82 02       	mov %d2,0
8000a2f6:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
    gethSFR->MAC_PACKET_FILTER.B.PR = ((enabled == 1) ? 1 : 0);
8000a2fa:	39 e2 f3 ff 	ld.bu %d2,[%a14]-13
8000a2fe:	8b 12 00 22 	eq %d2,%d2,1
8000a302:	8f f2 0f 31 	and %d3,%d2,255
8000a306:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000a30a:	d9 23 08 00 	lea %a3,[%a2]8
8000a30e:	54 32       	ld.w %d2,[%a3]
8000a310:	67 32 00 20 	ins.t %d2,%d2,0,%d3,0
8000a314:	d9 22 08 00 	lea %a2,[%a2]8
8000a318:	74 22       	st.w [%a2],%d2
}
8000a31a:	00 00       	nop 
    IfxGeth_mac_setAllMulticastPassing(geth->gethSFR, FALSE);
8000a31c:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a320:	54 22       	ld.w %d2,[%a2]
8000a322:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000a326:	82 02       	mov %d2,0
8000a328:	e9 e2 fb ff 	st.b [%a14]-5,%d2
    gethSFR->MAC_PACKET_FILTER.B.PM = ((enabled == 1) ? 1 : 0);
8000a32c:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
8000a330:	8b 12 00 22 	eq %d2,%d2,1
8000a334:	8f f2 0f 31 	and %d3,%d2,255
8000a338:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000a33c:	d9 23 08 00 	lea %a3,[%a2]8
8000a340:	54 32       	ld.w %d2,[%a3]
8000a342:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
8000a346:	d9 22 08 00 	lea %a2,[%a2]8
8000a34a:	74 22       	st.w [%a2],%d2
}
8000a34c:	00 00       	nop 

    /* set MAC Address */
    IfxGeth_mac_setMacAddress(geth->gethSFR, macConfig->macAddress);
8000a34e:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a352:	54 23       	ld.w %d3,[%a2]
8000a354:	19 e2 c0 ff 	ld.w %d2,[%a14]-64
8000a358:	1b c2 00 20 	addi %d2,%d2,12
8000a35c:	60 25       	mov.a %a5,%d2
8000a35e:	60 34       	mov.a %a4,%d3
8000a360:	6d ff 70 f4 	call 80008c40 <IfxGeth_mac_setMacAddress>
}
8000a364:	00 00       	nop 
8000a366:	00 90       	ret 

8000a368 <IfxGeth_Eth_freeReceiveBuffer>:


void IfxGeth_Eth_freeReceiveBuffer(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
8000a368:	40 ae       	mov.aa %a14,%sp
8000a36a:	20 18       	sub.a %sp,24
8000a36c:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000a370:	59 e4 e8 ff 	st.w [%a14]-24,%d4
8000a374:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000a378:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000a37c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000a380:	59 e2 f4 ff 	st.w [%a14]-12,%d2
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE volatile IfxGeth_RxDescr *IfxGeth_Eth_getActualRxDescriptor(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
    return geth->rxChannel[channelId].rxDescrPtr;
8000a384:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000a388:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000a38c:	06 42       	sh %d2,4
8000a38e:	42 32       	add %d2,%d3
8000a390:	60 22       	mov.a %a2,%d2
8000a392:	d9 22 24 10 	lea %a2,[%a2]100
8000a396:	54 22       	ld.w %d2,[%a2]
    volatile IfxGeth_RxDescr *descr = IfxGeth_Eth_getActualRxDescriptor(geth, channelId);
8000a398:	59 e2 fc ff 	st.w [%a14]-4,%d2

    IfxGeth_RxDescr3          rdes3;
    rdes3.U        = 0;
8000a39c:	82 02       	mov %d2,0
8000a39e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    rdes3.R.BUF1V  = 1; /* buffer 1 valid */
8000a3a2:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000a3a6:	b7 12 01 2c 	insert %d2,%d2,1,24,1
8000a3aa:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    rdes3.R.BUF2V  = 0; /* buffer 2 not valid */
8000a3ae:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000a3b2:	7b 00 e0 3f 	movh %d3,65024
8000a3b6:	c2 f3       	add %d3,-1
8000a3b8:	26 32       	and %d2,%d3
8000a3ba:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    rdes3.R.IOC    = 1; /* interrupt enabled */
8000a3be:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000a3c2:	b7 12 01 2f 	insert %d2,%d2,1,30,1
8000a3c6:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    rdes3.R.OWN    = 1; /* owned by DMA */
8000a3ca:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000a3ce:	b7 12 81 2f 	insert %d2,%d2,1,31,1
8000a3d2:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    descr->RDES3.U = rdes3.U;
8000a3d6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000a3da:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000a3de:	d9 22 0c 00 	lea %a2,[%a2]12
8000a3e2:	74 22       	st.w [%a2],%d2
    IfxGeth_Eth_shuffleRxDescriptor(geth, channelId);
8000a3e4:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
8000a3e8:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8000a3ec:	6d 00 73 15 	call 8000ced2 <IfxGeth_Eth_shuffleRxDescriptor>
}
8000a3f0:	00 00       	nop 
8000a3f2:	00 90       	ret 

8000a3f4 <IfxGeth_Eth_getReceiveBuffer>:


void *IfxGeth_Eth_getReceiveBuffer(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
8000a3f4:	40 ae       	mov.aa %a14,%sp
8000a3f6:	20 28       	sub.a %sp,40
8000a3f8:	b5 e4 dc ff 	st.a [%a14]-36,%a4
8000a3fc:	59 e4 d8 ff 	st.w [%a14]-40,%d4
    void                     *result = 0;
8000a400:	82 02       	mov %d2,0
8000a402:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000a406:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000a40a:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000a40e:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000a412:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000a416:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000a41a:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000a41e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000a422:	59 e2 e8 ff 	st.w [%a14]-24,%d2
8000a426:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000a42a:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000a42e:	06 42       	sh %d2,4
8000a430:	42 32       	add %d2,%d3
8000a432:	60 22       	mov.a %a2,%d2
8000a434:	d9 22 24 10 	lea %a2,[%a2]100
8000a438:	d4 22       	ld.a %a2,[%a2]
}


IFX_INLINE boolean IfxGeth_Eth_isRxDataAvailable(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
    return IfxGeth_Eth_getActualRxDescriptor(geth, channelId)->RDES3.R.OWN == 0;
8000a43a:	d9 22 0c 00 	lea %a2,[%a2]12
8000a43e:	54 22       	ld.w %d2,[%a2]
8000a440:	37 02 e1 2f 	extr.u %d2,%d2,31,1
8000a444:	8f f2 0f 21 	and %d2,%d2,255
8000a448:	8f 12 80 21 	xor %d2,%d2,1
8000a44c:	8f f2 0f 21 	and %d2,%d2,255
    volatile IfxGeth_RxDescr *descr;

    if (IfxGeth_Eth_isRxDataAvailable(geth, channelId))
8000a450:	df 02 31 00 	jeq %d2,0,8000a4b2 <IfxGeth_Eth_getReceiveBuffer+0xbe>
    {
        geth->rxChannel[channelId].rxCount++;
8000a454:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8000a458:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000a45c:	06 42       	sh %d2,4
8000a45e:	42 32       	add %d2,%d3
8000a460:	60 22       	mov.a %a2,%d2
8000a462:	d9 22 28 10 	lea %a2,[%a2]104
8000a466:	54 22       	ld.w %d2,[%a2]
8000a468:	1b 12 00 30 	addi %d3,%d2,1
8000a46c:	19 e4 dc ff 	ld.w %d4,[%a14]-36
8000a470:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000a474:	06 42       	sh %d2,4
8000a476:	42 42       	add %d2,%d4
8000a478:	60 22       	mov.a %a2,%d2
8000a47a:	d9 22 28 10 	lea %a2,[%a2]104
8000a47e:	74 23       	st.w [%a2],%d3
8000a480:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000a484:	59 e2 e4 ff 	st.w [%a14]-28,%d2
8000a488:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000a48c:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    return geth->rxChannel[channelId].rxDescrPtr;
8000a490:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8000a494:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000a498:	06 42       	sh %d2,4
8000a49a:	42 32       	add %d2,%d3
8000a49c:	60 22       	mov.a %a2,%d2
8000a49e:	d9 22 24 10 	lea %a2,[%a2]100
8000a4a2:	54 22       	ld.w %d2,[%a2]
        descr  = IfxGeth_Eth_getActualRxDescriptor(geth, channelId);
8000a4a4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        result = (void *)(descr->RDES0.U);
8000a4a8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000a4ac:	54 22       	ld.w %d2,[%a2]
8000a4ae:	59 e2 fc ff 	st.w [%a14]-4,%d2
    }

    IfxGeth_Eth_wakeupReceiver(geth, channelId);
8000a4b2:	19 e4 d8 ff 	ld.w %d4,[%a14]-40
8000a4b6:	99 e4 dc ff 	ld.a %a4,[%a14]-36
8000a4ba:	6d 00 d6 16 	call 8000d266 <IfxGeth_Eth_wakeupReceiver>

    return result;
8000a4be:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8000a4c2:	60 22       	mov.a %a2,%d2
8000a4c4:	00 90       	ret 

8000a4c6 <IfxGeth_Eth_getTransmitBuffer>:


void *IfxGeth_Eth_getTransmitBuffer(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
8000a4c6:	40 ae       	mov.aa %a14,%sp
8000a4c8:	20 18       	sub.a %sp,24
8000a4ca:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000a4ce:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    void                     *buffer = NULL_PTR;
8000a4d2:	82 02       	mov %d2,0
8000a4d4:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000a4d8:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000a4dc:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000a4e0:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000a4e4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return geth->txChannel[channelId].txDescrPtr;
8000a4e8:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000a4ec:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000a4f0:	c2 12       	add %d2,1
8000a4f2:	53 42 21 20 	mul %d2,%d2,20
8000a4f6:	60 32       	mov.a %a2,%d3
8000a4f8:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000a4fc:	54 22       	ld.w %d2,[%a2]
    volatile IfxGeth_TxDescr *descr  = IfxGeth_Eth_getActualTxDescriptor(geth, channelId);
8000a4fe:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    // check descriptor / buffer is free.
    if (descr->TDES3.R.OWN == 0)
8000a502:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000a506:	d9 22 0c 00 	lea %a2,[%a2]12
8000a50a:	54 22       	ld.w %d2,[%a2]
8000a50c:	37 02 e1 2f 	extr.u %d2,%d2,31,1
8000a510:	8f f2 0f 21 	and %d2,%d2,255
8000a514:	df 02 07 80 	jne %d2,0,8000a522 <IfxGeth_Eth_getTransmitBuffer+0x5c>
    {
        buffer = ((void *)descr->TDES0.U);
8000a518:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000a51c:	54 22       	ld.w %d2,[%a2]
8000a51e:	59 e2 fc ff 	st.w [%a14]-4,%d2
    }

    return buffer;
8000a522:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8000a526:	60 22       	mov.a %a2,%d2
8000a528:	00 90       	ret 

8000a52a <IfxGeth_Eth_initModule>:


void IfxGeth_Eth_initModule(IfxGeth_Eth *geth, IfxGeth_Eth_Config *config)
{
8000a52a:	40 ae       	mov.aa %a14,%sp
8000a52c:	20 48       	sub.a %sp,72
8000a52e:	b5 e4 fc ef 	st.a [%a14]-68,%a4
8000a532:	b5 e5 f8 ef 	st.a [%a14]-72,%a5
    Ifx_GETH *gethSFR = config->gethSFR;
8000a536:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a53a:	54 22       	ld.w %d2,[%a2]
8000a53c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    geth->gethSFR = gethSFR;
8000a540:	99 e2 fc ef 	ld.a %a2,[%a14]-68
8000a544:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000a548:	74 22       	st.w [%a2],%d2

    /* Enable Module */
    IfxGeth_enableModule(gethSFR);
8000a54a:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000a54e:	6d ff cf f2 	call 80008aec <IfxGeth_enableModule>

    /* Set up the pins */
    if (config->phyInterfaceMode == IfxGeth_PhyInterfaceMode_rmii)
8000a552:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a556:	b0 42       	add.a %a2,4
8000a558:	54 22       	ld.w %d2,[%a2]
8000a55a:	df 42 1f 80 	jne %d2,4,8000a598 <IfxGeth_Eth_initModule+0x6e>
    {
        if (config->pins.rmiiPins != NULL_PTR)
8000a55e:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a562:	d9 22 08 00 	lea %a2,[%a2]8
8000a566:	54 22       	ld.w %d2,[%a2]
8000a568:	df 02 56 00 	jeq %d2,0,8000a614 <IfxGeth_Eth_initModule+0xea>
        {
            IfxGeth_Eth_setupRmiiOutputPins(geth, config->pins.rmiiPins);
8000a56c:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a570:	d9 22 08 00 	lea %a2,[%a2]8
8000a574:	54 22       	ld.w %d2,[%a2]
8000a576:	60 25       	mov.a %a5,%d2
8000a578:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a57c:	6d 00 84 13 	call 8000cc84 <IfxGeth_Eth_setupRmiiOutputPins>
            IfxGeth_Eth_setupRmiiInputPins(geth, config->pins.rmiiPins);
8000a580:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a584:	d9 22 08 00 	lea %a2,[%a2]8
8000a588:	54 22       	ld.w %d2,[%a2]
8000a58a:	60 25       	mov.a %a5,%d2
8000a58c:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a590:	6d 00 14 12 	call 8000c9b8 <IfxGeth_Eth_setupRmiiInputPins>
8000a594:	1d 00 40 00 	j 8000a614 <IfxGeth_Eth_initModule+0xea>
        }
    }
    else if (config->phyInterfaceMode == IfxGeth_PhyInterfaceMode_rgmii)
8000a598:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a59c:	b0 42       	add.a %a2,4
8000a59e:	54 22       	ld.w %d2,[%a2]
8000a5a0:	df 12 1f 80 	jne %d2,1,8000a5de <IfxGeth_Eth_initModule+0xb4>
    {
        if (config->pins.rgmiiPins != NULL_PTR)
8000a5a4:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a5a8:	d9 22 0c 00 	lea %a2,[%a2]12
8000a5ac:	54 22       	ld.w %d2,[%a2]
8000a5ae:	df 02 33 00 	jeq %d2,0,8000a614 <IfxGeth_Eth_initModule+0xea>
        {
            IfxGeth_Eth_setupRgmiiOutputPins(geth, config->pins.rgmiiPins);
8000a5b2:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a5b6:	d9 22 0c 00 	lea %a2,[%a2]12
8000a5ba:	54 22       	ld.w %d2,[%a2]
8000a5bc:	60 25       	mov.a %a5,%d2
8000a5be:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a5c2:	6d 00 f2 0f 	call 8000c5a6 <IfxGeth_Eth_setupRgmiiOutputPins>
            IfxGeth_Eth_setupRgmiiInputPins(geth, config->pins.rgmiiPins);
8000a5c6:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a5ca:	d9 22 0c 00 	lea %a2,[%a2]12
8000a5ce:	54 22       	ld.w %d2,[%a2]
8000a5d0:	60 25       	mov.a %a5,%d2
8000a5d2:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a5d6:	6d 00 a3 0d 	call 8000c11c <IfxGeth_Eth_setupRgmiiInputPins>
8000a5da:	1d 00 1d 00 	j 8000a614 <IfxGeth_Eth_initModule+0xea>
        }
    }
    else
    {
        if (config->pins.miiPins != NULL_PTR)
8000a5de:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a5e2:	d9 22 10 00 	lea %a2,[%a2]16
8000a5e6:	54 22       	ld.w %d2,[%a2]
8000a5e8:	df 02 16 00 	jeq %d2,0,8000a614 <IfxGeth_Eth_initModule+0xea>
        {
            IfxGeth_Eth_setupMiiOutputPins(geth, config->pins.miiPins);
8000a5ec:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a5f0:	d9 22 10 00 	lea %a2,[%a2]16
8000a5f4:	54 22       	ld.w %d2,[%a2]
8000a5f6:	60 25       	mov.a %a5,%d2
8000a5f8:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a5fc:	6d 00 90 0b 	call 8000bd1c <IfxGeth_Eth_setupMiiOutputPins>
            IfxGeth_Eth_setupMiiInputPins(geth, config->pins.miiPins);
8000a600:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a604:	d9 22 10 00 	lea %a2,[%a2]16
8000a608:	54 22       	ld.w %d2,[%a2]
8000a60a:	60 25       	mov.a %a5,%d2
8000a60c:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a610:	6d 00 07 08 	call 8000b61e <IfxGeth_Eth_setupMiiInputPins>
        }
    }

    gethSFR->GPCTL.B.EPR = 0; /*GETH_TC.002*/
8000a614:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000a618:	d9 23 08 02 	lea %a3,[%a2]8200
8000a61c:	54 32       	ld.w %d2,[%a3]
8000a61e:	7b 00 e4 3f 	movh %d3,65088
8000a622:	c2 f3       	add %d3,-1
8000a624:	26 32       	and %d2,%d3
8000a626:	d9 22 08 02 	lea %a2,[%a2]8200
8000a62a:	74 22       	st.w [%a2],%d2
    gethSFR->SKEWCTL.U   = 0; /*GETH_TC.002*/
8000a62c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000a630:	82 02       	mov %d2,0
8000a632:	d9 22 00 12 	lea %a2,[%a2]8256
8000a636:	74 22       	st.w [%a2],%d2

    /* reset the Module */
    IfxGeth_resetModule(gethSFR);
8000a638:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000a63c:	6d ff 9c f7 	call 80009574 <IfxGeth_resetModule>
8000a640:	7b 00 00 2f 	movh %d2,61440
8000a644:	1b 02 00 21 	addi %d2,%d2,4096
8000a648:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000a64c:	3b 30 02 20 	mov %d2,35
8000a650:	59 e2 e8 ff 	st.w [%a14]-24,%d2
8000a654:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000a658:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return stm->TIM0.U;
8000a65c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000a660:	d9 22 10 00 	lea %a2,[%a2]16
8000a664:	54 22       	ld.w %d2,[%a2]
    beginTime = IfxStm_getLower(stm);
8000a666:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
8000a66a:	00 00       	nop 
8000a66c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000a670:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return stm->TIM0.U;
8000a674:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000a678:	d9 22 10 00 	lea %a2,[%a2]16
8000a67c:	54 23       	ld.w %d3,[%a2]
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
8000a67e:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000a682:	a2 23       	sub %d3,%d2
8000a684:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000a688:	3f 23 f2 ff 	jlt.u %d3,%d2,8000a66c <IfxGeth_Eth_initModule+0x142>
}
8000a68c:	00 00       	nop 

    IfxStm_waitTicks(&MODULE_STM0, 35); /*GETH_TC.002. Wait min 35 fSPB cycles after reset for RGMII*/

    /* select the Phy Interface Mode */
    IfxGeth_setPhyInterfaceMode(gethSFR, config->phyInterfaceMode);
8000a68e:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a692:	b0 42       	add.a %a2,4
8000a694:	54 22       	ld.w %d2,[%a2]
8000a696:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000a69a:	59 e3 f4 ff 	st.w [%a14]-12,%d3
8000a69e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    gethSFR->GPCTL.B.EPR = mode;
8000a6a2:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000a6a6:	8f 72 00 21 	and %d2,%d2,7
8000a6aa:	8f f2 0f 31 	and %d3,%d2,255
8000a6ae:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000a6b2:	d9 23 08 02 	lea %a3,[%a2]8200
8000a6b6:	54 32       	ld.w %d2,[%a3]
8000a6b8:	37 32 03 2b 	insert %d2,%d2,%d3,22,3
8000a6bc:	d9 22 08 02 	lea %a2,[%a2]8200
8000a6c0:	74 22       	st.w [%a2],%d2
}
8000a6c2:	00 00       	nop 

    if (config->phyInterfaceMode == IfxGeth_PhyInterfaceMode_rgmii)
8000a6c4:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a6c8:	b0 42       	add.a %a2,4
8000a6ca:	54 22       	ld.w %d2,[%a2]
8000a6cc:	df 12 26 80 	jne %d2,1,8000a718 <IfxGeth_Eth_initModule+0x1ee>
    {
        /*Skew Control is optional for RGMII and only applicable in RGMII mode*/
        gethSFR->SKEWCTL.B.TXCFG = config->rgmiiTxSkewControl;     /*GETH_TC.002*/
8000a6d0:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a6d4:	39 22 10 70 	ld.bu %d2,[%a2]464
8000a6d8:	8f f2 00 21 	and %d2,%d2,15
8000a6dc:	8f f2 0f 31 	and %d3,%d2,255
8000a6e0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000a6e4:	d9 23 00 12 	lea %a3,[%a2]8256
8000a6e8:	54 32       	ld.w %d2,[%a3]
8000a6ea:	37 32 04 20 	insert %d2,%d2,%d3,0,4
8000a6ee:	d9 22 00 12 	lea %a2,[%a2]8256
8000a6f2:	74 22       	st.w [%a2],%d2
        gethSFR->SKEWCTL.B.RXCFG = config->rgmiiRxSkewControl;     /*GETH_TC.002*/
8000a6f4:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000a6f8:	39 22 11 70 	ld.bu %d2,[%a2]465
8000a6fc:	8f f2 00 21 	and %d2,%d2,15
8000a700:	8f f2 0f 31 	and %d3,%d2,255
8000a704:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000a708:	d9 23 00 12 	lea %a3,[%a2]8256
8000a70c:	54 32       	ld.w %d2,[%a3]
8000a70e:	37 32 04 24 	insert %d2,%d2,%d3,8,4
8000a712:	d9 22 00 12 	lea %a2,[%a2]8256
8000a716:	74 22       	st.w [%a2],%d2
8000a718:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000a71c:	59 e2 c4 ff 	st.w [%a14]-60,%d2
    gethSFR->DMA_MODE.B.SWR = 1;
8000a720:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000a724:	d9 23 00 01 	lea %a3,[%a2]4096
8000a728:	54 32       	ld.w %d2,[%a3]
8000a72a:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000a72e:	d9 22 00 01 	lea %a2,[%a2]4096
8000a732:	74 22       	st.w [%a2],%d2
}
8000a734:	00 00       	nop 
8000a736:	7b 00 00 2f 	movh %d2,61440
8000a73a:	1b 02 00 21 	addi %d2,%d2,4096
8000a73e:	59 e2 d8 ff 	st.w [%a14]-40,%d2
8000a742:	82 42       	mov %d2,4
8000a744:	59 e2 d4 ff 	st.w [%a14]-44,%d2
8000a748:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000a74c:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    return stm->TIM0.U;
8000a750:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000a754:	d9 22 10 00 	lea %a2,[%a2]16
8000a758:	54 22       	ld.w %d2,[%a2]
    beginTime = IfxStm_getLower(stm);
8000a75a:	59 e2 cc ff 	st.w [%a14]-52,%d2
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
8000a75e:	00 00       	nop 
8000a760:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000a764:	59 e2 c8 ff 	st.w [%a14]-56,%d2
    return stm->TIM0.U;
8000a768:	99 e2 c8 ff 	ld.a %a2,[%a14]-56
8000a76c:	d9 22 10 00 	lea %a2,[%a2]16
8000a770:	54 23       	ld.w %d3,[%a2]
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
8000a772:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8000a776:	a2 23       	sub %d3,%d2
8000a778:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000a77c:	3f 23 f2 ff 	jlt.u %d3,%d2,8000a760 <IfxGeth_Eth_initModule+0x236>
}
8000a780:	00 00       	nop 

    IfxStm_waitTicks(&MODULE_STM0, 4); /*GETH_TC.002. Wait min 4 fSPB cycles after s/w reset*/

    /* wait until reset is finished or timeout. */
    {
        uint32 timeout = 0;
8000a782:	82 02       	mov %d2,0
8000a784:	59 e2 fc ff 	st.w [%a14]-4,%d2

        while ((IfxGeth_dma_isSoftwareResetDone(gethSFR) == 0) && (timeout < IFXGETH_MAX_TIMEOUT_VALUE))
8000a788:	1d 00 07 00 	j 8000a796 <IfxGeth_Eth_initModule+0x26c>
        {
            timeout++;
8000a78c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000a790:	c2 12       	add %d2,1
8000a792:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000a796:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000a79a:	59 e2 c0 ff 	st.w [%a14]-64,%d2
    return gethSFR->DMA_MODE.B.SWR == 0;
8000a79e:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
8000a7a2:	d9 22 00 01 	lea %a2,[%a2]4096
8000a7a6:	54 22       	ld.w %d2,[%a2]
8000a7a8:	37 02 61 20 	extr.u %d2,%d2,0,1
8000a7ac:	8f f2 0f 21 	and %d2,%d2,255
8000a7b0:	8f 12 80 21 	xor %d2,%d2,1
8000a7b4:	8f f2 0f 21 	and %d2,%d2,255
        while ((IfxGeth_dma_isSoftwareResetDone(gethSFR) == 0) && (timeout < IFXGETH_MAX_TIMEOUT_VALUE))
8000a7b8:	df 02 08 80 	jne %d2,0,8000a7c8 <IfxGeth_Eth_initModule+0x29e>
8000a7bc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000a7c0:	3b 80 3e 30 	mov %d3,1000
8000a7c4:	3f 32 e4 ff 	jlt.u %d2,%d3,8000a78c <IfxGeth_Eth_initModule+0x262>
        }
    }

    /* Configure MAC Core */
    IfxGeth_Eth_configureMacCore(geth, &config->mac);
8000a7c8:	19 e2 f8 ef 	ld.w %d2,[%a14]-72
8000a7cc:	1b 42 01 20 	addi %d2,%d2,20
8000a7d0:	60 25       	mov.a %a5,%d2
8000a7d2:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a7d6:	6d ff ed fc 	call 8000a1b0 <IfxGeth_Eth_configureMacCore>

    /* Configure MTL */
    IfxGeth_Eth_configureMTL(geth, &config->mtl);
8000a7da:	19 e2 f8 ef 	ld.w %d2,[%a14]-72
8000a7de:	1b 82 02 20 	addi %d2,%d2,40
8000a7e2:	60 25       	mov.a %a5,%d2
8000a7e4:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a7e8:	6d ff de fa 	call 80009da4 <IfxGeth_Eth_configureMTL>

    /* Configure DMA */
    IfxGeth_Eth_configureDMA(geth, &config->dma);
8000a7ec:	19 e2 f8 ef 	ld.w %d2,[%a14]-72
8000a7f0:	1b 42 0c 20 	addi %d2,%d2,196
8000a7f4:	60 25       	mov.a %a5,%d2
8000a7f6:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000a7fa:	6d ff ff f7 	call 800097f8 <IfxGeth_Eth_configureDMA>
}
8000a7fe:	00 00       	nop 
8000a800:	00 90       	ret 

8000a802 <IfxGeth_Eth_initModuleConfig>:


void IfxGeth_Eth_initModuleConfig(IfxGeth_Eth_Config *config, Ifx_GETH *gethSFR)
{
8000a802:	40 ae       	mov.aa %a14,%sp
8000a804:	d9 aa e0 8f 	lea %sp,[%sp]-480
8000a808:	b5 e4 e4 8f 	st.a [%a14]-476,%a4
8000a80c:	b5 e5 e0 8f 	st.a [%a14]-480,%a5
    IfxGeth_Index            gethIndex;
    gethIndex = IfxGeth_getIndex(gethSFR);
8000a810:	99 e4 e0 8f 	ld.a %a4,[%a14]-480
8000a814:	6d ff bb f7 	call 8000978a <IfxGeth_getIndex>
8000a818:	59 e2 fc ff 	st.w [%a14]-4,%d2
    const IfxGeth_Eth_Config defaultConfig = {
8000a81c:	82 02       	mov %d2,0
8000a81e:	59 e2 e8 8f 	st.w [%a14]-472,%d2
8000a822:	82 42       	mov %d2,4
8000a824:	59 e2 ec 8f 	st.w [%a14]-468,%d2
8000a828:	82 02       	mov %d2,0
8000a82a:	59 e2 f0 8f 	st.w [%a14]-464,%d2
8000a82e:	82 02       	mov %d2,0
8000a830:	59 e2 f4 8f 	st.w [%a14]-460,%d2
8000a834:	82 02       	mov %d2,0
8000a836:	59 e2 f8 8f 	st.w [%a14]-456,%d2
8000a83a:	82 12       	mov %d2,1
8000a83c:	59 e2 fc 8f 	st.w [%a14]-452,%d2
8000a840:	82 12       	mov %d2,1
8000a842:	59 e2 c0 9f 	st.w [%a14]-448,%d2
8000a846:	82 02       	mov %d2,0
8000a848:	59 e2 c4 9f 	st.w [%a14]-444,%d2
8000a84c:	82 02       	mov %d2,0
8000a84e:	59 e2 c8 9f 	st.w [%a14]-440,%d2
8000a852:	82 02       	mov %d2,0
8000a854:	f9 e2 cc 9f 	st.h [%a14]-436,%d2
8000a858:	3b e0 5e 20 	mov %d2,1518
8000a85c:	f9 e2 ce 9f 	st.h [%a14]-434,%d2
8000a860:	82 12       	mov %d2,1
8000a862:	59 e2 d0 9f 	st.w [%a14]-432,%d2
8000a866:	82 02       	mov %d2,0
8000a868:	59 e2 d4 9f 	st.w [%a14]-428,%d2
8000a86c:	82 12       	mov %d2,1
8000a86e:	59 e2 d8 9f 	st.w [%a14]-424,%d2
8000a872:	82 02       	mov %d2,0
8000a874:	59 e2 dc 9f 	st.w [%a14]-420,%d2
8000a878:	82 02       	mov %d2,0
8000a87a:	e9 e2 e0 9f 	st.b [%a14]-416,%d2
8000a87e:	82 02       	mov %d2,0
8000a880:	59 e2 e4 9f 	st.w [%a14]-412,%d2
8000a884:	82 02       	mov %d2,0
8000a886:	e9 e2 e8 9f 	st.b [%a14]-408,%d2
8000a88a:	82 02       	mov %d2,0
8000a88c:	e9 e2 ec 9f 	st.b [%a14]-404,%d2
8000a890:	82 02       	mov %d2,0
8000a892:	59 e2 f0 9f 	st.w [%a14]-400,%d2
8000a896:	82 02       	mov %d2,0
8000a898:	e9 e2 f4 9f 	st.b [%a14]-396,%d2
8000a89c:	82 02       	mov %d2,0
8000a89e:	e9 e2 f8 9f 	st.b [%a14]-392,%d2
8000a8a2:	82 02       	mov %d2,0
8000a8a4:	59 e2 fc 9f 	st.w [%a14]-388,%d2
8000a8a8:	82 02       	mov %d2,0
8000a8aa:	e9 e2 c0 af 	st.b [%a14]-384,%d2
8000a8ae:	82 02       	mov %d2,0
8000a8b0:	e9 e2 c4 af 	st.b [%a14]-380,%d2
8000a8b4:	82 02       	mov %d2,0
8000a8b6:	59 e2 c8 af 	st.w [%a14]-376,%d2
8000a8ba:	82 02       	mov %d2,0
8000a8bc:	e9 e2 cc af 	st.b [%a14]-372,%d2
8000a8c0:	82 02       	mov %d2,0
8000a8c2:	e9 e2 d0 af 	st.b [%a14]-368,%d2
8000a8c6:	82 02       	mov %d2,0
8000a8c8:	59 e2 d4 af 	st.w [%a14]-364,%d2
8000a8cc:	82 02       	mov %d2,0
8000a8ce:	e9 e2 d8 af 	st.b [%a14]-360,%d2
8000a8d2:	82 02       	mov %d2,0
8000a8d4:	e9 e2 d9 af 	st.b [%a14]-359,%d2
8000a8d8:	82 02       	mov %d2,0
8000a8da:	e9 e2 da af 	st.b [%a14]-358,%d2
8000a8de:	82 02       	mov %d2,0
8000a8e0:	59 e2 dc af 	st.w [%a14]-356,%d2
8000a8e4:	82 02       	mov %d2,0
8000a8e6:	e9 e2 e0 af 	st.b [%a14]-352,%d2
8000a8ea:	82 02       	mov %d2,0
8000a8ec:	e9 e2 e4 af 	st.b [%a14]-348,%d2
8000a8f0:	82 02       	mov %d2,0
8000a8f2:	59 e2 e8 af 	st.w [%a14]-344,%d2
8000a8f6:	82 02       	mov %d2,0
8000a8f8:	e9 e2 ec af 	st.b [%a14]-340,%d2
8000a8fc:	82 02       	mov %d2,0
8000a8fe:	e9 e2 ed af 	st.b [%a14]-339,%d2
8000a902:	82 02       	mov %d2,0
8000a904:	e9 e2 ee af 	st.b [%a14]-338,%d2
8000a908:	82 12       	mov %d2,1
8000a90a:	59 e2 f0 af 	st.w [%a14]-336,%d2
8000a90e:	82 02       	mov %d2,0
8000a910:	e9 e2 f4 af 	st.b [%a14]-332,%d2
8000a914:	82 02       	mov %d2,0
8000a916:	e9 e2 f8 af 	st.b [%a14]-328,%d2
8000a91a:	82 02       	mov %d2,0
8000a91c:	59 e2 fc af 	st.w [%a14]-324,%d2
8000a920:	82 02       	mov %d2,0
8000a922:	e9 e2 c0 bf 	st.b [%a14]-320,%d2
8000a926:	82 02       	mov %d2,0
8000a928:	e9 e2 c1 bf 	st.b [%a14]-319,%d2
8000a92c:	82 02       	mov %d2,0
8000a92e:	e9 e2 c2 bf 	st.b [%a14]-318,%d2
8000a932:	82 22       	mov %d2,2
8000a934:	59 e2 c4 bf 	st.w [%a14]-316,%d2
8000a938:	82 02       	mov %d2,0
8000a93a:	e9 e2 c8 bf 	st.b [%a14]-312,%d2
8000a93e:	82 02       	mov %d2,0
8000a940:	e9 e2 cc bf 	st.b [%a14]-308,%d2
8000a944:	82 02       	mov %d2,0
8000a946:	59 e2 d0 bf 	st.w [%a14]-304,%d2
8000a94a:	82 02       	mov %d2,0
8000a94c:	e9 e2 d4 bf 	st.b [%a14]-300,%d2
8000a950:	82 02       	mov %d2,0
8000a952:	e9 e2 d5 bf 	st.b [%a14]-299,%d2
8000a956:	82 02       	mov %d2,0
8000a958:	e9 e2 d6 bf 	st.b [%a14]-298,%d2
8000a95c:	82 32       	mov %d2,3
8000a95e:	59 e2 d8 bf 	st.w [%a14]-296,%d2
8000a962:	82 02       	mov %d2,0
8000a964:	e9 e2 dc bf 	st.b [%a14]-292,%d2
8000a968:	82 12       	mov %d2,1
8000a96a:	59 e2 e0 bf 	st.w [%a14]-288,%d2
8000a96e:	82 02       	mov %d2,0
8000a970:	f9 e2 e4 bf 	st.h [%a14]-284,%d2
8000a974:	82 02       	mov %d2,0
8000a976:	59 e2 e8 bf 	st.w [%a14]-280,%d2
8000a97a:	82 12       	mov %d2,1
8000a97c:	59 e2 ec bf 	st.w [%a14]-276,%d2
8000a980:	82 12       	mov %d2,1
8000a982:	59 e2 f0 bf 	st.w [%a14]-272,%d2
8000a986:	82 02       	mov %d2,0
8000a988:	e9 e2 f4 bf 	st.b [%a14]-268,%d2
8000a98c:	82 02       	mov %d2,0
8000a98e:	e9 e2 f5 bf 	st.b [%a14]-267,%d2
8000a992:	82 02       	mov %d2,0
8000a994:	e9 e2 f6 bf 	st.b [%a14]-266,%d2
8000a998:	82 02       	mov %d2,0
8000a99a:	59 e2 f8 bf 	st.w [%a14]-264,%d2
8000a99e:	82 02       	mov %d2,0
8000a9a0:	59 e2 fc bf 	st.w [%a14]-260,%d2
            .mixedBurstEnabled          = FALSE,
            .txChannel                  = {
                {
                    .channelId             = IfxGeth_TxDmaChannel_0,
                    .maxBurstLength        = IfxGeth_DmaBurstLength_0,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[gethIndex][0],
8000a9a4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000a9a8:	8f 92 00 20 	sh %d2,%d2,9
8000a9ac:	91 10 00 27 	movh.a %a2,28673
8000a9b0:	d9 22 c8 3a 	lea %a2,[%a2]-21304 <7000acc8 <IfxGeth_Eth_txDescrList>>
8000a9b4:	80 23       	mov.d %d3,%a2
8000a9b6:	42 32       	add %d2,%d3
    const IfxGeth_Eth_Config defaultConfig = {
8000a9b8:	59 e2 c0 cf 	st.w [%a14]-256,%d2
8000a9bc:	82 02       	mov %d2,0
8000a9be:	59 e2 c4 cf 	st.w [%a14]-252,%d2
8000a9c2:	3b 00 10 20 	mov %d2,256
8000a9c6:	f9 e2 c8 cf 	st.h [%a14]-248,%d2
8000a9ca:	82 02       	mov %d2,0
8000a9cc:	e9 e2 ca cf 	st.b [%a14]-246,%d2
8000a9d0:	82 12       	mov %d2,1
8000a9d2:	59 e2 cc cf 	st.w [%a14]-244,%d2
8000a9d6:	82 02       	mov %d2,0
8000a9d8:	59 e2 d0 cf 	st.w [%a14]-240,%d2
                },

                {
                    .channelId             = IfxGeth_TxDmaChannel_1,
                    .maxBurstLength        = IfxGeth_DmaBurstLength_0,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[gethIndex][1],
8000a9dc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000a9e0:	8f 92 00 20 	sh %d2,%d2,9
8000a9e4:	1b 02 08 20 	addi %d2,%d2,128
8000a9e8:	91 10 00 27 	movh.a %a2,28673
8000a9ec:	d9 22 c8 3a 	lea %a2,[%a2]-21304 <7000acc8 <IfxGeth_Eth_txDescrList>>
8000a9f0:	80 23       	mov.d %d3,%a2
8000a9f2:	42 32       	add %d2,%d3
    const IfxGeth_Eth_Config defaultConfig = {
8000a9f4:	59 e2 d4 cf 	st.w [%a14]-236,%d2
8000a9f8:	82 02       	mov %d2,0
8000a9fa:	59 e2 d8 cf 	st.w [%a14]-232,%d2
8000a9fe:	3b 00 10 20 	mov %d2,256
8000aa02:	f9 e2 dc cf 	st.h [%a14]-228,%d2
8000aa06:	82 02       	mov %d2,0
8000aa08:	e9 e2 de cf 	st.b [%a14]-226,%d2
8000aa0c:	82 22       	mov %d2,2
8000aa0e:	59 e2 e0 cf 	st.w [%a14]-224,%d2
8000aa12:	82 02       	mov %d2,0
8000aa14:	59 e2 e4 cf 	st.w [%a14]-220,%d2
                },

                {
                    .channelId             = IfxGeth_TxDmaChannel_2,
                    .maxBurstLength        = IfxGeth_DmaBurstLength_0,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[gethIndex][2],
8000aa18:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000aa1c:	8f 92 00 20 	sh %d2,%d2,9
8000aa20:	1b 02 10 20 	addi %d2,%d2,256
8000aa24:	91 10 00 27 	movh.a %a2,28673
8000aa28:	d9 22 c8 3a 	lea %a2,[%a2]-21304 <7000acc8 <IfxGeth_Eth_txDescrList>>
8000aa2c:	80 23       	mov.d %d3,%a2
8000aa2e:	42 32       	add %d2,%d3
    const IfxGeth_Eth_Config defaultConfig = {
8000aa30:	59 e2 e8 cf 	st.w [%a14]-216,%d2
8000aa34:	82 02       	mov %d2,0
8000aa36:	59 e2 ec cf 	st.w [%a14]-212,%d2
8000aa3a:	3b 00 10 20 	mov %d2,256
8000aa3e:	f9 e2 f0 cf 	st.h [%a14]-208,%d2
8000aa42:	82 02       	mov %d2,0
8000aa44:	e9 e2 f2 cf 	st.b [%a14]-206,%d2
8000aa48:	82 32       	mov %d2,3
8000aa4a:	59 e2 f4 cf 	st.w [%a14]-204,%d2
8000aa4e:	82 02       	mov %d2,0
8000aa50:	59 e2 f8 cf 	st.w [%a14]-200,%d2
                },

                {
                    .channelId             = IfxGeth_TxDmaChannel_3,
                    .maxBurstLength        = IfxGeth_DmaBurstLength_0,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[gethIndex][3],
8000aa54:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000aa58:	8f 92 00 20 	sh %d2,%d2,9
8000aa5c:	1b 02 18 20 	addi %d2,%d2,384
8000aa60:	91 10 00 27 	movh.a %a2,28673
8000aa64:	d9 22 c8 3a 	lea %a2,[%a2]-21304 <7000acc8 <IfxGeth_Eth_txDescrList>>
8000aa68:	80 23       	mov.d %d3,%a2
8000aa6a:	42 32       	add %d2,%d3
    const IfxGeth_Eth_Config defaultConfig = {
8000aa6c:	59 e2 fc cf 	st.w [%a14]-196,%d2
8000aa70:	82 02       	mov %d2,0
8000aa72:	59 e2 c0 df 	st.w [%a14]-192,%d2
8000aa76:	3b 00 10 20 	mov %d2,256
8000aa7a:	f9 e2 c4 df 	st.h [%a14]-188,%d2
8000aa7e:	82 02       	mov %d2,0
8000aa80:	e9 e2 c6 df 	st.b [%a14]-186,%d2
8000aa84:	82 02       	mov %d2,0
8000aa86:	59 e2 c8 df 	st.w [%a14]-184,%d2
8000aa8a:	82 02       	mov %d2,0
8000aa8c:	59 e2 cc df 	st.w [%a14]-180,%d2

            .rxChannel                                = {
                {
                    .channelId             = IfxGeth_RxDmaChannel_0,
                    .maxBurstLength        = IfxGeth_DmaBurstLength_0,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[gethIndex][0],
8000aa90:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000aa94:	8f 92 00 20 	sh %d2,%d2,9
8000aa98:	91 10 00 27 	movh.a %a2,28673
8000aa9c:	d9 22 88 ba 	lea %a2,[%a2]-21816 <7000aac8 <IfxGeth_Eth_rxDescrList>>
8000aaa0:	80 23       	mov.d %d3,%a2
8000aaa2:	42 32       	add %d2,%d3
    const IfxGeth_Eth_Config defaultConfig = {
8000aaa4:	59 e2 d0 df 	st.w [%a14]-176,%d2
8000aaa8:	82 02       	mov %d2,0
8000aaaa:	59 e2 d4 df 	st.w [%a14]-172,%d2
8000aaae:	3b 00 10 20 	mov %d2,256
8000aab2:	f9 e2 d8 df 	st.h [%a14]-168,%d2
8000aab6:	82 12       	mov %d2,1
8000aab8:	59 e2 dc df 	st.w [%a14]-164,%d2
8000aabc:	82 02       	mov %d2,0
8000aabe:	59 e2 e0 df 	st.w [%a14]-160,%d2
                },

                {
                    .channelId             = IfxGeth_RxDmaChannel_1,
                    .maxBurstLength        = IfxGeth_DmaBurstLength_0,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[gethIndex][1],
8000aac2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000aac6:	8f 92 00 20 	sh %d2,%d2,9
8000aaca:	1b 02 08 20 	addi %d2,%d2,128
8000aace:	91 10 00 27 	movh.a %a2,28673
8000aad2:	d9 22 88 ba 	lea %a2,[%a2]-21816 <7000aac8 <IfxGeth_Eth_rxDescrList>>
8000aad6:	80 23       	mov.d %d3,%a2
8000aad8:	42 32       	add %d2,%d3
    const IfxGeth_Eth_Config defaultConfig = {
8000aada:	59 e2 e4 df 	st.w [%a14]-156,%d2
8000aade:	82 02       	mov %d2,0
8000aae0:	59 e2 e8 df 	st.w [%a14]-152,%d2
8000aae4:	3b 00 10 20 	mov %d2,256
8000aae8:	f9 e2 ec df 	st.h [%a14]-148,%d2
8000aaec:	82 22       	mov %d2,2
8000aaee:	59 e2 f0 df 	st.w [%a14]-144,%d2
8000aaf2:	82 02       	mov %d2,0
8000aaf4:	59 e2 f4 df 	st.w [%a14]-140,%d2
                },

                {
                    .channelId             = IfxGeth_RxDmaChannel_2,
                    .maxBurstLength        = IfxGeth_DmaBurstLength_0,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[gethIndex][2],
8000aaf8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000aafc:	8f 92 00 20 	sh %d2,%d2,9
8000ab00:	1b 02 10 20 	addi %d2,%d2,256
8000ab04:	91 10 00 27 	movh.a %a2,28673
8000ab08:	d9 22 88 ba 	lea %a2,[%a2]-21816 <7000aac8 <IfxGeth_Eth_rxDescrList>>
8000ab0c:	80 23       	mov.d %d3,%a2
8000ab0e:	42 32       	add %d2,%d3
    const IfxGeth_Eth_Config defaultConfig = {
8000ab10:	59 e2 f8 df 	st.w [%a14]-136,%d2
8000ab14:	82 02       	mov %d2,0
8000ab16:	59 e2 fc df 	st.w [%a14]-132,%d2
8000ab1a:	3b 00 10 20 	mov %d2,256
8000ab1e:	f9 e2 c0 ef 	st.h [%a14]-128,%d2
8000ab22:	82 32       	mov %d2,3
8000ab24:	59 e2 c4 ef 	st.w [%a14]-124,%d2
8000ab28:	82 02       	mov %d2,0
8000ab2a:	59 e2 c8 ef 	st.w [%a14]-120,%d2
                },

                {
                    .channelId             = IfxGeth_RxDmaChannel_3,
                    .maxBurstLength        = IfxGeth_DmaBurstLength_0,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[gethIndex][3],
8000ab2e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000ab32:	8f 92 00 20 	sh %d2,%d2,9
8000ab36:	1b 02 18 20 	addi %d2,%d2,384
8000ab3a:	91 10 00 27 	movh.a %a2,28673
8000ab3e:	d9 22 88 ba 	lea %a2,[%a2]-21816 <7000aac8 <IfxGeth_Eth_rxDescrList>>
8000ab42:	80 23       	mov.d %d3,%a2
8000ab44:	42 32       	add %d2,%d3
    const IfxGeth_Eth_Config defaultConfig = {
8000ab46:	59 e2 cc ef 	st.w [%a14]-116,%d2
8000ab4a:	82 02       	mov %d2,0
8000ab4c:	59 e2 d0 ef 	st.w [%a14]-112,%d2
8000ab50:	3b 00 10 20 	mov %d2,256
8000ab54:	f9 e2 d4 ef 	st.h [%a14]-108,%d2
8000ab58:	82 02       	mov %d2,0
8000ab5a:	59 e2 d8 ef 	st.w [%a14]-104,%d2
8000ab5e:	82 02       	mov %d2,0
8000ab60:	f9 e2 dc ef 	st.h [%a14]-100,%d2
8000ab64:	82 02       	mov %d2,0
8000ab66:	59 e2 e0 ef 	st.w [%a14]-96,%d2
8000ab6a:	82 12       	mov %d2,1
8000ab6c:	59 e2 e4 ef 	st.w [%a14]-92,%d2
8000ab70:	82 02       	mov %d2,0
8000ab72:	f9 e2 e8 ef 	st.h [%a14]-88,%d2
8000ab76:	82 02       	mov %d2,0
8000ab78:	59 e2 ec ef 	st.w [%a14]-84,%d2
8000ab7c:	82 22       	mov %d2,2
8000ab7e:	59 e2 f0 ef 	st.w [%a14]-80,%d2
8000ab82:	82 02       	mov %d2,0
8000ab84:	f9 e2 f4 ef 	st.h [%a14]-76,%d2
8000ab88:	82 02       	mov %d2,0
8000ab8a:	59 e2 f8 ef 	st.w [%a14]-72,%d2
8000ab8e:	82 32       	mov %d2,3
8000ab90:	59 e2 fc ef 	st.w [%a14]-68,%d2
8000ab94:	82 02       	mov %d2,0
8000ab96:	f9 e2 c0 ff 	st.h [%a14]-64,%d2
8000ab9a:	82 02       	mov %d2,0
8000ab9c:	59 e2 c4 ff 	st.w [%a14]-60,%d2
8000aba0:	82 02       	mov %d2,0
8000aba2:	59 e2 c8 ff 	st.w [%a14]-56,%d2
8000aba6:	82 02       	mov %d2,0
8000aba8:	f9 e2 cc ff 	st.h [%a14]-52,%d2
8000abac:	82 02       	mov %d2,0
8000abae:	59 e2 d0 ff 	st.w [%a14]-48,%d2
8000abb2:	82 12       	mov %d2,1
8000abb4:	59 e2 d4 ff 	st.w [%a14]-44,%d2
8000abb8:	82 02       	mov %d2,0
8000abba:	f9 e2 d8 ff 	st.h [%a14]-40,%d2
8000abbe:	82 02       	mov %d2,0
8000abc0:	59 e2 dc ff 	st.w [%a14]-36,%d2
8000abc4:	82 22       	mov %d2,2
8000abc6:	59 e2 e0 ff 	st.w [%a14]-32,%d2
8000abca:	82 02       	mov %d2,0
8000abcc:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
8000abd0:	82 02       	mov %d2,0
8000abd2:	59 e2 e8 ff 	st.w [%a14]-24,%d2
8000abd6:	82 32       	mov %d2,3
8000abd8:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000abdc:	82 02       	mov %d2,0
8000abde:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
8000abe2:	82 02       	mov %d2,0
8000abe4:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000abe8:	82 02       	mov %d2,0
8000abea:	e9 e2 f8 ff 	st.b [%a14]-8,%d2
8000abee:	82 02       	mov %d2,0
8000abf0:	e9 e2 f9 ff 	st.b [%a14]-7,%d2
        .rgmiiTxSkewControl = 0,
        .rgmiiRxSkewControl = 0
    };

    /* Default Configuration */
    *config = defaultConfig;
8000abf4:	19 e2 e4 8f 	ld.w %d2,[%a14]-476
8000abf8:	60 23       	mov.a %a3,%d2
8000abfa:	d9 e2 e8 8f 	lea %a2,[%a14]-472
8000abfe:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac02:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac06:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac0a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac0e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac12:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac16:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac1a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac1e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac22:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac26:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac2a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac2e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac32:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac36:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac3a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac3e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac42:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac46:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac4a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac4e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac52:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac56:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac5a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac5e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac62:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac66:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac6a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac6e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac72:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac76:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac7a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac7e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac82:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac86:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac8a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac8e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac92:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac96:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ac9a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ac9e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000aca2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000aca6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acaa:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acae:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acb2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acb6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acba:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acbe:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acc2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acc6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acca:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acce:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acd2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acd6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acda:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acde:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ace2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ace6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acea:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acee:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acf2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acf6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000acfa:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000acfe:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad02:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad06:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad0a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad0e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad12:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad16:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad1a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad1e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad22:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad26:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad2a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad2e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad32:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad36:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad3a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad3e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad42:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad46:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad4a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad4e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad52:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad56:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad5a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad5e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad62:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad66:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad6a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad6e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad72:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad76:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad7a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad7e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad82:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad86:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad8a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad8e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad92:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad96:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ad9a:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ad9e:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000ada2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000ada6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000adaa:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000adae:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000adb2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000adb6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000adba:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000adbe:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000adc2:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000adc6:	09 24 48 01 	ld.d %e4,[%a2+]8 <70010008 <ram_heap+0x4f74>>
8000adca:	89 34 48 01 	st.d [%a3+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000adce:	44 24       	ld.w %d4,[%a2+]
8000add0:	64 34       	st.w [%a3+],%d4

    /* take over module pointer */
    config->gethSFR = gethSFR;
8000add2:	99 e2 e4 8f 	ld.a %a2,[%a14]-476 <70010008 <ram_heap+0x4f74>>
8000add6:	19 e2 e0 8f 	ld.w %d2,[%a14]-480 <70010008 <ram_heap+0x4f74>>
8000adda:	74 22       	st.w [%a2],%d2
}
8000addc:	00 00       	nop 
8000adde:	00 90       	ret 

8000ade0 <IfxGeth_Eth_initReceiveDescriptors>:


void IfxGeth_Eth_initReceiveDescriptors(IfxGeth_Eth *geth, IfxGeth_Eth_RxChannelConfig *config)
{
8000ade0:	40 ae       	mov.aa %a14,%sp
8000ade2:	20 60       	sub.a %sp,96
8000ade4:	b5 e4 e4 ef 	st.a [%a14]-92,%a4
8000ade8:	b5 e5 e0 ef 	st.a [%a14]-96,%a5
    int                       i;
    uint32                    buffer1StartAddress = (uint32)config->rxBuffer1StartAddress;
8000adec:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000adf0:	d9 22 0c 00 	lea %a2,[%a2]12
8000adf4:	54 22       	ld.w %d2,[%a2]
8000adf6:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    IfxGeth_RxDmaChannel      channelId           = config->channelId;
8000adfa:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000adfe:	54 22       	ld.w %d2,[%a2]
8000ae00:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    geth->rxChannel[channelId].channelId   = channelId;
8000ae04:	19 e3 e4 ef 	ld.w %d3,[%a14]-92
8000ae08:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000ae0c:	06 42       	sh %d2,4
8000ae0e:	42 32       	add %d2,%d3
8000ae10:	60 22       	mov.a %a2,%d2
8000ae12:	d9 22 1c 10 	lea %a2,[%a2]92
8000ae16:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000ae1a:	74 22       	st.w [%a2],%d2
    geth->rxChannel[channelId].rxDescrList = config->rxDescrList;
8000ae1c:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000ae20:	d9 22 08 00 	lea %a2,[%a2]8
8000ae24:	54 23       	ld.w %d3,[%a2]
8000ae26:	19 e4 e4 ef 	ld.w %d4,[%a14]-92
8000ae2a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000ae2e:	c2 62       	add %d2,6
8000ae30:	06 42       	sh %d2,4
8000ae32:	60 42       	mov.a %a2,%d4
8000ae34:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000ae38:	74 23       	st.w [%a2],%d3
8000ae3a:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
8000ae3e:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000ae42:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000ae46:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    return geth->rxChannel[channelId].rxDescrList->descr;
8000ae4a:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000ae4e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000ae52:	c2 62       	add %d2,6
8000ae54:	06 42       	sh %d2,4
8000ae56:	60 32       	mov.a %a2,%d3
8000ae58:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000ae5c:	54 22       	ld.w %d2,[%a2]

    volatile IfxGeth_RxDescr *descr = IfxGeth_Eth_getBaseRxDescriptor(geth, channelId);
8000ae5e:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    geth->rxChannel[channelId].rxDescrPtr = descr;
8000ae62:	19 e3 e4 ef 	ld.w %d3,[%a14]-92
8000ae66:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000ae6a:	06 42       	sh %d2,4
8000ae6c:	42 32       	add %d2,%d3
8000ae6e:	60 22       	mov.a %a2,%d2
8000ae70:	d9 22 24 10 	lea %a2,[%a2]100
8000ae74:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000ae78:	74 22       	st.w [%a2],%d2

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (config->rxBuffer1Size) % 4 == 0);

    /* Initialize descriptors in ring mode */
    for (i = 0; i < IFXGETH_MAX_RX_DESCRIPTORS; i++)
8000ae7a:	82 02       	mov %d2,0
8000ae7c:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000ae80:	1d 00 4c 00 	j 8000af18 <IfxGeth_Eth_initReceiveDescriptors+0x138>
    {
        descr->RDES0.U       = (uint32)(config->rxBuffer1Size * i) + buffer1StartAddress;
8000ae84:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000ae88:	b9 22 10 00 	ld.hu %d2,[%a2]16
8000ae8c:	02 23       	mov %d3,%d2
8000ae8e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000ae92:	e2 32       	mul %d2,%d3
8000ae94:	02 23       	mov %d3,%d2
8000ae96:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000ae9a:	42 32       	add %d2,%d3
8000ae9c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000aea0:	74 22       	st.w [%a2],%d2
        descr->RDES2.U       = 0; /* buffer2 not used */
8000aea2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000aea6:	82 02       	mov %d2,0
8000aea8:	d9 22 08 00 	lea %a2,[%a2]8
8000aeac:	74 22       	st.w [%a2],%d2

        descr->RDES3.R.BUF1V = 1; /* buffer 1 valid */
8000aeae:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000aeb2:	d9 23 0c 00 	lea %a3,[%a2]12
8000aeb6:	54 32       	ld.w %d2,[%a3]
8000aeb8:	b7 12 01 2c 	insert %d2,%d2,1,24,1
8000aebc:	d9 22 0c 00 	lea %a2,[%a2]12
8000aec0:	74 22       	st.w [%a2],%d2
        descr->RDES3.R.BUF2V = 0; /* buffer 2 not valid */
8000aec2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000aec6:	d9 23 0c 00 	lea %a3,[%a2]12
8000aeca:	54 32       	ld.w %d2,[%a3]
8000aecc:	7b 00 e0 3f 	movh %d3,65024
8000aed0:	c2 f3       	add %d3,-1
8000aed2:	26 32       	and %d2,%d3
8000aed4:	d9 22 0c 00 	lea %a2,[%a2]12
8000aed8:	74 22       	st.w [%a2],%d2
        descr->RDES3.R.IOC   = 1; /* interrupt enabled */
8000aeda:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000aede:	d9 23 0c 00 	lea %a3,[%a2]12
8000aee2:	54 32       	ld.w %d2,[%a3]
8000aee4:	b7 12 01 2f 	insert %d2,%d2,1,30,1
8000aee8:	d9 22 0c 00 	lea %a2,[%a2]12
8000aeec:	74 22       	st.w [%a2],%d2
        descr->RDES3.R.OWN   = 1; /* owned by DMA */
8000aeee:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000aef2:	d9 23 0c 00 	lea %a3,[%a2]12
8000aef6:	54 32       	ld.w %d2,[%a3]
8000aef8:	b7 12 81 2f 	insert %d2,%d2,1,31,1
8000aefc:	d9 22 0c 00 	lea %a2,[%a2]12
8000af00:	74 22       	st.w [%a2],%d2

        descr                = &descr[1];
8000af02:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000af06:	1b 02 01 20 	addi %d2,%d2,16
8000af0a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    for (i = 0; i < IFXGETH_MAX_RX_DESCRIPTORS; i++)
8000af0e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000af12:	c2 12       	add %d2,1
8000af14:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000af18:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000af1c:	8b 82 40 22 	lt %d2,%d2,8
8000af20:	df 02 b2 ff 	jne %d2,0,8000ae84 <IfxGeth_Eth_initReceiveDescriptors+0xa4>
8000af24:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
8000af28:	59 e2 ec ef 	st.w [%a14]-84,%d2
8000af2c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000af30:	59 e2 e8 ef 	st.w [%a14]-88,%d2
8000af34:	19 e3 ec ef 	ld.w %d3,[%a14]-84
8000af38:	19 e2 e8 ef 	ld.w %d2,[%a14]-88
8000af3c:	c2 62       	add %d2,6
8000af3e:	06 42       	sh %d2,4
8000af40:	60 32       	mov.a %a2,%d3
8000af42:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000af46:	54 22       	ld.w %d2,[%a2]
8000af48:	02 24       	mov %d4,%d2
    }

    /* rest the current pointer to base pointer in the handle */
    geth->rxChannel[channelId].rxDescrPtr = IfxGeth_Eth_getBaseRxDescriptor(geth, channelId);
8000af4a:	19 e3 e4 ef 	ld.w %d3,[%a14]-92
8000af4e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000af52:	06 42       	sh %d2,4
8000af54:	42 32       	add %d2,%d3
8000af56:	60 22       	mov.a %a2,%d2
8000af58:	d9 22 24 10 	lea %a2,[%a2]100
8000af5c:	74 24       	st.w [%a2],%d4

    /* set the buffer size */
    IfxGeth_dma_setRxBufferSize(geth->gethSFR, channelId, config->rxBuffer1Size);
8000af5e:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000af62:	54 23       	ld.w %d3,[%a2]
8000af64:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000af68:	b9 22 10 00 	ld.hu %d2,[%a2]16
8000af6c:	59 e3 f8 ef 	st.w [%a14]-72,%d3
8000af70:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8000af74:	59 e3 f4 ef 	st.w [%a14]-76,%d3
8000af78:	f9 e2 f2 ef 	st.h [%a14]-78,%d2
    gethSFR->DMA_CH[channel].RX_CONTROL.B.RBSZ_13_Y = (uint32)((size >> 2) & IFX_GETH_DMA_CH_RX_CONTROL_RBSZ_13_Y_MSK);
8000af7c:	b9 e2 f2 ef 	ld.hu %d2,[%a14]-78
8000af80:	06 e2       	sh %d2,-2
8000af82:	37 02 70 20 	extr.u %d2,%d2,0,16
8000af86:	02 23       	mov %d3,%d2
8000af88:	3b f0 ff 20 	mov %d2,4095
8000af8c:	26 32       	and %d2,%d3
8000af8e:	37 02 70 30 	extr.u %d3,%d2,0,16
8000af92:	19 e4 f8 ef 	ld.w %d4,[%a14]-72
8000af96:	19 e2 f4 ef 	ld.w %d2,[%a14]-76
8000af9a:	06 72       	sh %d2,7
8000af9c:	42 42       	add %d2,%d4
8000af9e:	60 22       	mov.a %a2,%d2
8000afa0:	d9 22 08 41 	lea %a2,[%a2]4360
8000afa4:	54 22       	ld.w %d2,[%a2]
8000afa6:	37 32 8c 21 	insert %d2,%d2,%d3,3,12
8000afaa:	74 22       	st.w [%a2],%d2
}
8000afac:	00 00       	nop 

    IfxGeth_dma_setRxDescriptorListAddress(geth->gethSFR, channelId, (uint32)IfxGeth_Eth_getBaseRxDescriptor(geth, channelId));
8000afae:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000afb2:	54 23       	ld.w %d3,[%a2]
8000afb4:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
8000afb8:	59 e2 c0 ff 	st.w [%a14]-64,%d2
8000afbc:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000afc0:	59 e2 fc ef 	st.w [%a14]-68,%d2
8000afc4:	19 e4 c0 ff 	ld.w %d4,[%a14]-64
8000afc8:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000afcc:	c2 62       	add %d2,6
8000afce:	06 42       	sh %d2,4
8000afd0:	60 42       	mov.a %a2,%d4
8000afd2:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000afd6:	54 22       	ld.w %d2,[%a2]
8000afd8:	02 24       	mov %d4,%d2
8000afda:	59 e3 cc ff 	st.w [%a14]-52,%d3
8000afde:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000afe2:	59 e2 c8 ff 	st.w [%a14]-56,%d2
8000afe6:	59 e4 c4 ff 	st.w [%a14]-60,%d4
    gethSFR->DMA_CH[channel].RXDESC_LIST_ADDRESS.U = (uint32)address;
8000afea:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000afee:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000aff2:	06 72       	sh %d2,7
8000aff4:	42 32       	add %d2,%d3
8000aff6:	60 22       	mov.a %a2,%d2
8000aff8:	d9 22 1c 41 	lea %a2,[%a2]4380
8000affc:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000b000:	74 22       	st.w [%a2],%d2
}
8000b002:	00 00       	nop 
    IfxGeth_dma_setRxDescriptorTailPointer(geth->gethSFR, channelId, (uint32)descr);
8000b004:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000b008:	54 23       	ld.w %d3,[%a2]
8000b00a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000b00e:	59 e3 d8 ff 	st.w [%a14]-40,%d3
8000b012:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8000b016:	59 e3 d4 ff 	st.w [%a14]-44,%d3
8000b01a:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    gethSFR->DMA_CH[channel].RXDESC_TAIL_POINTER.U = address;
8000b01e:	19 e3 d8 ff 	ld.w %d3,[%a14]-40
8000b022:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000b026:	06 72       	sh %d2,7
8000b028:	42 32       	add %d2,%d3
8000b02a:	60 22       	mov.a %a2,%d2
8000b02c:	d9 22 28 41 	lea %a2,[%a2]4392
8000b030:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000b034:	74 22       	st.w [%a2],%d2
}
8000b036:	00 00       	nop 
    IfxGeth_dma_setRxDescriptorRingLength(geth->gethSFR, channelId, (IFXGETH_MAX_RX_DESCRIPTORS - 1));
8000b038:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000b03c:	54 22       	ld.w %d2,[%a2]
8000b03e:	59 e2 e4 ff 	st.w [%a14]-28,%d2
8000b042:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b046:	59 e2 e0 ff 	st.w [%a14]-32,%d2
8000b04a:	82 72       	mov %d2,7
8000b04c:	59 e2 dc ff 	st.w [%a14]-36,%d2
    gethSFR->DMA_CH[channel].RXDESC_RING_LENGTH.U = length;
8000b050:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8000b054:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000b058:	06 72       	sh %d2,7
8000b05a:	42 32       	add %d2,%d3
8000b05c:	60 22       	mov.a %a2,%d2
8000b05e:	d9 22 30 41 	lea %a2,[%a2]4400
8000b062:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000b066:	74 22       	st.w [%a2],%d2
}
8000b068:	00 00       	nop 
}
8000b06a:	00 00       	nop 
8000b06c:	00 90       	ret 

8000b06e <IfxGeth_Eth_initTransmitDescriptors>:


void IfxGeth_Eth_initTransmitDescriptors(IfxGeth_Eth *geth, IfxGeth_Eth_TxChannelConfig *config)
{
8000b06e:	40 ae       	mov.aa %a14,%sp
8000b070:	20 48       	sub.a %sp,72
8000b072:	b5 e4 fc ef 	st.a [%a14]-68,%a4
8000b076:	b5 e5 f8 ef 	st.a [%a14]-72,%a5
    int                  i;
    uint32               buffer1StartAddress = (uint32)config->txBuffer1StartAddress;
8000b07a:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000b07e:	d9 22 0c 00 	lea %a2,[%a2]12
8000b082:	54 22       	ld.w %d2,[%a2]
8000b084:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    IfxGeth_TxDmaChannel channelId           = config->channelId;
8000b088:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000b08c:	54 22       	ld.w %d2,[%a2]
8000b08e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    geth->txChannel[channelId].channelId   = channelId;
8000b092:	19 e3 fc ef 	ld.w %d3,[%a14]-68
8000b096:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b09a:	53 42 21 20 	mul %d2,%d2,20
8000b09e:	42 32       	add %d2,%d3
8000b0a0:	60 22       	mov.a %a2,%d2
8000b0a2:	d9 22 0c 00 	lea %a2,[%a2]12
8000b0a6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b0aa:	74 22       	st.w [%a2],%d2
    geth->txChannel[channelId].txDescrList = config->txDescrList;
8000b0ac:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000b0b0:	d9 22 08 00 	lea %a2,[%a2]8
8000b0b4:	54 23       	ld.w %d3,[%a2]
8000b0b6:	19 e4 fc ef 	ld.w %d4,[%a14]-68
8000b0ba:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b0be:	53 42 21 20 	mul %d2,%d2,20
8000b0c2:	42 42       	add %d2,%d4
8000b0c4:	60 22       	mov.a %a2,%d2
8000b0c6:	d9 22 10 00 	lea %a2,[%a2]16
8000b0ca:	74 23       	st.w [%a2],%d3
    geth->txChannel[channelId].txBuf1Size  = (uint16)config->txBuffer1Size;
8000b0cc:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000b0d0:	b9 22 10 00 	ld.hu %d2,[%a2]16
8000b0d4:	19 e4 fc ef 	ld.w %d4,[%a14]-68
8000b0d8:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8000b0dc:	53 43 21 30 	mul %d3,%d3,20
8000b0e0:	42 43       	add %d3,%d4
8000b0e2:	60 32       	mov.a %a2,%d3
8000b0e4:	d9 22 1c 00 	lea %a2,[%a2]28
8000b0e8:	b4 22       	st.h [%a2],%d2
8000b0ea:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b0ee:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000b0f2:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b0f6:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    return geth->txChannel[channelId].txDescrList->descr;
8000b0fa:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000b0fe:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000b102:	53 42 21 20 	mul %d2,%d2,20
8000b106:	42 32       	add %d2,%d3
8000b108:	60 22       	mov.a %a2,%d2
8000b10a:	d9 22 10 00 	lea %a2,[%a2]16
8000b10e:	54 22       	ld.w %d2,[%a2]

    volatile IfxGeth_TxDescr *descr = IfxGeth_Eth_getBaseTxDescriptor(geth, channelId);
8000b110:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    geth->txChannel[channelId].txDescrPtr = descr;
8000b114:	19 e3 fc ef 	ld.w %d3,[%a14]-68
8000b118:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b11c:	c2 12       	add %d2,1
8000b11e:	53 42 21 20 	mul %d2,%d2,20
8000b122:	60 32       	mov.a %a2,%d3
8000b124:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000b128:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000b12c:	74 22       	st.w [%a2],%d2

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (config->txBuffer1Size) % 4 == 0);

    /* Initialize descriptors in ring mode */
    for (i = 0; i < IFXGETH_MAX_TX_DESCRIPTORS; i++)
8000b12e:	82 02       	mov %d2,0
8000b130:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000b134:	1d 00 65 00 	j 8000b1fe <IfxGeth_Eth_initTransmitDescriptors+0x190>
    {
        descr->TDES0.U           = (uint32)(config->txBuffer1Size * i) + buffer1StartAddress;
8000b138:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000b13c:	b9 22 10 00 	ld.hu %d2,[%a2]16
8000b140:	02 23       	mov %d3,%d2
8000b142:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b146:	e2 32       	mul %d2,%d3
8000b148:	02 23       	mov %d3,%d2
8000b14a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000b14e:	42 32       	add %d2,%d3
8000b150:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b154:	74 22       	st.w [%a2],%d2
        descr->TDES1.U           = 0; /* buffer2 not used */
8000b156:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b15a:	82 02       	mov %d2,0
8000b15c:	b0 42       	add.a %a2,4
8000b15e:	74 22       	st.w [%a2],%d2

        descr->TDES2.R.B1L       = config->txBuffer1Size;
8000b160:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8000b164:	b9 22 10 00 	ld.hu %d2,[%a2]16
8000b168:	02 23       	mov %d3,%d2
8000b16a:	3b f0 ff 23 	mov %d2,16383
8000b16e:	26 32       	and %d2,%d3
8000b170:	37 02 70 30 	extr.u %d3,%d2,0,16
8000b174:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b178:	d9 23 08 00 	lea %a3,[%a2]8
8000b17c:	54 32       	ld.w %d2,[%a3]
8000b17e:	37 32 0e 20 	insert %d2,%d2,%d3,0,14
8000b182:	d9 22 08 00 	lea %a2,[%a2]8
8000b186:	74 22       	st.w [%a2],%d2
        descr->TDES2.R.VTIR      = 0; /* do not use VLAN tag */
8000b188:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b18c:	d9 23 08 00 	lea %a3,[%a2]8
8000b190:	54 32       	ld.w %d2,[%a3]
8000b192:	7b f0 ff 3f 	movh %d3,65535
8000b196:	1b f3 ff 33 	addi %d3,%d3,16383
8000b19a:	26 32       	and %d2,%d3
8000b19c:	d9 22 08 00 	lea %a2,[%a2]8
8000b1a0:	74 22       	st.w [%a2],%d2
        descr->TDES2.R.B2L       = 0; /* buffer2 not used */
8000b1a2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b1a6:	d9 23 08 00 	lea %a3,[%a2]8
8000b1aa:	54 32       	ld.w %d2,[%a3]
8000b1ac:	7b 10 00 3c 	movh %d3,49153
8000b1b0:	c2 f3       	add %d3,-1
8000b1b2:	26 32       	and %d2,%d3
8000b1b4:	d9 22 08 00 	lea %a2,[%a2]8
8000b1b8:	74 22       	st.w [%a2],%d2
        descr->TDES2.R.TTSE_TMWD = 0; /* timestamp not used */
8000b1ba:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b1be:	d9 23 08 00 	lea %a3,[%a2]8
8000b1c2:	54 32       	ld.w %d2,[%a3]
8000b1c4:	7b 00 00 3c 	movh %d3,49152
8000b1c8:	c2 f3       	add %d3,-1
8000b1ca:	26 32       	and %d2,%d3
8000b1cc:	d9 22 08 00 	lea %a2,[%a2]8
8000b1d0:	74 22       	st.w [%a2],%d2
        descr->TDES2.R.IOC       = 0; /* interrupt disabled */
8000b1d2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b1d6:	d9 23 08 00 	lea %a3,[%a2]8
8000b1da:	54 32       	ld.w %d2,[%a3]
8000b1dc:	82 f3       	mov %d3,-1
8000b1de:	06 f3       	sh %d3,-1
8000b1e0:	26 32       	and %d2,%d3
8000b1e2:	d9 22 08 00 	lea %a2,[%a2]8
8000b1e6:	74 22       	st.w [%a2],%d2

        /* TDES3 will be configured while trasmitting each packet */

        descr = &descr[1];
8000b1e8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000b1ec:	1b 02 01 20 	addi %d2,%d2,16
8000b1f0:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    for (i = 0; i < IFXGETH_MAX_TX_DESCRIPTORS; i++)
8000b1f4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b1f8:	c2 12       	add %d2,1
8000b1fa:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000b1fe:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b202:	8b 82 40 22 	lt %d2,%d2,8
8000b206:	df 02 99 ff 	jne %d2,0,8000b138 <IfxGeth_Eth_initTransmitDescriptors+0xca>
8000b20a:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b20e:	59 e2 c4 ff 	st.w [%a14]-60,%d2
8000b212:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b216:	59 e2 c0 ff 	st.w [%a14]-64,%d2
8000b21a:	19 e3 c4 ff 	ld.w %d3,[%a14]-60
8000b21e:	19 e2 c0 ff 	ld.w %d2,[%a14]-64
8000b222:	53 42 21 20 	mul %d2,%d2,20
8000b226:	42 32       	add %d2,%d3
8000b228:	60 22       	mov.a %a2,%d2
8000b22a:	d9 22 10 00 	lea %a2,[%a2]16
8000b22e:	54 22       	ld.w %d2,[%a2]
8000b230:	02 24       	mov %d4,%d2
    }

    /* rest the current pointer to base pointer in the handle */
    geth->txChannel[channelId].txDescrPtr = IfxGeth_Eth_getBaseTxDescriptor(geth, channelId);
8000b232:	19 e3 fc ef 	ld.w %d3,[%a14]-68
8000b236:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b23a:	c2 12       	add %d2,1
8000b23c:	53 42 21 20 	mul %d2,%d2,20
8000b240:	60 32       	mov.a %a2,%d3
8000b242:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000b246:	74 24       	st.w [%a2],%d4

    IfxGeth_dma_setTxDescriptorListAddress(geth->gethSFR, channelId, (uint32)IfxGeth_Eth_getBaseTxDescriptor(geth, channelId));
8000b248:	99 e2 fc ef 	ld.a %a2,[%a14]-68
8000b24c:	54 23       	ld.w %d3,[%a2]
8000b24e:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b252:	59 e2 cc ff 	st.w [%a14]-52,%d2
8000b256:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b25a:	59 e2 c8 ff 	st.w [%a14]-56,%d2
8000b25e:	19 e4 cc ff 	ld.w %d4,[%a14]-52
8000b262:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000b266:	53 42 21 20 	mul %d2,%d2,20
8000b26a:	42 42       	add %d2,%d4
8000b26c:	60 22       	mov.a %a2,%d2
8000b26e:	d9 22 10 00 	lea %a2,[%a2]16
8000b272:	54 22       	ld.w %d2,[%a2]
8000b274:	02 24       	mov %d4,%d2
8000b276:	59 e3 d8 ff 	st.w [%a14]-40,%d3
8000b27a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b27e:	59 e2 d4 ff 	st.w [%a14]-44,%d2
8000b282:	59 e4 d0 ff 	st.w [%a14]-48,%d4
    gethSFR->DMA_CH[channel].TXDESC_LIST_ADDRESS.U = address;
8000b286:	19 e3 d8 ff 	ld.w %d3,[%a14]-40
8000b28a:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000b28e:	06 72       	sh %d2,7
8000b290:	42 32       	add %d2,%d3
8000b292:	60 22       	mov.a %a2,%d2
8000b294:	d9 22 14 41 	lea %a2,[%a2]4372
8000b298:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000b29c:	74 22       	st.w [%a2],%d2
}
8000b29e:	00 00       	nop 
    IfxGeth_dma_setTxDescriptorRingLength(geth->gethSFR, channelId, (IFXGETH_MAX_TX_DESCRIPTORS - 1));
8000b2a0:	99 e2 fc ef 	ld.a %a2,[%a14]-68
8000b2a4:	54 22       	ld.w %d2,[%a2]
8000b2a6:	59 e2 e4 ff 	st.w [%a14]-28,%d2
8000b2aa:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b2ae:	59 e2 e0 ff 	st.w [%a14]-32,%d2
8000b2b2:	82 72       	mov %d2,7
8000b2b4:	59 e2 dc ff 	st.w [%a14]-36,%d2
    gethSFR->DMA_CH[channel].TXDESC_RING_LENGTH.U = length;
8000b2b8:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8000b2bc:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000b2c0:	06 72       	sh %d2,7
8000b2c2:	42 32       	add %d2,%d3
8000b2c4:	60 22       	mov.a %a2,%d2
8000b2c6:	d9 22 2c 41 	lea %a2,[%a2]4396
8000b2ca:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000b2ce:	74 22       	st.w [%a2],%d2
}
8000b2d0:	00 00       	nop 
}
8000b2d2:	00 00       	nop 
8000b2d4:	00 90       	ret 

8000b2d6 <IfxGeth_Eth_sendTransmitBuffer>:
    IfxGeth_Eth_sendTransmitBuffer(geth, config->packetLength, config->channelId);
}


void IfxGeth_Eth_sendTransmitBuffer(IfxGeth_Eth *geth, uint32 packetLength, IfxGeth_TxDmaChannel channelId)
{
8000b2d6:	40 ae       	mov.aa %a14,%sp
8000b2d8:	20 48       	sub.a %sp,72
8000b2da:	b5 e4 c4 ff 	st.a [%a14]-60,%a4
8000b2de:	59 e4 c0 ff 	st.w [%a14]-64,%d4
8000b2e2:	59 e5 fc ef 	st.w [%a14]-68,%d5
8000b2e6:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000b2ea:	59 e2 e4 ff 	st.w [%a14]-28,%d2
8000b2ee:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b2f2:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    return geth->txChannel[channelId].txDescrPtr;
8000b2f6:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8000b2fa:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000b2fe:	c2 12       	add %d2,1
8000b300:	53 42 21 20 	mul %d2,%d2,20
8000b304:	60 32       	mov.a %a2,%d3
8000b306:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000b30a:	54 22       	ld.w %d2,[%a2]
    uint32                    i;
    volatile IfxGeth_TxDescr *firstDescr       = IfxGeth_Eth_getActualTxDescriptor(geth, channelId);
8000b30c:	59 e2 ec ff 	st.w [%a14]-20,%d2
    volatile IfxGeth_TxDescr *descr            = firstDescr;
8000b310:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000b314:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    volatile IfxGeth_TxDescr *nextDescr        = &firstDescr[1];
8000b318:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000b31c:	1b 02 01 20 	addi %d2,%d2,16
8000b320:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    uint32                    bufferLength     = geth->txChannel[channelId].txBuf1Size; /* get the configured buffer length */
8000b324:	19 e3 c4 ff 	ld.w %d3,[%a14]-60
8000b328:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b32c:	53 42 21 20 	mul %d2,%d2,20
8000b330:	42 32       	add %d2,%d3
8000b332:	60 22       	mov.a %a2,%d2
8000b334:	d9 22 1c 00 	lea %a2,[%a2]28
8000b338:	b9 22 00 00 	ld.hu %d2,[%a2]0
8000b33c:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    /* calculate the number of descriptors needed for the frame based on buffer length */
    uint32                    numOfDescriptors = packetLength / bufferLength;
8000b340:	19 e3 c0 ff 	ld.w %d3,[%a14]-64
8000b344:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000b348:	4b 23 11 22 	div.u %e2,%d3,%d2
8000b34c:	59 e2 f0 ff 	st.w [%a14]-16,%d2

    if (packetLength % bufferLength)
8000b350:	19 e3 c0 ff 	ld.w %d3,[%a14]-64
8000b354:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000b358:	4b 23 11 22 	div.u %e2,%d3,%d2
8000b35c:	02 32       	mov %d2,%d3
8000b35e:	df 02 07 00 	jeq %d2,0,8000b36c <IfxGeth_Eth_sendTransmitBuffer+0x96>
    {
        numOfDescriptors += 1;
8000b362:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b366:	c2 12       	add %d2,1
8000b368:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    }

    /* configure the first descriptor */
    firstDescr->TDES3.R.FL_TPL  = packetLength; /* total length of the packet */
8000b36c:	19 e2 c0 ff 	ld.w %d2,[%a14]-64
8000b370:	02 23       	mov %d3,%d2
8000b372:	3b f0 ff 27 	mov %d2,32767
8000b376:	26 32       	and %d2,%d3
8000b378:	37 02 70 30 	extr.u %d3,%d2,0,16
8000b37c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b380:	d9 23 0c 00 	lea %a3,[%a2]12
8000b384:	54 32       	ld.w %d2,[%a3]
8000b386:	37 32 0f 20 	insert %d2,%d2,%d3,0,15
8000b38a:	d9 22 0c 00 	lea %a2,[%a2]12
8000b38e:	74 22       	st.w [%a2],%d2
    firstDescr->TDES3.R.TSE     = 0;            /* TCP Segmentation Disable */
8000b390:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b394:	d9 23 0c 00 	lea %a3,[%a2]12
8000b398:	54 32       	ld.w %d2,[%a3]
8000b39a:	7b c0 ff 3f 	movh %d3,65532
8000b39e:	c2 f3       	add %d3,-1
8000b3a0:	26 32       	and %d2,%d3
8000b3a2:	d9 22 0c 00 	lea %a2,[%a2]12
8000b3a6:	74 22       	st.w [%a2],%d2
    firstDescr->TDES3.R.CIC_TPL = 3;
8000b3a8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b3ac:	d9 23 0c 00 	lea %a3,[%a2]12
8000b3b0:	54 32       	ld.w %d2,[%a3]
8000b3b2:	b7 32 02 28 	insert %d2,%d2,3,16,2
8000b3b6:	d9 22 0c 00 	lea %a2,[%a2]12
8000b3ba:	74 22       	st.w [%a2],%d2
    firstDescr->TDES3.R.SAIC    = 0;            /* Source Address insertion disabled */
8000b3bc:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b3c0:	d9 23 0c 00 	lea %a3,[%a2]12
8000b3c4:	54 32       	ld.w %d2,[%a3]
8000b3c6:	7b 00 c8 3f 	movh %d3,64640
8000b3ca:	c2 f3       	add %d3,-1
8000b3cc:	26 32       	and %d2,%d3
8000b3ce:	d9 22 0c 00 	lea %a2,[%a2]12
8000b3d2:	74 22       	st.w [%a2],%d2
    firstDescr->TDES3.R.CPC     = 0;            /* CRC and PAD insertion enabled */
8000b3d4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b3d8:	d9 23 0c 00 	lea %a3,[%a2]12
8000b3dc:	54 32       	ld.w %d2,[%a3]
8000b3de:	7b 00 40 3f 	movh %d3,62464
8000b3e2:	c2 f3       	add %d3,-1
8000b3e4:	26 32       	and %d2,%d3
8000b3e6:	d9 22 0c 00 	lea %a2,[%a2]12
8000b3ea:	74 22       	st.w [%a2],%d2

    /* configure every other descriptor including first descriptor for the frame transmission */
    for (i = 0; i < numOfDescriptors; i++)
8000b3ec:	82 02       	mov %d2,0
8000b3ee:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000b3f2:	1d 00 b2 00 	j 8000b556 <IfxGeth_Eth_sendTransmitBuffer+0x280>
    {
        if (i == (numOfDescriptors - 1))
8000b3f6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b3fa:	c2 f2       	add %d2,-1
8000b3fc:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000b400:	5f 23 36 80 	jne %d3,%d2,8000b46c <IfxGeth_Eth_sendTransmitBuffer+0x196>
        {
            descr->TDES3.R.LD  = 1;                                              /* last descriptor of the frame */
8000b404:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b408:	d9 23 0c 00 	lea %a3,[%a2]12
8000b40c:	54 32       	ld.w %d2,[%a3]
8000b40e:	b7 12 01 2e 	insert %d2,%d2,1,28,1
8000b412:	d9 22 0c 00 	lea %a2,[%a2]12
8000b416:	74 22       	st.w [%a2],%d2
            descr->TDES2.R.IOC = 1;                                              /* last descriptor of the frame set IOC */
8000b418:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b41c:	d9 23 08 00 	lea %a3,[%a2]8
8000b420:	54 32       	ld.w %d2,[%a3]
8000b422:	b7 12 81 2f 	insert %d2,%d2,1,31,1
8000b426:	d9 22 08 00 	lea %a2,[%a2]8
8000b42a:	74 22       	st.w [%a2],%d2
            descr->TDES3.R.FD  = 0;
8000b42c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b430:	d9 23 0c 00 	lea %a3,[%a2]12
8000b434:	54 32       	ld.w %d2,[%a3]
8000b436:	7b 00 00 3e 	movh %d3,57344
8000b43a:	c2 f3       	add %d3,-1
8000b43c:	26 32       	and %d2,%d3
8000b43e:	d9 22 0c 00 	lea %a2,[%a2]12
8000b442:	74 22       	st.w [%a2],%d2
            descr->TDES2.R.B1L = packetLength;
8000b444:	19 e2 c0 ff 	ld.w %d2,[%a14]-64
8000b448:	02 23       	mov %d3,%d2
8000b44a:	3b f0 ff 23 	mov %d2,16383
8000b44e:	26 32       	and %d2,%d3
8000b450:	37 02 70 30 	extr.u %d3,%d2,0,16
8000b454:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b458:	d9 23 08 00 	lea %a3,[%a2]8
8000b45c:	54 32       	ld.w %d2,[%a3]
8000b45e:	37 32 0e 20 	insert %d2,%d2,%d3,0,14
8000b462:	d9 22 08 00 	lea %a2,[%a2]8
8000b466:	74 22       	st.w [%a2],%d2
8000b468:	1d 00 49 00 	j 8000b4fa <IfxGeth_Eth_sendTransmitBuffer+0x224>
        }
        else
        {
            descr->TDES3.R.LD  = 0;
8000b46c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b470:	d9 23 0c 00 	lea %a3,[%a2]12
8000b474:	54 32       	ld.w %d2,[%a3]
8000b476:	7b 00 00 3f 	movh %d3,61440
8000b47a:	c2 f3       	add %d3,-1
8000b47c:	26 32       	and %d2,%d3
8000b47e:	d9 22 0c 00 	lea %a2,[%a2]12
8000b482:	74 22       	st.w [%a2],%d2
            descr->TDES3.R.FD  = 0;
8000b484:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b488:	d9 23 0c 00 	lea %a3,[%a2]12
8000b48c:	54 32       	ld.w %d2,[%a3]
8000b48e:	7b 00 00 3e 	movh %d3,57344
8000b492:	c2 f3       	add %d3,-1
8000b494:	26 32       	and %d2,%d3
8000b496:	d9 22 0c 00 	lea %a2,[%a2]12
8000b49a:	74 22       	st.w [%a2],%d2
            descr->TDES2.R.IOC = 0;                                        /* Clear the IOC bits for intermeditate buffers */
8000b49c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b4a0:	d9 23 08 00 	lea %a3,[%a2]8
8000b4a4:	54 32       	ld.w %d2,[%a3]
8000b4a6:	82 f3       	mov %d3,-1
8000b4a8:	06 f3       	sh %d3,-1
8000b4aa:	26 32       	and %d2,%d3
8000b4ac:	d9 22 08 00 	lea %a2,[%a2]8
8000b4b0:	74 22       	st.w [%a2],%d2
            descr->TDES2.R.B1L = geth->txChannel[channelId].txBuf1Size;
8000b4b2:	19 e3 c4 ff 	ld.w %d3,[%a14]-60
8000b4b6:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b4ba:	53 42 21 20 	mul %d2,%d2,20
8000b4be:	42 32       	add %d2,%d3
8000b4c0:	60 22       	mov.a %a2,%d2
8000b4c2:	d9 22 1c 00 	lea %a2,[%a2]28
8000b4c6:	b9 22 00 00 	ld.hu %d2,[%a2]0
8000b4ca:	02 23       	mov %d3,%d2
8000b4cc:	3b f0 ff 23 	mov %d2,16383
8000b4d0:	26 32       	and %d2,%d3
8000b4d2:	37 02 70 30 	extr.u %d3,%d2,0,16
8000b4d6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b4da:	d9 23 08 00 	lea %a3,[%a2]8
8000b4de:	54 32       	ld.w %d2,[%a3]
8000b4e0:	37 32 0e 20 	insert %d2,%d2,%d3,0,14
8000b4e4:	d9 22 08 00 	lea %a2,[%a2]8
8000b4e8:	74 22       	st.w [%a2],%d2
            packetLength      -= bufferLength;
8000b4ea:	19 e3 c0 ff 	ld.w %d3,[%a14]-64
8000b4ee:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000b4f2:	0b 23 80 20 	sub %d2,%d3,%d2
8000b4f6:	59 e2 c0 ff 	st.w [%a14]-64,%d2
        }

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, descr->TDES3.R.OWN != 1U);           /* Assert if buffers are not available for transfer */
        descr->TDES3.R.OWN = 1U;                                                 /* release to DMA */
8000b4fa:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000b4fe:	d9 23 0c 00 	lea %a3,[%a2]12
8000b502:	54 32       	ld.w %d2,[%a3]
8000b504:	b7 12 81 2f 	insert %d2,%d2,1,31,1
8000b508:	d9 22 0c 00 	lea %a2,[%a2]12
8000b50c:	74 22       	st.w [%a2],%d2
        IfxGeth_Eth_shuffleTxDescriptor(geth, channelId);
8000b50e:	19 e4 fc ef 	ld.w %d4,[%a14]-68
8000b512:	99 e4 c4 ff 	ld.a %a4,[%a14]-60
8000b516:	6d 00 3b 0d 	call 8000cf8c <IfxGeth_Eth_shuffleTxDescriptor>
8000b51a:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000b51e:	59 e2 dc ff 	st.w [%a14]-36,%d2
8000b522:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b526:	59 e2 d8 ff 	st.w [%a14]-40,%d2
8000b52a:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8000b52e:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000b532:	c2 12       	add %d2,1
8000b534:	53 42 21 20 	mul %d2,%d2,20
8000b538:	60 32       	mov.a %a2,%d3
8000b53a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000b53e:	54 22       	ld.w %d2,[%a2]
        descr              = IfxGeth_Eth_getActualTxDescriptor(geth, channelId); /* update the descr pointer */
8000b540:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        nextDescr          = descr;
8000b544:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000b548:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    for (i = 0; i < numOfDescriptors; i++)
8000b54c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b550:	c2 12       	add %d2,1
8000b552:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000b556:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000b55a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000b55e:	3f 23 4c ff 	jlt.u %d3,%d2,8000b3f6 <IfxGeth_Eth_sendTransmitBuffer+0x120>
    }

    firstDescr->TDES3.R.FD                = 1;          /* first descriptor of the frame */
8000b562:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b566:	d9 23 0c 00 	lea %a3,[%a2]12
8000b56a:	54 32       	ld.w %d2,[%a3]
8000b56c:	b7 12 81 2e 	insert %d2,%d2,1,29,1
8000b570:	d9 22 0c 00 	lea %a2,[%a2]12
8000b574:	74 22       	st.w [%a2],%d2
    geth->txChannel[channelId].txDescrPtr = firstDescr; /* point to first descriptor to initiate the transfer */
8000b576:	19 e3 c4 ff 	ld.w %d3,[%a14]-60
8000b57a:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b57e:	c2 12       	add %d2,1
8000b580:	53 42 21 20 	mul %d2,%d2,20
8000b584:	60 32       	mov.a %a2,%d3
8000b586:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000b58a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000b58e:	74 22       	st.w [%a2],%d2
    IfxGeth_dma_setTxDescriptorTailPointer(geth->gethSFR, channelId, (uint32)nextDescr);
8000b590:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000b594:	54 23       	ld.w %d3,[%a2]
8000b596:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000b59a:	59 e3 d4 ff 	st.w [%a14]-44,%d3
8000b59e:	19 e3 fc ef 	ld.w %d3,[%a14]-68
8000b5a2:	59 e3 d0 ff 	st.w [%a14]-48,%d3
8000b5a6:	59 e2 cc ff 	st.w [%a14]-52,%d2
    gethSFR->DMA_CH[channel].TXDESC_TAIL_POINTER.U = (uint32)address;
8000b5aa:	19 e3 d4 ff 	ld.w %d3,[%a14]-44
8000b5ae:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000b5b2:	06 72       	sh %d2,7
8000b5b4:	42 32       	add %d2,%d3
8000b5b6:	60 22       	mov.a %a2,%d2
8000b5b8:	d9 22 20 41 	lea %a2,[%a2]4384
8000b5bc:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8000b5c0:	74 22       	st.w [%a2],%d2
}
8000b5c2:	00 00       	nop 
    IfxGeth_Eth_wakeupTransmitter(geth, channelId);     /* initialte the transfer */
8000b5c4:	19 e4 fc ef 	ld.w %d4,[%a14]-68
8000b5c8:	99 e4 c4 ff 	ld.a %a4,[%a14]-60
8000b5cc:	6d 00 cc 0e 	call 8000d364 <IfxGeth_Eth_wakeupTransmitter>
    geth->txChannel[channelId].txDescrPtr = nextDescr;  /* update the handle pointer to next descriptor */
8000b5d0:	19 e3 c4 ff 	ld.w %d3,[%a14]-60
8000b5d4:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b5d8:	c2 12       	add %d2,1
8000b5da:	53 42 21 20 	mul %d2,%d2,20
8000b5de:	60 32       	mov.a %a2,%d3
8000b5e0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000b5e4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000b5e8:	74 22       	st.w [%a2],%d2

    geth->txChannel[channelId].txCount++;
8000b5ea:	19 e3 c4 ff 	ld.w %d3,[%a14]-60
8000b5ee:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b5f2:	53 42 21 20 	mul %d2,%d2,20
8000b5f6:	42 32       	add %d2,%d3
8000b5f8:	60 22       	mov.a %a2,%d2
8000b5fa:	d9 22 18 00 	lea %a2,[%a2]24
8000b5fe:	54 22       	ld.w %d2,[%a2]
8000b600:	1b 12 00 30 	addi %d3,%d2,1
8000b604:	19 e4 c4 ff 	ld.w %d4,[%a14]-60
8000b608:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000b60c:	53 42 21 20 	mul %d2,%d2,20
8000b610:	42 42       	add %d2,%d4
8000b612:	60 22       	mov.a %a2,%d2
8000b614:	d9 22 18 00 	lea %a2,[%a2]24
8000b618:	74 23       	st.w [%a2],%d3
}
8000b61a:	00 00       	nop 
8000b61c:	00 90       	ret 

8000b61e <IfxGeth_Eth_setupMiiInputPins>:


void IfxGeth_Eth_setupMiiInputPins(IfxGeth_Eth *geth, const IfxGeth_Eth_MiiPins *miiPins)
{
8000b61e:	40 ae       	mov.aa %a14,%sp
8000b620:	20 b8       	sub.a %sp,184
8000b622:	b5 e4 cc df 	st.a [%a14]-180,%a4
8000b626:	b5 e5 c8 df 	st.a [%a14]-184,%a5
    IfxPort_InputMode mode       = IfxPort_InputMode_noPullDevice;
8000b62a:	82 02       	mov %d2,0
8000b62c:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxPort_PadDriver speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed1;
8000b630:	82 02       	mov %d2,0
8000b632:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    if (miiPins->crs != NULL_PTR)
8000b636:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b63a:	54 22       	ld.w %d2,[%a2]
8000b63c:	df 02 52 00 	jeq %d2,0,8000b6e0 <IfxGeth_Eth_setupMiiInputPins+0xc2>
    {
        IfxGeth_Crs_In *crs = miiPins->crs;
8000b640:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b644:	54 22       	ld.w %d2,[%a2]
8000b646:	59 e2 f4 ff 	st.w [%a14]-12,%d2
        geth->gethSFR->GPCTL.B.ALTI2 = crs->select;
8000b64a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000b64e:	d9 22 0c 00 	lea %a2,[%a2]12
8000b652:	54 22       	ld.w %d2,[%a2]
8000b654:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000b658:	d4 22       	ld.a %a2,[%a2]
8000b65a:	8f 32 00 21 	and %d2,%d2,3
8000b65e:	8f f2 0f 31 	and %d3,%d2,255
8000b662:	d9 23 08 02 	lea %a3,[%a2]8200
8000b666:	54 32       	ld.w %d2,[%a3]
8000b668:	37 32 02 22 	insert %d2,%d2,%d3,4,2
8000b66c:	d9 22 08 02 	lea %a2,[%a2]8200
8000b670:	74 22       	st.w [%a2],%d2
        IfxPort_setPinControllerSelection(crs->pin.port, crs->pin.pinIndex);
8000b672:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000b676:	b0 42       	add.a %a2,4
8000b678:	54 22       	ld.w %d2,[%a2]
8000b67a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000b67e:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b682:	02 34       	mov %d4,%d3
8000b684:	60 24       	mov.a %a4,%d2
8000b686:	6d ff e7 e9 	call 80008a54 <IfxPort_setPinControllerSelection>
        IfxPort_setPinModeInput(crs->pin.port, crs->pin.pinIndex, mode);
8000b68a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000b68e:	b0 42       	add.a %a2,4
8000b690:	54 23       	ld.w %d3,[%a2]
8000b692:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000b696:	39 22 08 00 	ld.bu %d2,[%a2]8
8000b69a:	59 e3 c8 ff 	st.w [%a14]-56,%d3
8000b69e:	e9 e2 c7 ff 	st.b [%a14]-57,%d2
8000b6a2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b6a6:	59 e2 c0 ff 	st.w [%a14]-64,%d2
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000b6aa:	39 e2 c7 ff 	ld.bu %d2,[%a14]-57
8000b6ae:	19 e3 c0 ff 	ld.w %d3,[%a14]-64
8000b6b2:	02 35       	mov %d5,%d3
8000b6b4:	02 24       	mov %d4,%d2
8000b6b6:	99 e4 c8 ff 	ld.a %a4,[%a14]-56
8000b6ba:	6d ff 0a e9 	call 800088ce <IfxPort_setPinMode>
}
8000b6be:	00 00       	nop 
        IfxPort_setPinPadDriver(crs->pin.port, crs->pin.pinIndex, speedGrade);
8000b6c0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000b6c4:	b0 42       	add.a %a2,4
8000b6c6:	54 22       	ld.w %d2,[%a2]
8000b6c8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000b6cc:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b6d0:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000b6d4:	02 34       	mov %d4,%d3
8000b6d6:	60 24       	mov.a %a4,%d2
8000b6d8:	6d ff 6d e9 	call 800089b2 <IfxPort_setPinPadDriver>
8000b6dc:	1d 00 0d 00 	j 8000b6f6 <IfxGeth_Eth_setupMiiInputPins+0xd8>
    }
    else
    {
        /* Mii lite mode */
        geth->gethSFR->GPCTL.B.ALTI2 = Ifx_RxSel_d;
8000b6e0:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000b6e4:	d4 22       	ld.a %a2,[%a2]
8000b6e6:	d9 23 08 02 	lea %a3,[%a2]8200
8000b6ea:	54 32       	ld.w %d2,[%a3]
8000b6ec:	b7 32 02 22 	insert %d2,%d2,3,4,2
8000b6f0:	d9 22 08 02 	lea %a2,[%a2]8200
8000b6f4:	74 22       	st.w [%a2],%d2
    }

    if (miiPins->col != NULL_PTR)
8000b6f6:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b6fa:	b0 42       	add.a %a2,4
8000b6fc:	54 22       	ld.w %d2,[%a2]
8000b6fe:	df 02 53 00 	jeq %d2,0,8000b7a4 <IfxGeth_Eth_setupMiiInputPins+0x186>
    {
        IfxGeth_Col_In *col = miiPins->col;
8000b702:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b706:	b0 42       	add.a %a2,4
8000b708:	54 22       	ld.w %d2,[%a2]
8000b70a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        geth->gethSFR->GPCTL.B.ALTI3 = col->select;
8000b70e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000b712:	d9 22 0c 00 	lea %a2,[%a2]12
8000b716:	54 22       	ld.w %d2,[%a2]
8000b718:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000b71c:	d4 22       	ld.a %a2,[%a2]
8000b71e:	8f 32 00 21 	and %d2,%d2,3
8000b722:	8f f2 0f 31 	and %d3,%d2,255
8000b726:	d9 23 08 02 	lea %a3,[%a2]8200
8000b72a:	54 32       	ld.w %d2,[%a3]
8000b72c:	37 32 02 23 	insert %d2,%d2,%d3,6,2
8000b730:	d9 22 08 02 	lea %a2,[%a2]8200
8000b734:	74 22       	st.w [%a2],%d2
        IfxPort_setPinControllerSelection(col->pin.port, col->pin.pinIndex);
8000b736:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000b73a:	b0 42       	add.a %a2,4
8000b73c:	54 22       	ld.w %d2,[%a2]
8000b73e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000b742:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b746:	02 34       	mov %d4,%d3
8000b748:	60 24       	mov.a %a4,%d2
8000b74a:	6d ff 85 e9 	call 80008a54 <IfxPort_setPinControllerSelection>
        IfxPort_setPinModeInput(col->pin.port, col->pin.pinIndex, mode);
8000b74e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000b752:	b0 42       	add.a %a2,4
8000b754:	54 23       	ld.w %d3,[%a2]
8000b756:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000b75a:	39 22 08 00 	ld.bu %d2,[%a2]8
8000b75e:	59 e3 fc ef 	st.w [%a14]-68,%d3
8000b762:	e9 e2 fb ef 	st.b [%a14]-69,%d2
8000b766:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b76a:	59 e2 f4 ef 	st.w [%a14]-76,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000b76e:	39 e2 fb ef 	ld.bu %d2,[%a14]-69
8000b772:	19 e3 f4 ef 	ld.w %d3,[%a14]-76
8000b776:	02 35       	mov %d5,%d3
8000b778:	02 24       	mov %d4,%d2
8000b77a:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000b77e:	6d ff a8 e8 	call 800088ce <IfxPort_setPinMode>
}
8000b782:	00 00       	nop 
        IfxPort_setPinPadDriver(col->pin.port, col->pin.pinIndex, speedGrade);
8000b784:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000b788:	b0 42       	add.a %a2,4
8000b78a:	54 22       	ld.w %d2,[%a2]
8000b78c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000b790:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b794:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000b798:	02 34       	mov %d4,%d3
8000b79a:	60 24       	mov.a %a4,%d2
8000b79c:	6d ff 0b e9 	call 800089b2 <IfxPort_setPinPadDriver>
8000b7a0:	1d 00 0d 00 	j 8000b7ba <IfxGeth_Eth_setupMiiInputPins+0x19c>
    }
    else
    {
        /* Mii lite mode */
        geth->gethSFR->GPCTL.B.ALTI3 = Ifx_RxSel_d;
8000b7a4:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000b7a8:	d4 22       	ld.a %a2,[%a2]
8000b7aa:	d9 23 08 02 	lea %a3,[%a2]8200
8000b7ae:	54 32       	ld.w %d2,[%a3]
8000b7b0:	b7 32 02 23 	insert %d2,%d2,3,6,2
8000b7b4:	d9 22 08 02 	lea %a2,[%a2]8200
8000b7b8:	74 22       	st.w [%a2],%d2
    }

    IfxGeth_Txclk_In *txClk = miiPins->txClk;
8000b7ba:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b7be:	d9 22 08 00 	lea %a2,[%a2]8
8000b7c2:	54 22       	ld.w %d2,[%a2]
8000b7c4:	59 e2 ec ff 	st.w [%a14]-20,%d2
    geth->gethSFR->GPCTL.B.ALTI10 = txClk->select;
8000b7c8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b7cc:	d9 22 0c 00 	lea %a2,[%a2]12
8000b7d0:	54 22       	ld.w %d2,[%a2]
8000b7d2:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000b7d6:	d4 22       	ld.a %a2,[%a2]
8000b7d8:	8f 32 00 21 	and %d2,%d2,3
8000b7dc:	8f f2 0f 31 	and %d3,%d2,255
8000b7e0:	d9 23 08 02 	lea %a3,[%a2]8200
8000b7e4:	54 32       	ld.w %d2,[%a3]
8000b7e6:	37 32 02 2a 	insert %d2,%d2,%d3,20,2
8000b7ea:	d9 22 08 02 	lea %a2,[%a2]8200
8000b7ee:	74 22       	st.w [%a2],%d2
    IfxPort_setPinControllerSelection(txClk->pin.port, txClk->pin.pinIndex);
8000b7f0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b7f4:	b0 42       	add.a %a2,4
8000b7f6:	54 22       	ld.w %d2,[%a2]
8000b7f8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b7fc:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b800:	02 34       	mov %d4,%d3
8000b802:	60 24       	mov.a %a4,%d2
8000b804:	6d ff 28 e9 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeInput(txClk->pin.port, txClk->pin.pinIndex, mode);
8000b808:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b80c:	b0 42       	add.a %a2,4
8000b80e:	54 23       	ld.w %d3,[%a2]
8000b810:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b814:	39 22 08 00 	ld.bu %d2,[%a2]8
8000b818:	59 e3 d8 ef 	st.w [%a14]-104,%d3
8000b81c:	e9 e2 d7 ef 	st.b [%a14]-105,%d2
8000b820:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b824:	59 e2 d0 ef 	st.w [%a14]-112,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000b828:	39 e2 d7 ef 	ld.bu %d2,[%a14]-105
8000b82c:	19 e3 d0 ef 	ld.w %d3,[%a14]-112
8000b830:	02 35       	mov %d5,%d3
8000b832:	02 24       	mov %d4,%d2
8000b834:	99 e4 d8 ef 	ld.a %a4,[%a14]-104
8000b838:	6d ff 4b e8 	call 800088ce <IfxPort_setPinMode>
}
8000b83c:	00 00       	nop 
    IfxPort_setPinPadDriver(txClk->pin.port, txClk->pin.pinIndex, speedGrade);
8000b83e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b842:	b0 42       	add.a %a2,4
8000b844:	54 22       	ld.w %d2,[%a2]
8000b846:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000b84a:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b84e:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000b852:	02 34       	mov %d4,%d3
8000b854:	60 24       	mov.a %a4,%d2
8000b856:	6d ff ae e8 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Rxclk_In *rxClk = miiPins->rxClk;
8000b85a:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b85e:	d9 22 0c 00 	lea %a2,[%a2]12
8000b862:	54 22       	ld.w %d2,[%a2]
8000b864:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    geth->gethSFR->GPCTL.B.ALTI1 = rxClk->select;
8000b868:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000b86c:	d9 22 0c 00 	lea %a2,[%a2]12
8000b870:	54 22       	ld.w %d2,[%a2]
8000b872:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000b876:	d4 22       	ld.a %a2,[%a2]
8000b878:	8f 32 00 21 	and %d2,%d2,3
8000b87c:	8f f2 0f 31 	and %d3,%d2,255
8000b880:	d9 23 08 02 	lea %a3,[%a2]8200
8000b884:	54 32       	ld.w %d2,[%a3]
8000b886:	37 32 02 21 	insert %d2,%d2,%d3,2,2
8000b88a:	d9 22 08 02 	lea %a2,[%a2]8200
8000b88e:	74 22       	st.w [%a2],%d2
    IfxPort_setPinControllerSelection(rxClk->pin.port, rxClk->pin.pinIndex);
8000b890:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000b894:	b0 42       	add.a %a2,4
8000b896:	54 22       	ld.w %d2,[%a2]
8000b898:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000b89c:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b8a0:	02 34       	mov %d4,%d3
8000b8a2:	60 24       	mov.a %a4,%d2
8000b8a4:	6d ff d8 e8 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeInput(rxClk->pin.port, rxClk->pin.pinIndex, mode);
8000b8a8:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000b8ac:	b0 42       	add.a %a2,4
8000b8ae:	54 23       	ld.w %d3,[%a2]
8000b8b0:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000b8b4:	39 22 08 00 	ld.bu %d2,[%a2]8
8000b8b8:	59 e3 e4 ef 	st.w [%a14]-92,%d3
8000b8bc:	e9 e2 e3 ef 	st.b [%a14]-93,%d2
8000b8c0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b8c4:	59 e2 dc ef 	st.w [%a14]-100,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000b8c8:	39 e2 e3 ef 	ld.bu %d2,[%a14]-93
8000b8cc:	19 e3 dc ef 	ld.w %d3,[%a14]-100
8000b8d0:	02 35       	mov %d5,%d3
8000b8d2:	02 24       	mov %d4,%d2
8000b8d4:	99 e4 e4 ef 	ld.a %a4,[%a14]-92
8000b8d8:	6d ff fb e7 	call 800088ce <IfxPort_setPinMode>
}
8000b8dc:	00 00       	nop 
    IfxPort_setPinPadDriver(rxClk->pin.port, rxClk->pin.pinIndex, speedGrade);
8000b8de:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000b8e2:	b0 42       	add.a %a2,4
8000b8e4:	54 22       	ld.w %d2,[%a2]
8000b8e6:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000b8ea:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b8ee:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000b8f2:	02 34       	mov %d4,%d3
8000b8f4:	60 24       	mov.a %a4,%d2
8000b8f6:	6d ff 5e e8 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Rxdv_In *rxDv = miiPins->rxDv;
8000b8fa:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b8fe:	d9 22 10 00 	lea %a2,[%a2]16
8000b902:	54 22       	ld.w %d2,[%a2]
8000b904:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    geth->gethSFR->GPCTL.B.ALTI4 = rxDv->select;
8000b908:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000b90c:	d9 22 0c 00 	lea %a2,[%a2]12
8000b910:	54 22       	ld.w %d2,[%a2]
8000b912:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000b916:	d4 22       	ld.a %a2,[%a2]
8000b918:	8f 32 00 21 	and %d2,%d2,3
8000b91c:	8f f2 0f 31 	and %d3,%d2,255
8000b920:	d9 23 08 02 	lea %a3,[%a2]8200
8000b924:	54 32       	ld.w %d2,[%a3]
8000b926:	37 32 02 24 	insert %d2,%d2,%d3,8,2
8000b92a:	d9 22 08 02 	lea %a2,[%a2]8200
8000b92e:	74 22       	st.w [%a2],%d2
    IfxPort_setPinControllerSelection(rxDv->pin.port, rxDv->pin.pinIndex);
8000b930:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000b934:	b0 42       	add.a %a2,4
8000b936:	54 22       	ld.w %d2,[%a2]
8000b938:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000b93c:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b940:	02 34       	mov %d4,%d3
8000b942:	60 24       	mov.a %a4,%d2
8000b944:	6d ff 88 e8 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeInput(rxDv->pin.port, rxDv->pin.pinIndex, mode);
8000b948:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000b94c:	b0 42       	add.a %a2,4
8000b94e:	54 23       	ld.w %d3,[%a2]
8000b950:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000b954:	39 22 08 00 	ld.bu %d2,[%a2]8
8000b958:	59 e3 f0 ef 	st.w [%a14]-80,%d3
8000b95c:	e9 e2 ef ef 	st.b [%a14]-81,%d2
8000b960:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000b964:	59 e2 e8 ef 	st.w [%a14]-88,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000b968:	39 e2 ef ef 	ld.bu %d2,[%a14]-81
8000b96c:	19 e3 e8 ef 	ld.w %d3,[%a14]-88
8000b970:	02 35       	mov %d5,%d3
8000b972:	02 24       	mov %d4,%d2
8000b974:	99 e4 f0 ef 	ld.a %a4,[%a14]-80
8000b978:	6d ff ab e7 	call 800088ce <IfxPort_setPinMode>
}
8000b97c:	00 00       	nop 
    IfxPort_setPinPadDriver(rxDv->pin.port, rxDv->pin.pinIndex, speedGrade);
8000b97e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000b982:	b0 42       	add.a %a2,4
8000b984:	54 22       	ld.w %d2,[%a2]
8000b986:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000b98a:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b98e:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000b992:	02 34       	mov %d4,%d3
8000b994:	60 24       	mov.a %a4,%d2
8000b996:	6d ff 0e e8 	call 800089b2 <IfxPort_setPinPadDriver>

    if (miiPins->rxEr != NULL_PTR)
8000b99a:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b99e:	d9 22 14 00 	lea %a2,[%a2]20
8000b9a2:	54 22       	ld.w %d2,[%a2]
8000b9a4:	df 02 54 00 	jeq %d2,0,8000ba4c <IfxGeth_Eth_setupMiiInputPins+0x42e>
    {
        IfxGeth_Rxer_In *rxEr = miiPins->rxEr;
8000b9a8:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000b9ac:	d9 22 14 00 	lea %a2,[%a2]20
8000b9b0:	54 22       	ld.w %d2,[%a2]
8000b9b2:	59 e2 e0 ff 	st.w [%a14]-32,%d2
        geth->gethSFR->GPCTL.B.ALTI5 = rxEr->select;
8000b9b6:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000b9ba:	d9 22 0c 00 	lea %a2,[%a2]12
8000b9be:	54 22       	ld.w %d2,[%a2]
8000b9c0:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000b9c4:	d4 22       	ld.a %a2,[%a2]
8000b9c6:	8f 32 00 21 	and %d2,%d2,3
8000b9ca:	8f f2 0f 31 	and %d3,%d2,255
8000b9ce:	d9 23 08 02 	lea %a3,[%a2]8200
8000b9d2:	54 32       	ld.w %d2,[%a3]
8000b9d4:	37 32 02 25 	insert %d2,%d2,%d3,10,2
8000b9d8:	d9 22 08 02 	lea %a2,[%a2]8200
8000b9dc:	74 22       	st.w [%a2],%d2
        IfxPort_setPinControllerSelection(rxEr->pin.port, rxEr->pin.pinIndex);
8000b9de:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000b9e2:	b0 42       	add.a %a2,4
8000b9e4:	54 22       	ld.w %d2,[%a2]
8000b9e6:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000b9ea:	39 23 08 00 	ld.bu %d3,[%a2]8
8000b9ee:	02 34       	mov %d4,%d3
8000b9f0:	60 24       	mov.a %a4,%d2
8000b9f2:	6d ff 31 e8 	call 80008a54 <IfxPort_setPinControllerSelection>
        IfxPort_setPinModeInput(rxEr->pin.port, rxEr->pin.pinIndex, mode);
8000b9f6:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000b9fa:	b0 42       	add.a %a2,4
8000b9fc:	54 23       	ld.w %d3,[%a2]
8000b9fe:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000ba02:	39 22 08 00 	ld.bu %d2,[%a2]8
8000ba06:	59 e3 cc ef 	st.w [%a14]-116,%d3
8000ba0a:	e9 e2 cb ef 	st.b [%a14]-117,%d2
8000ba0e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000ba12:	59 e2 c4 ef 	st.w [%a14]-124,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000ba16:	39 e2 cb ef 	ld.bu %d2,[%a14]-117
8000ba1a:	19 e3 c4 ef 	ld.w %d3,[%a14]-124
8000ba1e:	02 35       	mov %d5,%d3
8000ba20:	02 24       	mov %d4,%d2
8000ba22:	99 e4 cc ef 	ld.a %a4,[%a14]-116
8000ba26:	6d ff 54 e7 	call 800088ce <IfxPort_setPinMode>
}
8000ba2a:	00 00       	nop 
        IfxPort_setPinPadDriver(rxEr->pin.port, rxEr->pin.pinIndex, speedGrade);
8000ba2c:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000ba30:	b0 42       	add.a %a2,4
8000ba32:	54 22       	ld.w %d2,[%a2]
8000ba34:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000ba38:	39 23 08 00 	ld.bu %d3,[%a2]8
8000ba3c:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000ba40:	02 34       	mov %d4,%d3
8000ba42:	60 24       	mov.a %a4,%d2
8000ba44:	6d ff b7 e7 	call 800089b2 <IfxPort_setPinPadDriver>
8000ba48:	1d 00 0d 00 	j 8000ba62 <IfxGeth_Eth_setupMiiInputPins+0x444>
    }
    else
    {
        /* Mii lite mode */
        geth->gethSFR->GPCTL.B.ALTI5 = Ifx_RxSel_d;
8000ba4c:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000ba50:	d4 22       	ld.a %a2,[%a2]
8000ba52:	d9 23 08 02 	lea %a3,[%a2]8200
8000ba56:	54 32       	ld.w %d2,[%a3]
8000ba58:	b7 32 02 25 	insert %d2,%d2,3,10,2
8000ba5c:	d9 22 08 02 	lea %a2,[%a2]8200
8000ba60:	74 22       	st.w [%a2],%d2
    }

    IfxGeth_Rxd_In *rxd0 = miiPins->rxd0;
8000ba62:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000ba66:	d9 22 18 00 	lea %a2,[%a2]24
8000ba6a:	54 22       	ld.w %d2,[%a2]
8000ba6c:	59 e2 dc ff 	st.w [%a14]-36,%d2
    geth->gethSFR->GPCTL.B.ALTI6 = rxd0->select;
8000ba70:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000ba74:	d9 22 0c 00 	lea %a2,[%a2]12
8000ba78:	54 22       	ld.w %d2,[%a2]
8000ba7a:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000ba7e:	d4 22       	ld.a %a2,[%a2]
8000ba80:	8f 32 00 21 	and %d2,%d2,3
8000ba84:	8f f2 0f 31 	and %d3,%d2,255
8000ba88:	d9 23 08 02 	lea %a3,[%a2]8200
8000ba8c:	54 32       	ld.w %d2,[%a3]
8000ba8e:	37 32 02 26 	insert %d2,%d2,%d3,12,2
8000ba92:	d9 22 08 02 	lea %a2,[%a2]8200
8000ba96:	74 22       	st.w [%a2],%d2
    IfxPort_setPinControllerSelection(rxd0->pin.port, rxd0->pin.pinIndex);
8000ba98:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000ba9c:	b0 42       	add.a %a2,4
8000ba9e:	54 22       	ld.w %d2,[%a2]
8000baa0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000baa4:	39 23 08 00 	ld.bu %d3,[%a2]8
8000baa8:	02 34       	mov %d4,%d3
8000baaa:	60 24       	mov.a %a4,%d2
8000baac:	6d ff d4 e7 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeInput(rxd0->pin.port, rxd0->pin.pinIndex, mode);
8000bab0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000bab4:	b0 42       	add.a %a2,4
8000bab6:	54 23       	ld.w %d3,[%a2]
8000bab8:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000babc:	39 22 08 00 	ld.bu %d2,[%a2]8
8000bac0:	59 e3 dc df 	st.w [%a14]-164,%d3
8000bac4:	e9 e2 db df 	st.b [%a14]-165,%d2
8000bac8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000bacc:	59 e2 d4 df 	st.w [%a14]-172,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000bad0:	39 e2 db df 	ld.bu %d2,[%a14]-165
8000bad4:	19 e3 d4 df 	ld.w %d3,[%a14]-172
8000bad8:	02 35       	mov %d5,%d3
8000bada:	02 24       	mov %d4,%d2
8000badc:	99 e4 dc df 	ld.a %a4,[%a14]-164
8000bae0:	6d ff f7 e6 	call 800088ce <IfxPort_setPinMode>
}
8000bae4:	00 00       	nop 
    IfxPort_setPinPadDriver(rxd0->pin.port, rxd0->pin.pinIndex, speedGrade);
8000bae6:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000baea:	b0 42       	add.a %a2,4
8000baec:	54 22       	ld.w %d2,[%a2]
8000baee:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000baf2:	39 23 08 00 	ld.bu %d3,[%a2]8
8000baf6:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000bafa:	02 34       	mov %d4,%d3
8000bafc:	60 24       	mov.a %a4,%d2
8000bafe:	6d ff 5a e7 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Rxd_In *rxd1 = miiPins->rxd1;
8000bb02:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000bb06:	d9 22 1c 00 	lea %a2,[%a2]28
8000bb0a:	54 22       	ld.w %d2,[%a2]
8000bb0c:	59 e2 d8 ff 	st.w [%a14]-40,%d2
    geth->gethSFR->GPCTL.B.ALTI7 = rxd1->select;
8000bb10:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000bb14:	d9 22 0c 00 	lea %a2,[%a2]12
8000bb18:	54 22       	ld.w %d2,[%a2]
8000bb1a:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000bb1e:	d4 22       	ld.a %a2,[%a2]
8000bb20:	8f 32 00 21 	and %d2,%d2,3
8000bb24:	8f f2 0f 31 	and %d3,%d2,255
8000bb28:	d9 23 08 02 	lea %a3,[%a2]8200
8000bb2c:	54 32       	ld.w %d2,[%a3]
8000bb2e:	37 32 02 27 	insert %d2,%d2,%d3,14,2
8000bb32:	d9 22 08 02 	lea %a2,[%a2]8200
8000bb36:	74 22       	st.w [%a2],%d2
    IfxPort_setPinControllerSelection(rxd1->pin.port, rxd1->pin.pinIndex);
8000bb38:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000bb3c:	b0 42       	add.a %a2,4
8000bb3e:	54 22       	ld.w %d2,[%a2]
8000bb40:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000bb44:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bb48:	02 34       	mov %d4,%d3
8000bb4a:	60 24       	mov.a %a4,%d2
8000bb4c:	6d ff 84 e7 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeInput(rxd1->pin.port, rxd1->pin.pinIndex, mode);
8000bb50:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000bb54:	b0 42       	add.a %a2,4
8000bb56:	54 23       	ld.w %d3,[%a2]
8000bb58:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000bb5c:	39 22 08 00 	ld.bu %d2,[%a2]8
8000bb60:	59 e3 e8 df 	st.w [%a14]-152,%d3
8000bb64:	e9 e2 e7 df 	st.b [%a14]-153,%d2
8000bb68:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000bb6c:	59 e2 e0 df 	st.w [%a14]-160,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000bb70:	39 e2 e7 df 	ld.bu %d2,[%a14]-153
8000bb74:	19 e3 e0 df 	ld.w %d3,[%a14]-160
8000bb78:	02 35       	mov %d5,%d3
8000bb7a:	02 24       	mov %d4,%d2
8000bb7c:	99 e4 e8 df 	ld.a %a4,[%a14]-152
8000bb80:	6d ff a7 e6 	call 800088ce <IfxPort_setPinMode>
}
8000bb84:	00 00       	nop 
    IfxPort_setPinPadDriver(rxd1->pin.port, rxd1->pin.pinIndex, speedGrade);
8000bb86:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000bb8a:	b0 42       	add.a %a2,4
8000bb8c:	54 22       	ld.w %d2,[%a2]
8000bb8e:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000bb92:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bb96:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000bb9a:	02 34       	mov %d4,%d3
8000bb9c:	60 24       	mov.a %a4,%d2
8000bb9e:	6d ff 0a e7 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Rxd_In *rxd2 = miiPins->rxd2;
8000bba2:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000bba6:	d9 22 20 00 	lea %a2,[%a2]32
8000bbaa:	54 22       	ld.w %d2,[%a2]
8000bbac:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    geth->gethSFR->GPCTL.B.ALTI8 = rxd2->select;
8000bbb0:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
8000bbb4:	d9 22 0c 00 	lea %a2,[%a2]12
8000bbb8:	54 22       	ld.w %d2,[%a2]
8000bbba:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000bbbe:	d4 22       	ld.a %a2,[%a2]
8000bbc0:	8f 32 00 21 	and %d2,%d2,3
8000bbc4:	8f f2 0f 31 	and %d3,%d2,255
8000bbc8:	d9 23 08 02 	lea %a3,[%a2]8200
8000bbcc:	54 32       	ld.w %d2,[%a3]
8000bbce:	37 32 02 28 	insert %d2,%d2,%d3,16,2
8000bbd2:	d9 22 08 02 	lea %a2,[%a2]8200
8000bbd6:	74 22       	st.w [%a2],%d2
    IfxPort_setPinControllerSelection(rxd2->pin.port, rxd2->pin.pinIndex);
8000bbd8:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
8000bbdc:	b0 42       	add.a %a2,4
8000bbde:	54 22       	ld.w %d2,[%a2]
8000bbe0:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
8000bbe4:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bbe8:	02 34       	mov %d4,%d3
8000bbea:	60 24       	mov.a %a4,%d2
8000bbec:	6d ff 34 e7 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeInput(rxd2->pin.port, rxd2->pin.pinIndex, mode);
8000bbf0:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
8000bbf4:	b0 42       	add.a %a2,4
8000bbf6:	54 23       	ld.w %d3,[%a2]
8000bbf8:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
8000bbfc:	39 22 08 00 	ld.bu %d2,[%a2]8
8000bc00:	59 e3 f4 df 	st.w [%a14]-140,%d3
8000bc04:	e9 e2 f3 df 	st.b [%a14]-141,%d2
8000bc08:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000bc0c:	59 e2 ec df 	st.w [%a14]-148,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000bc10:	39 e2 f3 df 	ld.bu %d2,[%a14]-141
8000bc14:	19 e3 ec df 	ld.w %d3,[%a14]-148
8000bc18:	02 35       	mov %d5,%d3
8000bc1a:	02 24       	mov %d4,%d2
8000bc1c:	99 e4 f4 df 	ld.a %a4,[%a14]-140
8000bc20:	6d ff 57 e6 	call 800088ce <IfxPort_setPinMode>
}
8000bc24:	00 00       	nop 
    IfxPort_setPinPadDriver(rxd2->pin.port, rxd2->pin.pinIndex, speedGrade);
8000bc26:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
8000bc2a:	b0 42       	add.a %a2,4
8000bc2c:	54 22       	ld.w %d2,[%a2]
8000bc2e:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
8000bc32:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bc36:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000bc3a:	02 34       	mov %d4,%d3
8000bc3c:	60 24       	mov.a %a4,%d2
8000bc3e:	6d ff ba e6 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Rxd_In *rxd3 = miiPins->rxd3;
8000bc42:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000bc46:	d9 22 24 00 	lea %a2,[%a2]36
8000bc4a:	54 22       	ld.w %d2,[%a2]
8000bc4c:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    geth->gethSFR->GPCTL.B.ALTI9 = rxd3->select;
8000bc50:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000bc54:	d9 22 0c 00 	lea %a2,[%a2]12
8000bc58:	54 22       	ld.w %d2,[%a2]
8000bc5a:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000bc5e:	d4 22       	ld.a %a2,[%a2]
8000bc60:	8f 32 00 21 	and %d2,%d2,3
8000bc64:	8f f2 0f 31 	and %d3,%d2,255
8000bc68:	d9 23 08 02 	lea %a3,[%a2]8200
8000bc6c:	54 32       	ld.w %d2,[%a3]
8000bc6e:	37 32 02 29 	insert %d2,%d2,%d3,18,2
8000bc72:	d9 22 08 02 	lea %a2,[%a2]8200
8000bc76:	74 22       	st.w [%a2],%d2
    IfxPort_setPinControllerSelection(rxd3->pin.port, rxd3->pin.pinIndex);
8000bc78:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000bc7c:	b0 42       	add.a %a2,4
8000bc7e:	54 22       	ld.w %d2,[%a2]
8000bc80:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000bc84:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bc88:	02 34       	mov %d4,%d3
8000bc8a:	60 24       	mov.a %a4,%d2
8000bc8c:	6d ff e4 e6 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeInput(rxd3->pin.port, rxd3->pin.pinIndex, mode);
8000bc90:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000bc94:	b0 42       	add.a %a2,4
8000bc96:	54 23       	ld.w %d3,[%a2]
8000bc98:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000bc9c:	39 22 08 00 	ld.bu %d2,[%a2]8
8000bca0:	59 e3 c0 ef 	st.w [%a14]-128,%d3
8000bca4:	e9 e2 ff df 	st.b [%a14]-129,%d2
8000bca8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000bcac:	59 e2 f8 df 	st.w [%a14]-136,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000bcb0:	39 e2 ff df 	ld.bu %d2,[%a14]-129
8000bcb4:	19 e3 f8 df 	ld.w %d3,[%a14]-136
8000bcb8:	02 35       	mov %d5,%d3
8000bcba:	02 24       	mov %d4,%d2
8000bcbc:	99 e4 c0 ef 	ld.a %a4,[%a14]-128
8000bcc0:	6d ff 07 e6 	call 800088ce <IfxPort_setPinMode>
}
8000bcc4:	00 00       	nop 
    IfxPort_setPinPadDriver(rxd3->pin.port, rxd3->pin.pinIndex, speedGrade);
8000bcc6:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000bcca:	b0 42       	add.a %a2,4
8000bccc:	54 22       	ld.w %d2,[%a2]
8000bcce:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000bcd2:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bcd6:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000bcda:	02 34       	mov %d4,%d3
8000bcdc:	60 24       	mov.a %a4,%d2
8000bcde:	6d ff 6a e6 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Mdio_InOut *mdio = miiPins->mdio;
8000bce2:	99 e2 c8 df 	ld.a %a2,[%a14]-184
8000bce6:	d9 22 04 10 	lea %a2,[%a2]68
8000bcea:	54 22       	ld.w %d2,[%a2]
8000bcec:	59 e2 cc ff 	st.w [%a14]-52,%d2
    geth->gethSFR->GPCTL.B.ALTI0 = mdio->inSelect;
8000bcf0:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000bcf4:	d9 22 0c 00 	lea %a2,[%a2]12
8000bcf8:	54 22       	ld.w %d2,[%a2]
8000bcfa:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000bcfe:	d4 22       	ld.a %a2,[%a2]
8000bd00:	8f 32 00 21 	and %d2,%d2,3
8000bd04:	8f f2 0f 31 	and %d3,%d2,255
8000bd08:	d9 23 08 02 	lea %a3,[%a2]8200
8000bd0c:	54 32       	ld.w %d2,[%a3]
8000bd0e:	37 32 02 20 	insert %d2,%d2,%d3,0,2
8000bd12:	d9 22 08 02 	lea %a2,[%a2]8200
8000bd16:	74 22       	st.w [%a2],%d2
}
8000bd18:	00 00       	nop 
8000bd1a:	00 90       	ret 

8000bd1c <IfxGeth_Eth_setupMiiOutputPins>:


void IfxGeth_Eth_setupMiiOutputPins(IfxGeth_Eth *geth, const IfxGeth_Eth_MiiPins *miiPins)
{
8000bd1c:	40 ae       	mov.aa %a14,%sp
8000bd1e:	20 a0       	sub.a %sp,160
8000bd20:	b5 e4 e4 df 	st.a [%a14]-156,%a4
8000bd24:	b5 e5 e0 df 	st.a [%a14]-160,%a5
    IFX_UNUSED_PARAMETER(geth);
    IfxPort_OutputMode mode       = IfxPort_OutputMode_pushPull;
8000bd28:	3b 00 08 20 	mov %d2,128
8000bd2c:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxPort_PadDriver  speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed1;
8000bd30:	82 02       	mov %d2,0
8000bd32:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    IfxGeth_Txen_Out  *txEn       = miiPins->txEn;
8000bd36:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000bd3a:	d9 22 28 00 	lea %a2,[%a2]40
8000bd3e:	54 22       	ld.w %d2,[%a2]
8000bd40:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    IfxPort_setPinControllerSelection(txEn->pin.port, txEn->pin.pinIndex);
8000bd44:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000bd48:	b0 42       	add.a %a2,4
8000bd4a:	54 22       	ld.w %d2,[%a2]
8000bd4c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000bd50:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bd54:	02 34       	mov %d4,%d3
8000bd56:	60 24       	mov.a %a4,%d2
8000bd58:	6d ff 7e e6 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeOutput(txEn->pin.port, txEn->pin.pinIndex, mode, txEn->select);
8000bd5c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000bd60:	b0 42       	add.a %a2,4
8000bd62:	54 24       	ld.w %d4,[%a2]
8000bd64:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000bd68:	39 22 08 00 	ld.bu %d2,[%a2]8
8000bd6c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000bd70:	d9 22 0c 00 	lea %a2,[%a2]12
8000bd74:	54 23       	ld.w %d3,[%a2]
8000bd76:	59 e4 d8 ff 	st.w [%a14]-40,%d4
8000bd7a:	e9 e2 d7 ff 	st.b [%a14]-41,%d2
8000bd7e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000bd82:	59 e2 d0 ff 	st.w [%a14]-48,%d2
8000bd86:	59 e3 cc ff 	st.w [%a14]-52,%d3


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000bd8a:	39 e3 d7 ff 	ld.bu %d3,[%a14]-41
8000bd8e:	19 e4 d0 ff 	ld.w %d4,[%a14]-48
8000bd92:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8000bd96:	a6 42       	or %d2,%d4
8000bd98:	02 25       	mov %d5,%d2
8000bd9a:	02 34       	mov %d4,%d3
8000bd9c:	99 e4 d8 ff 	ld.a %a4,[%a14]-40
8000bda0:	6d ff 97 e5 	call 800088ce <IfxPort_setPinMode>
}
8000bda4:	00 00       	nop 
    IfxPort_setPinPadDriver(txEn->pin.port, txEn->pin.pinIndex, speedGrade);
8000bda6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000bdaa:	b0 42       	add.a %a2,4
8000bdac:	54 22       	ld.w %d2,[%a2]
8000bdae:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000bdb2:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bdb6:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000bdba:	02 34       	mov %d4,%d3
8000bdbc:	60 24       	mov.a %a4,%d2
8000bdbe:	6d ff fa e5 	call 800089b2 <IfxPort_setPinPadDriver>

    /* Check for Mii Lite mode */
    if (miiPins->txEr != NULL_PTR)
8000bdc2:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000bdc6:	d9 22 2c 00 	lea %a2,[%a2]44
8000bdca:	54 22       	ld.w %d2,[%a2]
8000bdcc:	df 02 48 00 	jeq %d2,0,8000be5c <IfxGeth_Eth_setupMiiOutputPins+0x140>
    {
        IfxGeth_Txer_Out *txEr = miiPins->txEr;
8000bdd0:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000bdd4:	d9 22 2c 00 	lea %a2,[%a2]44
8000bdd8:	54 22       	ld.w %d2,[%a2]
8000bdda:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        IfxPort_setPinControllerSelection(txEr->pin.port, txEr->pin.pinIndex);
8000bdde:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000bde2:	b0 42       	add.a %a2,4
8000bde4:	54 22       	ld.w %d2,[%a2]
8000bde6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000bdea:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bdee:	02 34       	mov %d4,%d3
8000bdf0:	60 24       	mov.a %a4,%d2
8000bdf2:	6d ff 31 e6 	call 80008a54 <IfxPort_setPinControllerSelection>
        IfxPort_setPinModeOutput(txEr->pin.port, txEr->pin.pinIndex, mode, txEr->select);
8000bdf6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000bdfa:	b0 42       	add.a %a2,4
8000bdfc:	54 24       	ld.w %d4,[%a2]
8000bdfe:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000be02:	39 22 08 00 	ld.bu %d2,[%a2]8
8000be06:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000be0a:	d9 22 0c 00 	lea %a2,[%a2]12
8000be0e:	54 23       	ld.w %d3,[%a2]
8000be10:	59 e4 c8 ff 	st.w [%a14]-56,%d4
8000be14:	e9 e2 c7 ff 	st.b [%a14]-57,%d2
8000be18:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000be1c:	59 e2 c0 ff 	st.w [%a14]-64,%d2
8000be20:	59 e3 fc ef 	st.w [%a14]-68,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000be24:	39 e3 c7 ff 	ld.bu %d3,[%a14]-57
8000be28:	19 e4 c0 ff 	ld.w %d4,[%a14]-64
8000be2c:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000be30:	a6 42       	or %d2,%d4
8000be32:	02 25       	mov %d5,%d2
8000be34:	02 34       	mov %d4,%d3
8000be36:	99 e4 c8 ff 	ld.a %a4,[%a14]-56
8000be3a:	6d ff 4a e5 	call 800088ce <IfxPort_setPinMode>
}
8000be3e:	00 00       	nop 
        IfxPort_setPinPadDriver(txEr->pin.port, txEr->pin.pinIndex, speedGrade);
8000be40:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000be44:	b0 42       	add.a %a2,4
8000be46:	54 22       	ld.w %d2,[%a2]
8000be48:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000be4c:	39 23 08 00 	ld.bu %d3,[%a2]8
8000be50:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000be54:	02 34       	mov %d4,%d3
8000be56:	60 24       	mov.a %a4,%d2
8000be58:	6d ff ad e5 	call 800089b2 <IfxPort_setPinPadDriver>
    }

    IfxGeth_Txd_Out *txd0 = miiPins->txd0;
8000be5c:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000be60:	d9 22 30 00 	lea %a2,[%a2]48
8000be64:	54 22       	ld.w %d2,[%a2]
8000be66:	59 e2 ec ff 	st.w [%a14]-20,%d2
    IfxPort_setPinControllerSelection(txd0->pin.port, txd0->pin.pinIndex);
8000be6a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000be6e:	b0 42       	add.a %a2,4
8000be70:	54 22       	ld.w %d2,[%a2]
8000be72:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000be76:	39 23 08 00 	ld.bu %d3,[%a2]8
8000be7a:	02 34       	mov %d4,%d3
8000be7c:	60 24       	mov.a %a4,%d2
8000be7e:	6d ff eb e5 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeOutput(txd0->pin.port, txd0->pin.pinIndex, mode, txd0->select);
8000be82:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000be86:	b0 42       	add.a %a2,4
8000be88:	54 24       	ld.w %d4,[%a2]
8000be8a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000be8e:	39 22 08 00 	ld.bu %d2,[%a2]8
8000be92:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000be96:	d9 22 0c 00 	lea %a2,[%a2]12
8000be9a:	54 23       	ld.w %d3,[%a2]
8000be9c:	59 e4 f8 df 	st.w [%a14]-136,%d4
8000bea0:	e9 e2 f7 df 	st.b [%a14]-137,%d2
8000bea4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000bea8:	59 e2 f0 df 	st.w [%a14]-144,%d2
8000beac:	59 e3 ec df 	st.w [%a14]-148,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000beb0:	39 e3 f7 df 	ld.bu %d3,[%a14]-137
8000beb4:	19 e4 f0 df 	ld.w %d4,[%a14]-144
8000beb8:	19 e2 ec df 	ld.w %d2,[%a14]-148
8000bebc:	a6 42       	or %d2,%d4
8000bebe:	02 25       	mov %d5,%d2
8000bec0:	02 34       	mov %d4,%d3
8000bec2:	99 e4 f8 df 	ld.a %a4,[%a14]-136
8000bec6:	6d ff 04 e5 	call 800088ce <IfxPort_setPinMode>
}
8000beca:	00 00       	nop 
    IfxPort_setPinPadDriver(txd0->pin.port, txd0->pin.pinIndex, speedGrade);
8000becc:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000bed0:	b0 42       	add.a %a2,4
8000bed2:	54 22       	ld.w %d2,[%a2]
8000bed4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000bed8:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bedc:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000bee0:	02 34       	mov %d4,%d3
8000bee2:	60 24       	mov.a %a4,%d2
8000bee4:	6d ff 67 e5 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Txd_Out *txd1 = miiPins->txd1;
8000bee8:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000beec:	d9 22 34 00 	lea %a2,[%a2]52
8000bef0:	54 22       	ld.w %d2,[%a2]
8000bef2:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    IfxPort_setPinControllerSelection(txd1->pin.port, txd1->pin.pinIndex);
8000bef6:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000befa:	b0 42       	add.a %a2,4
8000befc:	54 22       	ld.w %d2,[%a2]
8000befe:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000bf02:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bf06:	02 34       	mov %d4,%d3
8000bf08:	60 24       	mov.a %a4,%d2
8000bf0a:	6d ff a5 e5 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeOutput(txd1->pin.port, txd1->pin.pinIndex, mode, txd1->select);
8000bf0e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000bf12:	b0 42       	add.a %a2,4
8000bf14:	54 24       	ld.w %d4,[%a2]
8000bf16:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000bf1a:	39 22 08 00 	ld.bu %d2,[%a2]8
8000bf1e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000bf22:	d9 22 0c 00 	lea %a2,[%a2]12
8000bf26:	54 23       	ld.w %d3,[%a2]
8000bf28:	59 e4 c8 ef 	st.w [%a14]-120,%d4
8000bf2c:	e9 e2 c7 ef 	st.b [%a14]-121,%d2
8000bf30:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000bf34:	59 e2 c0 ef 	st.w [%a14]-128,%d2
8000bf38:	59 e3 fc df 	st.w [%a14]-132,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000bf3c:	39 e3 c7 ef 	ld.bu %d3,[%a14]-121
8000bf40:	19 e4 c0 ef 	ld.w %d4,[%a14]-128
8000bf44:	19 e2 fc df 	ld.w %d2,[%a14]-132
8000bf48:	a6 42       	or %d2,%d4
8000bf4a:	02 25       	mov %d5,%d2
8000bf4c:	02 34       	mov %d4,%d3
8000bf4e:	99 e4 c8 ef 	ld.a %a4,[%a14]-120
8000bf52:	6d ff be e4 	call 800088ce <IfxPort_setPinMode>
}
8000bf56:	00 00       	nop 
    IfxPort_setPinPadDriver(txd1->pin.port, txd1->pin.pinIndex, speedGrade);
8000bf58:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000bf5c:	b0 42       	add.a %a2,4
8000bf5e:	54 22       	ld.w %d2,[%a2]
8000bf60:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000bf64:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bf68:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000bf6c:	02 34       	mov %d4,%d3
8000bf6e:	60 24       	mov.a %a4,%d2
8000bf70:	6d ff 21 e5 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Txd_Out *txd2 = miiPins->txd2;
8000bf74:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000bf78:	d9 22 38 00 	lea %a2,[%a2]56
8000bf7c:	54 22       	ld.w %d2,[%a2]
8000bf7e:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    IfxPort_setPinControllerSelection(txd2->pin.port, txd2->pin.pinIndex);
8000bf82:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000bf86:	b0 42       	add.a %a2,4
8000bf88:	54 22       	ld.w %d2,[%a2]
8000bf8a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000bf8e:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bf92:	02 34       	mov %d4,%d3
8000bf94:	60 24       	mov.a %a4,%d2
8000bf96:	6d ff 5f e5 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeOutput(txd2->pin.port, txd2->pin.pinIndex, mode, txd2->select);
8000bf9a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000bf9e:	b0 42       	add.a %a2,4
8000bfa0:	54 24       	ld.w %d4,[%a2]
8000bfa2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000bfa6:	39 22 08 00 	ld.bu %d2,[%a2]8
8000bfaa:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000bfae:	d9 22 0c 00 	lea %a2,[%a2]12
8000bfb2:	54 23       	ld.w %d3,[%a2]
8000bfb4:	59 e4 d8 ef 	st.w [%a14]-104,%d4
8000bfb8:	e9 e2 d7 ef 	st.b [%a14]-105,%d2
8000bfbc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000bfc0:	59 e2 d0 ef 	st.w [%a14]-112,%d2
8000bfc4:	59 e3 cc ef 	st.w [%a14]-116,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000bfc8:	39 e3 d7 ef 	ld.bu %d3,[%a14]-105
8000bfcc:	19 e4 d0 ef 	ld.w %d4,[%a14]-112
8000bfd0:	19 e2 cc ef 	ld.w %d2,[%a14]-116
8000bfd4:	a6 42       	or %d2,%d4
8000bfd6:	02 25       	mov %d5,%d2
8000bfd8:	02 34       	mov %d4,%d3
8000bfda:	99 e4 d8 ef 	ld.a %a4,[%a14]-104
8000bfde:	6d ff 78 e4 	call 800088ce <IfxPort_setPinMode>
}
8000bfe2:	00 00       	nop 
    IfxPort_setPinPadDriver(txd2->pin.port, txd2->pin.pinIndex, speedGrade);
8000bfe4:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000bfe8:	b0 42       	add.a %a2,4
8000bfea:	54 22       	ld.w %d2,[%a2]
8000bfec:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000bff0:	39 23 08 00 	ld.bu %d3,[%a2]8
8000bff4:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000bff8:	02 34       	mov %d4,%d3
8000bffa:	60 24       	mov.a %a4,%d2
8000bffc:	6d ff db e4 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Txd_Out *txd3 = miiPins->txd3;
8000c000:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c004:	d9 22 3c 00 	lea %a2,[%a2]60
8000c008:	54 22       	ld.w %d2,[%a2]
8000c00a:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    IfxPort_setPinControllerSelection(txd3->pin.port, txd3->pin.pinIndex);
8000c00e:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c012:	b0 42       	add.a %a2,4
8000c014:	54 22       	ld.w %d2,[%a2]
8000c016:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c01a:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c01e:	02 34       	mov %d4,%d3
8000c020:	60 24       	mov.a %a4,%d2
8000c022:	6d ff 19 e5 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeOutput(txd3->pin.port, txd3->pin.pinIndex, mode, txd3->select);
8000c026:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c02a:	b0 42       	add.a %a2,4
8000c02c:	54 24       	ld.w %d4,[%a2]
8000c02e:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c032:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c036:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c03a:	d9 22 0c 00 	lea %a2,[%a2]12
8000c03e:	54 23       	ld.w %d3,[%a2]
8000c040:	59 e4 e8 ef 	st.w [%a14]-88,%d4
8000c044:	e9 e2 e7 ef 	st.b [%a14]-89,%d2
8000c048:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c04c:	59 e2 e0 ef 	st.w [%a14]-96,%d2
8000c050:	59 e3 dc ef 	st.w [%a14]-100,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c054:	39 e3 e7 ef 	ld.bu %d3,[%a14]-89
8000c058:	19 e4 e0 ef 	ld.w %d4,[%a14]-96
8000c05c:	19 e2 dc ef 	ld.w %d2,[%a14]-100
8000c060:	a6 42       	or %d2,%d4
8000c062:	02 25       	mov %d5,%d2
8000c064:	02 34       	mov %d4,%d3
8000c066:	99 e4 e8 ef 	ld.a %a4,[%a14]-88
8000c06a:	6d ff 32 e4 	call 800088ce <IfxPort_setPinMode>
}
8000c06e:	00 00       	nop 
    IfxPort_setPinPadDriver(txd3->pin.port, txd3->pin.pinIndex, speedGrade);
8000c070:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c074:	b0 42       	add.a %a2,4
8000c076:	54 22       	ld.w %d2,[%a2]
8000c078:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c07c:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c080:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c084:	02 34       	mov %d4,%d3
8000c086:	60 24       	mov.a %a4,%d2
8000c088:	6d ff 95 e4 	call 800089b2 <IfxPort_setPinPadDriver>

    IfxGeth_Mdc_Out *mdc = miiPins->mdc;
8000c08c:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c090:	d9 22 00 10 	lea %a2,[%a2]64
8000c094:	54 22       	ld.w %d2,[%a2]
8000c096:	59 e2 dc ff 	st.w [%a14]-36,%d2
    IfxPort_setPinControllerSelection(mdc->pin.port, mdc->pin.pinIndex);
8000c09a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c09e:	b0 42       	add.a %a2,4
8000c0a0:	54 22       	ld.w %d2,[%a2]
8000c0a2:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c0a6:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c0aa:	02 34       	mov %d4,%d3
8000c0ac:	60 24       	mov.a %a4,%d2
8000c0ae:	6d ff d3 e4 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, mode, mdc->select);
8000c0b2:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c0b6:	b0 42       	add.a %a2,4
8000c0b8:	54 24       	ld.w %d4,[%a2]
8000c0ba:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c0be:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c0c2:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c0c6:	d9 22 0c 00 	lea %a2,[%a2]12
8000c0ca:	54 23       	ld.w %d3,[%a2]
8000c0cc:	59 e4 f8 ef 	st.w [%a14]-72,%d4
8000c0d0:	e9 e2 f7 ef 	st.b [%a14]-73,%d2
8000c0d4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c0d8:	59 e2 f0 ef 	st.w [%a14]-80,%d2
8000c0dc:	59 e3 ec ef 	st.w [%a14]-84,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c0e0:	39 e3 f7 ef 	ld.bu %d3,[%a14]-73
8000c0e4:	19 e4 f0 ef 	ld.w %d4,[%a14]-80
8000c0e8:	19 e2 ec ef 	ld.w %d2,[%a14]-84
8000c0ec:	a6 42       	or %d2,%d4
8000c0ee:	02 25       	mov %d5,%d2
8000c0f0:	02 34       	mov %d4,%d3
8000c0f2:	99 e4 f8 ef 	ld.a %a4,[%a14]-72
8000c0f6:	6d ff ec e3 	call 800088ce <IfxPort_setPinMode>
}
8000c0fa:	00 00       	nop 
    IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, speedGrade);
8000c0fc:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c100:	b0 42       	add.a %a2,4
8000c102:	54 22       	ld.w %d2,[%a2]
8000c104:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c108:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c10c:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c110:	02 34       	mov %d4,%d3
8000c112:	60 24       	mov.a %a4,%d2
8000c114:	6d ff 4f e4 	call 800089b2 <IfxPort_setPinPadDriver>
}
8000c118:	00 00       	nop 
8000c11a:	00 90       	ret 

8000c11c <IfxGeth_Eth_setupRgmiiInputPins>:


void IfxGeth_Eth_setupRgmiiInputPins(IfxGeth_Eth *geth, const IfxGeth_Eth_RgmiiPins *rgmiiPins)
{
8000c11c:	40 ae       	mov.aa %a14,%sp
8000c11e:	20 88       	sub.a %sp,136
8000c120:	b5 e4 fc df 	st.a [%a14]-132,%a4
8000c124:	b5 e5 f8 df 	st.a [%a14]-136,%a5
    IfxPort_InputMode   mode       = IfxPort_InputMode_noPullDevice;
8000c128:	82 02       	mov %d2,0
8000c12a:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxPort_PadDriver   speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed4;
8000c12e:	82 32       	mov %d2,3
8000c130:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    IfxGeth_Rxclk_In   *rxClk      = rgmiiPins->rxClk;
8000c134:	99 e2 f8 df 	ld.a %a2,[%a14]-136
8000c138:	d9 22 18 00 	lea %a2,[%a2]24
8000c13c:	54 22       	ld.w %d2,[%a2]
8000c13e:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    IfxGeth_Rxctl_In   *rxCtl      = rgmiiPins->rxCtl;
8000c142:	99 e2 f8 df 	ld.a %a2,[%a14]-136
8000c146:	d9 22 2c 00 	lea %a2,[%a2]44
8000c14a:	54 22       	ld.w %d2,[%a2]
8000c14c:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    IfxGeth_Rxd_In     *rxd0       = rgmiiPins->rxd0;
8000c150:	99 e2 f8 df 	ld.a %a2,[%a14]-136
8000c154:	d9 22 1c 00 	lea %a2,[%a2]28
8000c158:	54 22       	ld.w %d2,[%a2]
8000c15a:	59 e2 ec ff 	st.w [%a14]-20,%d2
    IfxGeth_Rxd_In     *rxd1       = rgmiiPins->rxd1;
8000c15e:	99 e2 f8 df 	ld.a %a2,[%a14]-136
8000c162:	d9 22 20 00 	lea %a2,[%a2]32
8000c166:	54 22       	ld.w %d2,[%a2]
8000c168:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    IfxGeth_Rxd_In     *rxd2       = rgmiiPins->rxd2;
8000c16c:	99 e2 f8 df 	ld.a %a2,[%a14]-136
8000c170:	d9 22 24 00 	lea %a2,[%a2]36
8000c174:	54 22       	ld.w %d2,[%a2]
8000c176:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    IfxGeth_Rxd_In     *rxd3       = rgmiiPins->rxd3;
8000c17a:	99 e2 f8 df 	ld.a %a2,[%a14]-136
8000c17e:	d9 22 28 00 	lea %a2,[%a2]40
8000c182:	54 22       	ld.w %d2,[%a2]
8000c184:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    IfxGeth_Grefclk_In *grefClk    = rgmiiPins->grefClk;
8000c188:	99 e2 f8 df 	ld.a %a2,[%a14]-136
8000c18c:	d9 22 38 00 	lea %a2,[%a2]56
8000c190:	54 22       	ld.w %d2,[%a2]
8000c192:	59 e2 dc ff 	st.w [%a14]-36,%d2
    IfxGeth_Mdio_InOut *mdio       = rgmiiPins->mdio;
8000c196:	99 e2 f8 df 	ld.a %a2,[%a14]-136
8000c19a:	d9 22 34 00 	lea %a2,[%a2]52
8000c19e:	54 22       	ld.w %d2,[%a2]
8000c1a0:	59 e2 d8 ff 	st.w [%a14]-40,%d2

    geth->gethSFR->GPCTL.B.ALTI0 = mdio->inSelect;
8000c1a4:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000c1a8:	d9 22 0c 00 	lea %a2,[%a2]12
8000c1ac:	54 22       	ld.w %d2,[%a2]
8000c1ae:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000c1b2:	d4 22       	ld.a %a2,[%a2]
8000c1b4:	8f 32 00 21 	and %d2,%d2,3
8000c1b8:	8f f2 0f 31 	and %d3,%d2,255
8000c1bc:	d9 23 08 02 	lea %a3,[%a2]8200
8000c1c0:	54 32       	ld.w %d2,[%a3]
8000c1c2:	37 32 02 20 	insert %d2,%d2,%d3,0,2
8000c1c6:	d9 22 08 02 	lea %a2,[%a2]8200
8000c1ca:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI1 = rxClk->select;
8000c1cc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c1d0:	d9 22 0c 00 	lea %a2,[%a2]12
8000c1d4:	54 22       	ld.w %d2,[%a2]
8000c1d6:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000c1da:	d4 22       	ld.a %a2,[%a2]
8000c1dc:	8f 32 00 21 	and %d2,%d2,3
8000c1e0:	8f f2 0f 31 	and %d3,%d2,255
8000c1e4:	d9 23 08 02 	lea %a3,[%a2]8200
8000c1e8:	54 32       	ld.w %d2,[%a3]
8000c1ea:	37 32 02 21 	insert %d2,%d2,%d3,2,2
8000c1ee:	d9 22 08 02 	lea %a2,[%a2]8200
8000c1f2:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI4 = rxCtl->select;
8000c1f4:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c1f8:	d9 22 0c 00 	lea %a2,[%a2]12
8000c1fc:	54 22       	ld.w %d2,[%a2]
8000c1fe:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000c202:	d4 22       	ld.a %a2,[%a2]
8000c204:	8f 32 00 21 	and %d2,%d2,3
8000c208:	8f f2 0f 31 	and %d3,%d2,255
8000c20c:	d9 23 08 02 	lea %a3,[%a2]8200
8000c210:	54 32       	ld.w %d2,[%a3]
8000c212:	37 32 02 24 	insert %d2,%d2,%d3,8,2
8000c216:	d9 22 08 02 	lea %a2,[%a2]8200
8000c21a:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI6 = rxd0->select;
8000c21c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c220:	d9 22 0c 00 	lea %a2,[%a2]12
8000c224:	54 22       	ld.w %d2,[%a2]
8000c226:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000c22a:	d4 22       	ld.a %a2,[%a2]
8000c22c:	8f 32 00 21 	and %d2,%d2,3
8000c230:	8f f2 0f 31 	and %d3,%d2,255
8000c234:	d9 23 08 02 	lea %a3,[%a2]8200
8000c238:	54 32       	ld.w %d2,[%a3]
8000c23a:	37 32 02 26 	insert %d2,%d2,%d3,12,2
8000c23e:	d9 22 08 02 	lea %a2,[%a2]8200
8000c242:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI7 = rxd1->select;
8000c244:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c248:	d9 22 0c 00 	lea %a2,[%a2]12
8000c24c:	54 22       	ld.w %d2,[%a2]
8000c24e:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000c252:	d4 22       	ld.a %a2,[%a2]
8000c254:	8f 32 00 21 	and %d2,%d2,3
8000c258:	8f f2 0f 31 	and %d3,%d2,255
8000c25c:	d9 23 08 02 	lea %a3,[%a2]8200
8000c260:	54 32       	ld.w %d2,[%a3]
8000c262:	37 32 02 27 	insert %d2,%d2,%d3,14,2
8000c266:	d9 22 08 02 	lea %a2,[%a2]8200
8000c26a:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI8 = rxd2->select;
8000c26c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c270:	d9 22 0c 00 	lea %a2,[%a2]12
8000c274:	54 22       	ld.w %d2,[%a2]
8000c276:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000c27a:	d4 22       	ld.a %a2,[%a2]
8000c27c:	8f 32 00 21 	and %d2,%d2,3
8000c280:	8f f2 0f 31 	and %d3,%d2,255
8000c284:	d9 23 08 02 	lea %a3,[%a2]8200
8000c288:	54 32       	ld.w %d2,[%a3]
8000c28a:	37 32 02 28 	insert %d2,%d2,%d3,16,2
8000c28e:	d9 22 08 02 	lea %a2,[%a2]8200
8000c292:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI9 = rxd3->select;
8000c294:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c298:	d9 22 0c 00 	lea %a2,[%a2]12
8000c29c:	54 22       	ld.w %d2,[%a2]
8000c29e:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000c2a2:	d4 22       	ld.a %a2,[%a2]
8000c2a4:	8f 32 00 21 	and %d2,%d2,3
8000c2a8:	8f f2 0f 31 	and %d3,%d2,255
8000c2ac:	d9 23 08 02 	lea %a3,[%a2]8200
8000c2b0:	54 32       	ld.w %d2,[%a3]
8000c2b2:	37 32 02 29 	insert %d2,%d2,%d3,18,2
8000c2b6:	d9 22 08 02 	lea %a2,[%a2]8200
8000c2ba:	74 22       	st.w [%a2],%d2

    IfxPort_setPinControllerSelection(rxClk->pin.port, rxClk->pin.pinIndex);
8000c2bc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c2c0:	b0 42       	add.a %a2,4
8000c2c2:	54 22       	ld.w %d2,[%a2]
8000c2c4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c2c8:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c2cc:	02 34       	mov %d4,%d3
8000c2ce:	60 24       	mov.a %a4,%d2
8000c2d0:	6d ff c2 e3 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(rxCtl->pin.port, rxCtl->pin.pinIndex);
8000c2d4:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c2d8:	b0 42       	add.a %a2,4
8000c2da:	54 22       	ld.w %d2,[%a2]
8000c2dc:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c2e0:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c2e4:	02 34       	mov %d4,%d3
8000c2e6:	60 24       	mov.a %a4,%d2
8000c2e8:	6d ff b6 e3 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(rxd0->pin.port, rxd0->pin.pinIndex);
8000c2ec:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c2f0:	b0 42       	add.a %a2,4
8000c2f2:	54 22       	ld.w %d2,[%a2]
8000c2f4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c2f8:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c2fc:	02 34       	mov %d4,%d3
8000c2fe:	60 24       	mov.a %a4,%d2
8000c300:	6d ff aa e3 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(rxd1->pin.port, rxd1->pin.pinIndex);
8000c304:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c308:	b0 42       	add.a %a2,4
8000c30a:	54 22       	ld.w %d2,[%a2]
8000c30c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c310:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c314:	02 34       	mov %d4,%d3
8000c316:	60 24       	mov.a %a4,%d2
8000c318:	6d ff 9e e3 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(rxd2->pin.port, rxd2->pin.pinIndex);
8000c31c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c320:	b0 42       	add.a %a2,4
8000c322:	54 22       	ld.w %d2,[%a2]
8000c324:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c328:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c32c:	02 34       	mov %d4,%d3
8000c32e:	60 24       	mov.a %a4,%d2
8000c330:	6d ff 92 e3 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(rxd3->pin.port, rxd3->pin.pinIndex);
8000c334:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c338:	b0 42       	add.a %a2,4
8000c33a:	54 22       	ld.w %d2,[%a2]
8000c33c:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c340:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c344:	02 34       	mov %d4,%d3
8000c346:	60 24       	mov.a %a4,%d2
8000c348:	6d ff 86 e3 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(grefClk->pin.port, grefClk->pin.pinIndex);
8000c34c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c350:	b0 42       	add.a %a2,4
8000c352:	54 22       	ld.w %d2,[%a2]
8000c354:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c358:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c35c:	02 34       	mov %d4,%d3
8000c35e:	60 24       	mov.a %a4,%d2
8000c360:	6d ff 7a e3 	call 80008a54 <IfxPort_setPinControllerSelection>

    IfxPort_setPinModeInput(rxClk->pin.port, rxClk->pin.pinIndex, mode);
8000c364:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c368:	b0 42       	add.a %a2,4
8000c36a:	54 23       	ld.w %d3,[%a2]
8000c36c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c370:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c374:	59 e3 cc ef 	st.w [%a14]-116,%d3
8000c378:	e9 e2 cb ef 	st.b [%a14]-117,%d2
8000c37c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c380:	59 e2 c4 ef 	st.w [%a14]-124,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000c384:	39 e2 cb ef 	ld.bu %d2,[%a14]-117
8000c388:	19 e3 c4 ef 	ld.w %d3,[%a14]-124
8000c38c:	02 35       	mov %d5,%d3
8000c38e:	02 24       	mov %d4,%d2
8000c390:	99 e4 cc ef 	ld.a %a4,[%a14]-116
8000c394:	6d ff 9d e2 	call 800088ce <IfxPort_setPinMode>
}
8000c398:	00 00       	nop 
    IfxPort_setPinModeInput(rxCtl->pin.port, rxCtl->pin.pinIndex, mode);
8000c39a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c39e:	b0 42       	add.a %a2,4
8000c3a0:	54 23       	ld.w %d3,[%a2]
8000c3a2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c3a6:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c3aa:	59 e3 d8 ef 	st.w [%a14]-104,%d3
8000c3ae:	e9 e2 d7 ef 	st.b [%a14]-105,%d2
8000c3b2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c3b6:	59 e2 d0 ef 	st.w [%a14]-112,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000c3ba:	39 e2 d7 ef 	ld.bu %d2,[%a14]-105
8000c3be:	19 e3 d0 ef 	ld.w %d3,[%a14]-112
8000c3c2:	02 35       	mov %d5,%d3
8000c3c4:	02 24       	mov %d4,%d2
8000c3c6:	99 e4 d8 ef 	ld.a %a4,[%a14]-104
8000c3ca:	6d ff 82 e2 	call 800088ce <IfxPort_setPinMode>
}
8000c3ce:	00 00       	nop 
    IfxPort_setPinModeInput(rxd0->pin.port, rxd0->pin.pinIndex, mode);
8000c3d0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c3d4:	b0 42       	add.a %a2,4
8000c3d6:	54 23       	ld.w %d3,[%a2]
8000c3d8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c3dc:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c3e0:	59 e3 e4 ef 	st.w [%a14]-92,%d3
8000c3e4:	e9 e2 e3 ef 	st.b [%a14]-93,%d2
8000c3e8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c3ec:	59 e2 dc ef 	st.w [%a14]-100,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000c3f0:	39 e2 e3 ef 	ld.bu %d2,[%a14]-93
8000c3f4:	19 e3 dc ef 	ld.w %d3,[%a14]-100
8000c3f8:	02 35       	mov %d5,%d3
8000c3fa:	02 24       	mov %d4,%d2
8000c3fc:	99 e4 e4 ef 	ld.a %a4,[%a14]-92
8000c400:	6d ff 67 e2 	call 800088ce <IfxPort_setPinMode>
}
8000c404:	00 00       	nop 
    IfxPort_setPinModeInput(rxd1->pin.port, rxd1->pin.pinIndex, mode);
8000c406:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c40a:	b0 42       	add.a %a2,4
8000c40c:	54 23       	ld.w %d3,[%a2]
8000c40e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c412:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c416:	59 e3 f0 ef 	st.w [%a14]-80,%d3
8000c41a:	e9 e2 ef ef 	st.b [%a14]-81,%d2
8000c41e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c422:	59 e2 e8 ef 	st.w [%a14]-88,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000c426:	39 e2 ef ef 	ld.bu %d2,[%a14]-81
8000c42a:	19 e3 e8 ef 	ld.w %d3,[%a14]-88
8000c42e:	02 35       	mov %d5,%d3
8000c430:	02 24       	mov %d4,%d2
8000c432:	99 e4 f0 ef 	ld.a %a4,[%a14]-80
8000c436:	6d ff 4c e2 	call 800088ce <IfxPort_setPinMode>
}
8000c43a:	00 00       	nop 
    IfxPort_setPinModeInput(rxd2->pin.port, rxd2->pin.pinIndex, mode);
8000c43c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c440:	b0 42       	add.a %a2,4
8000c442:	54 23       	ld.w %d3,[%a2]
8000c444:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c448:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c44c:	59 e3 fc ef 	st.w [%a14]-68,%d3
8000c450:	e9 e2 fb ef 	st.b [%a14]-69,%d2
8000c454:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c458:	59 e2 f4 ef 	st.w [%a14]-76,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000c45c:	39 e2 fb ef 	ld.bu %d2,[%a14]-69
8000c460:	19 e3 f4 ef 	ld.w %d3,[%a14]-76
8000c464:	02 35       	mov %d5,%d3
8000c466:	02 24       	mov %d4,%d2
8000c468:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000c46c:	6d ff 31 e2 	call 800088ce <IfxPort_setPinMode>
}
8000c470:	00 00       	nop 
    IfxPort_setPinModeInput(rxd3->pin.port, rxd3->pin.pinIndex, mode);
8000c472:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c476:	b0 42       	add.a %a2,4
8000c478:	54 23       	ld.w %d3,[%a2]
8000c47a:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c47e:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c482:	59 e3 c8 ff 	st.w [%a14]-56,%d3
8000c486:	e9 e2 c7 ff 	st.b [%a14]-57,%d2
8000c48a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c48e:	59 e2 c0 ff 	st.w [%a14]-64,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000c492:	39 e2 c7 ff 	ld.bu %d2,[%a14]-57
8000c496:	19 e3 c0 ff 	ld.w %d3,[%a14]-64
8000c49a:	02 35       	mov %d5,%d3
8000c49c:	02 24       	mov %d4,%d2
8000c49e:	99 e4 c8 ff 	ld.a %a4,[%a14]-56
8000c4a2:	6d ff 16 e2 	call 800088ce <IfxPort_setPinMode>
}
8000c4a6:	00 00       	nop 
    IfxPort_setPinModeInput(grefClk->pin.port, grefClk->pin.pinIndex, mode);
8000c4a8:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c4ac:	b0 42       	add.a %a2,4
8000c4ae:	54 23       	ld.w %d3,[%a2]
8000c4b0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c4b4:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c4b8:	59 e3 d4 ff 	st.w [%a14]-44,%d3
8000c4bc:	e9 e2 d3 ff 	st.b [%a14]-45,%d2
8000c4c0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c4c4:	59 e2 cc ff 	st.w [%a14]-52,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000c4c8:	39 e2 d3 ff 	ld.bu %d2,[%a14]-45
8000c4cc:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000c4d0:	02 35       	mov %d5,%d3
8000c4d2:	02 24       	mov %d4,%d2
8000c4d4:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
8000c4d8:	6d ff fb e1 	call 800088ce <IfxPort_setPinMode>
}
8000c4dc:	00 00       	nop 

    IfxPort_setPinPadDriver(rxClk->pin.port, rxClk->pin.pinIndex, speedGrade);
8000c4de:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c4e2:	b0 42       	add.a %a2,4
8000c4e4:	54 22       	ld.w %d2,[%a2]
8000c4e6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c4ea:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c4ee:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c4f2:	02 34       	mov %d4,%d3
8000c4f4:	60 24       	mov.a %a4,%d2
8000c4f6:	6d ff 5e e2 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(rxCtl->pin.port, rxCtl->pin.pinIndex, speedGrade);
8000c4fa:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c4fe:	b0 42       	add.a %a2,4
8000c500:	54 22       	ld.w %d2,[%a2]
8000c502:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c506:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c50a:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c50e:	02 34       	mov %d4,%d3
8000c510:	60 24       	mov.a %a4,%d2
8000c512:	6d ff 50 e2 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(rxd0->pin.port, rxd0->pin.pinIndex, speedGrade);
8000c516:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c51a:	b0 42       	add.a %a2,4
8000c51c:	54 22       	ld.w %d2,[%a2]
8000c51e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c522:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c526:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c52a:	02 34       	mov %d4,%d3
8000c52c:	60 24       	mov.a %a4,%d2
8000c52e:	6d ff 42 e2 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(rxd1->pin.port, rxd1->pin.pinIndex, speedGrade);
8000c532:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c536:	b0 42       	add.a %a2,4
8000c538:	54 22       	ld.w %d2,[%a2]
8000c53a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c53e:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c542:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c546:	02 34       	mov %d4,%d3
8000c548:	60 24       	mov.a %a4,%d2
8000c54a:	6d ff 34 e2 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(rxd2->pin.port, rxd2->pin.pinIndex, speedGrade);
8000c54e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c552:	b0 42       	add.a %a2,4
8000c554:	54 22       	ld.w %d2,[%a2]
8000c556:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c55a:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c55e:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c562:	02 34       	mov %d4,%d3
8000c564:	60 24       	mov.a %a4,%d2
8000c566:	6d ff 26 e2 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(rxd3->pin.port, rxd3->pin.pinIndex, speedGrade);
8000c56a:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c56e:	b0 42       	add.a %a2,4
8000c570:	54 22       	ld.w %d2,[%a2]
8000c572:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c576:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c57a:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c57e:	02 34       	mov %d4,%d3
8000c580:	60 24       	mov.a %a4,%d2
8000c582:	6d ff 18 e2 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(grefClk->pin.port, grefClk->pin.pinIndex, speedGrade);
8000c586:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c58a:	b0 42       	add.a %a2,4
8000c58c:	54 22       	ld.w %d2,[%a2]
8000c58e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c592:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c596:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c59a:	02 34       	mov %d4,%d3
8000c59c:	60 24       	mov.a %a4,%d2
8000c59e:	6d ff 0a e2 	call 800089b2 <IfxPort_setPinPadDriver>
}
8000c5a2:	00 00       	nop 
8000c5a4:	00 90       	ret 

8000c5a6 <IfxGeth_Eth_setupRgmiiOutputPins>:


void IfxGeth_Eth_setupRgmiiOutputPins(IfxGeth_Eth *geth, const IfxGeth_Eth_RgmiiPins *rgmiiPins)
{
8000c5a6:	40 ae       	mov.aa %a14,%sp
8000c5a8:	20 a0       	sub.a %sp,160
8000c5aa:	b5 e4 e4 df 	st.a [%a14]-156,%a4
8000c5ae:	b5 e5 e0 df 	st.a [%a14]-160,%a5
    IFX_UNUSED_PARAMETER(geth);
    IfxPort_OutputMode  mode       = IfxPort_OutputMode_pushPull;
8000c5b2:	3b 00 08 20 	mov %d2,128
8000c5b6:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxPort_PadDriver   speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed4;
8000c5ba:	82 32       	mov %d2,3
8000c5bc:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    IfxGeth_Txclk_Out  *txClk      = rgmiiPins->txClk;
8000c5c0:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c5c4:	54 22       	ld.w %d2,[%a2]
8000c5c6:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    IfxGeth_Txctl_Out  *txCtl      = rgmiiPins->txCtl;
8000c5ca:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c5ce:	d9 22 14 00 	lea %a2,[%a2]20
8000c5d2:	54 22       	ld.w %d2,[%a2]
8000c5d4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    IfxGeth_Txd_Out    *txd0       = rgmiiPins->txd0;
8000c5d8:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c5dc:	b0 42       	add.a %a2,4
8000c5de:	54 22       	ld.w %d2,[%a2]
8000c5e0:	59 e2 ec ff 	st.w [%a14]-20,%d2
    IfxGeth_Txd_Out    *txd1       = rgmiiPins->txd1;
8000c5e4:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c5e8:	d9 22 08 00 	lea %a2,[%a2]8
8000c5ec:	54 22       	ld.w %d2,[%a2]
8000c5ee:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    IfxGeth_Txd_Out    *txd2       = rgmiiPins->txd2;
8000c5f2:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c5f6:	d9 22 0c 00 	lea %a2,[%a2]12
8000c5fa:	54 22       	ld.w %d2,[%a2]
8000c5fc:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    IfxGeth_Txd_Out    *txd3       = rgmiiPins->txd3;
8000c600:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c604:	d9 22 10 00 	lea %a2,[%a2]16
8000c608:	54 22       	ld.w %d2,[%a2]
8000c60a:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    IfxGeth_Mdc_Out    *mdc        = rgmiiPins->mdc;
8000c60e:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c612:	d9 22 30 00 	lea %a2,[%a2]48
8000c616:	54 22       	ld.w %d2,[%a2]
8000c618:	59 e2 dc ff 	st.w [%a14]-36,%d2
    IfxGeth_Mdio_InOut *mdio       = rgmiiPins->mdio;
8000c61c:	99 e2 e0 df 	ld.a %a2,[%a14]-160
8000c620:	d9 22 34 00 	lea %a2,[%a2]52
8000c624:	54 22       	ld.w %d2,[%a2]
8000c626:	59 e2 d8 ff 	st.w [%a14]-40,%d2

    IfxPort_setPinControllerSelection(mdc->pin.port, mdc->pin.pinIndex);
8000c62a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c62e:	b0 42       	add.a %a2,4
8000c630:	54 22       	ld.w %d2,[%a2]
8000c632:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c636:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c63a:	02 34       	mov %d4,%d3
8000c63c:	60 24       	mov.a %a4,%d2
8000c63e:	6d ff 0b e2 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(mdio->pin.port, mdio->pin.pinIndex);
8000c642:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000c646:	b0 42       	add.a %a2,4
8000c648:	54 22       	ld.w %d2,[%a2]
8000c64a:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
8000c64e:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c652:	02 34       	mov %d4,%d3
8000c654:	60 24       	mov.a %a4,%d2
8000c656:	6d ff ff e1 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txClk->pin.port, txClk->pin.pinIndex);
8000c65a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c65e:	b0 42       	add.a %a2,4
8000c660:	54 22       	ld.w %d2,[%a2]
8000c662:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c666:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c66a:	02 34       	mov %d4,%d3
8000c66c:	60 24       	mov.a %a4,%d2
8000c66e:	6d ff f3 e1 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txCtl->pin.port, txCtl->pin.pinIndex);
8000c672:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c676:	b0 42       	add.a %a2,4
8000c678:	54 22       	ld.w %d2,[%a2]
8000c67a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c67e:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c682:	02 34       	mov %d4,%d3
8000c684:	60 24       	mov.a %a4,%d2
8000c686:	6d ff e7 e1 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txd0->pin.port, txd0->pin.pinIndex);
8000c68a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c68e:	b0 42       	add.a %a2,4
8000c690:	54 22       	ld.w %d2,[%a2]
8000c692:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c696:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c69a:	02 34       	mov %d4,%d3
8000c69c:	60 24       	mov.a %a4,%d2
8000c69e:	6d ff db e1 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txd1->pin.port, txd1->pin.pinIndex);
8000c6a2:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c6a6:	b0 42       	add.a %a2,4
8000c6a8:	54 22       	ld.w %d2,[%a2]
8000c6aa:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c6ae:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c6b2:	02 34       	mov %d4,%d3
8000c6b4:	60 24       	mov.a %a4,%d2
8000c6b6:	6d ff cf e1 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txd2->pin.port, txd2->pin.pinIndex);
8000c6ba:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c6be:	b0 42       	add.a %a2,4
8000c6c0:	54 22       	ld.w %d2,[%a2]
8000c6c2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c6c6:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c6ca:	02 34       	mov %d4,%d3
8000c6cc:	60 24       	mov.a %a4,%d2
8000c6ce:	6d ff c3 e1 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txd3->pin.port, txd3->pin.pinIndex);
8000c6d2:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c6d6:	b0 42       	add.a %a2,4
8000c6d8:	54 22       	ld.w %d2,[%a2]
8000c6da:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c6de:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c6e2:	02 34       	mov %d4,%d3
8000c6e4:	60 24       	mov.a %a4,%d2
8000c6e6:	6d ff b7 e1 	call 80008a54 <IfxPort_setPinControllerSelection>

    IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, mode, mdc->select);
8000c6ea:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c6ee:	b0 42       	add.a %a2,4
8000c6f0:	54 24       	ld.w %d4,[%a2]
8000c6f2:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c6f6:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c6fa:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c6fe:	d9 22 0c 00 	lea %a2,[%a2]12
8000c702:	54 23       	ld.w %d3,[%a2]
8000c704:	59 e4 f4 df 	st.w [%a14]-140,%d4
8000c708:	e9 e2 f3 df 	st.b [%a14]-141,%d2
8000c70c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c710:	59 e2 ec df 	st.w [%a14]-148,%d2
8000c714:	59 e3 e8 df 	st.w [%a14]-152,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c718:	39 e3 f3 df 	ld.bu %d3,[%a14]-141
8000c71c:	19 e4 ec df 	ld.w %d4,[%a14]-148
8000c720:	19 e2 e8 df 	ld.w %d2,[%a14]-152
8000c724:	a6 42       	or %d2,%d4
8000c726:	02 25       	mov %d5,%d2
8000c728:	02 34       	mov %d4,%d3
8000c72a:	99 e4 f4 df 	ld.a %a4,[%a14]-140
8000c72e:	6d ff d0 e0 	call 800088ce <IfxPort_setPinMode>
}
8000c732:	00 00       	nop 
    IfxPort_setPinModeOutput(txClk->pin.port, txClk->pin.pinIndex, mode, txClk->select);
8000c734:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c738:	b0 42       	add.a %a2,4
8000c73a:	54 24       	ld.w %d4,[%a2]
8000c73c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c740:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c744:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c748:	d9 22 0c 00 	lea %a2,[%a2]12
8000c74c:	54 23       	ld.w %d3,[%a2]
8000c74e:	59 e4 c4 ef 	st.w [%a14]-124,%d4
8000c752:	e9 e2 c3 ef 	st.b [%a14]-125,%d2
8000c756:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c75a:	59 e2 fc df 	st.w [%a14]-132,%d2
8000c75e:	59 e3 f8 df 	st.w [%a14]-136,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c762:	39 e3 c3 ef 	ld.bu %d3,[%a14]-125
8000c766:	19 e4 fc df 	ld.w %d4,[%a14]-132
8000c76a:	19 e2 f8 df 	ld.w %d2,[%a14]-136
8000c76e:	a6 42       	or %d2,%d4
8000c770:	02 25       	mov %d5,%d2
8000c772:	02 34       	mov %d4,%d3
8000c774:	99 e4 c4 ef 	ld.a %a4,[%a14]-124
8000c778:	6d ff ab e0 	call 800088ce <IfxPort_setPinMode>
}
8000c77c:	00 00       	nop 
    IfxPort_setPinModeOutput(txCtl->pin.port, txCtl->pin.pinIndex, mode, txCtl->select);
8000c77e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c782:	b0 42       	add.a %a2,4
8000c784:	54 24       	ld.w %d4,[%a2]
8000c786:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c78a:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c78e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c792:	d9 22 0c 00 	lea %a2,[%a2]12
8000c796:	54 23       	ld.w %d3,[%a2]
8000c798:	59 e4 d4 ef 	st.w [%a14]-108,%d4
8000c79c:	e9 e2 d3 ef 	st.b [%a14]-109,%d2
8000c7a0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c7a4:	59 e2 cc ef 	st.w [%a14]-116,%d2
8000c7a8:	59 e3 c8 ef 	st.w [%a14]-120,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c7ac:	39 e3 d3 ef 	ld.bu %d3,[%a14]-109
8000c7b0:	19 e4 cc ef 	ld.w %d4,[%a14]-116
8000c7b4:	19 e2 c8 ef 	ld.w %d2,[%a14]-120
8000c7b8:	a6 42       	or %d2,%d4
8000c7ba:	02 25       	mov %d5,%d2
8000c7bc:	02 34       	mov %d4,%d3
8000c7be:	99 e4 d4 ef 	ld.a %a4,[%a14]-108
8000c7c2:	6d ff 86 e0 	call 800088ce <IfxPort_setPinMode>
}
8000c7c6:	00 00       	nop 
    IfxPort_setPinModeOutput(txd0->pin.port, txd0->pin.pinIndex, mode, txd0->select);
8000c7c8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c7cc:	b0 42       	add.a %a2,4
8000c7ce:	54 24       	ld.w %d4,[%a2]
8000c7d0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c7d4:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c7d8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c7dc:	d9 22 0c 00 	lea %a2,[%a2]12
8000c7e0:	54 23       	ld.w %d3,[%a2]
8000c7e2:	59 e4 e4 ef 	st.w [%a14]-92,%d4
8000c7e6:	e9 e2 e3 ef 	st.b [%a14]-93,%d2
8000c7ea:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c7ee:	59 e2 dc ef 	st.w [%a14]-100,%d2
8000c7f2:	59 e3 d8 ef 	st.w [%a14]-104,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c7f6:	39 e3 e3 ef 	ld.bu %d3,[%a14]-93
8000c7fa:	19 e4 dc ef 	ld.w %d4,[%a14]-100
8000c7fe:	19 e2 d8 ef 	ld.w %d2,[%a14]-104
8000c802:	a6 42       	or %d2,%d4
8000c804:	02 25       	mov %d5,%d2
8000c806:	02 34       	mov %d4,%d3
8000c808:	99 e4 e4 ef 	ld.a %a4,[%a14]-92
8000c80c:	6d ff 61 e0 	call 800088ce <IfxPort_setPinMode>
}
8000c810:	00 00       	nop 
    IfxPort_setPinModeOutput(txd1->pin.port, txd1->pin.pinIndex, mode, txd1->select);
8000c812:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c816:	b0 42       	add.a %a2,4
8000c818:	54 24       	ld.w %d4,[%a2]
8000c81a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c81e:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c822:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c826:	d9 22 0c 00 	lea %a2,[%a2]12
8000c82a:	54 23       	ld.w %d3,[%a2]
8000c82c:	59 e4 f4 ef 	st.w [%a14]-76,%d4
8000c830:	e9 e2 f3 ef 	st.b [%a14]-77,%d2
8000c834:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c838:	59 e2 ec ef 	st.w [%a14]-84,%d2
8000c83c:	59 e3 e8 ef 	st.w [%a14]-88,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c840:	39 e3 f3 ef 	ld.bu %d3,[%a14]-77
8000c844:	19 e4 ec ef 	ld.w %d4,[%a14]-84
8000c848:	19 e2 e8 ef 	ld.w %d2,[%a14]-88
8000c84c:	a6 42       	or %d2,%d4
8000c84e:	02 25       	mov %d5,%d2
8000c850:	02 34       	mov %d4,%d3
8000c852:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
8000c856:	6d ff 3c e0 	call 800088ce <IfxPort_setPinMode>
}
8000c85a:	00 00       	nop 
    IfxPort_setPinModeOutput(txd2->pin.port, txd2->pin.pinIndex, mode, txd2->select);
8000c85c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c860:	b0 42       	add.a %a2,4
8000c862:	54 24       	ld.w %d4,[%a2]
8000c864:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c868:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c86c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c870:	d9 22 0c 00 	lea %a2,[%a2]12
8000c874:	54 23       	ld.w %d3,[%a2]
8000c876:	59 e4 c4 ff 	st.w [%a14]-60,%d4
8000c87a:	e9 e2 c3 ff 	st.b [%a14]-61,%d2
8000c87e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c882:	59 e2 fc ef 	st.w [%a14]-68,%d2
8000c886:	59 e3 f8 ef 	st.w [%a14]-72,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c88a:	39 e3 c3 ff 	ld.bu %d3,[%a14]-61
8000c88e:	19 e4 fc ef 	ld.w %d4,[%a14]-68
8000c892:	19 e2 f8 ef 	ld.w %d2,[%a14]-72
8000c896:	a6 42       	or %d2,%d4
8000c898:	02 25       	mov %d5,%d2
8000c89a:	02 34       	mov %d4,%d3
8000c89c:	99 e4 c4 ff 	ld.a %a4,[%a14]-60
8000c8a0:	6d ff 17 e0 	call 800088ce <IfxPort_setPinMode>
}
8000c8a4:	00 00       	nop 
    IfxPort_setPinModeOutput(txd3->pin.port, txd3->pin.pinIndex, mode, txd3->select);
8000c8a6:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c8aa:	b0 42       	add.a %a2,4
8000c8ac:	54 24       	ld.w %d4,[%a2]
8000c8ae:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c8b2:	39 22 08 00 	ld.bu %d2,[%a2]8
8000c8b6:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c8ba:	d9 22 0c 00 	lea %a2,[%a2]12
8000c8be:	54 23       	ld.w %d3,[%a2]
8000c8c0:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000c8c4:	e9 e2 d3 ff 	st.b [%a14]-45,%d2
8000c8c8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000c8cc:	59 e2 cc ff 	st.w [%a14]-52,%d2
8000c8d0:	59 e3 c8 ff 	st.w [%a14]-56,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000c8d4:	39 e3 d3 ff 	ld.bu %d3,[%a14]-45
8000c8d8:	19 e4 cc ff 	ld.w %d4,[%a14]-52
8000c8dc:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000c8e0:	a6 42       	or %d2,%d4
8000c8e2:	02 25       	mov %d5,%d2
8000c8e4:	02 34       	mov %d4,%d3
8000c8e6:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
8000c8ea:	6d ff f2 df 	call 800088ce <IfxPort_setPinMode>
}
8000c8ee:	00 00       	nop 

    IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, speedGrade);
8000c8f0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c8f4:	b0 42       	add.a %a2,4
8000c8f6:	54 22       	ld.w %d2,[%a2]
8000c8f8:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8000c8fc:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c900:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c904:	02 34       	mov %d4,%d3
8000c906:	60 24       	mov.a %a4,%d2
8000c908:	6d ff 55 e0 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txClk->pin.port, txClk->pin.pinIndex, speedGrade);
8000c90c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c910:	b0 42       	add.a %a2,4
8000c912:	54 22       	ld.w %d2,[%a2]
8000c914:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000c918:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c91c:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c920:	02 34       	mov %d4,%d3
8000c922:	60 24       	mov.a %a4,%d2
8000c924:	6d ff 47 e0 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txCtl->pin.port, txCtl->pin.pinIndex, speedGrade);
8000c928:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c92c:	b0 42       	add.a %a2,4
8000c92e:	54 22       	ld.w %d2,[%a2]
8000c930:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000c934:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c938:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c93c:	02 34       	mov %d4,%d3
8000c93e:	60 24       	mov.a %a4,%d2
8000c940:	6d ff 39 e0 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txd0->pin.port, txd0->pin.pinIndex, speedGrade);
8000c944:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c948:	b0 42       	add.a %a2,4
8000c94a:	54 22       	ld.w %d2,[%a2]
8000c94c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000c950:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c954:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c958:	02 34       	mov %d4,%d3
8000c95a:	60 24       	mov.a %a4,%d2
8000c95c:	6d ff 2b e0 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txd1->pin.port, txd1->pin.pinIndex, speedGrade);
8000c960:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c964:	b0 42       	add.a %a2,4
8000c966:	54 22       	ld.w %d2,[%a2]
8000c968:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000c96c:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c970:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c974:	02 34       	mov %d4,%d3
8000c976:	60 24       	mov.a %a4,%d2
8000c978:	6d ff 1d e0 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txd2->pin.port, txd2->pin.pinIndex, speedGrade);
8000c97c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c980:	b0 42       	add.a %a2,4
8000c982:	54 22       	ld.w %d2,[%a2]
8000c984:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000c988:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c98c:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c990:	02 34       	mov %d4,%d3
8000c992:	60 24       	mov.a %a4,%d2
8000c994:	6d ff 0f e0 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txd3->pin.port, txd3->pin.pinIndex, speedGrade);
8000c998:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c99c:	b0 42       	add.a %a2,4
8000c99e:	54 22       	ld.w %d2,[%a2]
8000c9a0:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8000c9a4:	39 23 08 00 	ld.bu %d3,[%a2]8
8000c9a8:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000c9ac:	02 34       	mov %d4,%d3
8000c9ae:	60 24       	mov.a %a4,%d2
8000c9b0:	6d ff 01 e0 	call 800089b2 <IfxPort_setPinPadDriver>
}
8000c9b4:	00 00       	nop 
8000c9b6:	00 90       	ret 

8000c9b8 <IfxGeth_Eth_setupRmiiInputPins>:


void IfxGeth_Eth_setupRmiiInputPins(IfxGeth_Eth *geth, const IfxGeth_Eth_RmiiPins *rmiiPins)
{
8000c9b8:	40 ae       	mov.aa %a14,%sp
8000c9ba:	20 58       	sub.a %sp,88
8000c9bc:	b5 e4 ec ef 	st.a [%a14]-84,%a4
8000c9c0:	b5 e5 e8 ef 	st.a [%a14]-88,%a5
    IfxPort_InputMode   mode       = IfxPort_InputMode_noPullDevice;
8000c9c4:	82 02       	mov %d2,0
8000c9c6:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxPort_PadDriver   speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed1;
8000c9ca:	82 02       	mov %d2,0
8000c9cc:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    IfxGeth_Crsdv_In   *crsDiv     = rmiiPins->crsDiv;
8000c9d0:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
8000c9d4:	54 22       	ld.w %d2,[%a2]
8000c9d6:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    IfxGeth_Refclk_In  *refClk     = rmiiPins->refClk;
8000c9da:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
8000c9de:	b0 42       	add.a %a2,4
8000c9e0:	54 22       	ld.w %d2,[%a2]
8000c9e2:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    IfxGeth_Rxd_In     *rxd0       = rmiiPins->rxd0;
8000c9e6:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
8000c9ea:	d9 22 08 00 	lea %a2,[%a2]8
8000c9ee:	54 22       	ld.w %d2,[%a2]
8000c9f0:	59 e2 ec ff 	st.w [%a14]-20,%d2
    IfxGeth_Rxd_In     *rxd1       = rmiiPins->rxd1;
8000c9f4:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
8000c9f8:	d9 22 0c 00 	lea %a2,[%a2]12
8000c9fc:	54 22       	ld.w %d2,[%a2]
8000c9fe:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    IfxGeth_Mdio_InOut *mdio       = rmiiPins->mdio;
8000ca02:	99 e2 e8 ef 	ld.a %a2,[%a14]-88
8000ca06:	d9 22 10 00 	lea %a2,[%a2]16
8000ca0a:	54 22       	ld.w %d2,[%a2]
8000ca0c:	59 e2 e4 ff 	st.w [%a14]-28,%d2

    geth->gethSFR->GPCTL.B.ALTI0 = mdio->inSelect;
8000ca10:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000ca14:	d9 22 0c 00 	lea %a2,[%a2]12
8000ca18:	54 22       	ld.w %d2,[%a2]
8000ca1a:	99 e2 ec ef 	ld.a %a2,[%a14]-84
8000ca1e:	d4 22       	ld.a %a2,[%a2]
8000ca20:	8f 32 00 21 	and %d2,%d2,3
8000ca24:	8f f2 0f 31 	and %d3,%d2,255
8000ca28:	d9 23 08 02 	lea %a3,[%a2]8200
8000ca2c:	54 32       	ld.w %d2,[%a3]
8000ca2e:	37 32 02 20 	insert %d2,%d2,%d3,0,2
8000ca32:	d9 22 08 02 	lea %a2,[%a2]8200
8000ca36:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI1 = refClk->select;
8000ca38:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000ca3c:	d9 22 0c 00 	lea %a2,[%a2]12
8000ca40:	54 22       	ld.w %d2,[%a2]
8000ca42:	99 e2 ec ef 	ld.a %a2,[%a14]-84
8000ca46:	d4 22       	ld.a %a2,[%a2]
8000ca48:	8f 32 00 21 	and %d2,%d2,3
8000ca4c:	8f f2 0f 31 	and %d3,%d2,255
8000ca50:	d9 23 08 02 	lea %a3,[%a2]8200
8000ca54:	54 32       	ld.w %d2,[%a3]
8000ca56:	37 32 02 21 	insert %d2,%d2,%d3,2,2
8000ca5a:	d9 22 08 02 	lea %a2,[%a2]8200
8000ca5e:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI4 = crsDiv->select;
8000ca60:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000ca64:	d9 22 0c 00 	lea %a2,[%a2]12
8000ca68:	54 22       	ld.w %d2,[%a2]
8000ca6a:	99 e2 ec ef 	ld.a %a2,[%a14]-84
8000ca6e:	d4 22       	ld.a %a2,[%a2]
8000ca70:	8f 32 00 21 	and %d2,%d2,3
8000ca74:	8f f2 0f 31 	and %d3,%d2,255
8000ca78:	d9 23 08 02 	lea %a3,[%a2]8200
8000ca7c:	54 32       	ld.w %d2,[%a3]
8000ca7e:	37 32 02 24 	insert %d2,%d2,%d3,8,2
8000ca82:	d9 22 08 02 	lea %a2,[%a2]8200
8000ca86:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI6 = rxd0->select;
8000ca88:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000ca8c:	d9 22 0c 00 	lea %a2,[%a2]12
8000ca90:	54 22       	ld.w %d2,[%a2]
8000ca92:	99 e2 ec ef 	ld.a %a2,[%a14]-84
8000ca96:	d4 22       	ld.a %a2,[%a2]
8000ca98:	8f 32 00 21 	and %d2,%d2,3
8000ca9c:	8f f2 0f 31 	and %d3,%d2,255
8000caa0:	d9 23 08 02 	lea %a3,[%a2]8200
8000caa4:	54 32       	ld.w %d2,[%a3]
8000caa6:	37 32 02 26 	insert %d2,%d2,%d3,12,2
8000caaa:	d9 22 08 02 	lea %a2,[%a2]8200
8000caae:	74 22       	st.w [%a2],%d2
    geth->gethSFR->GPCTL.B.ALTI7 = rxd1->select;
8000cab0:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cab4:	d9 22 0c 00 	lea %a2,[%a2]12
8000cab8:	54 22       	ld.w %d2,[%a2]
8000caba:	99 e2 ec ef 	ld.a %a2,[%a14]-84
8000cabe:	d4 22       	ld.a %a2,[%a2]
8000cac0:	8f 32 00 21 	and %d2,%d2,3
8000cac4:	8f f2 0f 31 	and %d3,%d2,255
8000cac8:	d9 23 08 02 	lea %a3,[%a2]8200
8000cacc:	54 32       	ld.w %d2,[%a3]
8000cace:	37 32 02 27 	insert %d2,%d2,%d3,14,2
8000cad2:	d9 22 08 02 	lea %a2,[%a2]8200
8000cad6:	74 22       	st.w [%a2],%d2

    IfxPort_setPinControllerSelection(crsDiv->pin.port, crsDiv->pin.pinIndex);
8000cad8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cadc:	b0 42       	add.a %a2,4
8000cade:	54 22       	ld.w %d2,[%a2]
8000cae0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cae4:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cae8:	02 34       	mov %d4,%d3
8000caea:	60 24       	mov.a %a4,%d2
8000caec:	6d ff b4 df 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(refClk->pin.port, refClk->pin.pinIndex);
8000caf0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000caf4:	b0 42       	add.a %a2,4
8000caf6:	54 22       	ld.w %d2,[%a2]
8000caf8:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000cafc:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cb00:	02 34       	mov %d4,%d3
8000cb02:	60 24       	mov.a %a4,%d2
8000cb04:	6d ff a8 df 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(rxd0->pin.port, rxd0->pin.pinIndex);
8000cb08:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cb0c:	b0 42       	add.a %a2,4
8000cb0e:	54 22       	ld.w %d2,[%a2]
8000cb10:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cb14:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cb18:	02 34       	mov %d4,%d3
8000cb1a:	60 24       	mov.a %a4,%d2
8000cb1c:	6d ff 9c df 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(rxd1->pin.port, rxd1->pin.pinIndex);
8000cb20:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cb24:	b0 42       	add.a %a2,4
8000cb26:	54 22       	ld.w %d2,[%a2]
8000cb28:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cb2c:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cb30:	02 34       	mov %d4,%d3
8000cb32:	60 24       	mov.a %a4,%d2
8000cb34:	6d ff 90 df 	call 80008a54 <IfxPort_setPinControllerSelection>

    IfxPort_setPinModeInput(crsDiv->pin.port, crsDiv->pin.pinIndex, mode);
8000cb38:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cb3c:	b0 42       	add.a %a2,4
8000cb3e:	54 23       	ld.w %d3,[%a2]
8000cb40:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cb44:	39 22 08 00 	ld.bu %d2,[%a2]8
8000cb48:	59 e3 fc ef 	st.w [%a14]-68,%d3
8000cb4c:	e9 e2 fb ef 	st.b [%a14]-69,%d2
8000cb50:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000cb54:	59 e2 f4 ef 	st.w [%a14]-76,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000cb58:	39 e2 fb ef 	ld.bu %d2,[%a14]-69
8000cb5c:	19 e3 f4 ef 	ld.w %d3,[%a14]-76
8000cb60:	02 35       	mov %d5,%d3
8000cb62:	02 24       	mov %d4,%d2
8000cb64:	99 e4 fc ef 	ld.a %a4,[%a14]-68
8000cb68:	6d ff b3 de 	call 800088ce <IfxPort_setPinMode>
}
8000cb6c:	00 00       	nop 
    IfxPort_setPinModeInput(refClk->pin.port, refClk->pin.pinIndex, mode);
8000cb6e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000cb72:	b0 42       	add.a %a2,4
8000cb74:	54 23       	ld.w %d3,[%a2]
8000cb76:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000cb7a:	39 22 08 00 	ld.bu %d2,[%a2]8
8000cb7e:	59 e3 c8 ff 	st.w [%a14]-56,%d3
8000cb82:	e9 e2 c7 ff 	st.b [%a14]-57,%d2
8000cb86:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000cb8a:	59 e2 c0 ff 	st.w [%a14]-64,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000cb8e:	39 e2 c7 ff 	ld.bu %d2,[%a14]-57
8000cb92:	19 e3 c0 ff 	ld.w %d3,[%a14]-64
8000cb96:	02 35       	mov %d5,%d3
8000cb98:	02 24       	mov %d4,%d2
8000cb9a:	99 e4 c8 ff 	ld.a %a4,[%a14]-56
8000cb9e:	6d ff 98 de 	call 800088ce <IfxPort_setPinMode>
}
8000cba2:	00 00       	nop 
    IfxPort_setPinModeInput(rxd0->pin.port, rxd0->pin.pinIndex, mode);
8000cba4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cba8:	b0 42       	add.a %a2,4
8000cbaa:	54 23       	ld.w %d3,[%a2]
8000cbac:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cbb0:	39 22 08 00 	ld.bu %d2,[%a2]8
8000cbb4:	59 e3 d4 ff 	st.w [%a14]-44,%d3
8000cbb8:	e9 e2 d3 ff 	st.b [%a14]-45,%d2
8000cbbc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000cbc0:	59 e2 cc ff 	st.w [%a14]-52,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000cbc4:	39 e2 d3 ff 	ld.bu %d2,[%a14]-45
8000cbc8:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000cbcc:	02 35       	mov %d5,%d3
8000cbce:	02 24       	mov %d4,%d2
8000cbd0:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
8000cbd4:	6d ff 7d de 	call 800088ce <IfxPort_setPinMode>
}
8000cbd8:	00 00       	nop 
    IfxPort_setPinModeInput(rxd1->pin.port, rxd1->pin.pinIndex, mode);
8000cbda:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cbde:	b0 42       	add.a %a2,4
8000cbe0:	54 23       	ld.w %d3,[%a2]
8000cbe2:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cbe6:	39 22 08 00 	ld.bu %d2,[%a2]8
8000cbea:	59 e3 e0 ff 	st.w [%a14]-32,%d3
8000cbee:	e9 e2 df ff 	st.b [%a14]-33,%d2
8000cbf2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000cbf6:	59 e2 d8 ff 	st.w [%a14]-40,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000cbfa:	39 e2 df ff 	ld.bu %d2,[%a14]-33
8000cbfe:	19 e3 d8 ff 	ld.w %d3,[%a14]-40
8000cc02:	02 35       	mov %d5,%d3
8000cc04:	02 24       	mov %d4,%d2
8000cc06:	99 e4 e0 ff 	ld.a %a4,[%a14]-32
8000cc0a:	6d ff 62 de 	call 800088ce <IfxPort_setPinMode>
}
8000cc0e:	00 00       	nop 

    IfxPort_setPinPadDriver(crsDiv->pin.port, crsDiv->pin.pinIndex, speedGrade);
8000cc10:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cc14:	b0 42       	add.a %a2,4
8000cc16:	54 22       	ld.w %d2,[%a2]
8000cc18:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cc1c:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cc20:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000cc24:	02 34       	mov %d4,%d3
8000cc26:	60 24       	mov.a %a4,%d2
8000cc28:	6d ff c5 de 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(refClk->pin.port, refClk->pin.pinIndex, speedGrade);
8000cc2c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000cc30:	b0 42       	add.a %a2,4
8000cc32:	54 22       	ld.w %d2,[%a2]
8000cc34:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000cc38:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cc3c:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000cc40:	02 34       	mov %d4,%d3
8000cc42:	60 24       	mov.a %a4,%d2
8000cc44:	6d ff b7 de 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(rxd0->pin.port, rxd0->pin.pinIndex, speedGrade);
8000cc48:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cc4c:	b0 42       	add.a %a2,4
8000cc4e:	54 22       	ld.w %d2,[%a2]
8000cc50:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cc54:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cc58:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000cc5c:	02 34       	mov %d4,%d3
8000cc5e:	60 24       	mov.a %a4,%d2
8000cc60:	6d ff a9 de 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(rxd1->pin.port, rxd1->pin.pinIndex, speedGrade);
8000cc64:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cc68:	b0 42       	add.a %a2,4
8000cc6a:	54 22       	ld.w %d2,[%a2]
8000cc6c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cc70:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cc74:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000cc78:	02 34       	mov %d4,%d3
8000cc7a:	60 24       	mov.a %a4,%d2
8000cc7c:	6d ff 9b de 	call 800089b2 <IfxPort_setPinPadDriver>
}
8000cc80:	00 00       	nop 
8000cc82:	00 90       	ret 

8000cc84 <IfxGeth_Eth_setupRmiiOutputPins>:


void IfxGeth_Eth_setupRmiiOutputPins(IfxGeth_Eth *geth, const IfxGeth_Eth_RmiiPins *rmiiPins)
{
8000cc84:	40 ae       	mov.aa %a14,%sp
8000cc86:	20 60       	sub.a %sp,96
8000cc88:	b5 e4 e4 ef 	st.a [%a14]-92,%a4
8000cc8c:	b5 e5 e0 ef 	st.a [%a14]-96,%a5
    IFX_UNUSED_PARAMETER(geth);
    IfxPort_OutputMode mode       = IfxPort_OutputMode_pushPull;
8000cc90:	3b 00 08 20 	mov %d2,128
8000cc94:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxPort_PadDriver  speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed1;
8000cc98:	82 02       	mov %d2,0
8000cc9a:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    IfxGeth_Mdc_Out   *mdc        = rmiiPins->mdc;
8000cc9e:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000cca2:	d9 22 18 00 	lea %a2,[%a2]24
8000cca6:	54 22       	ld.w %d2,[%a2]
8000cca8:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    IfxGeth_Txen_Out  *txen       = rmiiPins->txEn;
8000ccac:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000ccb0:	d9 22 20 00 	lea %a2,[%a2]32
8000ccb4:	54 22       	ld.w %d2,[%a2]
8000ccb6:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    IfxGeth_Txd_Out   *txd0       = rmiiPins->txd0;
8000ccba:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000ccbe:	d9 22 14 00 	lea %a2,[%a2]20
8000ccc2:	54 22       	ld.w %d2,[%a2]
8000ccc4:	59 e2 ec ff 	st.w [%a14]-20,%d2
    IfxGeth_Txd_Out   *txd1       = rmiiPins->txd1;
8000ccc8:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000cccc:	d9 22 1c 00 	lea %a2,[%a2]28
8000ccd0:	54 22       	ld.w %d2,[%a2]
8000ccd2:	59 e2 e8 ff 	st.w [%a14]-24,%d2

    IfxPort_setPinControllerSelection(mdc->pin.port, mdc->pin.pinIndex);
8000ccd6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000ccda:	b0 42       	add.a %a2,4
8000ccdc:	54 22       	ld.w %d2,[%a2]
8000ccde:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cce2:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cce6:	02 34       	mov %d4,%d3
8000cce8:	60 24       	mov.a %a4,%d2
8000ccea:	6d ff b5 de 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txen->pin.port, txen->pin.pinIndex);
8000ccee:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000ccf2:	b0 42       	add.a %a2,4
8000ccf4:	54 22       	ld.w %d2,[%a2]
8000ccf6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000ccfa:	39 23 08 00 	ld.bu %d3,[%a2]8
8000ccfe:	02 34       	mov %d4,%d3
8000cd00:	60 24       	mov.a %a4,%d2
8000cd02:	6d ff a9 de 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txd0->pin.port, txd0->pin.pinIndex);
8000cd06:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cd0a:	b0 42       	add.a %a2,4
8000cd0c:	54 22       	ld.w %d2,[%a2]
8000cd0e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cd12:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cd16:	02 34       	mov %d4,%d3
8000cd18:	60 24       	mov.a %a4,%d2
8000cd1a:	6d ff 9d de 	call 80008a54 <IfxPort_setPinControllerSelection>
    IfxPort_setPinControllerSelection(txd1->pin.port, txd1->pin.pinIndex);
8000cd1e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cd22:	b0 42       	add.a %a2,4
8000cd24:	54 22       	ld.w %d2,[%a2]
8000cd26:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cd2a:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cd2e:	02 34       	mov %d4,%d3
8000cd30:	60 24       	mov.a %a4,%d2
8000cd32:	6d ff 91 de 	call 80008a54 <IfxPort_setPinControllerSelection>

    IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, mode, mdc->select);
8000cd36:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cd3a:	b0 42       	add.a %a2,4
8000cd3c:	54 24       	ld.w %d4,[%a2]
8000cd3e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cd42:	39 22 08 00 	ld.bu %d2,[%a2]8
8000cd46:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000cd4a:	d9 22 0c 00 	lea %a2,[%a2]12
8000cd4e:	54 23       	ld.w %d3,[%a2]
8000cd50:	59 e4 f4 ef 	st.w [%a14]-76,%d4
8000cd54:	e9 e2 f3 ef 	st.b [%a14]-77,%d2
8000cd58:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000cd5c:	59 e2 ec ef 	st.w [%a14]-84,%d2
8000cd60:	59 e3 e8 ef 	st.w [%a14]-88,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000cd64:	39 e3 f3 ef 	ld.bu %d3,[%a14]-77
8000cd68:	19 e4 ec ef 	ld.w %d4,[%a14]-84
8000cd6c:	19 e2 e8 ef 	ld.w %d2,[%a14]-88
8000cd70:	a6 42       	or %d2,%d4
8000cd72:	02 25       	mov %d5,%d2
8000cd74:	02 34       	mov %d4,%d3
8000cd76:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
8000cd7a:	6d ff aa dd 	call 800088ce <IfxPort_setPinMode>
}
8000cd7e:	00 00       	nop 
    IfxPort_setPinModeOutput(txen->pin.port, txen->pin.pinIndex, mode, txen->select);
8000cd80:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000cd84:	b0 42       	add.a %a2,4
8000cd86:	54 24       	ld.w %d4,[%a2]
8000cd88:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000cd8c:	39 22 08 00 	ld.bu %d2,[%a2]8
8000cd90:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000cd94:	d9 22 0c 00 	lea %a2,[%a2]12
8000cd98:	54 23       	ld.w %d3,[%a2]
8000cd9a:	59 e4 c4 ff 	st.w [%a14]-60,%d4
8000cd9e:	e9 e2 c3 ff 	st.b [%a14]-61,%d2
8000cda2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000cda6:	59 e2 fc ef 	st.w [%a14]-68,%d2
8000cdaa:	59 e3 f8 ef 	st.w [%a14]-72,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000cdae:	39 e3 c3 ff 	ld.bu %d3,[%a14]-61
8000cdb2:	19 e4 fc ef 	ld.w %d4,[%a14]-68
8000cdb6:	19 e2 f8 ef 	ld.w %d2,[%a14]-72
8000cdba:	a6 42       	or %d2,%d4
8000cdbc:	02 25       	mov %d5,%d2
8000cdbe:	02 34       	mov %d4,%d3
8000cdc0:	99 e4 c4 ff 	ld.a %a4,[%a14]-60
8000cdc4:	6d ff 85 dd 	call 800088ce <IfxPort_setPinMode>
}
8000cdc8:	00 00       	nop 
    IfxPort_setPinModeOutput(txd0->pin.port, txd0->pin.pinIndex, mode, txd0->select);
8000cdca:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cdce:	b0 42       	add.a %a2,4
8000cdd0:	54 24       	ld.w %d4,[%a2]
8000cdd2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cdd6:	39 22 08 00 	ld.bu %d2,[%a2]8
8000cdda:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cdde:	d9 22 0c 00 	lea %a2,[%a2]12
8000cde2:	54 23       	ld.w %d3,[%a2]
8000cde4:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000cde8:	e9 e2 d3 ff 	st.b [%a14]-45,%d2
8000cdec:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000cdf0:	59 e2 cc ff 	st.w [%a14]-52,%d2
8000cdf4:	59 e3 c8 ff 	st.w [%a14]-56,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000cdf8:	39 e3 d3 ff 	ld.bu %d3,[%a14]-45
8000cdfc:	19 e4 cc ff 	ld.w %d4,[%a14]-52
8000ce00:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000ce04:	a6 42       	or %d2,%d4
8000ce06:	02 25       	mov %d5,%d2
8000ce08:	02 34       	mov %d4,%d3
8000ce0a:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
8000ce0e:	6d ff 60 dd 	call 800088ce <IfxPort_setPinMode>
}
8000ce12:	00 00       	nop 
    IfxPort_setPinModeOutput(txd1->pin.port, txd1->pin.pinIndex, mode, txd1->select);
8000ce14:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000ce18:	b0 42       	add.a %a2,4
8000ce1a:	54 24       	ld.w %d4,[%a2]
8000ce1c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000ce20:	39 22 08 00 	ld.bu %d2,[%a2]8
8000ce24:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000ce28:	d9 22 0c 00 	lea %a2,[%a2]12
8000ce2c:	54 23       	ld.w %d3,[%a2]
8000ce2e:	59 e4 e4 ff 	st.w [%a14]-28,%d4
8000ce32:	e9 e2 e3 ff 	st.b [%a14]-29,%d2
8000ce36:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000ce3a:	59 e2 dc ff 	st.w [%a14]-36,%d2
8000ce3e:	59 e3 d8 ff 	st.w [%a14]-40,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000ce42:	39 e3 e3 ff 	ld.bu %d3,[%a14]-29
8000ce46:	19 e4 dc ff 	ld.w %d4,[%a14]-36
8000ce4a:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000ce4e:	a6 42       	or %d2,%d4
8000ce50:	02 25       	mov %d5,%d2
8000ce52:	02 34       	mov %d4,%d3
8000ce54:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8000ce58:	6d ff 3b dd 	call 800088ce <IfxPort_setPinMode>
}
8000ce5c:	00 00       	nop 

    IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, speedGrade);
8000ce5e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000ce62:	b0 42       	add.a %a2,4
8000ce64:	54 22       	ld.w %d2,[%a2]
8000ce66:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000ce6a:	39 23 08 00 	ld.bu %d3,[%a2]8
8000ce6e:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000ce72:	02 34       	mov %d4,%d3
8000ce74:	60 24       	mov.a %a4,%d2
8000ce76:	6d ff 9e dd 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txen->pin.port, txen->pin.pinIndex, speedGrade);
8000ce7a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000ce7e:	b0 42       	add.a %a2,4
8000ce80:	54 22       	ld.w %d2,[%a2]
8000ce82:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000ce86:	39 23 08 00 	ld.bu %d3,[%a2]8
8000ce8a:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000ce8e:	02 34       	mov %d4,%d3
8000ce90:	60 24       	mov.a %a4,%d2
8000ce92:	6d ff 90 dd 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txd0->pin.port, txd0->pin.pinIndex, speedGrade);
8000ce96:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000ce9a:	b0 42       	add.a %a2,4
8000ce9c:	54 22       	ld.w %d2,[%a2]
8000ce9e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000cea2:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cea6:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000ceaa:	02 34       	mov %d4,%d3
8000ceac:	60 24       	mov.a %a4,%d2
8000ceae:	6d ff 82 dd 	call 800089b2 <IfxPort_setPinPadDriver>
    IfxPort_setPinPadDriver(txd1->pin.port, txd1->pin.pinIndex, speedGrade);
8000ceb2:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000ceb6:	b0 42       	add.a %a2,4
8000ceb8:	54 22       	ld.w %d2,[%a2]
8000ceba:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000cebe:	39 23 08 00 	ld.bu %d3,[%a2]8
8000cec2:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8000cec6:	02 34       	mov %d4,%d3
8000cec8:	60 24       	mov.a %a4,%d2
8000ceca:	6d ff 74 dd 	call 800089b2 <IfxPort_setPinPadDriver>
}
8000cece:	00 00       	nop 
8000ced0:	00 90       	ret 

8000ced2 <IfxGeth_Eth_shuffleRxDescriptor>:


void IfxGeth_Eth_shuffleRxDescriptor(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
8000ced2:	40 ae       	mov.aa %a14,%sp
8000ced4:	20 18       	sub.a %sp,24
8000ced6:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000ceda:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    volatile IfxGeth_RxDescr *currentDescr = geth->rxChannel[channelId].rxDescrPtr;
8000cede:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000cee2:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cee6:	06 42       	sh %d2,4
8000cee8:	42 32       	add %d2,%d3
8000ceea:	60 22       	mov.a %a2,%d2
8000ceec:	d9 22 24 10 	lea %a2,[%a2]100
8000cef0:	54 22       	ld.w %d2,[%a2]
8000cef2:	59 e2 fc ff 	st.w [%a14]-4,%d2
    volatile IfxGeth_RxDescr *lastDescr    = &geth->rxChannel[channelId].rxDescrList->descr[IFXGETH_MAX_RX_DESCRIPTORS - 1];
8000cef6:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000cefa:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cefe:	c2 62       	add %d2,6
8000cf00:	06 42       	sh %d2,4
8000cf02:	60 32       	mov.a %a2,%d3
8000cf04:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000cf08:	54 22       	ld.w %d2,[%a2]
8000cf0a:	1b 02 07 20 	addi %d2,%d2,112
8000cf0e:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    if (currentDescr == lastDescr)
8000cf12:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000cf16:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000cf1a:	5f 23 21 80 	jne %d3,%d2,8000cf5c <IfxGeth_Eth_shuffleRxDescriptor+0x8a>
8000cf1e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000cf22:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000cf26:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cf2a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return geth->rxChannel[channelId].rxDescrList->descr;
8000cf2e:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000cf32:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000cf36:	c2 62       	add %d2,6
8000cf38:	06 42       	sh %d2,4
8000cf3a:	60 32       	mov.a %a2,%d3
8000cf3c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000cf40:	54 22       	ld.w %d2,[%a2]
8000cf42:	02 24       	mov %d4,%d2
    {
        /* wrap around the descriptors */
        geth->rxChannel[channelId].rxDescrPtr = IfxGeth_Eth_getBaseRxDescriptor(geth, channelId);
8000cf44:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000cf48:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cf4c:	06 42       	sh %d2,4
8000cf4e:	42 32       	add %d2,%d3
8000cf50:	60 22       	mov.a %a2,%d2
8000cf52:	d9 22 24 10 	lea %a2,[%a2]100
8000cf56:	74 24       	st.w [%a2],%d4
    else
    {
        /* point to the next descriptor */
        geth->rxChannel[channelId].rxDescrPtr = &geth->rxChannel[channelId].rxDescrPtr[1];
    }
}
8000cf58:	1d 00 18 00 	j 8000cf88 <IfxGeth_Eth_shuffleRxDescriptor+0xb6>
        geth->rxChannel[channelId].rxDescrPtr = &geth->rxChannel[channelId].rxDescrPtr[1];
8000cf5c:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000cf60:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cf64:	06 42       	sh %d2,4
8000cf66:	42 32       	add %d2,%d3
8000cf68:	60 22       	mov.a %a2,%d2
8000cf6a:	d9 22 24 10 	lea %a2,[%a2]100
8000cf6e:	54 22       	ld.w %d2,[%a2]
8000cf70:	1b 02 01 30 	addi %d3,%d2,16
8000cf74:	19 e4 ec ff 	ld.w %d4,[%a14]-20
8000cf78:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cf7c:	06 42       	sh %d2,4
8000cf7e:	42 42       	add %d2,%d4
8000cf80:	60 22       	mov.a %a2,%d2
8000cf82:	d9 22 24 10 	lea %a2,[%a2]100
8000cf86:	74 23       	st.w [%a2],%d3
}
8000cf88:	00 00       	nop 
8000cf8a:	00 90       	ret 

8000cf8c <IfxGeth_Eth_shuffleTxDescriptor>:


void IfxGeth_Eth_shuffleTxDescriptor(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
8000cf8c:	40 ae       	mov.aa %a14,%sp
8000cf8e:	20 18       	sub.a %sp,24
8000cf90:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000cf94:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    volatile IfxGeth_TxDescr *currentDescr = geth->txChannel[channelId].txDescrPtr;
8000cf98:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000cf9c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cfa0:	c2 12       	add %d2,1
8000cfa2:	53 42 21 20 	mul %d2,%d2,20
8000cfa6:	60 32       	mov.a %a2,%d3
8000cfa8:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000cfac:	54 22       	ld.w %d2,[%a2]
8000cfae:	59 e2 fc ff 	st.w [%a14]-4,%d2
    volatile IfxGeth_TxDescr *lastDescr    = &geth->txChannel[channelId].txDescrList->descr[IFXGETH_MAX_TX_DESCRIPTORS - 1];
8000cfb2:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000cfb6:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cfba:	53 42 21 20 	mul %d2,%d2,20
8000cfbe:	42 32       	add %d2,%d3
8000cfc0:	60 22       	mov.a %a2,%d2
8000cfc2:	d9 22 10 00 	lea %a2,[%a2]16
8000cfc6:	54 22       	ld.w %d2,[%a2]
8000cfc8:	1b 02 07 20 	addi %d2,%d2,112
8000cfcc:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    if (currentDescr == lastDescr)
8000cfd0:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000cfd4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000cfd8:	5f 23 23 80 	jne %d3,%d2,8000d01e <IfxGeth_Eth_shuffleTxDescriptor+0x92>
8000cfdc:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000cfe0:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000cfe4:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000cfe8:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return geth->txChannel[channelId].txDescrList->descr;
8000cfec:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000cff0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000cff4:	53 42 21 20 	mul %d2,%d2,20
8000cff8:	42 32       	add %d2,%d3
8000cffa:	60 22       	mov.a %a2,%d2
8000cffc:	d9 22 10 00 	lea %a2,[%a2]16
8000d000:	54 22       	ld.w %d2,[%a2]
8000d002:	02 24       	mov %d4,%d2
    {
        /* wrap around the descriptors */
        geth->txChannel[channelId].txDescrPtr = IfxGeth_Eth_getBaseTxDescriptor(geth, channelId);
8000d004:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000d008:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d00c:	c2 12       	add %d2,1
8000d00e:	53 42 21 20 	mul %d2,%d2,20
8000d012:	60 32       	mov.a %a2,%d3
8000d014:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000d018:	74 24       	st.w [%a2],%d4
    else
    {
        /* point to the next descriptor */
        geth->txChannel[channelId].txDescrPtr = &geth->txChannel[channelId].txDescrPtr[1];
    }
}
8000d01a:	1d 00 1a 00 	j 8000d04e <IfxGeth_Eth_shuffleTxDescriptor+0xc2>
        geth->txChannel[channelId].txDescrPtr = &geth->txChannel[channelId].txDescrPtr[1];
8000d01e:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000d022:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d026:	c2 12       	add %d2,1
8000d028:	53 42 21 20 	mul %d2,%d2,20
8000d02c:	60 32       	mov.a %a2,%d3
8000d02e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000d032:	54 22       	ld.w %d2,[%a2]
8000d034:	1b 02 01 30 	addi %d3,%d2,16
8000d038:	19 e4 ec ff 	ld.w %d4,[%a14]-20
8000d03c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d040:	c2 12       	add %d2,1
8000d042:	53 42 21 20 	mul %d2,%d2,20
8000d046:	60 42       	mov.a %a2,%d4
8000d048:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000d04c:	74 23       	st.w [%a2],%d3
}
8000d04e:	00 00       	nop 
8000d050:	00 90       	ret 

8000d052 <IfxGeth_Eth_startReceiver>:


void IfxGeth_Eth_startReceiver(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
8000d052:	40 ae       	mov.aa %a14,%sp
8000d054:	20 18       	sub.a %sp,24
8000d056:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000d05a:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    IfxGeth_mac_enableReceiver(geth->gethSFR);
8000d05e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d062:	54 22       	ld.w %d2,[%a2]
8000d064:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    gethSFR->MAC_CONFIGURATION.B.RE = 1;
8000d068:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000d06c:	54 22       	ld.w %d2,[%a2]
8000d06e:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000d072:	74 22       	st.w [%a2],%d2
}
8000d074:	00 00       	nop 
    IfxGeth_dma_startReceiver(geth->gethSFR, channelId);
8000d076:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d07a:	54 22       	ld.w %d2,[%a2]
8000d07c:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d080:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d084:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    gethSFR->DMA_CH[channel].RX_CONTROL.B.SR = TRUE;
8000d088:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000d08c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d090:	06 72       	sh %d2,7
8000d092:	42 32       	add %d2,%d3
8000d094:	60 22       	mov.a %a2,%d2
8000d096:	d9 22 08 41 	lea %a2,[%a2]4360
8000d09a:	54 22       	ld.w %d2,[%a2]
8000d09c:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000d0a0:	74 22       	st.w [%a2],%d2
}
8000d0a2:	00 00       	nop 
}
8000d0a4:	00 00       	nop 
8000d0a6:	00 90       	ret 

8000d0a8 <IfxGeth_Eth_startReceivers>:


void IfxGeth_Eth_startReceivers(IfxGeth_Eth *geth, uint32 numOfChannels)
{
8000d0a8:	40 ae       	mov.aa %a14,%sp
8000d0aa:	20 18       	sub.a %sp,24
8000d0ac:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000d0b0:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    uint32 i;
    IfxGeth_mac_enableReceiver(geth->gethSFR);
8000d0b4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d0b8:	54 22       	ld.w %d2,[%a2]
8000d0ba:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    gethSFR->MAC_CONFIGURATION.B.RE = 1;
8000d0be:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000d0c2:	54 22       	ld.w %d2,[%a2]
8000d0c4:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000d0c8:	74 22       	st.w [%a2],%d2
}
8000d0ca:	00 00       	nop 

    for (i = 0; i < numOfChannels; i++)
8000d0cc:	82 02       	mov %d2,0
8000d0ce:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d0d2:	1d 00 1e 00 	j 8000d10e <IfxGeth_Eth_startReceivers+0x66>
    {
        IfxGeth_dma_startReceiver(geth->gethSFR, (IfxGeth_RxDmaChannel)i);
8000d0d6:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d0da:	54 22       	ld.w %d2,[%a2]
8000d0dc:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000d0e0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000d0e4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    gethSFR->DMA_CH[channel].RX_CONTROL.B.SR = TRUE;
8000d0e8:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000d0ec:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d0f0:	06 72       	sh %d2,7
8000d0f2:	42 32       	add %d2,%d3
8000d0f4:	60 22       	mov.a %a2,%d2
8000d0f6:	d9 22 08 41 	lea %a2,[%a2]4360
8000d0fa:	54 22       	ld.w %d2,[%a2]
8000d0fc:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000d100:	74 22       	st.w [%a2],%d2
}
8000d102:	00 00       	nop 
    for (i = 0; i < numOfChannels; i++)
8000d104:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000d108:	c2 12       	add %d2,1
8000d10a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d10e:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000d112:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d116:	3f 23 e0 ff 	jlt.u %d3,%d2,8000d0d6 <IfxGeth_Eth_startReceivers+0x2e>
    }
}
8000d11a:	00 00       	nop 
8000d11c:	00 00       	nop 
8000d11e:	00 90       	ret 

8000d120 <IfxGeth_Eth_startTransmitter>:


void IfxGeth_Eth_startTransmitter(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
8000d120:	40 ae       	mov.aa %a14,%sp
8000d122:	20 18       	sub.a %sp,24
8000d124:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000d128:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    IfxGeth_mac_enableTransmitter(geth->gethSFR);
8000d12c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d130:	54 22       	ld.w %d2,[%a2]
8000d132:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    gethSFR->MAC_CONFIGURATION.B.TE = 1;
8000d136:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000d13a:	54 22       	ld.w %d2,[%a2]
8000d13c:	b7 12 81 20 	insert %d2,%d2,1,1,1
8000d140:	74 22       	st.w [%a2],%d2
}
8000d142:	00 00       	nop 
    IfxGeth_dma_startTransmitter(geth->gethSFR, channelId);
8000d144:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d148:	54 22       	ld.w %d2,[%a2]
8000d14a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d14e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d152:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    gethSFR->DMA_CH[channel].TX_CONTROL.B.ST = TRUE;
8000d156:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000d15a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d15e:	06 72       	sh %d2,7
8000d160:	42 32       	add %d2,%d3
8000d162:	60 22       	mov.a %a2,%d2
8000d164:	d9 22 04 41 	lea %a2,[%a2]4356
8000d168:	54 22       	ld.w %d2,[%a2]
8000d16a:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000d16e:	74 22       	st.w [%a2],%d2
}
8000d170:	00 00       	nop 
}
8000d172:	00 00       	nop 
8000d174:	00 90       	ret 

8000d176 <IfxGeth_Eth_startTransmitters>:


void IfxGeth_Eth_startTransmitters(IfxGeth_Eth *geth, uint32 numOfChannels)
{
8000d176:	40 ae       	mov.aa %a14,%sp
8000d178:	20 18       	sub.a %sp,24
8000d17a:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000d17e:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    uint32 i;
    IfxGeth_mac_enableTransmitter(geth->gethSFR);
8000d182:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d186:	54 22       	ld.w %d2,[%a2]
8000d188:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    gethSFR->MAC_CONFIGURATION.B.TE = 1;
8000d18c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000d190:	54 22       	ld.w %d2,[%a2]
8000d192:	b7 12 81 20 	insert %d2,%d2,1,1,1
8000d196:	74 22       	st.w [%a2],%d2
}
8000d198:	00 00       	nop 

    for (i = 0; i < numOfChannels; i++)
8000d19a:	82 02       	mov %d2,0
8000d19c:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d1a0:	1d 00 1e 00 	j 8000d1dc <IfxGeth_Eth_startTransmitters+0x66>
    {
        IfxGeth_dma_startTransmitter(geth->gethSFR, (IfxGeth_TxDmaChannel)i);
8000d1a4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d1a8:	54 22       	ld.w %d2,[%a2]
8000d1aa:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000d1ae:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000d1b2:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    gethSFR->DMA_CH[channel].TX_CONTROL.B.ST = TRUE;
8000d1b6:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000d1ba:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d1be:	06 72       	sh %d2,7
8000d1c0:	42 32       	add %d2,%d3
8000d1c2:	60 22       	mov.a %a2,%d2
8000d1c4:	d9 22 04 41 	lea %a2,[%a2]4356
8000d1c8:	54 22       	ld.w %d2,[%a2]
8000d1ca:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000d1ce:	74 22       	st.w [%a2],%d2
}
8000d1d0:	00 00       	nop 
    for (i = 0; i < numOfChannels; i++)
8000d1d2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000d1d6:	c2 12       	add %d2,1
8000d1d8:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d1dc:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000d1e0:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d1e4:	3f 23 e0 ff 	jlt.u %d3,%d2,8000d1a4 <IfxGeth_Eth_startTransmitters+0x2e>
    }
}
8000d1e8:	00 00       	nop 
8000d1ea:	00 00       	nop 
8000d1ec:	00 90       	ret 

8000d1ee <IfxGeth_Eth_stopTransmitters>:


void IfxGeth_Eth_stopTransmitters(IfxGeth_Eth *geth, uint32 numOfChannels)
{
8000d1ee:	40 ae       	mov.aa %a14,%sp
8000d1f0:	20 18       	sub.a %sp,24
8000d1f2:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000d1f6:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    uint32 i;
    IfxGeth_mac_disableTransmitter(geth->gethSFR);
8000d1fa:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d1fe:	54 22       	ld.w %d2,[%a2]
8000d200:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    gethSFR->MAC_CONFIGURATION.B.TE = 0;
8000d204:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000d208:	54 22       	ld.w %d2,[%a2]
8000d20a:	8f 22 c0 21 	andn %d2,%d2,2
8000d20e:	74 22       	st.w [%a2],%d2
}
8000d210:	00 00       	nop 

    for (i = 0; i < numOfChannels; i++)
8000d212:	82 02       	mov %d2,0
8000d214:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d218:	1d 00 1e 00 	j 8000d254 <IfxGeth_Eth_stopTransmitters+0x66>
    {
        IfxGeth_dma_stopTransmitter(geth->gethSFR, (IfxGeth_TxDmaChannel)i);
8000d21c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000d220:	54 22       	ld.w %d2,[%a2]
8000d222:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000d226:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000d22a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    gethSFR->DMA_CH[channel].TX_CONTROL.B.ST = FALSE;
8000d22e:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000d232:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d236:	06 72       	sh %d2,7
8000d238:	42 32       	add %d2,%d3
8000d23a:	60 22       	mov.a %a2,%d2
8000d23c:	d9 22 04 41 	lea %a2,[%a2]4356
8000d240:	54 22       	ld.w %d2,[%a2]
8000d242:	8f 12 c0 21 	andn %d2,%d2,1
8000d246:	74 22       	st.w [%a2],%d2
}
8000d248:	00 00       	nop 
    for (i = 0; i < numOfChannels; i++)
8000d24a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000d24e:	c2 12       	add %d2,1
8000d250:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d254:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000d258:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d25c:	3f 23 e0 ff 	jlt.u %d3,%d2,8000d21c <IfxGeth_Eth_stopTransmitters+0x2e>
    }
}
8000d260:	00 00       	nop 
8000d262:	00 00       	nop 
8000d264:	00 90       	ret 

8000d266 <IfxGeth_Eth_wakeupReceiver>:


void IfxGeth_Eth_wakeupReceiver(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
8000d266:	40 ae       	mov.aa %a14,%sp
8000d268:	20 38       	sub.a %sp,56
8000d26a:	b5 e4 cc ff 	st.a [%a14]-52,%a4
8000d26e:	59 e4 c8 ff 	st.w [%a14]-56,%d4
    /* check if receiver suspended */
    if (IfxGeth_dma_isInterruptFlagSet(geth->gethSFR, (IfxGeth_DmaChannel)channelId, IfxGeth_DmaInterruptFlag_receiveStopped))
8000d272:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000d276:	54 22       	ld.w %d2,[%a2]
8000d278:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d27c:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000d280:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000d284:	3b 80 00 20 	mov %d2,8
8000d288:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    uint32 value = (1 << flag);
8000d28c:	82 13       	mov %d3,1
8000d28e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000d292:	0f 23 00 20 	sh %d2,%d3,%d2
8000d296:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    if (gethSFR->DMA_CH[channelId].STATUS.U & (Ifx_UReg_32Bit)value)
8000d29a:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000d29e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d2a2:	06 72       	sh %d2,7
8000d2a4:	42 32       	add %d2,%d3
8000d2a6:	60 22       	mov.a %a2,%d2
8000d2a8:	d9 22 20 51 	lea %a2,[%a2]4448
8000d2ac:	54 23       	ld.w %d3,[%a2]
8000d2ae:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d2b2:	26 32       	and %d2,%d3
8000d2b4:	df 02 05 00 	jeq %d2,0,8000d2be <IfxGeth_Eth_wakeupReceiver+0x58>
        return 1;
8000d2b8:	82 12       	mov %d2,1
8000d2ba:	1d 00 03 00 	j 8000d2c0 <IfxGeth_Eth_wakeupReceiver+0x5a>
        return 0;
8000d2be:	82 02       	mov %d2,0
8000d2c0:	df 02 50 00 	jeq %d2,0,8000d360 <IfxGeth_Eth_wakeupReceiver+0xfa>
    {
        /* check if receive buffer unavailable */
        if (IfxGeth_dma_isInterruptFlagSet(geth->gethSFR, (IfxGeth_DmaChannel)channelId, IfxGeth_DmaInterruptFlag_receiveBufferUnavailable))
8000d2c4:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000d2c8:	54 22       	ld.w %d2,[%a2]
8000d2ca:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000d2ce:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000d2d2:	59 e2 e8 ff 	st.w [%a14]-24,%d2
8000d2d6:	82 72       	mov %d2,7
8000d2d8:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    uint32 value = (1 << flag);
8000d2dc:	82 13       	mov %d3,1
8000d2de:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d2e2:	0f 23 00 20 	sh %d2,%d3,%d2
8000d2e6:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    if (gethSFR->DMA_CH[channelId].STATUS.U & (Ifx_UReg_32Bit)value)
8000d2ea:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000d2ee:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d2f2:	06 72       	sh %d2,7
8000d2f4:	42 32       	add %d2,%d3
8000d2f6:	60 22       	mov.a %a2,%d2
8000d2f8:	d9 22 20 51 	lea %a2,[%a2]4448
8000d2fc:	54 23       	ld.w %d3,[%a2]
8000d2fe:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000d302:	26 32       	and %d2,%d3
8000d304:	df 02 05 00 	jeq %d2,0,8000d30e <IfxGeth_Eth_wakeupReceiver+0xa8>
        return 1;
8000d308:	82 12       	mov %d2,1
8000d30a:	1d 00 03 00 	j 8000d310 <IfxGeth_Eth_wakeupReceiver+0xaa>
        return 0;
8000d30e:	82 02       	mov %d2,0
8000d310:	df 02 22 00 	jeq %d2,0,8000d354 <IfxGeth_Eth_wakeupReceiver+0xee>
        {
            IfxGeth_dma_clearInterruptFlag(geth->gethSFR, (IfxGeth_DmaChannel)channelId, IfxGeth_DmaInterruptFlag_receiveBufferUnavailable);
8000d314:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000d318:	54 22       	ld.w %d2,[%a2]
8000d31a:	59 e2 dc ff 	st.w [%a14]-36,%d2
8000d31e:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000d322:	59 e2 d8 ff 	st.w [%a14]-40,%d2
8000d326:	82 72       	mov %d2,7
8000d328:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    uint32 value = (1 << flag);
8000d32c:	82 13       	mov %d3,1
8000d32e:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d332:	0f 23 00 20 	sh %d2,%d3,%d2
8000d336:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    gethSFR->DMA_CH[channelId].STATUS.U = value;
8000d33a:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8000d33e:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000d342:	06 72       	sh %d2,7
8000d344:	42 32       	add %d2,%d3
8000d346:	60 22       	mov.a %a2,%d2
8000d348:	d9 22 20 51 	lea %a2,[%a2]4448
8000d34c:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000d350:	74 22       	st.w [%a2],%d2
}
8000d352:	00 00       	nop 
        }

        IfxGeth_Eth_startReceiver(geth, channelId);
8000d354:	19 e4 c8 ff 	ld.w %d4,[%a14]-56
8000d358:	99 e4 cc ff 	ld.a %a4,[%a14]-52
8000d35c:	6d ff 7b fe 	call 8000d052 <IfxGeth_Eth_startReceiver>
    }
}
8000d360:	00 00       	nop 
8000d362:	00 90       	ret 

8000d364 <IfxGeth_Eth_wakeupTransmitter>:


void IfxGeth_Eth_wakeupTransmitter(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
8000d364:	40 ae       	mov.aa %a14,%sp
8000d366:	20 38       	sub.a %sp,56
8000d368:	b5 e4 cc ff 	st.a [%a14]-52,%a4
8000d36c:	59 e4 c8 ff 	st.w [%a14]-56,%d4
    /* check if transmitter suspended */
    if (IfxGeth_dma_isInterruptFlagSet(geth->gethSFR, (IfxGeth_DmaChannel)channelId, IfxGeth_DmaInterruptFlag_transmitStopped))
8000d370:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000d374:	54 22       	ld.w %d2,[%a2]
8000d376:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000d37a:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000d37e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000d382:	82 12       	mov %d2,1
8000d384:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    uint32 value = (1 << flag);
8000d388:	82 13       	mov %d3,1
8000d38a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000d38e:	0f 23 00 20 	sh %d2,%d3,%d2
8000d392:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    if (gethSFR->DMA_CH[channelId].STATUS.U & (Ifx_UReg_32Bit)value)
8000d396:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000d39a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d39e:	06 72       	sh %d2,7
8000d3a0:	42 32       	add %d2,%d3
8000d3a2:	60 22       	mov.a %a2,%d2
8000d3a4:	d9 22 20 51 	lea %a2,[%a2]4448
8000d3a8:	54 23       	ld.w %d3,[%a2]
8000d3aa:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d3ae:	26 32       	and %d2,%d3
8000d3b0:	df 02 05 00 	jeq %d2,0,8000d3ba <IfxGeth_Eth_wakeupTransmitter+0x56>
        return 1;
8000d3b4:	82 12       	mov %d2,1
8000d3b6:	1d 00 03 00 	j 8000d3bc <IfxGeth_Eth_wakeupTransmitter+0x58>
        return 0;
8000d3ba:	82 02       	mov %d2,0
8000d3bc:	df 02 64 00 	jeq %d2,0,8000d484 <IfxGeth_Eth_wakeupTransmitter+0x120>
    {
        /* check if transmit buffer unavailable */
        if (IfxGeth_dma_isInterruptFlagSet(geth->gethSFR, (IfxGeth_DmaChannel)channelId, IfxGeth_DmaInterruptFlag_transmitBufferUnavailable))
8000d3c0:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000d3c4:	54 22       	ld.w %d2,[%a2]
8000d3c6:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000d3ca:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000d3ce:	59 e2 e8 ff 	st.w [%a14]-24,%d2
8000d3d2:	82 22       	mov %d2,2
8000d3d4:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    uint32 value = (1 << flag);
8000d3d8:	82 13       	mov %d3,1
8000d3da:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d3de:	0f 23 00 20 	sh %d2,%d3,%d2
8000d3e2:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    if (gethSFR->DMA_CH[channelId].STATUS.U & (Ifx_UReg_32Bit)value)
8000d3e6:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000d3ea:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000d3ee:	06 72       	sh %d2,7
8000d3f0:	42 32       	add %d2,%d3
8000d3f2:	60 22       	mov.a %a2,%d2
8000d3f4:	d9 22 20 51 	lea %a2,[%a2]4448
8000d3f8:	54 23       	ld.w %d3,[%a2]
8000d3fa:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000d3fe:	26 32       	and %d2,%d3
8000d400:	df 02 05 00 	jeq %d2,0,8000d40a <IfxGeth_Eth_wakeupTransmitter+0xa6>
        return 1;
8000d404:	82 12       	mov %d2,1
8000d406:	1d 00 03 00 	j 8000d40c <IfxGeth_Eth_wakeupTransmitter+0xa8>
        return 0;
8000d40a:	82 02       	mov %d2,0
8000d40c:	df 02 22 00 	jeq %d2,0,8000d450 <IfxGeth_Eth_wakeupTransmitter+0xec>
        {
            IfxGeth_dma_clearInterruptFlag(geth->gethSFR, (IfxGeth_DmaChannel)channelId, IfxGeth_DmaInterruptFlag_transmitBufferUnavailable);
8000d410:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000d414:	54 22       	ld.w %d2,[%a2]
8000d416:	59 e2 dc ff 	st.w [%a14]-36,%d2
8000d41a:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000d41e:	59 e2 d8 ff 	st.w [%a14]-40,%d2
8000d422:	82 22       	mov %d2,2
8000d424:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    uint32 value = (1 << flag);
8000d428:	82 13       	mov %d3,1
8000d42a:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d42e:	0f 23 00 20 	sh %d2,%d3,%d2
8000d432:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    gethSFR->DMA_CH[channelId].STATUS.U = value;
8000d436:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8000d43a:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000d43e:	06 72       	sh %d2,7
8000d440:	42 32       	add %d2,%d3
8000d442:	60 22       	mov.a %a2,%d2
8000d444:	d9 22 20 51 	lea %a2,[%a2]4448
8000d448:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000d44c:	74 22       	st.w [%a2],%d2
}
8000d44e:	00 00       	nop 
        }

        /* check MTL underflow flag */
        if (IfxGeth_mtl_isInterruptFlagSet(geth->gethSFR, (IfxGeth_MtlQueue)channelId, IfxGeth_MtlInterruptFlag_txQueueUnderflow))
8000d450:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000d454:	54 22       	ld.w %d2,[%a2]
8000d456:	82 05       	mov %d5,0
8000d458:	19 e4 c8 ff 	ld.w %d4,[%a14]-56
8000d45c:	60 24       	mov.a %a4,%d2
8000d45e:	6d ff c3 dd 	call 80008fe4 <IfxGeth_mtl_isInterruptFlagSet>
8000d462:	df 02 0b 00 	jeq %d2,0,8000d478 <IfxGeth_Eth_wakeupTransmitter+0x114>
        {
            IfxGeth_mtl_clearInterruptFlag(geth->gethSFR, (IfxGeth_MtlQueue)channelId, IfxGeth_MtlInterruptFlag_txQueueUnderflow);
8000d466:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000d46a:	54 22       	ld.w %d2,[%a2]
8000d46c:	82 05       	mov %d5,0
8000d46e:	19 e4 c8 ff 	ld.w %d4,[%a14]-56
8000d472:	60 24       	mov.a %a4,%d2
8000d474:	6d ff 82 dc 	call 80008d78 <IfxGeth_mtl_clearInterruptFlag>
        }

        IfxGeth_Eth_startTransmitter(geth, channelId);
8000d478:	19 e4 c8 ff 	ld.w %d4,[%a14]-56
8000d47c:	99 e4 cc ff 	ld.a %a4,[%a14]-52
8000d480:	6d ff 50 fe 	call 8000d120 <IfxGeth_Eth_startTransmitter>
    }
}
8000d484:	00 00       	nop 
8000d486:	00 90       	ret 

8000d488 <IfxCpu_Trap_memoryManagementError>:
{
8000d488:	40 ae       	mov.aa %a14,%sp
8000d48a:	20 30       	sub.a %sp,48
8000d48c:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d490:	82 02       	mov %d2,0
8000d492:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d496:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d49a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
}

IFX_INLINE void* Ifx__getA11(void)
{
    uint32 *res;
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d49e:	40 b2       	mov.aa %a2,%a11
8000d4a0:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d4a4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d4a8:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d4ac:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d4b0:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d4b4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d4b8:	8f f2 0f 21 	and %d2,%d2,255
8000d4bc:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d4c0:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d4c4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d4c8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d4cc:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d4d0:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d4d4:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d4d8:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d4dc:	8f 72 00 21 	and %d2,%d2,7
8000d4e0:	8f f2 0f 31 	and %d3,%d2,255
8000d4e4:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d4e8:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d4ec:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d4f0:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d4f4:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_MME_HOOK(trapWatch);
8000d4f8:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm__ volatile ("debug" : : : "memory");
8000d4fc:	00 a0       	debug 
}
8000d4fe:	00 00       	nop 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d500:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d504:	00 80       	rfe 
}
8000d506:	00 00       	nop 
8000d508:	00 90       	ret 

8000d50a <IfxCpu_Trap_internalProtectionError>:
{
8000d50a:	40 ae       	mov.aa %a14,%sp
8000d50c:	20 30       	sub.a %sp,48
8000d50e:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d512:	82 12       	mov %d2,1
8000d514:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d518:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d51c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d520:	40 b2       	mov.aa %a2,%a11
8000d522:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d526:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d52a:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d52e:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d532:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d536:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d53a:	8f f2 0f 21 	and %d2,%d2,255
8000d53e:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d542:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d546:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d54a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d54e:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d552:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d556:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d55a:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d55e:	8f 72 00 21 	and %d2,%d2,7
8000d562:	8f f2 0f 31 	and %d3,%d2,255
8000d566:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d56a:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d56e:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d572:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d576:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_IPE_HOOK(trapWatch);
8000d57a:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm__ volatile ("debug" : : : "memory");
8000d57e:	00 a0       	debug 
}
8000d580:	00 00       	nop 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d582:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d586:	00 80       	rfe 
}
8000d588:	00 00       	nop 
8000d58a:	00 90       	ret 

8000d58c <IfxCpu_Trap_instructionError>:
{
8000d58c:	40 ae       	mov.aa %a14,%sp
8000d58e:	20 30       	sub.a %sp,48
8000d590:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d594:	82 22       	mov %d2,2
8000d596:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d59a:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d59e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d5a2:	40 b2       	mov.aa %a2,%a11
8000d5a4:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d5a8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d5ac:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d5b0:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d5b4:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d5b8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d5bc:	8f f2 0f 21 	and %d2,%d2,255
8000d5c0:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d5c4:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d5c8:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d5cc:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d5d0:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d5d4:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d5d8:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d5dc:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d5e0:	8f 72 00 21 	and %d2,%d2,7
8000d5e4:	8f f2 0f 31 	and %d3,%d2,255
8000d5e8:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d5ec:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d5f0:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d5f4:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d5f8:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_IE_HOOK(trapWatch);
8000d5fc:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm__ volatile ("debug" : : : "memory");
8000d600:	00 a0       	debug 
}
8000d602:	00 00       	nop 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d604:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d608:	00 80       	rfe 
}
8000d60a:	00 00       	nop 
8000d60c:	00 90       	ret 

8000d60e <IfxCpu_Trap_contextManagementError>:
{
8000d60e:	40 ae       	mov.aa %a14,%sp
8000d610:	20 30       	sub.a %sp,48
8000d612:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d616:	82 32       	mov %d2,3
8000d618:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d61c:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d620:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d624:	40 b2       	mov.aa %a2,%a11
8000d626:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d62a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d62e:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d632:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d636:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d63a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d63e:	8f f2 0f 21 	and %d2,%d2,255
8000d642:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d646:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d64a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d64e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d652:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d656:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d65a:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d65e:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d662:	8f 72 00 21 	and %d2,%d2,7
8000d666:	8f f2 0f 31 	and %d3,%d2,255
8000d66a:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d66e:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d672:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d676:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d67a:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_CME_HOOK(trapWatch);
8000d67e:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm__ volatile ("debug" : : : "memory");
8000d682:	00 a0       	debug 
}
8000d684:	00 00       	nop 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d686:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d68a:	00 80       	rfe 
}
8000d68c:	00 00       	nop 
8000d68e:	00 90       	ret 

8000d690 <IfxCpu_Trap_busError>:
{
8000d690:	40 ae       	mov.aa %a14,%sp
8000d692:	20 30       	sub.a %sp,48
8000d694:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d698:	82 42       	mov %d2,4
8000d69a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d69e:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d6a2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d6a6:	40 b2       	mov.aa %a2,%a11
8000d6a8:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d6ac:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d6b0:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d6b4:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d6b8:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d6bc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d6c0:	8f f2 0f 21 	and %d2,%d2,255
8000d6c4:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d6c8:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d6cc:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d6d0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d6d4:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d6d8:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d6dc:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d6e0:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d6e4:	8f 72 00 21 	and %d2,%d2,7
8000d6e8:	8f f2 0f 31 	and %d3,%d2,255
8000d6ec:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d6f0:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d6f4:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d6f8:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d6fc:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_BE_HOOK(trapWatch);
8000d700:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm__ volatile ("debug" : : : "memory");
8000d704:	00 a0       	debug 
}
8000d706:	00 00       	nop 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d708:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d70c:	00 80       	rfe 
}
8000d70e:	00 00       	nop 
8000d710:	00 90       	ret 

8000d712 <IfxCpu_Trap_assertion>:
{
8000d712:	40 ae       	mov.aa %a14,%sp
8000d714:	20 30       	sub.a %sp,48
8000d716:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d71a:	82 52       	mov %d2,5
8000d71c:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d720:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d724:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d728:	40 b2       	mov.aa %a2,%a11
8000d72a:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d72e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d732:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d736:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d73a:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d73e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d742:	8f f2 0f 21 	and %d2,%d2,255
8000d746:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d74a:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d74e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d752:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d756:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d75a:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d75e:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d762:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d766:	8f 72 00 21 	and %d2,%d2,7
8000d76a:	8f f2 0f 31 	and %d3,%d2,255
8000d76e:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d772:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d776:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d77a:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d77e:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_ASSERT_HOOK(trapWatch);
8000d782:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm__ volatile ("debug" : : : "memory");
8000d786:	00 a0       	debug 
}
8000d788:	00 00       	nop 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d78a:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d78e:	00 80       	rfe 
}
8000d790:	00 00       	nop 
8000d792:	00 90       	ret 

8000d794 <IfxCpu_Trap_systemCall_Cpu0>:
{
8000d794:	40 ae       	mov.aa %a14,%sp
8000d796:	20 30       	sub.a %sp,48
8000d798:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d79c:	82 62       	mov %d2,6
8000d79e:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d7a2:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d7a6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d7aa:	40 b2       	mov.aa %a2,%a11
8000d7ac:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d7b0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d7b4:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d7b8:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d7bc:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d7c0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d7c4:	8f f2 0f 21 	and %d2,%d2,255
8000d7c8:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d7cc:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d7d0:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d7d4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d7d8:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d7dc:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d7e0:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d7e4:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d7e8:	8f 72 00 21 	and %d2,%d2,7
8000d7ec:	8f f2 0f 31 	and %d3,%d2,255
8000d7f0:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d7f4:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d7f8:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d7fc:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d800:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU0_HOOK(trapWatch);
8000d804:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d808:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d80c:	00 80       	rfe 
}
8000d80e:	00 00       	nop 
8000d810:	00 90       	ret 

8000d812 <IfxCpu_Trap_systemCall_Cpu1>:
{
8000d812:	40 ae       	mov.aa %a14,%sp
8000d814:	20 30       	sub.a %sp,48
8000d816:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d81a:	82 62       	mov %d2,6
8000d81c:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d820:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d824:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d828:	40 b2       	mov.aa %a2,%a11
8000d82a:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d82e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d832:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d836:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d83a:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d83e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d842:	8f f2 0f 21 	and %d2,%d2,255
8000d846:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d84a:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d84e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d852:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d856:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d85a:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d85e:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d862:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d866:	8f 72 00 21 	and %d2,%d2,7
8000d86a:	8f f2 0f 31 	and %d3,%d2,255
8000d86e:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d872:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d876:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d87a:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d87e:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU1_HOOK(trapWatch);
8000d882:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d886:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d88a:	00 80       	rfe 
}
8000d88c:	00 00       	nop 
8000d88e:	00 90       	ret 

8000d890 <IfxCpu_Trap_systemCall_Cpu2>:
{
8000d890:	40 ae       	mov.aa %a14,%sp
8000d892:	20 30       	sub.a %sp,48
8000d894:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d898:	82 62       	mov %d2,6
8000d89a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d89e:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d8a2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d8a6:	40 b2       	mov.aa %a2,%a11
8000d8a8:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d8ac:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d8b0:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d8b4:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d8b8:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d8bc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d8c0:	8f f2 0f 21 	and %d2,%d2,255
8000d8c4:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d8c8:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d8cc:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d8d0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d8d4:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d8d8:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d8dc:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d8e0:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d8e4:	8f 72 00 21 	and %d2,%d2,7
8000d8e8:	8f f2 0f 31 	and %d3,%d2,255
8000d8ec:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d8f0:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d8f4:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d8f8:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d8fc:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU2_HOOK(trapWatch);
8000d900:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d904:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d908:	00 80       	rfe 
}
8000d90a:	00 00       	nop 
8000d90c:	00 90       	ret 

8000d90e <IfxCpu_Trap_systemCall_Cpu3>:
{
8000d90e:	40 ae       	mov.aa %a14,%sp
8000d910:	20 30       	sub.a %sp,48
8000d912:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d916:	82 62       	mov %d2,6
8000d918:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d91c:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d920:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d924:	40 b2       	mov.aa %a2,%a11
8000d926:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d92a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d92e:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d932:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d936:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d93a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d93e:	8f f2 0f 21 	and %d2,%d2,255
8000d942:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d946:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d94a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d94e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d952:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d956:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d95a:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d95e:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d962:	8f 72 00 21 	and %d2,%d2,7
8000d966:	8f f2 0f 31 	and %d3,%d2,255
8000d96a:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d96e:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d972:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d976:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d97a:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU3_HOOK(trapWatch);
8000d97e:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000d982:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000d986:	00 80       	rfe 
}
8000d988:	00 00       	nop 
8000d98a:	00 90       	ret 

8000d98c <IfxCpu_Trap_systemCall_Cpu4>:
{
8000d98c:	40 ae       	mov.aa %a14,%sp
8000d98e:	20 30       	sub.a %sp,48
8000d990:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000d994:	82 62       	mov %d2,6
8000d996:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000d99a:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000d99e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000d9a2:	40 b2       	mov.aa %a2,%a11
8000d9a4:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000d9a8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000d9ac:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000d9b0:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000d9b4:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000d9b8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000d9bc:	8f f2 0f 21 	and %d2,%d2,255
8000d9c0:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000d9c4:	4d c0 e1 2f 	mfcr %d2,$core_id
8000d9c8:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000d9cc:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000d9d0:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000d9d4:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000d9d8:	37 02 63 20 	extr.u %d2,%d2,0,3
8000d9dc:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000d9e0:	8f 72 00 21 	and %d2,%d2,7
8000d9e4:	8f f2 0f 31 	and %d3,%d2,255
8000d9e8:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000d9ec:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000d9f0:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000d9f4:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000d9f8:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU4_HOOK(trapWatch);
8000d9fc:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000da00:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000da04:	00 80       	rfe 
}
8000da06:	00 00       	nop 
8000da08:	00 90       	ret 

8000da0a <IfxCpu_Trap_systemCall_Cpu5>:
{
8000da0a:	40 ae       	mov.aa %a14,%sp
8000da0c:	20 30       	sub.a %sp,48
8000da0e:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000da12:	82 62       	mov %d2,6
8000da14:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000da18:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000da1c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000da20:	40 b2       	mov.aa %a2,%a11
8000da22:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000da26:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000da2a:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000da2e:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000da32:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000da36:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000da3a:	8f f2 0f 21 	and %d2,%d2,255
8000da3e:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000da42:	4d c0 e1 2f 	mfcr %d2,$core_id
8000da46:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000da4a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000da4e:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000da52:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000da56:	37 02 63 20 	extr.u %d2,%d2,0,3
8000da5a:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000da5e:	8f 72 00 21 	and %d2,%d2,7
8000da62:	8f f2 0f 31 	and %d3,%d2,255
8000da66:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000da6a:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000da6e:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000da72:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000da76:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU5_HOOK(trapWatch);
8000da7a:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000da7e:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000da82:	00 80       	rfe 
}
8000da84:	00 00       	nop 
8000da86:	00 90       	ret 

8000da88 <IfxCpu_Trap_nonMaskableInterrupt>:
{
8000da88:	40 ae       	mov.aa %a14,%sp
8000da8a:	20 30       	sub.a %sp,48
8000da8c:	59 e4 d4 ff 	st.w [%a14]-44,%d4
8000da90:	82 72       	mov %d2,7
8000da92:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8000da96:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000da9a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000da9e:	40 b2       	mov.aa %a2,%a11
8000daa0:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
    return res;
8000daa4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
    trapInfo.tAddr  = (unsigned int)__getA11();
8000daa8:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    trapInfo.tClass = trapClass;
8000daac:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8000dab0:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
    trapInfo.tId    = tin;
8000dab4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000dab8:	8f f2 0f 21 	and %d2,%d2,255
8000dabc:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000dac0:	4d c0 e1 2f 	mfcr %d2,$core_id
8000dac4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000dac8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000dacc:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return (IfxCpu_Id)reg.B.CORE_ID;
8000dad0:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000dad4:	37 02 63 20 	extr.u %d2,%d2,0,3
8000dad8:	8f f2 0f 21 	and %d2,%d2,255
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000dadc:	8f 72 00 21 	and %d2,%d2,7
8000dae0:	8f f2 0f 31 	and %d3,%d2,255
8000dae4:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000dae8:	37 32 03 28 	insert %d2,%d2,%d3,16,3
8000daec:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    return trapInfo;
8000daf0:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
8000daf4:	89 e2 e8 f9 	st.da [%a14]-24,%a2
    IFX_CFG_CPU_TRAP_NMI_HOOK(trapWatch);    
8000daf8:	09 e2 e8 f9 	ld.da %a2,[%a14]-24
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000dafc:	0d 00 40 02 	rslcx 
    __asm("rfe");
8000db00:	00 80       	rfe 
}
8000db02:	00 00       	nop 
8000db04:	00 90       	ret 

8000db06 <IfxCpu_waitEvent>:
    return retVal;
}


boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec)
{
8000db06:	40 ae       	mov.aa %a14,%sp
8000db08:	20 20       	sub.a %sp,32
8000db0a:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
8000db0e:	59 e4 e0 ff 	st.w [%a14]-32,%d4
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
8000db12:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000db16:	7b 00 00 3f 	movh %d3,61440
8000db1a:	26 32       	and %d2,%d3
8000db1c:	7b 00 00 3d 	movh %d3,53248
8000db20:	5f 32 17 80 	jne %d2,%d3,8000db4e <IfxCpu_waitEvent+0x48>
8000db24:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000db28:	82 f3       	mov %d3,-1
8000db2a:	8f 43 1f 30 	sh %d3,%d3,-12
8000db2e:	26 32       	and %d2,%d3
8000db30:	7b 00 00 37 	movh %d3,28672
8000db34:	a6 23       	or %d3,%d2
8000db36:	4d c0 e1 2f 	mfcr %d2,$core_id
8000db3a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000db3e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000db42:	8f c2 01 20 	sh %d2,%d2,28
8000db46:	0b 23 80 20 	sub %d2,%d3,%d2
8000db4a:	1d 00 04 00 	j 8000db52 <IfxCpu_waitEvent+0x4c>
8000db4e:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000db52:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    boolean          errorcnt      = 0U;
8000db56:	82 02       	mov %d2,0
8000db58:	e9 e2 ff ff 	st.b [%a14]-1,%d2
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / SCU_CCUCON0.B.STMDIV;
8000db5c:	82 04       	mov %d4,0
8000db5e:	6d ff a9 c9 	call 80006eb0 <IfxScuCcu_getSourceFrequency>
8000db62:	02 23       	mov %d3,%d2
8000db64:	91 30 00 2f 	movh.a %a2,61443
8000db68:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000db6c:	54 22       	ld.w %d2,[%a2]
8000db6e:	37 02 64 20 	extr.u %d2,%d2,0,4
8000db72:	8f f2 0f 21 	and %d2,%d2,255
8000db76:	4b 02 41 21 	itof %d2,%d2
8000db7a:	4b 23 51 20 	div.f %d2,%d3,%d2
    /* Divide with 1000, gives the count value equivalent to milliseconds */
    uint32           stmCount      = (uint32)((IfxScuCcu_getStmFrequency() / 1000) * timeoutMilliSec);
8000db7e:	7b a0 47 34 	movh %d3,17530
8000db82:	4b 32 51 30 	div.f %d3,%d2,%d3
8000db86:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000db8a:	4b 02 61 21 	utof %d2,%d2
8000db8e:	4b 23 41 20 	mul.f %d2,%d3,%d2
8000db92:	4b 02 71 21 	ftouz %d2,%d2
8000db96:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    uint32           stmCountBegin = STM0_TIM0.U;
8000db9a:	c5 f2 10 01 	lea %a2,f0001010 <bmhd_3_copy+0x40bffa10>
8000db9e:	54 22       	ld.w %d2,[%a2]
8000dba0:	59 e2 ec ff 	st.w [%a14]-20,%d2

    while ((*sync & IFXCPU_CFG_ALLCORE_DONE) != IFXCPU_CFG_ALLCORE_DONE)
8000dba4:	1d 00 13 00 	j 8000dbca <IfxCpu_waitEvent+0xc4>
    __asm__ volatile ("nop" : : : "memory");
8000dba8:	00 00       	nop 
}
8000dbaa:	00 00       	nop 
    {
        __nop();

        if ((uint32)(STM0_TIM0.U - stmCountBegin) >= stmCount)
8000dbac:	c5 f2 10 01 	lea %a2,f0001010 <bmhd_3_copy+0x40bffa10>
8000dbb0:	54 23       	ld.w %d3,[%a2]
8000dbb2:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000dbb6:	a2 23       	sub %d3,%d2
8000dbb8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000dbbc:	3f 23 07 80 	jlt.u %d3,%d2,8000dbca <IfxCpu_waitEvent+0xc4>
        {
            errorcnt = 1;
8000dbc0:	82 12       	mov %d2,1
8000dbc2:	e9 e2 ff ff 	st.b [%a14]-1,%d2
            break;
8000dbc6:	1d 00 0b 00 	j 8000dbdc <IfxCpu_waitEvent+0xd6>
    while ((*sync & IFXCPU_CFG_ALLCORE_DONE) != IFXCPU_CFG_ALLCORE_DONE)
8000dbca:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000dbce:	54 22       	ld.w %d2,[%a2]
8000dbd0:	8f f2 05 21 	and %d2,%d2,95
8000dbd4:	8b f2 25 22 	ne %d2,%d2,95
8000dbd8:	df 02 e8 ff 	jne %d2,0,8000dba8 <IfxCpu_waitEvent+0xa2>
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

    return errorcnt;
8000dbdc:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
}
8000dbe0:	00 90       	ret 

8000dbe2 <IfxCpu_emitEvent>:


void IfxCpu_emitEvent(IfxCpu_syncEvent *event)
{
8000dbe2:	40 ae       	mov.aa %a14,%sp
8000dbe4:	20 18       	sub.a %sp,24
8000dbe6:	b5 e4 ec ff 	st.a [%a14]-20,%a4
    Ifx__imaskldmst(event, 1, __mfcr(CPU_CORE_ID), 1);
8000dbea:	4d c0 e1 2f 	mfcr %d2,$core_id
8000dbee:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000dbf2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000dbf6:	82 13       	mov %d3,1
8000dbf8:	57 30 21 22 	imask %e2,%d3,%d2,1
8000dbfc:	89 e2 74 f9 	st.d [%a14]-12,%e2
8000dc00:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000dc04:	09 e2 74 f9 	ld.d %e2,[%a14]-12
8000dc08:	49 22 40 08 	ldmst [%a2]0,%e2
}
8000dc0c:	00 00       	nop 
8000dc0e:	00 90       	ret 

8000dc10 <IfxCpu_Irq_getTos>:

/** \brief API to get type of service of the caller CPU.
 *
 */
IfxSrc_Tos IfxCpu_Irq_getTos(IfxCpu_ResourceCpu coreId)
{
8000dc10:	40 ae       	mov.aa %a14,%sp
8000dc12:	20 20       	sub.a %sp,32
8000dc14:	59 e4 e4 ff 	st.w [%a14]-28,%d4
    const IfxSrc_Tos tos[IFXCPU_NUM_MODULES] = {
8000dc18:	91 10 00 27 	movh.a %a2,28673
8000dc1c:	d9 23 30 8a 	lea %a3,[%a2]-24016 <7000a230 <IfxGeth_Eth_Phy_Rtl8211f_iPhyInitDone+0x8>>
8000dc20:	d9 e2 e8 ff 	lea %a2,[%a14]-24 <7000a230 <IfxGeth_Eth_Phy_Rtl8211f_iPhyInitDone+0x8>>
8000dc24:	09 34 48 01 	ld.d %e4,[%a3+]8 <7000a230 <IfxGeth_Eth_Phy_Rtl8211f_iPhyInitDone+0x8>>
8000dc28:	89 24 48 01 	st.d [%a2+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000dc2c:	09 34 48 01 	ld.d %e4,[%a3+]8 <70010008 <ram_heap+0x4f74>>
8000dc30:	89 24 48 01 	st.d [%a2+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000dc34:	09 34 48 01 	ld.d %e4,[%a3+]8 <70010008 <ram_heap+0x4f74>>
8000dc38:	89 24 48 01 	st.d [%a2+]8 <70010008 <ram_heap+0x4f74>>,%e4
        IfxSrc_Tos_cpu0, IfxSrc_Tos_cpu1,
        IfxSrc_Tos_cpu2, IfxSrc_Tos_cpu3,
        IfxSrc_Tos_cpu4, IfxSrc_Tos_cpu5,
    };

    return tos[coreId];
8000dc3c:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <70010008 <ram_heap+0x4f74>>
8000dc40:	06 22       	sh %d2,2
8000dc42:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
8000dc46:	d9 22 e8 ff 	lea %a2,[%a2]-24
8000dc4a:	54 22       	ld.w %d2,[%a2]
}
8000dc4c:	00 90       	ret 

8000dc4e <IfxAsclin_enableModule>:
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  /* enables Rx fifo Overflow error*/
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
8000dc4e:	40 ae       	mov.aa %a14,%sp
8000dc50:	20 10       	sub.a %sp,16
8000dc52:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
8000dc56:	6d ff 3f d5 	call 800086d4 <IfxScuWdt_getCpuWatchdogPassword>
8000dc5a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
8000dc5e:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000dc62:	02 24       	mov %d4,%d2
8000dc64:	6d ff 41 d3 	call 800082e6 <IfxScuWdt_clearCpuEndinit>
8000dc68:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000dc6c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
}


IFX_INLINE void IfxAsclin_setEnableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 0;
8000dc70:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000dc74:	54 22       	ld.w %d2,[%a2]
8000dc76:	8f 12 c0 21 	andn %d2,%d2,1
8000dc7a:	74 22       	st.w [%a2],%d2
}
8000dc7c:	00 00       	nop 
    IfxAsclin_setEnableModuleRequest(asclin); /* enables the module*/
    IfxScuWdt_setCpuEndinit(psw);             /* sets the endinit protection back on*/
8000dc7e:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000dc82:	02 24       	mov %d4,%d2
8000dc84:	6d ff 78 d5 	call 80008774 <IfxScuWdt_setCpuEndinit>
}
8000dc88:	00 00       	nop 
8000dc8a:	00 90       	ret 

8000dc8c <IfxAsclin_getFaFrequency>:
    return module;
}


float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
8000dc8c:	40 ae       	mov.aa %a14,%sp
8000dc8e:	20 28       	sub.a %sp,40
8000dc90:	b5 e4 dc ff 	st.a [%a14]-36,%a4
8000dc94:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000dc98:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    return asclin->CSR.B.CLKSEL;
8000dc9c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000dca0:	d9 22 0c 10 	lea %a2,[%a2]76
8000dca4:	54 22       	ld.w %d2,[%a2]
8000dca6:	37 02 65 20 	extr.u %d2,%d2,0,5
8000dcaa:	8f f2 0f 21 	and %d2,%d2,255
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/
8000dcae:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    switch (clockSource)
8000dcb2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000dcb6:	df 42 67 00 	jeq %d2,4,8000dd84 <IfxAsclin_getFaFrequency+0xf8>
8000dcba:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000dcbe:	ff 52 69 80 	jge.u %d2,5,8000dd90 <IfxAsclin_getFaFrequency+0x104>
8000dcc2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000dcc6:	df 02 08 00 	jeq %d2,0,8000dcd6 <IfxAsclin_getFaFrequency+0x4a>
8000dcca:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000dcce:	df 22 09 00 	jeq %d2,2,8000dce0 <IfxAsclin_getFaFrequency+0x54>
8000dcd2:	1d 00 5f 00 	j 8000dd90 <IfxAsclin_getFaFrequency+0x104>
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0f;
8000dcd6:	82 02       	mov %d2,0
8000dcd8:	59 e2 fc ff 	st.w [%a14]-4,%d2
        break;
8000dcdc:	1d 00 5e 00 	j 8000dd98 <IfxAsclin_getFaFrequency+0x10c>
    float32 freq          = 0;
8000dce0:	82 02       	mov %d2,0
8000dce2:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    uint8   asclindiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
8000dce6:	91 00 00 28 	movh.a %a2,32768
8000dcea:	d9 23 88 50 	lea %a3,[%a2]2376 <80000948 <IfxCpu_Trap_vectorTable0_end+0x754>>
8000dcee:	d9 e2 e0 ff 	lea %a2,[%a14]-32 <80000948 <IfxCpu_Trap_vectorTable0_end+0x754>>
8000dcf2:	04 32       	ld.bu %d2,[%a3+]
8000dcf4:	24 22       	st.b [%a2+],%d2
8000dcf6:	04 32       	ld.bu %d2,[%a3+]
8000dcf8:	24 22       	st.b [%a2+],%d2
8000dcfa:	04 32       	ld.bu %d2,[%a3+]
8000dcfc:	24 22       	st.b [%a2+],%d2
8000dcfe:	04 32       	ld.bu %d2,[%a3+]
8000dd00:	24 22       	st.b [%a2+],%d2
8000dd02:	04 32       	ld.bu %d2,[%a3+]
8000dd04:	24 22       	st.b [%a2+],%d2
8000dd06:	04 32       	ld.bu %d2,[%a3+]
8000dd08:	24 22       	st.b [%a2+],%d2
8000dd0a:	04 32       	ld.bu %d2,[%a3+]
8000dd0c:	24 22       	st.b [%a2+],%d2
8000dd0e:	04 32       	ld.bu %d2,[%a3+]
8000dd10:	24 22       	st.b [%a2+],%d2
8000dd12:	04 32       	ld.bu %d2,[%a3+]
8000dd14:	24 22       	st.b [%a2+],%d2
8000dd16:	04 32       	ld.bu %d2,[%a3+]
8000dd18:	24 22       	st.b [%a2+],%d2
8000dd1a:	04 32       	ld.bu %d2,[%a3+]
8000dd1c:	24 22       	st.b [%a2+],%d2
8000dd1e:	04 32       	ld.bu %d2,[%a3+]
8000dd20:	24 22       	st.b [%a2+],%d2
8000dd22:	04 32       	ld.bu %d2,[%a3+]
8000dd24:	24 22       	st.b [%a2+],%d2
8000dd26:	04 32       	ld.bu %d2,[%a3+]
8000dd28:	24 22       	st.b [%a2+],%d2
8000dd2a:	04 32       	ld.bu %d2,[%a3+]
8000dd2c:	24 22       	st.b [%a2+],%d2
8000dd2e:	04 32       	ld.bu %d2,[%a3+]
8000dd30:	24 22       	st.b [%a2+],%d2
    if (SCU_CCUCON2.B.ASCLINFDIV)
8000dd32:	91 30 00 2f 	movh.a %a2,61443
8000dd36:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
8000dd3a:	54 22       	ld.w %d2,[%a2]
8000dd3c:	37 02 64 20 	extr.u %d2,%d2,0,4
8000dd40:	8f f2 0f 21 	and %d2,%d2,255
8000dd44:	df 02 1a 00 	jeq %d2,0,8000dd78 <IfxAsclin_getFaFrequency+0xec>
        freq = IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_2) / asclindiv[SCU_CCUCON2.B.ASCLINFDIV];
8000dd48:	82 24       	mov %d4,2
8000dd4a:	6d ff b3 c8 	call 80006eb0 <IfxScuCcu_getSourceFrequency>
8000dd4e:	02 23       	mov %d3,%d2
8000dd50:	91 30 00 2f 	movh.a %a2,61443
8000dd54:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <bmhd_3_copy+0x40c34a40>>
8000dd58:	54 22       	ld.w %d2,[%a2]
8000dd5a:	37 02 64 20 	extr.u %d2,%d2,0,4
8000dd5e:	8f f2 0f 21 	and %d2,%d2,255
8000dd62:	d9 e2 e0 ff 	lea %a2,[%a14]-32
8000dd66:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000dd6a:	14 22       	ld.bu %d2,[%a2]
8000dd6c:	4b 02 41 21 	itof %d2,%d2
8000dd70:	4b 23 51 20 	div.f %d2,%d3,%d2
8000dd74:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    return freq;
8000dd78:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getAsclinFFrequency();
8000dd7c:	59 e2 fc ff 	st.w [%a14]-4,%d2
        break;
8000dd80:	1d 00 0c 00 	j 8000dd98 <IfxAsclin_getFaFrequency+0x10c>
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getAsclinSFrequency();
8000dd84:	6d ff 80 c6 	call 80006a84 <IfxScuCcu_getAsclinSFrequency>
8000dd88:	59 e2 fc ff 	st.w [%a14]-4,%d2
        break;
8000dd8c:	1d 00 06 00 	j 8000dd98 <IfxAsclin_getFaFrequency+0x10c>
    default:
        frequency = 0.0f;
8000dd90:	82 02       	mov %d2,0
8000dd92:	59 e2 fc ff 	st.w [%a14]-4,%d2
        break;
8000dd96:	00 00       	nop 
    }

    return frequency;
8000dd98:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8000dd9c:	00 90       	ret 

8000dd9e <IfxAsclin_getIndex>:


IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
8000dd9e:	40 ae       	mov.aa %a14,%sp
8000dda0:	20 10       	sub.a %sp,16
8000dda2:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;
8000dda6:	82 f2       	mov %d2,-1
8000dda8:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
8000ddac:	82 02       	mov %d2,0
8000ddae:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000ddb2:	1d 00 26 00 	j 8000ddfe <IfxAsclin_getIndex+0x60>
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
8000ddb6:	91 00 00 28 	movh.a %a2,32768
8000ddba:	d9 22 30 54 	lea %a2,[%a2]16752 <80004170 <IfxAsclin_cfg_indexMap>>
8000ddbe:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <80004170 <IfxAsclin_cfg_indexMap>>
8000ddc2:	06 32       	sh %d2,3
8000ddc4:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000ddc8:	54 22       	ld.w %d2,[%a2]
8000ddca:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000ddce:	5f 23 13 80 	jne %d3,%d2,8000ddf4 <IfxAsclin_getIndex+0x56>
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
8000ddd2:	91 00 00 28 	movh.a %a2,32768
8000ddd6:	d9 22 30 54 	lea %a2,[%a2]16752 <80004170 <IfxAsclin_cfg_indexMap>>
8000ddda:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <80004170 <IfxAsclin_cfg_indexMap>>
8000ddde:	06 32       	sh %d2,3
8000dde0:	80 23       	mov.d %d3,%a2
8000dde2:	42 23       	add %d3,%d2
8000dde4:	02 32       	mov %d2,%d3
8000dde6:	60 22       	mov.a %a2,%d2
8000dde8:	b0 42       	add.a %a2,4
8000ddea:	54 22       	ld.w %d2,[%a2]
8000ddec:	59 e2 f8 ff 	st.w [%a14]-8,%d2
            break;
8000ddf0:	1d 00 0b 00 	j 8000de06 <IfxAsclin_getIndex+0x68>
    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
8000ddf4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000ddf8:	c2 12       	add %d2,1
8000ddfa:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000ddfe:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000de02:	bf c2 da ff 	jlt.u %d2,12,8000ddb6 <IfxAsclin_getIndex+0x18>
        }
    }

    return result;
8000de06:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
}
8000de0a:	00 90       	ret 

8000de0c <IfxAsclin_getPdFrequency>:
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
8000de0c:	40 ae       	mov.aa %a14,%sp
8000de0e:	20 08       	sub.a %sp,8
8000de10:	b5 e4 fc ff 	st.a [%a14]-4,%a4
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
8000de14:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8000de18:	6d ff 3a ff 	call 8000dc8c <IfxAsclin_getFaFrequency>
8000de1c:	02 23       	mov %d3,%d2
8000de1e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000de22:	d9 22 14 00 	lea %a2,[%a2]20
8000de26:	54 22       	ld.w %d2,[%a2]
8000de28:	37 02 6c 20 	extr.u %d2,%d2,0,12
8000de2c:	37 02 70 20 	extr.u %d2,%d2,0,16
8000de30:	c2 12       	add %d2,1
8000de32:	4b 02 41 21 	itof %d2,%d2
8000de36:	4b 23 51 20 	div.f %d2,%d3,%d2
}
8000de3a:	00 90       	ret 

8000de3c <IfxAsclin_getSrcPointerEr>:
    return IfxAsclin_getOvsFrequency(asclin) / (asclin->BITCON.B.OVERSAMPLING + 1);
}


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
8000de3c:	40 ae       	mov.aa %a14,%sp
8000de3e:	20 08       	sub.a %sp,8
8000de40:	b5 e4 fc ff 	st.a [%a14]-4,%a4
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
8000de44:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8000de48:	6d ff ab ff 	call 8000dd9e <IfxAsclin_getIndex>
8000de4c:	53 c2 20 20 	mul %d2,%d2,12
8000de50:	1b 82 00 20 	addi %d2,%d2,8
8000de54:	1b 02 05 28 	addi %d2,%d2,-32688
8000de58:	9b 42 00 2f 	addih %d2,%d2,61444
}
8000de5c:	60 22       	mov.a %a2,%d2
8000de5e:	00 90       	ret 

8000de60 <IfxAsclin_getSrcPointerRx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
8000de60:	40 ae       	mov.aa %a14,%sp
8000de62:	20 08       	sub.a %sp,8
8000de64:	b5 e4 fc ff 	st.a [%a14]-4,%a4
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
8000de68:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8000de6c:	6d ff 99 ff 	call 8000dd9e <IfxAsclin_getIndex>
8000de70:	53 c2 20 20 	mul %d2,%d2,12
8000de74:	c2 42       	add %d2,4
8000de76:	1b 02 05 28 	addi %d2,%d2,-32688
8000de7a:	9b 42 00 2f 	addih %d2,%d2,61444
}
8000de7e:	60 22       	mov.a %a2,%d2
8000de80:	00 90       	ret 

8000de82 <IfxAsclin_getSrcPointerTx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
8000de82:	40 ae       	mov.aa %a14,%sp
8000de84:	20 08       	sub.a %sp,8
8000de86:	b5 e4 fc ff 	st.a [%a14]-4,%a4
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
8000de8a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8000de8e:	6d ff 88 ff 	call 8000dd9e <IfxAsclin_getIndex>
8000de92:	53 c2 20 20 	mul %d2,%d2,12
8000de96:	1b 02 05 28 	addi %d2,%d2,-32688
8000de9a:	9b 42 00 2f 	addih %d2,%d2,61444
}
8000de9e:	60 22       	mov.a %a2,%d2
8000dea0:	00 90       	ret 

8000dea2 <IfxAsclin_setBitTiming>:
    IfxAsclin_setClockSource(asclin, clockSource);                                               /* sets the clock source back on*/
}


boolean IfxAsclin_setBitTiming(Ifx_ASCLIN *asclin, float32 baudrate, IfxAsclin_OversamplingFactor oversampling, IfxAsclin_SamplePointPosition samplepoint, IfxAsclin_SamplesPerBit medianFilter)
{
8000dea2:	40 ae       	mov.aa %a14,%sp
8000dea4:	20 78       	sub.a %sp,120
8000dea6:	b5 e4 dc ef 	st.a [%a14]-100,%a4
8000deaa:	59 e4 d8 ef 	st.w [%a14]-104,%d4
8000deae:	59 e5 d4 ef 	st.w [%a14]-108,%d5
8000deb2:	59 e6 d0 ef 	st.w [%a14]-112,%d6
8000deb6:	59 e7 cc ef 	st.w [%a14]-116,%d7
8000deba:	19 e2 dc ef 	ld.w %d2,[%a14]-100
8000debe:	59 e2 e4 ef 	st.w [%a14]-92,%d2
8000dec2:	99 e2 e4 ef 	ld.a %a2,[%a14]-92
8000dec6:	d9 22 0c 10 	lea %a2,[%a2]76
8000deca:	54 22       	ld.w %d2,[%a2]
8000decc:	37 02 65 20 	extr.u %d2,%d2,0,5
8000ded0:	8f f2 0f 21 	and %d2,%d2,255
    IfxAsclin_ClockSource source = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);
8000ded4:	59 e2 d8 ff 	st.w [%a14]-40,%d2
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
8000ded8:	82 02       	mov %d2,0
8000deda:	59 e2 d4 ff 	st.w [%a14]-44,%d2
8000dede:	82 12       	mov %d2,1
8000dee0:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000dee4:	82 12       	mov %d2,1
8000dee6:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
8000deea:	99 e4 dc ef 	ld.a %a4,[%a14]-100
8000deee:	6d ff 8f ff 	call 8000de0c <IfxAsclin_getPdFrequency>
8000def2:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
8000def6:	19 e2 d4 ef 	ld.w %d2,[%a14]-108
8000defa:	c2 12       	add %d2,1
8000defc:	59 e2 f0 ef 	st.w [%a14]-80,%d2
8000df00:	82 42       	mov %d2,4
8000df02:	59 e2 ec ef 	st.w [%a14]-84,%d2
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000df06:	19 e2 f0 ef 	ld.w %d2,[%a14]-80
8000df0a:	19 e3 ec ef 	ld.w %d3,[%a14]-84
8000df0e:	0b 32 b0 21 	max.u %d2,%d2,%d3
8000df12:	59 e2 e8 ef 	st.w [%a14]-88,%d2
    return res;
8000df16:	19 e2 e8 ef 	ld.w %d2,[%a14]-88
8000df1a:	59 e2 d4 ef 	st.w [%a14]-108,%d2
8000df1e:	19 e2 d0 ef 	ld.w %d2,[%a14]-112
8000df22:	59 e2 fc ef 	st.w [%a14]-68,%d2
8000df26:	82 12       	mov %d2,1
8000df28:	59 e2 f8 ef 	st.w [%a14]-72,%d2
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000df2c:	19 e2 fc ef 	ld.w %d2,[%a14]-68
8000df30:	19 e3 f8 ef 	ld.w %d3,[%a14]-72
8000df34:	0b 32 b0 21 	max.u %d2,%d2,%d3
8000df38:	59 e2 f4 ef 	st.w [%a14]-76,%d2
    return res;
8000df3c:	19 e2 f4 ef 	ld.w %d2,[%a14]-76
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
8000df40:	59 e2 d0 ef 	st.w [%a14]-112,%d2
    fOvs         = baudrate * oversampling;
8000df44:	19 e2 d4 ef 	ld.w %d2,[%a14]-108
8000df48:	4b 02 61 21 	utof %d2,%d2
8000df4c:	19 e3 d8 ef 	ld.w %d3,[%a14]-104
8000df50:	4b 23 41 20 	mul.f %d2,%d3,%d2
8000df54:	59 e2 cc ff 	st.w [%a14]-52,%d2
    float32               relError   = fOvs;
8000df58:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8000df5c:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    float32               limit      = 0.001f * fOvs;                    // save the error limit
8000df60:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8000df64:	7b 30 a8 33 	movh %d3,14979
8000df68:	1b f3 26 31 	addi %d3,%d3,4719
8000df6c:	4b 32 41 20 	mul.f %d2,%d2,%d3
8000df70:	59 e2 c8 ff 	st.w [%a14]-56,%d2

    boolean               terminated = FALSE;
8000df74:	82 02       	mov %d2,0
8000df76:	e9 e2 ef ff 	st.b [%a14]-17,%d2
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
8000df7a:	19 e3 d0 ff 	ld.w %d3,[%a14]-48
8000df7e:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8000df82:	4b 23 51 20 	div.f %d2,%d3,%d2
8000df86:	4b 02 71 21 	ftouz %d2,%d2
8000df8a:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    n = 1;
8000df8e:	82 12       	mov %d2,1
8000df90:	59 e2 fc ff 	st.w [%a14]-4,%d2
            /* Increase the value of the oversampling to generate the required baudrate */
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
8000df94:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000df98:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    nBest          = n;
8000df9c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000dfa0:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    adder_facL_min = 0;
8000dfa4:	82 02       	mov %d2,0
8000dfa6:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    f              = (fpd * n) / d;
8000dfaa:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000dfae:	4b 02 61 31 	utof %d3,%d2
8000dfb2:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000dfb6:	4b 23 41 30 	mul.f %d3,%d3,%d2
8000dfba:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000dfbe:	4b 02 61 21 	utof %d2,%d2
8000dfc2:	4b 23 51 20 	div.f %d2,%d3,%d2
8000dfc6:	59 e2 c4 ff 	st.w [%a14]-60,%d2
    relError       = __absf(fOvs - f);
8000dfca:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000dfce:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000dfd2:	6b 02 31 23 	sub.f %d2,%d3,%d2
8000dfd6:	82 03       	mov %d3,0
8000dfd8:	4b 32 01 20 	cmp.f %d2,%d2,%d3
8000dfdc:	87 22 20 20 	or.t %d2,%d2,0,%d2,0
8000dfe0:	df 02 0c 00 	jeq %d2,0,8000dff8 <IfxAsclin_setBitTiming+0x156>
8000dfe4:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000dfe8:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000dfec:	6b 02 31 23 	sub.f %d2,%d3,%d2
8000dff0:	9b 02 00 28 	addih %d2,%d2,32768
8000dff4:	1d 00 08 00 	j 8000e004 <IfxAsclin_setBitTiming+0x162>
8000dff8:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000dffc:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000e000:	6b 02 31 23 	sub.f %d2,%d3,%d2
8000e004:	59 e2 f0 ff 	st.w [%a14]-16,%d2

    if (relError <= limit)
8000e008:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000e00c:	19 e3 c8 ff 	ld.w %d3,[%a14]-56
8000e010:	4b 32 01 20 	cmp.f %d2,%d2,%d3
8000e014:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
8000e018:	df 02 05 00 	jeq %d2,0,8000e022 <IfxAsclin_setBitTiming+0x180>
    {
        terminated = TRUE;
8000e01c:	82 12       	mov %d2,1
8000e01e:	e9 e2 ef ff 	st.b [%a14]-17,%d2
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
8000e022:	82 22       	mov %d2,2
8000e024:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000e028:	1d 00 93 00 	j 8000e14e <IfxAsclin_setBitTiming+0x2ac>
    {
        if (n == 2)
8000e02c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000e030:	df 22 0a 80 	jne %d2,2,8000e044 <IfxAsclin_setBitTiming+0x1a2>
        {
            adder_facL = 1;
8000e034:	82 12       	mov %d2,1
8000e036:	59 e2 e8 ff 	st.w [%a14]-24,%d2
            adder_facH = 1;
8000e03a:	82 12       	mov %d2,1
8000e03c:	59 e2 e4 ff 	st.w [%a14]-28,%d2
8000e040:	1d 00 12 00 	j 8000e064 <IfxAsclin_setBitTiming+0x1c2>
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
8000e044:	19 e3 e0 ff 	ld.w %d3,[%a14]-32
8000e048:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000e04c:	e2 32       	mul %d2,%d3
8000e04e:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000e052:	4b 32 11 22 	div.u %e2,%d2,%d3
8000e056:	59 e2 e8 ff 	st.w [%a14]-24,%d2
            adder_facH = adder_facL + 1;
8000e05a:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000e05e:	c2 12       	add %d2,1
8000e060:	59 e2 e4 ff 	st.w [%a14]-28,%d2
        }

        for (count = adder_facL; count <= adder_facH; count++)
8000e064:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000e068:	59 e2 dc ff 	st.w [%a14]-36,%d2
8000e06c:	1d 00 5c 00 	j 8000e124 <IfxAsclin_setBitTiming+0x282>
        {
            f           = (fpd * n) / (n * d + count);
8000e070:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000e074:	4b 02 61 31 	utof %d3,%d2
8000e078:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000e07c:	4b 23 41 30 	mul.f %d3,%d3,%d2
8000e080:	19 e4 fc ff 	ld.w %d4,[%a14]-4
8000e084:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000e088:	e2 42       	mul %d2,%d4
8000e08a:	19 e4 dc ff 	ld.w %d4,[%a14]-36
8000e08e:	42 42       	add %d2,%d4
8000e090:	4b 02 61 21 	utof %d2,%d2
8000e094:	4b 23 51 20 	div.f %d2,%d3,%d2
8000e098:	59 e2 c4 ff 	st.w [%a14]-60,%d2
            newRelError = __absf(fOvs - f);
8000e09c:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000e0a0:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000e0a4:	6b 02 31 23 	sub.f %d2,%d3,%d2
8000e0a8:	82 03       	mov %d3,0
8000e0aa:	4b 32 01 20 	cmp.f %d2,%d2,%d3
8000e0ae:	87 22 20 20 	or.t %d2,%d2,0,%d2,0
8000e0b2:	df 02 0c 00 	jeq %d2,0,8000e0ca <IfxAsclin_setBitTiming+0x228>
8000e0b6:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000e0ba:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000e0be:	6b 02 31 23 	sub.f %d2,%d3,%d2
8000e0c2:	9b 02 00 28 	addih %d2,%d2,32768
8000e0c6:	1d 00 08 00 	j 8000e0d6 <IfxAsclin_setBitTiming+0x234>
8000e0ca:	19 e3 cc ff 	ld.w %d3,[%a14]-52
8000e0ce:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8000e0d2:	6b 02 31 23 	sub.f %d2,%d3,%d2
8000e0d6:	59 e2 c0 ff 	st.w [%a14]-64,%d2

            if (relError > (newRelError))
8000e0da:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000e0de:	19 e3 c0 ff 	ld.w %d3,[%a14]-64
8000e0e2:	4b 32 01 20 	cmp.f %d2,%d2,%d3
8000e0e6:	87 22 22 21 	or.t %d2,%d2,2,%d2,2
8000e0ea:	df 02 18 00 	jeq %d2,0,8000e11a <IfxAsclin_setBitTiming+0x278>
            {
                relError       = newRelError;
8000e0ee:	19 e2 c0 ff 	ld.w %d2,[%a14]-64
8000e0f2:	59 e2 f0 ff 	st.w [%a14]-16,%d2
                nBest          = n;
8000e0f6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000e0fa:	59 e2 f4 ff 	st.w [%a14]-12,%d2
                dBest          = (n * d + count);
8000e0fe:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000e102:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000e106:	e2 32       	mul %d2,%d3
8000e108:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8000e10c:	42 32       	add %d2,%d3
8000e10e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
                adder_facL_min = count;
8000e112:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000e116:	59 e2 e0 ff 	st.w [%a14]-32,%d2
        for (count = adder_facL; count <= adder_facH; count++)
8000e11a:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000e11e:	c2 12       	add %d2,1
8000e120:	59 e2 dc ff 	st.w [%a14]-36,%d2
8000e124:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000e128:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8000e12c:	7f 23 a2 ff 	jge.u %d3,%d2,8000e070 <IfxAsclin_setBitTiming+0x1ce>
            }
        }

        if (relError <= limit)
8000e130:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000e134:	19 e3 c8 ff 	ld.w %d3,[%a14]-56
8000e138:	4b 32 01 20 	cmp.f %d2,%d2,%d3
8000e13c:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
8000e140:	df 02 16 80 	jne %d2,0,8000e16c <IfxAsclin_setBitTiming+0x2ca>
    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
8000e144:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000e148:	c2 12       	add %d2,1
8000e14a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000e14e:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
8000e152:	df 02 0e 80 	jne %d2,0,8000e16e <IfxAsclin_setBitTiming+0x2cc>
8000e156:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8000e15a:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000e15e:	e2 32       	mul %d2,%d3
8000e160:	3b 00 00 31 	mov %d3,4096
8000e164:	3f 32 64 ff 	jlt.u %d2,%d3,8000e02c <IfxAsclin_setBitTiming+0x18a>
8000e168:	1d 00 03 00 	j 8000e16e <IfxAsclin_setBitTiming+0x2cc>
        {
            break;
8000e16c:	00 00       	nop 
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
8000e16e:	82 04       	mov %d4,0
8000e170:	99 e4 dc ef 	ld.a %a4,[%a14]-100
8000e174:	6d 00 63 00 	call 8000e23a <IfxAsclin_setClockSource>
    asclin->BRG.B.DENOMINATOR = dBest;
8000e178:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000e17c:	02 23       	mov %d3,%d2
8000e17e:	3b f0 ff 20 	mov %d2,4095
8000e182:	26 32       	and %d2,%d3
8000e184:	37 02 70 30 	extr.u %d3,%d2,0,16
8000e188:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000e18c:	d9 23 20 00 	lea %a3,[%a2]32
8000e190:	54 32       	ld.w %d2,[%a3]
8000e192:	37 32 0c 20 	insert %d2,%d2,%d3,0,12
8000e196:	d9 22 20 00 	lea %a2,[%a2]32
8000e19a:	74 22       	st.w [%a2],%d2
    asclin->BRG.B.NUMERATOR   = nBest;
8000e19c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000e1a0:	02 23       	mov %d3,%d2
8000e1a2:	3b f0 ff 20 	mov %d2,4095
8000e1a6:	26 32       	and %d2,%d3
8000e1a8:	37 02 70 30 	extr.u %d3,%d2,0,16
8000e1ac:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000e1b0:	d9 23 20 00 	lea %a3,[%a2]32
8000e1b4:	54 32       	ld.w %d2,[%a3]
8000e1b6:	37 32 0c 28 	insert %d2,%d2,%d3,16,12
8000e1ba:	d9 22 20 00 	lea %a2,[%a2]32
8000e1be:	74 22       	st.w [%a2],%d2

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
8000e1c0:	19 e2 d4 ef 	ld.w %d2,[%a14]-108
8000e1c4:	8f f2 0f 21 	and %d2,%d2,255
8000e1c8:	c2 f2       	add %d2,-1
8000e1ca:	8f f2 0f 21 	and %d2,%d2,255
8000e1ce:	8f f2 00 21 	and %d2,%d2,15
8000e1d2:	8f f2 0f 31 	and %d3,%d2,255
8000e1d6:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000e1da:	d9 23 14 00 	lea %a3,[%a2]20
8000e1de:	54 32       	ld.w %d2,[%a3]
8000e1e0:	37 32 04 28 	insert %d2,%d2,%d3,16,4
8000e1e4:	d9 22 14 00 	lea %a2,[%a2]20
8000e1e8:	74 22       	st.w [%a2],%d2

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
8000e1ea:	19 e2 d0 ef 	ld.w %d2,[%a14]-112
8000e1ee:	8f f2 00 21 	and %d2,%d2,15
8000e1f2:	8f f2 0f 31 	and %d3,%d2,255
8000e1f6:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000e1fa:	d9 23 14 00 	lea %a3,[%a2]20
8000e1fe:	54 32       	ld.w %d2,[%a3]
8000e200:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
8000e204:	d9 22 14 00 	lea %a2,[%a2]20
8000e208:	74 22       	st.w [%a2],%d2

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
8000e20a:	19 e2 cc ef 	ld.w %d2,[%a14]-116
8000e20e:	8b 02 20 22 	ne %d2,%d2,0
8000e212:	8f f2 0f 31 	and %d3,%d2,255
8000e216:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000e21a:	d9 23 14 00 	lea %a3,[%a2]20
8000e21e:	54 32       	ld.w %d2,[%a3]
8000e220:	67 32 1f 20 	ins.t %d2,%d2,31,%d3,0
8000e224:	d9 22 14 00 	lea %a2,[%a2]20
8000e228:	74 22       	st.w [%a2],%d2

    IfxAsclin_setClockSource(asclin, source);
8000e22a:	19 e4 d8 ff 	ld.w %d4,[%a14]-40
8000e22e:	99 e4 dc ef 	ld.a %a4,[%a14]-100
8000e232:	6d 00 04 00 	call 8000e23a <IfxAsclin_setClockSource>

    return TRUE;
8000e236:	82 12       	mov %d2,1
}
8000e238:	00 90       	ret 

8000e23a <IfxAsclin_setClockSource>:


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
8000e23a:	40 ae       	mov.aa %a14,%sp
8000e23c:	20 10       	sub.a %sp,16
8000e23e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8000e242:	59 e4 f0 ff 	st.w [%a14]-16,%d4
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
8000e246:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000e24a:	8f f2 01 21 	and %d2,%d2,31
8000e24e:	8f f2 0f 31 	and %d3,%d2,255
8000e252:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000e256:	d9 23 0c 10 	lea %a3,[%a2]76
8000e25a:	54 32       	ld.w %d2,[%a3]
8000e25c:	37 32 05 20 	insert %d2,%d2,%d3,0,5
8000e260:	d9 22 0c 10 	lea %a2,[%a2]76
8000e264:	74 22       	st.w [%a2],%d2

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
8000e266:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000e26a:	df 02 14 80 	jne %d2,0,8000e292 <IfxAsclin_setClockSource+0x58>
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
8000e26e:	00 00       	nop 
8000e270:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000e274:	59 e2 fc ff 	st.w [%a14]-4,%d2
    return asclin->CSR.B.CON;
8000e278:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000e27c:	d9 22 0c 10 	lea %a2,[%a2]76
8000e280:	54 22       	ld.w %d2,[%a2]
8000e282:	37 02 e1 2f 	extr.u %d2,%d2,31,1
8000e286:	8f f2 0f 21 	and %d2,%d2,255
8000e28a:	df 02 f3 ff 	jne %d2,0,8000e270 <IfxAsclin_setClockSource+0x36>
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
        {}
    }
}
8000e28e:	1d 00 12 00 	j 8000e2b2 <IfxAsclin_setClockSource+0x78>
        while (IfxAsclin_getClockStatus(asclin) != 1U)
8000e292:	00 00       	nop 
8000e294:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000e298:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000e29c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000e2a0:	d9 22 0c 10 	lea %a2,[%a2]76
8000e2a4:	54 22       	ld.w %d2,[%a2]
8000e2a6:	37 02 e1 2f 	extr.u %d2,%d2,31,1
8000e2aa:	8f f2 0f 21 	and %d2,%d2,255
8000e2ae:	df 12 f3 ff 	jne %d2,1,8000e294 <IfxAsclin_setClockSource+0x5a>
}
8000e2b2:	00 00       	nop 
8000e2b4:	00 90       	ret 

8000e2b6 <IfxAsclin_write8>:
    return count;
}


uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
8000e2b6:	40 ae       	mov.aa %a14,%sp
8000e2b8:	20 18       	sub.a %sp,24
8000e2ba:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8000e2be:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
8000e2c2:	59 e4 ec ff 	st.w [%a14]-20,%d4
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;
8000e2c6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000e2ca:	1b 42 04 20 	addi %d2,%d2,68
8000e2ce:	59 e2 fc ff 	st.w [%a14]-4,%d2

    while ((count > 0))
8000e2d2:	1d 00 11 00 	j 8000e2f4 <IfxAsclin_write8+0x3e>
    {
        txData->U = *data++;
8000e2d6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e2da:	80 22       	mov.d %d2,%a2
8000e2dc:	c2 12       	add %d2,1
8000e2de:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000e2e2:	14 22       	ld.bu %d2,[%a2]
8000e2e4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000e2e8:	74 22       	st.w [%a2],%d2
        count--;
8000e2ea:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000e2ee:	c2 f2       	add %d2,-1
8000e2f0:	59 e2 ec ff 	st.w [%a14]-20,%d2
    while ((count > 0))
8000e2f4:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000e2f8:	df 02 ef ff 	jne %d2,0,8000e2d6 <IfxAsclin_write8+0x20>
    }

    return count;
8000e2fc:	19 e2 ec ff 	ld.w %d2,[%a14]-20
}
8000e300:	00 90       	ret 

8000e302 <IfxAsclin_Asc_initModule>:
    return &asclin->tx->eventWriter;
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
8000e302:	40 ae       	mov.aa %a14,%sp
8000e304:	d9 aa d0 8f 	lea %sp,[%sp]-496
8000e308:	b5 e4 d4 8f 	st.a [%a14]-492,%a4
8000e30c:	b5 e5 d0 8f 	st.a [%a14]-496,%a5
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
8000e310:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e314:	54 22       	ld.w %d2,[%a2]
8000e316:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    IfxAsclin_Status status    = IfxAsclin_Status_noError;
8000e31a:	82 12       	mov %d2,1
8000e31c:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
8000e320:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000e324:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000e328:	74 22       	st.w [%a2],%d2

    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
8000e32a:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000e32e:	6d ff 90 fc 	call 8000dc4e <IfxAsclin_enableModule>
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
8000e332:	82 04       	mov %d4,0
8000e334:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000e338:	6d ff 81 ff 	call 8000e23a <IfxAsclin_setClockSource>
8000e33c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000e340:	59 e2 fc cf 	st.w [%a14]-196,%d2
8000e344:	82 02       	mov %d2,0
8000e346:	59 e2 f8 cf 	st.w [%a14]-200,%d2
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
8000e34a:	19 e2 f8 cf 	ld.w %d2,[%a14]-200
8000e34e:	8f 32 00 21 	and %d2,%d2,3
8000e352:	8f f2 0f 31 	and %d3,%d2,255
8000e356:	99 e2 fc cf 	ld.a %a2,[%a14]-196
8000e35a:	d9 23 18 00 	lea %a3,[%a2]24
8000e35e:	54 32       	ld.w %d2,[%a3]
8000e360:	37 32 02 28 	insert %d2,%d2,%d3,16,2
8000e364:	d9 22 18 00 	lea %a2,[%a2]24
8000e368:	74 22       	st.w [%a2],%d2
}
8000e36a:	00 00       	nop 
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
8000e36c:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e370:	b9 22 08 00 	ld.hu %d2,[%a2]8
8000e374:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e378:	59 e3 c4 df 	st.w [%a14]-188,%d3
8000e37c:	f9 e2 c2 df 	st.h [%a14]-190,%d2
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
8000e380:	c9 e2 c2 df 	ld.h %d2,[%a14]-190
8000e384:	c2 f2       	add %d2,-1
8000e386:	37 02 70 20 	extr.u %d2,%d2,0,16
8000e38a:	02 23       	mov %d3,%d2
8000e38c:	3b f0 ff 20 	mov %d2,4095
8000e390:	26 32       	and %d2,%d3
8000e392:	37 02 70 30 	extr.u %d3,%d2,0,16
8000e396:	99 e2 c4 df 	ld.a %a2,[%a14]-188
8000e39a:	d9 23 14 00 	lea %a3,[%a2]20
8000e39e:	54 32       	ld.w %d2,[%a3]
8000e3a0:	37 32 0c 20 	insert %d2,%d2,%d3,0,12
8000e3a4:	d9 22 14 00 	lea %a2,[%a2]20
8000e3a8:	74 22       	st.w [%a2],%d2
}
8000e3aa:	00 00       	nop 
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
8000e3ac:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e3b0:	d9 22 20 10 	lea %a2,[%a2]96
8000e3b4:	54 22       	ld.w %d2,[%a2]
8000e3b6:	02 24       	mov %d4,%d2
8000e3b8:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000e3bc:	6d ff 3f ff 	call 8000e23a <IfxAsclin_setClockSource>
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
        config->baudrate.baudrate,
8000e3c0:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e3c4:	b0 42       	add.a %a2,4
8000e3c6:	54 22       	ld.w %d2,[%a2]
        config->baudrate.oversampling,
8000e3c8:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e3cc:	d9 22 0c 00 	lea %a2,[%a2]12
8000e3d0:	54 23       	ld.w %d3,[%a2]
        config->bitTiming.samplePointPosition,
8000e3d2:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e3d6:	d9 22 14 00 	lea %a2,[%a2]20
8000e3da:	54 24       	ld.w %d4,[%a2]
        config->bitTiming.medianFilter);
8000e3dc:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e3e0:	d9 22 10 00 	lea %a2,[%a2]16
8000e3e4:	54 25       	ld.w %d5,[%a2]
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
8000e3e6:	02 57       	mov %d7,%d5
8000e3e8:	02 46       	mov %d6,%d4
8000e3ea:	02 35       	mov %d5,%d3
8000e3ec:	02 24       	mov %d4,%d2
8000e3ee:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000e3f2:	6d ff 58 fd 	call 8000dea2 <IfxAsclin_setBitTiming>
8000e3f6:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
8000e3fa:	82 04       	mov %d4,0
8000e3fc:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000e400:	6d ff 1d ff 	call 8000e23a <IfxAsclin_setClockSource>

    IfxAsclin_enableLoopBackMode(asclinSFR, config->loopBack);                       /* selecting the loopback mode */
8000e404:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e408:	39 22 34 10 	ld.bu %d2,[%a2]116
8000e40c:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e410:	59 e3 cc df 	st.w [%a14]-180,%d3
8000e414:	e9 e2 cb df 	st.b [%a14]-181,%d2
    asclin->IOCR.B.LB = enable ? 1 : 0;
8000e418:	39 e2 cb df 	ld.bu %d2,[%a14]-181
8000e41c:	8b 02 20 22 	ne %d2,%d2,0
8000e420:	8f f2 0f 31 	and %d3,%d2,255
8000e424:	99 e2 cc df 	ld.a %a2,[%a14]-180
8000e428:	d9 23 04 00 	lea %a3,[%a2]4
8000e42c:	54 32       	ld.w %d2,[%a3]
8000e42e:	67 32 1c 20 	ins.t %d2,%d2,28,%d3,0
8000e432:	b0 42       	add.a %a2,4
8000e434:	74 22       	st.w [%a2],%d2
}
8000e436:	00 00       	nop 
    IfxAsclin_enableParity(asclinSFR, config->frame.parityBit);                      /* setting parity enable */
8000e438:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e43c:	39 22 30 00 	ld.bu %d2,[%a2]48
8000e440:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e444:	59 e3 d4 df 	st.w [%a14]-172,%d3
8000e448:	e9 e2 d3 df 	st.b [%a14]-173,%d2
    asclin->FRAMECON.B.PEN = enable ? 1 : 0;
8000e44c:	39 e2 d3 df 	ld.bu %d2,[%a14]-173
8000e450:	8b 02 20 22 	ne %d2,%d2,0
8000e454:	8f f2 0f 31 	and %d3,%d2,255
8000e458:	99 e2 d4 df 	ld.a %a2,[%a14]-172
8000e45c:	d9 23 18 00 	lea %a3,[%a2]24
8000e460:	54 32       	ld.w %d2,[%a3]
8000e462:	67 32 1e 20 	ins.t %d2,%d2,30,%d3,0
8000e466:	d9 22 18 00 	lea %a2,[%a2]24
8000e46a:	74 22       	st.w [%a2],%d2
}
8000e46c:	00 00       	nop 
    IfxAsclin_setParityType(asclinSFR, config->frame.parityType);                    /* setting parity type (odd/even)*/
8000e46e:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e472:	d9 22 28 00 	lea %a2,[%a2]40
8000e476:	54 22       	ld.w %d2,[%a2]
8000e478:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e47c:	59 e3 dc df 	st.w [%a14]-164,%d3
8000e480:	59 e2 d8 df 	st.w [%a14]-168,%d2
    asclin->FRAMECON.B.ODD = type;
8000e484:	19 e2 d8 df 	ld.w %d2,[%a14]-168
8000e488:	8f 12 00 21 	and %d2,%d2,1
8000e48c:	8f f2 0f 31 	and %d3,%d2,255
8000e490:	99 e2 dc df 	ld.a %a2,[%a14]-164
8000e494:	d9 23 18 00 	lea %a3,[%a2]24
8000e498:	54 32       	ld.w %d2,[%a3]
8000e49a:	67 32 1f 20 	ins.t %d2,%d2,31,%d3,0
8000e49e:	d9 22 18 00 	lea %a2,[%a2]24
8000e4a2:	74 22       	st.w [%a2],%d2
}
8000e4a4:	00 00       	nop 
    IfxAsclin_setStopBit(asclinSFR, config->frame.stopBit);                          /* setting the stop bit */
8000e4a6:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e4aa:	d9 22 1c 00 	lea %a2,[%a2]28
8000e4ae:	54 22       	ld.w %d2,[%a2]
8000e4b0:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e4b4:	59 e3 e4 df 	st.w [%a14]-156,%d3
8000e4b8:	59 e2 e0 df 	st.w [%a14]-160,%d2
}


IFX_INLINE void IfxAsclin_setStopBit(Ifx_ASCLIN *asclin, IfxAsclin_StopBit stopBit)
{
    asclin->FRAMECON.B.STOP = stopBit;
8000e4bc:	19 e2 e0 df 	ld.w %d2,[%a14]-160
8000e4c0:	8f 72 00 21 	and %d2,%d2,7
8000e4c4:	8f f2 0f 31 	and %d3,%d2,255
8000e4c8:	99 e2 e4 df 	ld.a %a2,[%a14]-156
8000e4cc:	d9 23 18 00 	lea %a3,[%a2]24
8000e4d0:	54 32       	ld.w %d2,[%a3]
8000e4d2:	37 32 83 24 	insert %d2,%d2,%d3,9,3
8000e4d6:	d9 22 18 00 	lea %a2,[%a2]24
8000e4da:	74 22       	st.w [%a2],%d2
}
8000e4dc:	00 00       	nop 
    IfxAsclin_setShiftDirection(asclinSFR, config->frame.shiftDir);                  /* setting the shift direction */
8000e4de:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e4e2:	d9 22 24 00 	lea %a2,[%a2]36
8000e4e6:	54 22       	ld.w %d2,[%a2]
8000e4e8:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e4ec:	59 e3 ec df 	st.w [%a14]-148,%d3
8000e4f0:	59 e2 e8 df 	st.w [%a14]-152,%d2
    asclin->FRAMECON.B.MSB = dir;
8000e4f4:	19 e2 e8 df 	ld.w %d2,[%a14]-152
8000e4f8:	8f 12 00 21 	and %d2,%d2,1
8000e4fc:	8f f2 0f 31 	and %d3,%d2,255
8000e500:	99 e2 ec df 	ld.a %a2,[%a14]-148
8000e504:	d9 23 18 00 	lea %a3,[%a2]24
8000e508:	54 32       	ld.w %d2,[%a3]
8000e50a:	67 32 1c 20 	ins.t %d2,%d2,28,%d3,0
8000e50e:	d9 22 18 00 	lea %a2,[%a2]24
8000e512:	74 22       	st.w [%a2],%d2
}
8000e514:	00 00       	nop 
    IfxAsclin_setDataLength(asclinSFR, config->frame.dataLength);                    /* setting the data length */
8000e516:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e51a:	d9 22 2c 00 	lea %a2,[%a2]44
8000e51e:	54 22       	ld.w %d2,[%a2]
8000e520:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e524:	59 e3 f4 df 	st.w [%a14]-140,%d3
8000e528:	59 e2 f0 df 	st.w [%a14]-144,%d2
    asclin->DATCON.B.DATLEN = length;
8000e52c:	19 e2 f0 df 	ld.w %d2,[%a14]-144
8000e530:	8f f2 00 21 	and %d2,%d2,15
8000e534:	8f f2 0f 31 	and %d3,%d2,255
8000e538:	99 e2 f4 df 	ld.a %a2,[%a14]-140
8000e53c:	d9 23 1c 00 	lea %a3,[%a2]28
8000e540:	54 32       	ld.w %d2,[%a3]
8000e542:	37 32 04 20 	insert %d2,%d2,%d3,0,4
8000e546:	d9 22 1c 00 	lea %a2,[%a2]28
8000e54a:	74 22       	st.w [%a2],%d2
}
8000e54c:	00 00       	nop 
    IfxAsclin_setTxFifoInletWidth(asclinSFR, config->fifo.inWidth);                  /* setting Tx FIFO inlet width */
8000e54e:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e552:	d9 22 34 00 	lea %a2,[%a2]52
8000e556:	54 22       	ld.w %d2,[%a2]
8000e558:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e55c:	59 e3 fc df 	st.w [%a14]-132,%d3
8000e560:	59 e2 f8 df 	st.w [%a14]-136,%d2
}


IFX_INLINE void IfxAsclin_setTxFifoInletWidth(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInletWidth width)
{
    asclin->TXFIFOCON.B.INW = width;
8000e564:	19 e2 f8 df 	ld.w %d2,[%a14]-136
8000e568:	8f 32 00 21 	and %d2,%d2,3
8000e56c:	8f f2 0f 31 	and %d3,%d2,255
8000e570:	99 e2 fc df 	ld.a %a2,[%a14]-132
8000e574:	d9 23 0c 00 	lea %a3,[%a2]12
8000e578:	54 32       	ld.w %d2,[%a3]
8000e57a:	37 32 02 23 	insert %d2,%d2,%d3,6,2
8000e57e:	d9 22 0c 00 	lea %a2,[%a2]12
8000e582:	74 22       	st.w [%a2],%d2
}
8000e584:	00 00       	nop 
    IfxAsclin_setRxFifoOutletWidth(asclinSFR, config->fifo.outWidth);                /* setting Rx FIFO outlet width */
8000e586:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e58a:	d9 22 38 00 	lea %a2,[%a2]56
8000e58e:	54 22       	ld.w %d2,[%a2]
8000e590:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e594:	59 e3 c4 ef 	st.w [%a14]-124,%d3
8000e598:	59 e2 c0 ef 	st.w [%a14]-128,%d2
    asclin->RXFIFOCON.B.OUTW = width;
8000e59c:	19 e2 c0 ef 	ld.w %d2,[%a14]-128
8000e5a0:	8f 32 00 21 	and %d2,%d2,3
8000e5a4:	8f f2 0f 31 	and %d3,%d2,255
8000e5a8:	99 e2 c4 ef 	ld.a %a2,[%a14]-124
8000e5ac:	d9 23 10 00 	lea %a3,[%a2]16
8000e5b0:	54 32       	ld.w %d2,[%a3]
8000e5b2:	37 32 02 23 	insert %d2,%d2,%d3,6,2
8000e5b6:	d9 22 10 00 	lea %a2,[%a2]16
8000e5ba:	74 22       	st.w [%a2],%d2
}
8000e5bc:	00 00       	nop 
    IfxAsclin_setIdleDelay(asclinSFR, config->frame.idleDelay);                      /* setting idle delay */
8000e5be:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e5c2:	d9 22 18 00 	lea %a2,[%a2]24
8000e5c6:	54 22       	ld.w %d2,[%a2]
8000e5c8:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e5cc:	59 e3 cc ef 	st.w [%a14]-116,%d3
8000e5d0:	59 e2 c8 ef 	st.w [%a14]-120,%d2
    asclin->FRAMECON.B.IDLE = delay;
8000e5d4:	19 e2 c8 ef 	ld.w %d2,[%a14]-120
8000e5d8:	8f 72 00 21 	and %d2,%d2,7
8000e5dc:	8f f2 0f 31 	and %d3,%d2,255
8000e5e0:	99 e2 cc ef 	ld.a %a2,[%a14]-116
8000e5e4:	d9 23 18 00 	lea %a3,[%a2]24
8000e5e8:	54 32       	ld.w %d2,[%a3]
8000e5ea:	37 32 03 23 	insert %d2,%d2,%d3,6,3
8000e5ee:	d9 22 18 00 	lea %a2,[%a2]24
8000e5f2:	74 22       	st.w [%a2],%d2
}
8000e5f4:	00 00       	nop 
    IfxAsclin_setTxFifoInterruptLevel(asclinSFR, config->fifo.txFifoInterruptLevel); /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
8000e5f6:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e5fa:	d9 22 3c 00 	lea %a2,[%a2]60
8000e5fe:	54 22       	ld.w %d2,[%a2]
8000e600:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e604:	59 e3 e0 ef 	st.w [%a14]-96,%d3
8000e608:	59 e2 dc ef 	st.w [%a14]-100,%d2
8000e60c:	19 e2 dc ef 	ld.w %d2,[%a14]-100
8000e610:	59 e2 d8 ef 	st.w [%a14]-104,%d2
8000e614:	3b f0 00 20 	mov %d2,15
8000e618:	59 e2 d4 ef 	st.w [%a14]-108,%d2
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000e61c:	19 e2 d8 ef 	ld.w %d2,[%a14]-104
8000e620:	19 e3 d4 ef 	ld.w %d3,[%a14]-108
8000e624:	0b 32 90 21 	min.u %d2,%d2,%d3
8000e628:	59 e2 d0 ef 	st.w [%a14]-112,%d2
    return res;
8000e62c:	19 e2 d0 ef 	ld.w %d2,[%a14]-112


IFX_INLINE void IfxAsclin_setTxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInterruptLevel level)
{
    asclin->TXFIFOCON.B.INTLEVEL = __minu(level, 15);
8000e630:	8f f2 00 21 	and %d2,%d2,15
8000e634:	8f f2 0f 31 	and %d3,%d2,255
8000e638:	99 e2 e0 ef 	ld.a %a2,[%a14]-96
8000e63c:	d9 23 0c 00 	lea %a3,[%a2]12
8000e640:	54 32       	ld.w %d2,[%a3]
8000e642:	37 32 04 24 	insert %d2,%d2,%d3,8,4
8000e646:	d9 22 0c 00 	lea %a2,[%a2]12
8000e64a:	74 22       	st.w [%a2],%d2
}
8000e64c:	00 00       	nop 
    IfxAsclin_setRxFifoInterruptLevel(asclinSFR, config->fifo.rxFifoInterruptLevel); /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
8000e64e:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e652:	d9 22 00 10 	lea %a2,[%a2]64
8000e656:	54 22       	ld.w %d2,[%a2]
8000e658:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e65c:	59 e3 f4 ef 	st.w [%a14]-76,%d3
8000e660:	59 e2 f0 ef 	st.w [%a14]-80,%d2
8000e664:	19 e2 f0 ef 	ld.w %d2,[%a14]-80
8000e668:	59 e2 ec ef 	st.w [%a14]-84,%d2
8000e66c:	3b f0 00 20 	mov %d2,15
8000e670:	59 e2 e8 ef 	st.w [%a14]-88,%d2
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000e674:	19 e2 ec ef 	ld.w %d2,[%a14]-84
8000e678:	19 e3 e8 ef 	ld.w %d3,[%a14]-88
8000e67c:	0b 32 90 21 	min.u %d2,%d2,%d3
8000e680:	59 e2 e4 ef 	st.w [%a14]-92,%d2
    return res;
8000e684:	19 e2 e4 ef 	ld.w %d2,[%a14]-92
    asclin->RXFIFOCON.B.INTLEVEL = __minu(level, 15);
8000e688:	8f f2 00 21 	and %d2,%d2,15
8000e68c:	8f f2 0f 31 	and %d3,%d2,255
8000e690:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8000e694:	d9 23 10 00 	lea %a3,[%a2]16
8000e698:	54 32       	ld.w %d2,[%a3]
8000e69a:	37 32 04 24 	insert %d2,%d2,%d3,8,4
8000e69e:	d9 22 10 00 	lea %a2,[%a2]16
8000e6a2:	74 22       	st.w [%a2],%d2
}
8000e6a4:	00 00       	nop 
    IfxAsclin_setTxFifoInterruptMode(asclinSFR, config->fifo.txFifoInterruptMode);   /* setting Tx FIFO interrupt generation mode */
8000e6a6:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e6aa:	d9 22 08 10 	lea %a2,[%a2]72
8000e6ae:	54 22       	ld.w %d2,[%a2]
8000e6b0:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e6b4:	59 e3 fc ef 	st.w [%a14]-68,%d3
8000e6b8:	59 e2 f8 ef 	st.w [%a14]-72,%d2


IFX_INLINE void IfxAsclin_setTxFifoInterruptMode(Ifx_ASCLIN *asclin, IfxAsclin_FifoInterruptMode mode)
{
    asclin->TXFIFOCON.B.FM = mode;
8000e6bc:	19 e2 f8 ef 	ld.w %d2,[%a14]-72
8000e6c0:	8f 32 00 21 	and %d2,%d2,3
8000e6c4:	8f f2 0f 31 	and %d3,%d2,255
8000e6c8:	99 e2 fc ef 	ld.a %a2,[%a14]-68
8000e6cc:	d9 23 0c 00 	lea %a3,[%a2]12
8000e6d0:	54 32       	ld.w %d2,[%a3]
8000e6d2:	37 32 02 22 	insert %d2,%d2,%d3,4,2
8000e6d6:	d9 22 0c 00 	lea %a2,[%a2]12
8000e6da:	74 22       	st.w [%a2],%d2
}
8000e6dc:	00 00       	nop 
    IfxAsclin_setRxFifoInterruptMode(asclinSFR, config->fifo.rxFifoInterruptMode);   /* setting Rx FIFO interrupt generation mode */
8000e6de:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e6e2:	d9 22 0c 10 	lea %a2,[%a2]76
8000e6e6:	54 22       	ld.w %d2,[%a2]
8000e6e8:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e6ec:	59 e3 c4 ff 	st.w [%a14]-60,%d3
8000e6f0:	59 e2 c0 ff 	st.w [%a14]-64,%d2
    asclin->RXFIFOCON.B.FM = mode;
8000e6f4:	19 e2 c0 ff 	ld.w %d2,[%a14]-64
8000e6f8:	8f 32 00 21 	and %d2,%d2,3
8000e6fc:	8f f2 0f 31 	and %d3,%d2,255
8000e700:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8000e704:	d9 23 10 00 	lea %a3,[%a2]16
8000e708:	54 32       	ld.w %d2,[%a3]
8000e70a:	37 32 02 22 	insert %d2,%d2,%d3,4,2
8000e70e:	d9 22 10 00 	lea %a2,[%a2]16
8000e712:	74 22       	st.w [%a2],%d2
}
8000e714:	00 00       	nop 
    IfxAsclin_setFrameMode(asclinSFR, config->frame.frameMode);                      /* selecting the frame mode*/
8000e716:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e71a:	d9 22 20 00 	lea %a2,[%a2]32
8000e71e:	54 22       	ld.w %d2,[%a2]
8000e720:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000e724:	59 e3 cc ff 	st.w [%a14]-52,%d3
8000e728:	59 e2 c8 ff 	st.w [%a14]-56,%d2
    asclin->FRAMECON.B.MODE = mode;
8000e72c:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8000e730:	8f 32 00 21 	and %d2,%d2,3
8000e734:	8f f2 0f 31 	and %d3,%d2,255
8000e738:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000e73c:	d9 23 18 00 	lea %a3,[%a2]24
8000e740:	54 32       	ld.w %d2,[%a3]
8000e742:	37 32 02 28 	insert %d2,%d2,%d3,16,2
8000e746:	d9 22 18 00 	lea %a2,[%a2]24
8000e74a:	74 22       	st.w [%a2],%d2
}
8000e74c:	00 00       	nop 

    /* Pin mapping */
    const IfxAsclin_Asc_Pins *pins = config->pins;
8000e74e:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000e752:	d9 22 1c 10 	lea %a2,[%a2]92
8000e756:	54 22       	ld.w %d2,[%a2]
8000e758:	59 e2 f0 ff 	st.w [%a14]-16,%d2

    if (pins != NULL_PTR)
8000e75c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000e760:	df 02 8b 01 	jeq %d2,0,8000ea76 <IfxAsclin_Asc_initModule+0x774>
    {
        IfxAsclin_Cts_In *cts = pins->cts;
8000e764:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e768:	54 22       	ld.w %d2,[%a2]
8000e76a:	59 e2 ec ff 	st.w [%a14]-20,%d2

        if (cts != NULL_PTR)
8000e76e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8000e772:	df 02 77 00 	jeq %d2,0,8000e860 <IfxAsclin_Asc_initModule+0x55e>
        {
            IfxAsclin_initCtsPin(cts, pins->ctsMode, pins->pinDriver);
8000e776:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e77a:	b0 42       	add.a %a2,4
8000e77c:	54 23       	ld.w %d3,[%a2]
8000e77e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e782:	d9 22 20 00 	lea %a2,[%a2]32
8000e786:	54 22       	ld.w %d2,[%a2]
8000e788:	19 e4 ec ff 	ld.w %d4,[%a14]-20
8000e78c:	59 e4 f4 cf 	st.w [%a14]-204,%d4
8000e790:	59 e3 f0 cf 	st.w [%a14]-208,%d3
8000e794:	59 e2 ec cf 	st.w [%a14]-212,%d2
    if (cts->pin.port != NULL_PTR)
8000e798:	99 e2 f4 cf 	ld.a %a2,[%a14]-204
8000e79c:	b0 42       	add.a %a2,4
8000e79e:	54 22       	ld.w %d2,[%a2]
8000e7a0:	df 02 5f 00 	jeq %d2,0,8000e85e <IfxAsclin_Asc_initModule+0x55c>
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
8000e7a4:	99 e2 f4 cf 	ld.a %a2,[%a14]-204
8000e7a8:	b0 42       	add.a %a2,4
8000e7aa:	54 23       	ld.w %d3,[%a2]
8000e7ac:	99 e2 f4 cf 	ld.a %a2,[%a14]-204
8000e7b0:	39 22 08 00 	ld.bu %d2,[%a2]8
8000e7b4:	59 e3 e8 cf 	st.w [%a14]-216,%d3
8000e7b8:	e9 e2 e7 cf 	st.b [%a14]-217,%d2
8000e7bc:	19 e2 f0 cf 	ld.w %d2,[%a14]-208
8000e7c0:	59 e2 e0 cf 	st.w [%a14]-224,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000e7c4:	39 e2 e7 cf 	ld.bu %d2,[%a14]-217
8000e7c8:	19 e3 e0 cf 	ld.w %d3,[%a14]-224
8000e7cc:	02 35       	mov %d5,%d3
8000e7ce:	02 24       	mov %d4,%d2
8000e7d0:	99 e4 e8 cf 	ld.a %a4,[%a14]-216
8000e7d4:	6d ff 7d d0 	call 800088ce <IfxPort_setPinMode>
}
8000e7d8:	00 00       	nop 
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
8000e7da:	99 e2 f4 cf 	ld.a %a2,[%a14]-204
8000e7de:	b0 42       	add.a %a2,4
8000e7e0:	54 22       	ld.w %d2,[%a2]
8000e7e2:	99 e2 f4 cf 	ld.a %a2,[%a14]-204
8000e7e6:	39 23 08 00 	ld.bu %d3,[%a2]8
8000e7ea:	19 e5 ec cf 	ld.w %d5,[%a14]-212
8000e7ee:	02 34       	mov %d4,%d3
8000e7f0:	60 24       	mov.a %a4,%d2
8000e7f2:	6d ff e0 d0 	call 800089b2 <IfxPort_setPinPadDriver>
        IfxAsclin_enableCts(cts->module, TRUE);
8000e7f6:	99 e2 f4 cf 	ld.a %a2,[%a14]-204
8000e7fa:	54 22       	ld.w %d2,[%a2]
8000e7fc:	59 e2 dc cf 	st.w [%a14]-228,%d2
8000e800:	82 12       	mov %d2,1
8000e802:	e9 e2 db cf 	st.b [%a14]-229,%d2
    asclin->IOCR.B.CTSEN = enable ? 1 : 0;
8000e806:	39 e2 db cf 	ld.bu %d2,[%a14]-229
8000e80a:	8b 02 20 22 	ne %d2,%d2,0
8000e80e:	8f f2 0f 31 	and %d3,%d2,255
8000e812:	99 e2 dc cf 	ld.a %a2,[%a14]-228
8000e816:	d9 23 04 00 	lea %a3,[%a2]4
8000e81a:	54 32       	ld.w %d2,[%a3]
8000e81c:	67 32 1d 20 	ins.t %d2,%d2,29,%d3,0
8000e820:	b0 42       	add.a %a2,4
8000e822:	74 22       	st.w [%a2],%d2
}
8000e824:	00 00       	nop 
        IfxAsclin_setCtsInput(cts->module, (IfxAsclin_CtsInputSelect)cts->select);
8000e826:	99 e2 f4 cf 	ld.a %a2,[%a14]-204
8000e82a:	54 23       	ld.w %d3,[%a2]
8000e82c:	99 e2 f4 cf 	ld.a %a2,[%a14]-204
8000e830:	d9 22 0c 00 	lea %a2,[%a2]12
8000e834:	54 22       	ld.w %d2,[%a2]
8000e836:	59 e3 d4 cf 	st.w [%a14]-236,%d3
8000e83a:	59 e2 d0 cf 	st.w [%a14]-240,%d2
    asclin->IOCR.B.CTS = ctsi;
8000e83e:	19 e2 d0 cf 	ld.w %d2,[%a14]-240
8000e842:	8f 32 00 21 	and %d2,%d2,3
8000e846:	8f f2 0f 31 	and %d3,%d2,255
8000e84a:	99 e2 d4 cf 	ld.a %a2,[%a14]-236
8000e84e:	d9 23 04 00 	lea %a3,[%a2]4
8000e852:	54 32       	ld.w %d2,[%a3]
8000e854:	37 32 02 28 	insert %d2,%d2,%d3,16,2
8000e858:	b0 42       	add.a %a2,4
8000e85a:	74 22       	st.w [%a2],%d2
}
8000e85c:	00 00       	nop 
}
8000e85e:	00 00       	nop 
        }

        IfxAsclin_Rx_In *rx = pins->rx;
8000e860:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e864:	d9 22 08 00 	lea %a2,[%a2]8
8000e868:	54 22       	ld.w %d2,[%a2]
8000e86a:	59 e2 e8 ff 	st.w [%a14]-24,%d2

        if (rx != NULL_PTR)
8000e86e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8000e872:	df 02 60 00 	jeq %d2,0,8000e932 <IfxAsclin_Asc_initModule+0x630>
        {
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
8000e876:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e87a:	d9 22 0c 00 	lea %a2,[%a2]12
8000e87e:	54 23       	ld.w %d3,[%a2]
8000e880:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e884:	d9 22 20 00 	lea %a2,[%a2]32
8000e888:	54 22       	ld.w %d2,[%a2]
8000e88a:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
8000e88e:	59 e4 cc cf 	st.w [%a14]-244,%d4
8000e892:	59 e3 c8 cf 	st.w [%a14]-248,%d3
8000e896:	59 e2 c4 cf 	st.w [%a14]-252,%d2
    if (rx->pin.port != NULL_PTR)
8000e89a:	99 e2 cc cf 	ld.a %a2,[%a14]-244
8000e89e:	b0 42       	add.a %a2,4
8000e8a0:	54 22       	ld.w %d2,[%a2]
8000e8a2:	df 02 47 00 	jeq %d2,0,8000e930 <IfxAsclin_Asc_initModule+0x62e>
        IfxPort_setPinModeInput(rx->pin.port, rx->pin.pinIndex, inputMode);
8000e8a6:	99 e2 cc cf 	ld.a %a2,[%a14]-244
8000e8aa:	b0 42       	add.a %a2,4
8000e8ac:	54 23       	ld.w %d3,[%a2]
8000e8ae:	99 e2 cc cf 	ld.a %a2,[%a14]-244
8000e8b2:	39 22 08 00 	ld.bu %d2,[%a2]8
8000e8b6:	59 e3 c0 cf 	st.w [%a14]-256,%d3
8000e8ba:	e9 e2 ff bf 	st.b [%a14]-257,%d2
8000e8be:	19 e2 c8 cf 	ld.w %d2,[%a14]-248
8000e8c2:	59 e2 f8 bf 	st.w [%a14]-264,%d2
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000e8c6:	39 e2 ff bf 	ld.bu %d2,[%a14]-257
8000e8ca:	19 e3 f8 bf 	ld.w %d3,[%a14]-264
8000e8ce:	02 35       	mov %d5,%d3
8000e8d0:	02 24       	mov %d4,%d2
8000e8d2:	99 e4 c0 cf 	ld.a %a4,[%a14]-256
8000e8d6:	6d ff fc cf 	call 800088ce <IfxPort_setPinMode>
}
8000e8da:	00 00       	nop 
        IfxPort_setPinPadDriver(rx->pin.port, rx->pin.pinIndex, padDriver);
8000e8dc:	99 e2 cc cf 	ld.a %a2,[%a14]-244
8000e8e0:	b0 42       	add.a %a2,4
8000e8e2:	54 22       	ld.w %d2,[%a2]
8000e8e4:	99 e2 cc cf 	ld.a %a2,[%a14]-244
8000e8e8:	39 23 08 00 	ld.bu %d3,[%a2]8
8000e8ec:	19 e5 c4 cf 	ld.w %d5,[%a14]-252
8000e8f0:	02 34       	mov %d4,%d3
8000e8f2:	60 24       	mov.a %a4,%d2
8000e8f4:	6d ff 5f d0 	call 800089b2 <IfxPort_setPinPadDriver>
        IfxAsclin_setRxInput(rx->module, (IfxAsclin_RxInputSelect)rx->select);
8000e8f8:	99 e2 cc cf 	ld.a %a2,[%a14]-244
8000e8fc:	54 23       	ld.w %d3,[%a2]
8000e8fe:	99 e2 cc cf 	ld.a %a2,[%a14]-244
8000e902:	d9 22 0c 00 	lea %a2,[%a2]12
8000e906:	54 22       	ld.w %d2,[%a2]
8000e908:	59 e3 f4 bf 	st.w [%a14]-268,%d3
8000e90c:	59 e2 f0 bf 	st.w [%a14]-272,%d2
    asclin->IOCR.B.ALTI = alti;
8000e910:	19 e2 f0 bf 	ld.w %d2,[%a14]-272
8000e914:	8f 72 00 21 	and %d2,%d2,7
8000e918:	8f f2 0f 31 	and %d3,%d2,255
8000e91c:	99 e2 f4 bf 	ld.a %a2,[%a14]-268
8000e920:	d9 23 04 00 	lea %a3,[%a2]4
8000e924:	54 32       	ld.w %d2,[%a3]
8000e926:	37 32 03 20 	insert %d2,%d2,%d3,0,3
8000e92a:	b0 42       	add.a %a2,4
8000e92c:	74 22       	st.w [%a2],%d2
}
8000e92e:	00 00       	nop 
}
8000e930:	00 00       	nop 
        }

        IfxAsclin_Rts_Out *rts = pins->rts;
8000e932:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e936:	d9 22 10 00 	lea %a2,[%a2]16
8000e93a:	54 22       	ld.w %d2,[%a2]
8000e93c:	59 e2 e4 ff 	st.w [%a14]-28,%d2

        if (rts != NULL_PTR)
8000e940:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8000e944:	df 02 48 00 	jeq %d2,0,8000e9d4 <IfxAsclin_Asc_initModule+0x6d2>
        {
            IfxAsclin_initRtsPin(rts, pins->rtsMode, pins->pinDriver);
8000e948:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e94c:	d9 22 14 00 	lea %a2,[%a2]20
8000e950:	54 23       	ld.w %d3,[%a2]
8000e952:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e956:	d9 22 20 00 	lea %a2,[%a2]32
8000e95a:	54 22       	ld.w %d2,[%a2]
8000e95c:	19 e4 e4 ff 	ld.w %d4,[%a14]-28
8000e960:	59 e4 ec bf 	st.w [%a14]-276,%d4
8000e964:	59 e3 e8 bf 	st.w [%a14]-280,%d3
8000e968:	59 e2 e4 bf 	st.w [%a14]-284,%d2
    IfxPort_setPinModeOutput(rts->pin.port, rts->pin.pinIndex, outputMode, rts->select);
8000e96c:	99 e2 ec bf 	ld.a %a2,[%a14]-276
8000e970:	b0 42       	add.a %a2,4
8000e972:	54 24       	ld.w %d4,[%a2]
8000e974:	99 e2 ec bf 	ld.a %a2,[%a14]-276
8000e978:	39 22 08 00 	ld.bu %d2,[%a2]8
8000e97c:	99 e2 ec bf 	ld.a %a2,[%a14]-276
8000e980:	d9 22 0c 00 	lea %a2,[%a2]12
8000e984:	54 23       	ld.w %d3,[%a2]
8000e986:	59 e4 e0 bf 	st.w [%a14]-288,%d4
8000e98a:	e9 e2 df bf 	st.b [%a14]-289,%d2
8000e98e:	19 e2 e8 bf 	ld.w %d2,[%a14]-280
8000e992:	59 e2 d8 bf 	st.w [%a14]-296,%d2
8000e996:	59 e3 d4 bf 	st.w [%a14]-300,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000e99a:	39 e3 df bf 	ld.bu %d3,[%a14]-289
8000e99e:	19 e4 d8 bf 	ld.w %d4,[%a14]-296
8000e9a2:	19 e2 d4 bf 	ld.w %d2,[%a14]-300
8000e9a6:	a6 42       	or %d2,%d4
8000e9a8:	02 25       	mov %d5,%d2
8000e9aa:	02 34       	mov %d4,%d3
8000e9ac:	99 e4 e0 bf 	ld.a %a4,[%a14]-288
8000e9b0:	6d ff 8f cf 	call 800088ce <IfxPort_setPinMode>
}
8000e9b4:	00 00       	nop 
    IfxPort_setPinPadDriver(rts->pin.port, rts->pin.pinIndex, padDriver);
8000e9b6:	99 e2 ec bf 	ld.a %a2,[%a14]-276
8000e9ba:	b0 42       	add.a %a2,4
8000e9bc:	54 22       	ld.w %d2,[%a2]
8000e9be:	99 e2 ec bf 	ld.a %a2,[%a14]-276
8000e9c2:	39 23 08 00 	ld.bu %d3,[%a2]8
8000e9c6:	19 e5 e4 bf 	ld.w %d5,[%a14]-284
8000e9ca:	02 34       	mov %d4,%d3
8000e9cc:	60 24       	mov.a %a4,%d2
8000e9ce:	6d ff f2 cf 	call 800089b2 <IfxPort_setPinPadDriver>
}
8000e9d2:	00 00       	nop 
        }

        IfxAsclin_Tx_Out *tx = pins->tx;
8000e9d4:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e9d8:	d9 22 18 00 	lea %a2,[%a2]24
8000e9dc:	54 22       	ld.w %d2,[%a2]
8000e9de:	59 e2 e0 ff 	st.w [%a14]-32,%d2

        if (tx != NULL_PTR)
8000e9e2:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8000e9e6:	df 02 48 00 	jeq %d2,0,8000ea76 <IfxAsclin_Asc_initModule+0x774>
        {
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
8000e9ea:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e9ee:	d9 22 1c 00 	lea %a2,[%a2]28
8000e9f2:	54 23       	ld.w %d3,[%a2]
8000e9f4:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000e9f8:	d9 22 20 00 	lea %a2,[%a2]32
8000e9fc:	54 22       	ld.w %d2,[%a2]
8000e9fe:	19 e4 e0 ff 	ld.w %d4,[%a14]-32
8000ea02:	59 e4 d0 bf 	st.w [%a14]-304,%d4
8000ea06:	59 e3 cc bf 	st.w [%a14]-308,%d3
8000ea0a:	59 e2 c8 bf 	st.w [%a14]-312,%d2
    IfxPort_setPinModeOutput(tx->pin.port, tx->pin.pinIndex, outputMode, tx->select);
8000ea0e:	99 e2 d0 bf 	ld.a %a2,[%a14]-304
8000ea12:	b0 42       	add.a %a2,4
8000ea14:	54 24       	ld.w %d4,[%a2]
8000ea16:	99 e2 d0 bf 	ld.a %a2,[%a14]-304
8000ea1a:	39 22 08 00 	ld.bu %d2,[%a2]8
8000ea1e:	99 e2 d0 bf 	ld.a %a2,[%a14]-304
8000ea22:	d9 22 0c 00 	lea %a2,[%a2]12
8000ea26:	54 23       	ld.w %d3,[%a2]
8000ea28:	59 e4 c4 bf 	st.w [%a14]-316,%d4
8000ea2c:	e9 e2 c3 bf 	st.b [%a14]-317,%d2
8000ea30:	19 e2 cc bf 	ld.w %d2,[%a14]-308
8000ea34:	59 e2 fc af 	st.w [%a14]-324,%d2
8000ea38:	59 e3 f8 af 	st.w [%a14]-328,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8000ea3c:	39 e3 c3 bf 	ld.bu %d3,[%a14]-317
8000ea40:	19 e4 fc af 	ld.w %d4,[%a14]-324
8000ea44:	19 e2 f8 af 	ld.w %d2,[%a14]-328
8000ea48:	a6 42       	or %d2,%d4
8000ea4a:	02 25       	mov %d5,%d2
8000ea4c:	02 34       	mov %d4,%d3
8000ea4e:	99 e4 c4 bf 	ld.a %a4,[%a14]-316
8000ea52:	6d ff 3e cf 	call 800088ce <IfxPort_setPinMode>
}
8000ea56:	00 00       	nop 
    IfxPort_setPinPadDriver(tx->pin.port, tx->pin.pinIndex, padDriver);
8000ea58:	99 e2 d0 bf 	ld.a %a2,[%a14]-304
8000ea5c:	b0 42       	add.a %a2,4
8000ea5e:	54 22       	ld.w %d2,[%a2]
8000ea60:	99 e2 d0 bf 	ld.a %a2,[%a14]-304
8000ea64:	39 23 08 00 	ld.bu %d3,[%a2]8
8000ea68:	19 e5 c8 bf 	ld.w %d5,[%a14]-312
8000ea6c:	02 34       	mov %d4,%d3
8000ea6e:	60 24       	mov.a %a4,%d2
8000ea70:	6d ff a1 cf 	call 800089b2 <IfxPort_setPinPadDriver>
}
8000ea74:	00 00       	nop 
        }
    }

    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* select the clock source*/
8000ea76:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ea7a:	d9 22 20 10 	lea %a2,[%a2]96
8000ea7e:	54 22       	ld.w %d2,[%a2]
8000ea80:	02 24       	mov %d4,%d2
8000ea82:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000ea86:	6d ff da fb 	call 8000e23a <IfxAsclin_setClockSource>
8000ea8a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000ea8e:	59 e2 f0 af 	st.w [%a14]-336,%d2
    asclin->FLAGSENABLE.U = 0x00000000;
8000ea92:	99 e2 f0 af 	ld.a %a2,[%a14]-336
8000ea96:	82 02       	mov %d2,0
8000ea98:	d9 22 00 10 	lea %a2,[%a2]64
8000ea9c:	74 22       	st.w [%a2],%d2
}
8000ea9e:	00 00       	nop 
8000eaa0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000eaa4:	59 e2 f4 af 	st.w [%a14]-332,%d2
    asclin->FLAGSCLEAR.U = 0xFFFFFFFF;
8000eaa8:	99 e2 f4 af 	ld.a %a2,[%a14]-332
8000eaac:	82 f2       	mov %d2,-1
8000eaae:	d9 22 3c 00 	lea %a2,[%a2]60
8000eab2:	74 22       	st.w [%a2],%d2
}
8000eab4:	00 00       	nop 

    IfxAsclin_disableAllFlags(asclinSFR);                     /* disable all flags */
    IfxAsclin_clearAllFlags(asclinSFR);                       /* clear all flags */

    /* HW error flags */
    asclin->errorFlags.ALL = 0;
8000eab6:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000eaba:	82 02       	mov %d2,0
8000eabc:	e9 22 0e 00 	st.b [%a2]14,%d2

    if (config->errorFlags.flags.parityError)
8000eac0:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000eac4:	39 22 24 10 	ld.bu %d2,[%a2]100
8000eac8:	8f 12 00 21 	and %d2,%d2,1
8000eacc:	8f f2 0f 21 	and %d2,%d2,255
8000ead0:	df 02 1a 00 	jeq %d2,0,8000eb04 <IfxAsclin_Asc_initModule+0x802>
8000ead4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000ead8:	59 e2 ec af 	st.w [%a14]-340,%d2
8000eadc:	82 12       	mov %d2,1
8000eade:	e9 e2 eb af 	st.b [%a14]-341,%d2
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
8000eae2:	39 e2 eb af 	ld.bu %d2,[%a14]-341
8000eae6:	8b 02 20 22 	ne %d2,%d2,0
8000eaea:	8f f2 0f 31 	and %d3,%d2,255
8000eaee:	99 e2 ec af 	ld.a %a2,[%a14]-340
8000eaf2:	d9 23 00 10 	lea %a3,[%a2]64
8000eaf6:	54 32       	ld.w %d2,[%a3]
8000eaf8:	67 32 10 20 	ins.t %d2,%d2,16,%d3,0
8000eafc:	d9 22 00 10 	lea %a2,[%a2]64
8000eb00:	74 22       	st.w [%a2],%d2
}
8000eb02:	00 00       	nop 
    {
        IfxAsclin_enableParityErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.frameError)
8000eb04:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000eb08:	39 22 24 10 	ld.bu %d2,[%a2]100
8000eb0c:	8f 22 00 21 	and %d2,%d2,2
8000eb10:	8f f2 0f 21 	and %d2,%d2,255
8000eb14:	df 02 1a 00 	jeq %d2,0,8000eb48 <IfxAsclin_Asc_initModule+0x846>
8000eb18:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000eb1c:	59 e2 e4 af 	st.w [%a14]-348,%d2
8000eb20:	82 12       	mov %d2,1
8000eb22:	e9 e2 e3 af 	st.b [%a14]-349,%d2
    asclin->FLAGSENABLE.B.FEE = enable ? 1 : 0;
8000eb26:	39 e2 e3 af 	ld.bu %d2,[%a14]-349
8000eb2a:	8b 02 20 22 	ne %d2,%d2,0
8000eb2e:	8f f2 0f 31 	and %d3,%d2,255
8000eb32:	99 e2 e4 af 	ld.a %a2,[%a14]-348
8000eb36:	d9 23 00 10 	lea %a3,[%a2]64
8000eb3a:	54 32       	ld.w %d2,[%a3]
8000eb3c:	67 32 12 20 	ins.t %d2,%d2,18,%d3,0
8000eb40:	d9 22 00 10 	lea %a2,[%a2]64
8000eb44:	74 22       	st.w [%a2],%d2
}
8000eb46:	00 00       	nop 
    {
        IfxAsclin_enableFrameErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoOverflow)
8000eb48:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000eb4c:	39 22 24 10 	ld.bu %d2,[%a2]100
8000eb50:	8f 42 00 21 	and %d2,%d2,4
8000eb54:	8f f2 0f 21 	and %d2,%d2,255
8000eb58:	df 02 1a 00 	jeq %d2,0,8000eb8c <IfxAsclin_Asc_initModule+0x88a>
8000eb5c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000eb60:	59 e2 dc af 	st.w [%a14]-356,%d2
8000eb64:	82 12       	mov %d2,1
8000eb66:	e9 e2 db af 	st.b [%a14]-357,%d2
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
8000eb6a:	39 e2 db af 	ld.bu %d2,[%a14]-357
8000eb6e:	8b 02 20 22 	ne %d2,%d2,0
8000eb72:	8f f2 0f 31 	and %d3,%d2,255
8000eb76:	99 e2 dc af 	ld.a %a2,[%a14]-356
8000eb7a:	d9 23 00 10 	lea %a3,[%a2]64
8000eb7e:	54 32       	ld.w %d2,[%a3]
8000eb80:	67 32 1a 20 	ins.t %d2,%d2,26,%d3,0
8000eb84:	d9 22 00 10 	lea %a2,[%a2]64
8000eb88:	74 22       	st.w [%a2],%d2
}
8000eb8a:	00 00       	nop 
    {
        IfxAsclin_enableRxFifoOverflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoUnderflow)
8000eb8c:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000eb90:	39 22 24 10 	ld.bu %d2,[%a2]100
8000eb94:	8f 82 00 21 	and %d2,%d2,8
8000eb98:	8f f2 0f 21 	and %d2,%d2,255
8000eb9c:	df 02 1a 00 	jeq %d2,0,8000ebd0 <IfxAsclin_Asc_initModule+0x8ce>
8000eba0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000eba4:	59 e2 d4 af 	st.w [%a14]-364,%d2
8000eba8:	82 12       	mov %d2,1
8000ebaa:	e9 e2 d3 af 	st.b [%a14]-365,%d2
    asclin->FLAGSENABLE.B.RFUE = enable ? 1 : 0;
8000ebae:	39 e2 d3 af 	ld.bu %d2,[%a14]-365
8000ebb2:	8b 02 20 22 	ne %d2,%d2,0
8000ebb6:	8f f2 0f 31 	and %d3,%d2,255
8000ebba:	99 e2 d4 af 	ld.a %a2,[%a14]-364
8000ebbe:	d9 23 00 10 	lea %a3,[%a2]64
8000ebc2:	54 32       	ld.w %d2,[%a3]
8000ebc4:	67 32 1b 20 	ins.t %d2,%d2,27,%d3,0
8000ebc8:	d9 22 00 10 	lea %a2,[%a2]64
8000ebcc:	74 22       	st.w [%a2],%d2
}
8000ebce:	00 00       	nop 
    {
        IfxAsclin_enableRxFifoUnderflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.txFifoOverflow)
8000ebd0:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ebd4:	39 22 24 10 	ld.bu %d2,[%a2]100
8000ebd8:	8f 02 01 21 	and %d2,%d2,16
8000ebdc:	8f f2 0f 21 	and %d2,%d2,255
8000ebe0:	df 02 1a 00 	jeq %d2,0,8000ec14 <IfxAsclin_Asc_initModule+0x912>
8000ebe4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000ebe8:	59 e2 cc af 	st.w [%a14]-372,%d2
8000ebec:	82 12       	mov %d2,1
8000ebee:	e9 e2 cb af 	st.b [%a14]-373,%d2
    asclin->FLAGSENABLE.B.TFOE = enable ? 1 : 0;
8000ebf2:	39 e2 cb af 	ld.bu %d2,[%a14]-373
8000ebf6:	8b 02 20 22 	ne %d2,%d2,0
8000ebfa:	8f f2 0f 31 	and %d3,%d2,255
8000ebfe:	99 e2 cc af 	ld.a %a2,[%a14]-372
8000ec02:	d9 23 00 10 	lea %a3,[%a2]64
8000ec06:	54 32       	ld.w %d2,[%a3]
8000ec08:	67 32 1e 20 	ins.t %d2,%d2,30,%d3,0
8000ec0c:	d9 22 00 10 	lea %a2,[%a2]64
8000ec10:	74 22       	st.w [%a2],%d2
}
8000ec12:	00 00       	nop 
    {
        IfxAsclin_enableTxFifoOverflowFlag(asclinSFR, TRUE);
    }

    /* transmission flags */
    asclin->rxSwFifoOverflow = FALSE;
8000ec14:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ec18:	82 02       	mov %d2,0
8000ec1a:	e9 22 0d 00 	st.b [%a2]13,%d2
    asclin->txInProgress     = FALSE;
8000ec1e:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ec22:	82 02       	mov %d2,0
8000ec24:	e9 22 0c 00 	st.b [%a2]12,%d2

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
8000ec28:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ec2c:	d9 22 38 10 	lea %a2,[%a2]120
8000ec30:	54 22       	ld.w %d2,[%a2]
8000ec32:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ec36:	d9 22 10 00 	lea %a2,[%a2]16
8000ec3a:	74 22       	st.w [%a2],%d2
    asclin->txTimestamp    = 0;
8000ec3c:	99 e4 d4 8f 	ld.a %a4,[%a14]-492
8000ec40:	a0 02       	mov.a %a2,0
8000ec42:	a0 03       	mov.a %a3,0
8000ec44:	89 42 d8 09 	st.da [%a4]24,%a2
    asclin->sendCount      = 0;
8000ec48:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ec4c:	82 02       	mov %d2,0
8000ec4e:	d9 22 14 00 	lea %a2,[%a2]20
8000ec52:	74 22       	st.w [%a2],%d2

    switch (asclin->dataBufferMode)
8000ec54:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ec58:	d9 22 10 00 	lea %a2,[%a2]16
8000ec5c:	54 22       	ld.w %d2,[%a2]
8000ec5e:	df 02 06 00 	jeq %d2,0,8000ec6a <IfxAsclin_Asc_initModule+0x968>
8000ec62:	df 12 09 00 	jeq %d2,1,8000ec74 <IfxAsclin_Asc_initModule+0x972>
8000ec66:	1d 00 0d 00 	j 8000ec80 <IfxAsclin_Asc_initModule+0x97e>
    {
    case Ifx_DataBufferMode_normal:
        elementSize = 1;
8000ec6a:	82 12       	mov %d2,1
8000ec6c:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        break;
8000ec70:	1d 00 0c 00 	j 8000ec88 <IfxAsclin_Asc_initModule+0x986>
    case Ifx_DataBufferMode_timeStampSingle:
        elementSize = sizeof(Ifx_DataBufferMode_TimeStampSingle);
8000ec74:	3b c0 00 20 	mov %d2,12
8000ec78:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        break;
8000ec7c:	1d 00 06 00 	j 8000ec88 <IfxAsclin_Asc_initModule+0x986>
    default:
        elementSize = 0;
8000ec80:	82 02       	mov %d2,0
8000ec82:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
8000ec86:	00 00       	nop 
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
8000ec88:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ec8c:	d9 22 28 10 	lea %a2,[%a2]104
8000ec90:	54 22       	ld.w %d2,[%a2]
8000ec92:	df 02 19 00 	jeq %d2,0,8000ecc4 <IfxAsclin_Asc_initModule+0x9c2>
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
8000ec96:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ec9a:	d9 22 28 10 	lea %a2,[%a2]104
8000ec9e:	54 23       	ld.w %d3,[%a2]
8000eca0:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000eca4:	c9 22 26 10 	ld.h %d2,[%a2]102
8000eca8:	02 24       	mov %d4,%d2
8000ecaa:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8000ecae:	02 25       	mov %d5,%d2
8000ecb0:	60 34       	mov.a %a4,%d3
8000ecb2:	6d ff 89 b5 	call 800057c4 <Ifx_Fifo_init>
8000ecb6:	80 22       	mov.d %d2,%a2
8000ecb8:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ecbc:	b0 42       	add.a %a2,4
8000ecbe:	74 22       	st.w [%a2],%d2
8000ecc0:	1d 00 12 00 	j 8000ece4 <IfxAsclin_Asc_initModule+0x9e2>
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
8000ecc4:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ecc8:	c9 22 26 10 	ld.h %d2,[%a2]102
8000eccc:	02 23       	mov %d3,%d2
8000ecce:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8000ecd2:	02 25       	mov %d5,%d2
8000ecd4:	02 34       	mov %d4,%d3
8000ecd6:	6d ff 42 b5 	call 8000575a <Ifx_Fifo_create>
8000ecda:	80 22       	mov.d %d2,%a2
8000ecdc:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ece0:	b0 42       	add.a %a2,4
8000ece2:	74 22       	st.w [%a2],%d2
    }

    if (config->rxBuffer != NULL_PTR)
8000ece4:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ece8:	d9 22 30 10 	lea %a2,[%a2]112
8000ecec:	54 22       	ld.w %d2,[%a2]
8000ecee:	df 02 1a 00 	jeq %d2,0,8000ed22 <IfxAsclin_Asc_initModule+0xa20>
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
8000ecf2:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ecf6:	d9 22 30 10 	lea %a2,[%a2]112
8000ecfa:	54 23       	ld.w %d3,[%a2]
8000ecfc:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ed00:	c9 22 2c 10 	ld.h %d2,[%a2]108
8000ed04:	02 24       	mov %d4,%d2
8000ed06:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8000ed0a:	02 25       	mov %d5,%d2
8000ed0c:	60 34       	mov.a %a4,%d3
8000ed0e:	6d ff 5b b5 	call 800057c4 <Ifx_Fifo_init>
8000ed12:	80 22       	mov.d %d2,%a2
8000ed14:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ed18:	d9 22 08 00 	lea %a2,[%a2]8
8000ed1c:	74 22       	st.w [%a2],%d2
8000ed1e:	1d 00 13 00 	j 8000ed44 <IfxAsclin_Asc_initModule+0xa42>
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
8000ed22:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ed26:	c9 22 2c 10 	ld.h %d2,[%a2]108
8000ed2a:	02 23       	mov %d3,%d2
8000ed2c:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8000ed30:	02 25       	mov %d5,%d2
8000ed32:	02 34       	mov %d4,%d3
8000ed34:	6d ff 13 b5 	call 8000575a <Ifx_Fifo_create>
8000ed38:	80 22       	mov.d %d2,%a2
8000ed3a:	99 e2 d4 8f 	ld.a %a2,[%a14]-492
8000ed3e:	d9 22 08 00 	lea %a2,[%a2]8
8000ed42:	74 22       	st.w [%a2],%d2
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;
8000ed44:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ed48:	d9 22 18 10 	lea %a2,[%a2]88
8000ed4c:	54 22       	ld.w %d2,[%a2]
8000ed4e:	59 e2 dc ff 	st.w [%a14]-36,%d2

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
8000ed52:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ed56:	b9 22 12 10 	ld.hu %d2,[%a2]82
8000ed5a:	df 02 06 80 	jne %d2,0,8000ed66 <IfxAsclin_Asc_initModule+0xa64>
8000ed5e:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000ed62:	df 12 5b 80 	jne %d2,1,8000ee18 <IfxAsclin_Asc_initModule+0xb16>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerRx(asclinSFR);
8000ed66:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000ed6a:	6d ff 7b f8 	call 8000de60 <IfxAsclin_getSrcPointerRx>
8000ed6e:	b5 e2 d8 ff 	st.a [%a14]-40,%a2
        IfxSrc_init(src, tos, config->interrupt.rxPriority);
8000ed72:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ed76:	b9 22 12 10 	ld.hu %d2,[%a2]82
8000ed7a:	19 e3 d8 ff 	ld.w %d3,[%a14]-40
8000ed7e:	59 e3 f8 9f 	st.w [%a14]-392,%d3
8000ed82:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8000ed86:	59 e3 f4 9f 	st.w [%a14]-396,%d3
8000ed8a:	f9 e2 f2 9f 	st.h [%a14]-398,%d2
    src->B.SRPN = priority;
8000ed8e:	c9 e2 f2 9f 	ld.h %d2,[%a14]-398
8000ed92:	8f f2 0f 31 	and %d3,%d2,255
8000ed96:	99 e2 f8 9f 	ld.a %a2,[%a14]-392
8000ed9a:	54 22       	ld.w %d2,[%a2]
8000ed9c:	37 32 08 20 	insert %d2,%d2,%d3,0,8
8000eda0:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000eda2:	19 e2 f4 9f 	ld.w %d2,[%a14]-396
8000eda6:	8f 72 00 21 	and %d2,%d2,7
8000edaa:	8f f2 0f 31 	and %d3,%d2,255
8000edae:	99 e2 f8 9f 	ld.a %a2,[%a14]-392
8000edb2:	54 22       	ld.w %d2,[%a2]
8000edb4:	37 32 83 25 	insert %d2,%d2,%d3,11,3
8000edb8:	74 22       	st.w [%a2],%d2
8000edba:	19 e2 f8 9f 	ld.w %d2,[%a14]-392
8000edbe:	59 e2 ec 9f 	st.w [%a14]-404,%d2
    src->B.CLRR = 1;
8000edc2:	99 e2 ec 9f 	ld.a %a2,[%a14]-404
8000edc6:	54 22       	ld.w %d2,[%a2]
8000edc8:	b7 12 81 2c 	insert %d2,%d2,1,25,1
8000edcc:	74 22       	st.w [%a2],%d2
}
8000edce:	00 00       	nop 
}
8000edd0:	00 00       	nop 
8000edd2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000edd6:	59 e2 c0 af 	st.w [%a14]-384,%d2
8000edda:	82 12       	mov %d2,1
8000eddc:	e9 e2 ff 9f 	st.b [%a14]-385,%d2
    asclin->FLAGSENABLE.B.RFLE = enable ? 1 : 0;
8000ede0:	39 e2 ff 9f 	ld.bu %d2,[%a14]-385
8000ede4:	8b 02 20 22 	ne %d2,%d2,0
8000ede8:	8f f2 0f 31 	and %d3,%d2,255
8000edec:	99 e2 c0 af 	ld.a %a2,[%a14]-384
8000edf0:	d9 23 00 10 	lea %a3,[%a2]64
8000edf4:	54 32       	ld.w %d2,[%a3]
8000edf6:	67 32 1c 20 	ins.t %d2,%d2,28,%d3,0
8000edfa:	d9 22 00 10 	lea %a2,[%a2]64
8000edfe:	74 22       	st.w [%a2],%d2
}
8000ee00:	00 00       	nop 
8000ee02:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8000ee06:	59 e2 c4 af 	st.w [%a14]-380,%d2
    src->B.SRE = 1;
8000ee0a:	99 e2 c4 af 	ld.a %a2,[%a14]-380
8000ee0e:	54 22       	ld.w %d2,[%a2]
8000ee10:	b7 12 01 25 	insert %d2,%d2,1,10,1
8000ee14:	74 22       	st.w [%a2],%d2
}
8000ee16:	00 00       	nop 
        IfxAsclin_enableRxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if ((config->interrupt.txPriority > 0) || (tos == IfxSrc_Tos_dma))
8000ee18:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ee1c:	b9 22 10 10 	ld.hu %d2,[%a2]80
8000ee20:	df 02 06 80 	jne %d2,0,8000ee2c <IfxAsclin_Asc_initModule+0xb2a>
8000ee24:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8000ee28:	df 12 5b 80 	jne %d2,1,8000eede <IfxAsclin_Asc_initModule+0xbdc>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerTx(asclinSFR);
8000ee2c:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000ee30:	6d ff 29 f8 	call 8000de82 <IfxAsclin_getSrcPointerTx>
8000ee34:	b5 e2 d4 ff 	st.a [%a14]-44,%a2
        IfxSrc_init(src, tos, config->interrupt.txPriority);
8000ee38:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000ee3c:	b9 22 10 10 	ld.hu %d2,[%a2]80
8000ee40:	19 e3 d4 ff 	ld.w %d3,[%a14]-44
8000ee44:	59 e3 dc 9f 	st.w [%a14]-420,%d3
8000ee48:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8000ee4c:	59 e3 d8 9f 	st.w [%a14]-424,%d3
8000ee50:	f9 e2 d6 9f 	st.h [%a14]-426,%d2
    src->B.SRPN = priority;
8000ee54:	c9 e2 d6 9f 	ld.h %d2,[%a14]-426
8000ee58:	8f f2 0f 31 	and %d3,%d2,255
8000ee5c:	99 e2 dc 9f 	ld.a %a2,[%a14]-420
8000ee60:	54 22       	ld.w %d2,[%a2]
8000ee62:	37 32 08 20 	insert %d2,%d2,%d3,0,8
8000ee66:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000ee68:	19 e2 d8 9f 	ld.w %d2,[%a14]-424
8000ee6c:	8f 72 00 21 	and %d2,%d2,7
8000ee70:	8f f2 0f 31 	and %d3,%d2,255
8000ee74:	99 e2 dc 9f 	ld.a %a2,[%a14]-420
8000ee78:	54 22       	ld.w %d2,[%a2]
8000ee7a:	37 32 83 25 	insert %d2,%d2,%d3,11,3
8000ee7e:	74 22       	st.w [%a2],%d2
8000ee80:	19 e2 dc 9f 	ld.w %d2,[%a14]-420
8000ee84:	59 e2 d0 9f 	st.w [%a14]-432,%d2
    src->B.CLRR = 1;
8000ee88:	99 e2 d0 9f 	ld.a %a2,[%a14]-432
8000ee8c:	54 22       	ld.w %d2,[%a2]
8000ee8e:	b7 12 81 2c 	insert %d2,%d2,1,25,1
8000ee92:	74 22       	st.w [%a2],%d2
}
8000ee94:	00 00       	nop 
}
8000ee96:	00 00       	nop 
8000ee98:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000ee9c:	59 e2 e4 9f 	st.w [%a14]-412,%d2
8000eea0:	82 12       	mov %d2,1
8000eea2:	e9 e2 e3 9f 	st.b [%a14]-413,%d2
    asclin->FLAGSENABLE.B.TFLE = enable ? 1 : 0;
8000eea6:	39 e2 e3 9f 	ld.bu %d2,[%a14]-413
8000eeaa:	8b 02 20 22 	ne %d2,%d2,0
8000eeae:	8f f2 0f 31 	and %d3,%d2,255
8000eeb2:	99 e2 e4 9f 	ld.a %a2,[%a14]-412
8000eeb6:	d9 23 00 10 	lea %a3,[%a2]64
8000eeba:	54 32       	ld.w %d2,[%a3]
8000eebc:	67 32 1f 20 	ins.t %d2,%d2,31,%d3,0
8000eec0:	d9 22 00 10 	lea %a2,[%a2]64
8000eec4:	74 22       	st.w [%a2],%d2
}
8000eec6:	00 00       	nop 
8000eec8:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8000eecc:	59 e2 e8 9f 	st.w [%a14]-408,%d2
    src->B.SRE = 1;
8000eed0:	99 e2 e8 9f 	ld.a %a2,[%a14]-408
8000eed4:	54 22       	ld.w %d2,[%a2]
8000eed6:	b7 12 01 25 	insert %d2,%d2,1,10,1
8000eeda:	74 22       	st.w [%a2],%d2
}
8000eedc:	00 00       	nop 
        IfxAsclin_enableTxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if (config->interrupt.erPriority > 0) /*These interrupts are not serviced by dma*/
8000eede:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000eee2:	b9 22 14 10 	ld.hu %d2,[%a2]84
8000eee6:	df 02 5b 00 	jeq %d2,0,8000ef9c <IfxAsclin_Asc_initModule+0xc9a>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerEr(asclinSFR);
8000eeea:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8000eeee:	6d ff a7 f7 	call 8000de3c <IfxAsclin_getSrcPointerEr>
8000eef2:	b5 e2 d0 ff 	st.a [%a14]-48,%a2
        IfxSrc_init(src, tos, config->interrupt.erPriority);
8000eef6:	99 e2 d0 8f 	ld.a %a2,[%a14]-496
8000eefa:	b9 22 14 10 	ld.hu %d2,[%a2]84
8000eefe:	19 e3 d0 ff 	ld.w %d3,[%a14]-48
8000ef02:	59 e3 c0 9f 	st.w [%a14]-448,%d3
8000ef06:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8000ef0a:	59 e3 fc 8f 	st.w [%a14]-452,%d3
8000ef0e:	f9 e2 fa 8f 	st.h [%a14]-454,%d2
    src->B.SRPN = priority;
8000ef12:	c9 e2 fa 8f 	ld.h %d2,[%a14]-454
8000ef16:	8f f2 0f 31 	and %d3,%d2,255
8000ef1a:	99 e2 c0 9f 	ld.a %a2,[%a14]-448
8000ef1e:	54 22       	ld.w %d2,[%a2]
8000ef20:	37 32 08 20 	insert %d2,%d2,%d3,0,8
8000ef24:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000ef26:	19 e2 fc 8f 	ld.w %d2,[%a14]-452
8000ef2a:	8f 72 00 21 	and %d2,%d2,7
8000ef2e:	8f f2 0f 31 	and %d3,%d2,255
8000ef32:	99 e2 c0 9f 	ld.a %a2,[%a14]-448
8000ef36:	54 22       	ld.w %d2,[%a2]
8000ef38:	37 32 83 25 	insert %d2,%d2,%d3,11,3
8000ef3c:	74 22       	st.w [%a2],%d2
8000ef3e:	19 e2 c0 9f 	ld.w %d2,[%a14]-448
8000ef42:	59 e2 f4 8f 	st.w [%a14]-460,%d2
    src->B.CLRR = 1;
8000ef46:	99 e2 f4 8f 	ld.a %a2,[%a14]-460
8000ef4a:	54 22       	ld.w %d2,[%a2]
8000ef4c:	b7 12 81 2c 	insert %d2,%d2,1,25,1
8000ef50:	74 22       	st.w [%a2],%d2
}
8000ef52:	00 00       	nop 
}
8000ef54:	00 00       	nop 
8000ef56:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000ef5a:	59 e2 c8 9f 	st.w [%a14]-440,%d2
8000ef5e:	82 12       	mov %d2,1
8000ef60:	e9 e2 c7 9f 	st.b [%a14]-441,%d2
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
8000ef64:	39 e2 c7 9f 	ld.bu %d2,[%a14]-441
8000ef68:	8b 02 20 22 	ne %d2,%d2,0
8000ef6c:	8f f2 0f 31 	and %d3,%d2,255
8000ef70:	99 e2 c8 9f 	ld.a %a2,[%a14]-440
8000ef74:	d9 23 00 10 	lea %a3,[%a2]64
8000ef78:	54 32       	ld.w %d2,[%a3]
8000ef7a:	67 32 10 20 	ins.t %d2,%d2,16,%d3,0
8000ef7e:	d9 22 00 10 	lea %a2,[%a2]64
8000ef82:	74 22       	st.w [%a2],%d2
}
8000ef84:	00 00       	nop 
8000ef86:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8000ef8a:	59 e2 cc 9f 	st.w [%a14]-436,%d2
    src->B.SRE = 1;
8000ef8e:	99 e2 cc 9f 	ld.a %a2,[%a14]-436
8000ef92:	54 22       	ld.w %d2,[%a2]
8000ef94:	b7 12 01 25 	insert %d2,%d2,1,10,1
8000ef98:	74 22       	st.w [%a2],%d2
}
8000ef9a:	00 00       	nop 
8000ef9c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000efa0:	59 e2 e0 8f 	st.w [%a14]-480,%d2
8000efa4:	82 12       	mov %d2,1
8000efa6:	e9 e2 df 8f 	st.b [%a14]-481,%d2
    asclin->RXFIFOCON.B.ENI = enable ? 1 : 0;
8000efaa:	39 e2 df 8f 	ld.bu %d2,[%a14]-481
8000efae:	8b 02 20 22 	ne %d2,%d2,0
8000efb2:	8f f2 0f 31 	and %d3,%d2,255
8000efb6:	99 e2 e0 8f 	ld.a %a2,[%a14]-480
8000efba:	d9 23 10 00 	lea %a3,[%a2]16
8000efbe:	54 32       	ld.w %d2,[%a3]
8000efc0:	67 32 01 20 	ins.t %d2,%d2,1,%d3,0
8000efc4:	d9 22 10 00 	lea %a2,[%a2]16
8000efc8:	74 22       	st.w [%a2],%d2
}
8000efca:	00 00       	nop 
8000efcc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000efd0:	59 e2 e8 8f 	st.w [%a14]-472,%d2
8000efd4:	82 12       	mov %d2,1
8000efd6:	e9 e2 e7 8f 	st.b [%a14]-473,%d2
    asclin->TXFIFOCON.B.ENO = enable ? 1 : 0;
8000efda:	39 e2 e7 8f 	ld.bu %d2,[%a14]-473
8000efde:	8b 02 20 22 	ne %d2,%d2,0
8000efe2:	8f f2 0f 31 	and %d3,%d2,255
8000efe6:	99 e2 e8 8f 	ld.a %a2,[%a14]-472
8000efea:	d9 23 0c 00 	lea %a3,[%a2]12
8000efee:	54 32       	ld.w %d2,[%a3]
8000eff0:	67 32 01 20 	ins.t %d2,%d2,1,%d3,0
8000eff4:	d9 22 0c 00 	lea %a2,[%a2]12
8000eff8:	74 22       	st.w [%a2],%d2
}
8000effa:	00 00       	nop 
8000effc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000f000:	59 e2 ec 8f 	st.w [%a14]-468,%d2
    asclin->RXFIFOCON.B.FLUSH = 1;
8000f004:	99 e2 ec 8f 	ld.a %a2,[%a14]-468
8000f008:	d9 23 10 00 	lea %a3,[%a2]16
8000f00c:	54 32       	ld.w %d2,[%a3]
8000f00e:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000f012:	d9 22 10 00 	lea %a2,[%a2]16
8000f016:	74 22       	st.w [%a2],%d2
}
8000f018:	00 00       	nop 
8000f01a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000f01e:	59 e2 f0 8f 	st.w [%a14]-464,%d2
    asclin->TXFIFOCON.B.FLUSH = 1;
8000f022:	99 e2 f0 8f 	ld.a %a2,[%a14]-464
8000f026:	d9 23 0c 00 	lea %a3,[%a2]12
8000f02a:	54 32       	ld.w %d2,[%a3]
8000f02c:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000f030:	d9 22 0c 00 	lea %a2,[%a2]12
8000f034:	74 22       	st.w [%a2],%d2
}
8000f036:	00 00       	nop 
    IfxAsclin_enableTxFifoOutlet(asclinSFR, TRUE); // enabling Tx FIFO for transmitting

    IfxAsclin_flushRxFifo(asclinSFR);              // flushing Rx FIFO
    IfxAsclin_flushTxFifo(asclinSFR);              // flushing Tx FIFO

    return status;
8000f038:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
}
8000f03c:	00 90       	ret 

8000f03e <IfxAsclin_Asc_initModuleConfig>:


void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
8000f03e:	40 ae       	mov.aa %a14,%sp
8000f040:	20 08       	sub.a %sp,8
8000f042:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8000f046:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
    config->asclin = asclin;
8000f04a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f04e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000f052:	74 22       	st.w [%a2],%d2

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
8000f054:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f058:	82 02       	mov %d2,0
8000f05a:	e9 22 34 10 	st.b [%a2]116,%d2

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_ascFastClock;        /* Asclin fast clock, fasclinf*/
8000f05e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f062:	82 22       	mov %d2,2
8000f064:	d9 22 20 10 	lea %a2,[%a2]96
8000f068:	74 22       	st.w [%a2],%d2
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
8000f06a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f06e:	82 12       	mov %d2,1
8000f070:	f9 22 08 00 	st.h [%a2]8,%d2
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
8000f074:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f078:	7b 10 7e 24 	movh %d2,18401
8000f07c:	b0 42       	add.a %a2,4
8000f07e:	74 22       	st.w [%a2],%d2
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
8000f080:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f084:	82 32       	mov %d2,3
8000f086:	d9 22 0c 00 	lea %a2,[%a2]12
8000f08a:	74 22       	st.w [%a2],%d2

    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
8000f08c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f090:	82 02       	mov %d2,0
8000f092:	d9 22 10 00 	lea %a2,[%a2]16
8000f096:	74 22       	st.w [%a2],%d2
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
8000f098:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f09c:	82 32       	mov %d2,3
8000f09e:	d9 22 14 00 	lea %a2,[%a2]20
8000f0a2:	74 22       	st.w [%a2],%d2
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
8000f0a4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f0a8:	82 02       	mov %d2,0
8000f0aa:	d9 22 18 00 	lea %a2,[%a2]24
8000f0ae:	74 22       	st.w [%a2],%d2
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
8000f0b0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f0b4:	82 12       	mov %d2,1
8000f0b6:	d9 22 1c 00 	lea %a2,[%a2]28
8000f0ba:	74 22       	st.w [%a2],%d2
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
8000f0bc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f0c0:	82 12       	mov %d2,1
8000f0c2:	d9 22 20 00 	lea %a2,[%a2]32
8000f0c6:	74 22       	st.w [%a2],%d2
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
8000f0c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f0cc:	82 02       	mov %d2,0
8000f0ce:	d9 22 24 00 	lea %a2,[%a2]36
8000f0d2:	74 22       	st.w [%a2],%d2
    config->frame.parityBit               = FALSE;                             /* disable parity*/
8000f0d4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f0d8:	82 02       	mov %d2,0
8000f0da:	e9 22 30 00 	st.b [%a2]48,%d2
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
8000f0de:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f0e2:	82 02       	mov %d2,0
8000f0e4:	d9 22 28 00 	lea %a2,[%a2]40
8000f0e8:	74 22       	st.w [%a2],%d2
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
8000f0ea:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f0ee:	82 72       	mov %d2,7
8000f0f0:	d9 22 2c 00 	lea %a2,[%a2]44
8000f0f4:	74 22       	st.w [%a2],%d2

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
8000f0f6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f0fa:	82 12       	mov %d2,1
8000f0fc:	d9 22 34 00 	lea %a2,[%a2]52
8000f100:	74 22       	st.w [%a2],%d2
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
8000f102:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f106:	82 12       	mov %d2,1
8000f108:	d9 22 38 00 	lea %a2,[%a2]56
8000f10c:	74 22       	st.w [%a2],%d2
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
8000f10e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f112:	82 02       	mov %d2,0
8000f114:	d9 22 3c 00 	lea %a2,[%a2]60
8000f118:	74 22       	st.w [%a2],%d2
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
8000f11a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f11e:	82 02       	mov %d2,0
8000f120:	d9 22 00 10 	lea %a2,[%a2]64
8000f124:	74 22       	st.w [%a2],%d2
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/
8000f126:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f12a:	82 02       	mov %d2,0
8000f12c:	d9 22 04 10 	lea %a2,[%a2]68
8000f130:	74 22       	st.w [%a2],%d2
    config->fifo.txFifoInterruptMode  = IfxAsclin_FifoInterruptMode_combined;
8000f132:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f136:	82 02       	mov %d2,0
8000f138:	d9 22 08 10 	lea %a2,[%a2]72
8000f13c:	74 22       	st.w [%a2],%d2
    config->fifo.rxFifoInterruptMode  = IfxAsclin_FifoInterruptMode_combined;
8000f13e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f142:	82 02       	mov %d2,0
8000f144:	d9 22 0c 10 	lea %a2,[%a2]76
8000f148:	74 22       	st.w [%a2],%d2

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                /* receive interrupt priority 0*/
8000f14a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f14e:	82 02       	mov %d2,0
8000f150:	f9 22 12 10 	st.h [%a2]82,%d2
    config->interrupt.txPriority    = 0;                                /* transmit interrupt priority 0*/
8000f154:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f158:	82 02       	mov %d2,0
8000f15a:	f9 22 10 10 	st.h [%a2]80,%d2
    config->interrupt.erPriority    = 0;                                /* error interrupt priority 0*/
8000f15e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f162:	82 02       	mov %d2,0
8000f164:	f9 22 14 10 	st.h [%a2]84,%d2
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                  /* type of service CPU0*/
8000f168:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f16c:	82 02       	mov %d2,0
8000f16e:	d9 22 18 10 	lea %a2,[%a2]88
8000f172:	74 22       	st.w [%a2],%d2

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                        /* all error flags enabled*/
8000f174:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f178:	82 f2       	mov %d2,-1
8000f17a:	e9 22 24 10 	st.b [%a2]100,%d2

    /* init pointers */
    config->pins           = NULL_PTR;                                  /* pins to null pointer*/
8000f17e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f182:	82 02       	mov %d2,0
8000f184:	d9 22 1c 10 	lea %a2,[%a2]92
8000f188:	74 22       	st.w [%a2],%d2
    config->rxBuffer       = NULL_PTR;                                  /* Rx Fifo buffer*/
8000f18a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f18e:	82 02       	mov %d2,0
8000f190:	d9 22 30 10 	lea %a2,[%a2]112
8000f194:	74 22       	st.w [%a2],%d2
    config->txBuffer       = NULL_PTR;                                  /* Tx Fifo buffer*/
8000f196:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f19a:	82 02       	mov %d2,0
8000f19c:	d9 22 28 10 	lea %a2,[%a2]104
8000f1a0:	74 22       	st.w [%a2],%d2

    config->txBufferSize   = 0;                                         /* Rx Fifo buffer size*/
8000f1a2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f1a6:	82 02       	mov %d2,0
8000f1a8:	f9 22 26 10 	st.h [%a2]102,%d2
    config->rxBufferSize   = 0;                                         /* Rx Fifo buffer size*/
8000f1ac:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f1b0:	82 02       	mov %d2,0
8000f1b2:	f9 22 2c 10 	st.h [%a2]108,%d2

    config->dataBufferMode = Ifx_DataBufferMode_normal;
8000f1b6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f1ba:	82 02       	mov %d2,0
8000f1bc:	d9 22 38 10 	lea %a2,[%a2]120
8000f1c0:	74 22       	st.w [%a2],%d2
}
8000f1c2:	00 00       	nop 
8000f1c4:	00 90       	ret 

8000f1c6 <IfxAsclin_Asc_initiateTransmission>:


void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
8000f1c6:	40 ae       	mov.aa %a14,%sp
8000f1c8:	20 20       	sub.a %sp,32
8000f1ca:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
8000f1ce:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000f1d2:	39 22 0c 00 	ld.bu %d2,[%a2]12
8000f1d6:	df 02 50 80 	jne %d2,0,8000f276 <IfxAsclin_Asc_initiateTransmission+0xb0>
    {
        if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
8000f1da:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000f1de:	b0 42       	add.a %a2,4
8000f1e0:	54 22       	ld.w %d2,[%a2]
8000f1e2:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000f1e6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000f1ea:	59 e2 f8 ff 	st.w [%a14]-8,%d2
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
8000f1ee:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000f1f2:	c9 22 04 00 	ld.h %d2,[%a2]4
 * \retval TRUE is the buffer is empty
 * \retval FALSE is the buffer is not empty
 */
IFX_INLINE boolean Ifx_Fifo_isEmpty(Ifx_Fifo *fifo)
{
    return (Ifx_Fifo_readCount(fifo) != FALSE) ? FALSE : TRUE;
8000f1f6:	8b 02 00 22 	eq %d2,%d2,0
8000f1fa:	8f f2 0f 21 	and %d2,%d2,255
8000f1fe:	df 02 3c 80 	jne %d2,0,8000f276 <IfxAsclin_Asc_initiateTransmission+0xb0>
        {
            uint8 data;
            asclin->txInProgress = TRUE;
8000f202:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000f206:	82 12       	mov %d2,1
8000f208:	e9 22 0c 00 	st.b [%a2]12,%d2

            switch (asclin->dataBufferMode)
8000f20c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000f210:	d9 22 10 00 	lea %a2,[%a2]16
8000f214:	54 22       	ld.w %d2,[%a2]
8000f216:	df 02 06 00 	jeq %d2,0,8000f222 <IfxAsclin_Asc_initiateTransmission+0x5c>
8000f21a:	df 12 12 00 	jeq %d2,1,8000f23e <IfxAsclin_Asc_initiateTransmission+0x78>
8000f21e:	1d 00 22 00 	j 8000f262 <IfxAsclin_Asc_initiateTransmission+0x9c>
            {
            case Ifx_DataBufferMode_normal:
            {
                Ifx_Fifo_read(asclin->tx, &data, 1, TIME_NULL);
8000f222:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000f226:	b0 42       	add.a %a2,4
8000f228:	54 22       	ld.w %d2,[%a2]
8000f22a:	d9 e2 f7 ff 	lea %a2,[%a14]-9
8000f22e:	d2 06       	mov %e6,0
8000f230:	82 14       	mov %d4,1
8000f232:	40 25       	mov.aa %a5,%a2
8000f234:	60 24       	mov.a %a4,%d2
8000f236:	6d ff 17 b4 	call 80005a64 <Ifx_Fifo_read>
            }
            break;
8000f23a:	1d 00 14 00 	j 8000f262 <IfxAsclin_Asc_initiateTransmission+0x9c>
            case Ifx_DataBufferMode_timeStampSingle:
            {
                Ifx_DataBufferMode_TimeStampSingle packedData;
                Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
8000f23e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000f242:	b0 42       	add.a %a2,4
8000f244:	54 22       	ld.w %d2,[%a2]
8000f246:	d9 e2 e8 ff 	lea %a2,[%a14]-24
8000f24a:	d2 06       	mov %e6,0
8000f24c:	3b c0 00 40 	mov %d4,12
8000f250:	40 25       	mov.aa %a5,%a2
8000f252:	60 24       	mov.a %a4,%d2
8000f254:	6d ff 08 b4 	call 80005a64 <Ifx_Fifo_read>
                data = packedData.data;
8000f258:	39 e2 f0 ff 	ld.bu %d2,[%a14]-16
8000f25c:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
            }
            break;
8000f260:	00 00       	nop 
            }

            IfxAsclin_write8(asclin->asclin, &data, 1);
8000f262:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8000f266:	54 22       	ld.w %d2,[%a2]
8000f268:	d9 e2 f7 ff 	lea %a2,[%a14]-9
8000f26c:	82 14       	mov %d4,1
8000f26e:	40 25       	mov.aa %a5,%a2
8000f270:	60 24       	mov.a %a4,%d2
8000f272:	6d ff 22 f8 	call 8000e2b6 <IfxAsclin_write8>
        }
    }
}
8000f276:	00 00       	nop 
8000f278:	00 90       	ret 

8000f27a <IfxAsclin_Asc_isrTransmit>:
    }
}


void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
8000f27a:	40 ae       	mov.aa %a14,%sp
8000f27c:	20 68       	sub.a %sp,104
8000f27e:	b5 e4 dc ef 	st.a [%a14]-100,%a4
    reg.U = __mfcr(CPU_ICR);
8000f282:	4d c0 e2 4f 	mfcr %d4,$icr
8000f286:	59 e4 f0 ff 	st.w [%a14]-16,%d4
8000f28a:	19 e4 f0 ff 	ld.w %d4,[%a14]-16
8000f28e:	59 e4 c8 ff 	st.w [%a14]-56,%d4
    return reg.B.IE != 0;
8000f292:	19 e4 c8 ff 	ld.w %d4,[%a14]-56
8000f296:	37 04 e1 47 	extr.u %d4,%d4,15,1
8000f29a:	8f f4 0f 41 	and %d4,%d4,255
    enabled = IfxCpu_areInterruptsEnabled();
8000f29e:	e9 e4 ef ff 	st.b [%a14]-17,%d4
    __disable();
8000f2a2:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
8000f2a6:	00 00       	nop 
}
8000f2a8:	00 00       	nop 
    return enabled;
8000f2aa:	39 e4 ef ff 	ld.bu %d4,[%a14]-17
    interruptState = IfxCpu_disableInterrupts();
8000f2ae:	e9 e4 ee ff 	st.b [%a14]-18,%d4
8000f2b2:	7b 00 00 4f 	movh %d4,61440
8000f2b6:	1b 04 00 41 	addi %d4,%d4,4096
8000f2ba:	59 e4 e8 ff 	st.w [%a14]-24,%d4
    result  = stm->TIM0.U;
8000f2be:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000f2c2:	d9 22 10 00 	lea %a2,[%a2]16
8000f2c6:	54 24       	ld.w %d4,[%a2]
8000f2c8:	02 44       	mov %d4,%d4
8000f2ca:	82 05       	mov %d5,0
8000f2cc:	89 e4 60 f9 	st.d [%a14]-32,%e4
    result |= ((uint64)stm->CAP.U) << 32;
8000f2d0:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000f2d4:	d9 22 2c 00 	lea %a2,[%a2]44
8000f2d8:	54 24       	ld.w %d4,[%a2]
8000f2da:	02 44       	mov %d4,%d4
8000f2dc:	82 05       	mov %d5,0
8000f2de:	02 47       	mov %d7,%d4
8000f2e0:	82 06       	mov %d6,0
8000f2e2:	19 e4 e0 ff 	ld.w %d4,[%a14]-32
8000f2e6:	0f 64 a0 20 	or %d2,%d4,%d6
8000f2ea:	19 e4 e4 ff 	ld.w %d4,[%a14]-28
8000f2ee:	0f 74 a0 30 	or %d3,%d4,%d7
8000f2f2:	89 e2 60 f9 	st.d [%a14]-32,%e2
    return result;
8000f2f6:	09 e2 e0 f9 	ld.da %a2,[%a14]-32
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000f2fa:	80 22       	mov.d %d2,%a2
8000f2fc:	80 33       	mov.d %d3,%a3
8000f2fe:	02 24       	mov %d4,%d2
8000f300:	59 e4 d8 ff 	st.w [%a14]-40,%d4
8000f304:	82 f4       	mov %d4,-1
8000f306:	06 f4       	sh %d4,-1
8000f308:	0f 43 80 20 	and %d2,%d3,%d4
8000f30c:	59 e2 dc ff 	st.w [%a14]-36,%d2
    IfxCpu_restoreInterrupts(interruptState);
8000f310:	39 e2 ee ff 	ld.bu %d2,[%a14]-18
8000f314:	e9 e2 d7 ff 	st.b [%a14]-41,%d2
    if (enabled != FALSE)
8000f318:	39 e2 d7 ff 	ld.bu %d2,[%a14]-41
8000f31c:	df 02 04 00 	jeq %d2,0,8000f324 <IfxAsclin_Asc_isrTransmit+0xaa>
        __enable();
8000f320:	0d 00 00 03 	enable 
}
8000f324:	00 00       	nop 
    return stmNow;
8000f326:	09 e2 d8 f9 	ld.da %a2,[%a14]-40
    asclin->txTimestamp = IfxStm_now();
8000f32a:	99 e4 dc ef 	ld.a %a4,[%a14]-100
8000f32e:	89 42 d8 09 	st.da [%a4]24,%a2
    asclin->sendCount++;
8000f332:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f336:	d9 22 14 00 	lea %a2,[%a2]20
8000f33a:	54 22       	ld.w %d2,[%a2]
8000f33c:	c2 12       	add %d2,1
8000f33e:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f342:	d9 22 14 00 	lea %a2,[%a2]20
8000f346:	74 22       	st.w [%a2],%d2

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
8000f348:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f34c:	b0 42       	add.a %a2,4
8000f34e:	54 22       	ld.w %d2,[%a2]
8000f350:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000f354:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000f358:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    return fifo->shared.count;
8000f35c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000f360:	c9 22 04 00 	ld.h %d2,[%a2]4
    return (Ifx_Fifo_readCount(fifo) != FALSE) ? FALSE : TRUE;
8000f364:	8b 02 00 22 	eq %d2,%d2,0
8000f368:	8f f2 0f 21 	and %d2,%d2,255
8000f36c:	df 02 7d 80 	jne %d2,0,8000f466 <IfxAsclin_Asc_isrTransmit+0x1ec>
    {
        switch (asclin->dataBufferMode)
8000f370:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f374:	d9 22 10 00 	lea %a2,[%a2]16
8000f378:	54 22       	ld.w %d2,[%a2]
8000f37a:	df 02 06 00 	jeq %d2,0,8000f386 <IfxAsclin_Asc_isrTransmit+0x10c>
8000f37e:	df 12 57 00 	jeq %d2,1,8000f42c <IfxAsclin_Asc_isrTransmit+0x1b2>
    else
    {
        /* Transmit buffer is empty */
        asclin->txInProgress = FALSE;
    }
}
8000f382:	1d 00 79 00 	j 8000f474 <IfxAsclin_Asc_isrTransmit+0x1fa>
            uint16         count            = 0, i_count = 0;
8000f386:	82 02       	mov %d2,0
8000f388:	f9 e2 fc ff 	st.h [%a14]-4,%d2
8000f38c:	82 02       	mov %d2,0
8000f38e:	f9 e2 fe ff 	st.h [%a14]-2,%d2
            volatile uint8 hw_tx_fill_level = 0;
8000f392:	82 02       	mov %d2,0
8000f394:	e9 e2 f7 ef 	st.b [%a14]-73,%d2
            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/
8000f398:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f39c:	b0 42       	add.a %a2,4
8000f39e:	54 22       	ld.w %d2,[%a2]
8000f3a0:	59 e2 cc ff 	st.w [%a14]-52,%d2
    return fifo->shared.count;
8000f3a4:	99 e2 cc ff 	ld.a %a2,[%a14]-52
8000f3a8:	c9 22 04 00 	ld.h %d2,[%a2]4
8000f3ac:	f9 e2 fc ff 	st.h [%a14]-4,%d2
            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
8000f3b0:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f3b4:	54 22       	ld.w %d2,[%a2]
8000f3b6:	59 e2 d0 ff 	st.w [%a14]-48,%d2
    return asclin->TXFIFOCON.B.FILL;
8000f3ba:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8000f3be:	d9 22 0c 00 	lea %a2,[%a2]12
8000f3c2:	54 22       	ld.w %d2,[%a2]
8000f3c4:	37 02 65 28 	extr.u %d2,%d2,16,5
8000f3c8:	8f f2 0f 21 	and %d2,%d2,255
8000f3cc:	e9 e2 f7 ef 	st.b [%a14]-73,%d2
            i_count          = (16 - hw_tx_fill_level);
8000f3d0:	39 e2 f7 ef 	ld.bu %d2,[%a14]-73
8000f3d4:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f3d8:	8b 02 01 21 	rsub %d2,%d2,16
8000f3dc:	f9 e2 fe ff 	st.h [%a14]-2,%d2
            if (i_count > count)
8000f3e0:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f3e4:	b9 e3 fc ff 	ld.hu %d3,[%a14]-4
8000f3e8:	7f 23 06 80 	jge.u %d3,%d2,8000f3f4 <IfxAsclin_Asc_isrTransmit+0x17a>
                i_count = count;
8000f3ec:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
8000f3f0:	f9 e2 fe ff 	st.h [%a14]-2,%d2
            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
8000f3f4:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f3f8:	b0 42       	add.a %a2,4
8000f3fa:	54 22       	ld.w %d2,[%a2]
8000f3fc:	c9 e3 fe ff 	ld.h %d3,[%a14]-2
8000f400:	d9 e2 f8 ef 	lea %a2,[%a14]-72
8000f404:	d2 06       	mov %e6,0
8000f406:	02 34       	mov %d4,%d3
8000f408:	40 25       	mov.aa %a5,%a2
8000f40a:	60 24       	mov.a %a4,%d2
8000f40c:	6d ff 2c b3 	call 80005a64 <Ifx_Fifo_read>
            IfxAsclin_write8(asclin->asclin, &ascData[0], i_count);
8000f410:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f414:	54 23       	ld.w %d3,[%a2]
8000f416:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f41a:	d9 e2 f8 ef 	lea %a2,[%a14]-72
8000f41e:	02 24       	mov %d4,%d2
8000f420:	40 25       	mov.aa %a5,%a2
8000f422:	60 34       	mov.a %a4,%d3
8000f424:	6d ff 49 f7 	call 8000e2b6 <IfxAsclin_write8>
        break;
8000f428:	1d 00 26 00 	j 8000f474 <IfxAsclin_Asc_isrTransmit+0x1fa>
            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
8000f42c:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f430:	b0 42       	add.a %a2,4
8000f432:	54 22       	ld.w %d2,[%a2]
8000f434:	d9 e2 e8 ef 	lea %a2,[%a14]-88
8000f438:	d2 06       	mov %e6,0
8000f43a:	3b c0 00 40 	mov %d4,12
8000f43e:	40 25       	mov.aa %a5,%a2
8000f440:	60 24       	mov.a %a4,%d2
8000f442:	6d ff 11 b3 	call 80005a64 <Ifx_Fifo_read>
            ascData = packedData.data;
8000f446:	39 e2 f0 ef 	ld.bu %d2,[%a14]-80
8000f44a:	e9 e2 e7 ef 	st.b [%a14]-89,%d2
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
8000f44e:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f452:	54 22       	ld.w %d2,[%a2]
8000f454:	d9 e2 e7 ef 	lea %a2,[%a14]-89
8000f458:	82 14       	mov %d4,1
8000f45a:	40 25       	mov.aa %a5,%a2
8000f45c:	60 24       	mov.a %a4,%d2
8000f45e:	6d ff 2c f7 	call 8000e2b6 <IfxAsclin_write8>
        break;
8000f462:	1d 00 09 00 	j 8000f474 <IfxAsclin_Asc_isrTransmit+0x1fa>
        asclin->txInProgress = FALSE;
8000f466:	99 e2 dc ef 	ld.a %a2,[%a14]-100
8000f46a:	82 02       	mov %d2,0
8000f46c:	e9 22 0c 00 	st.b [%a2]12,%d2
}
8000f470:	1d 00 02 00 	j 8000f474 <IfxAsclin_Asc_isrTransmit+0x1fa>
8000f474:	00 00       	nop 
8000f476:	00 90       	ret 

8000f478 <IfxAsclin_Asc_write>:
    return TRUE;
}


boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
8000f478:	40 ae       	mov.aa %a14,%sp
8000f47a:	20 20       	sub.a %sp,32
8000f47c:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8000f480:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
8000f484:	b5 e6 ec ff 	st.a [%a14]-20,%a6
8000f488:	89 e4 64 f9 	st.d [%a14]-28,%e4
    Ifx_SizeT left;
    boolean   result       = TRUE;
8000f48c:	82 12       	mov %d2,1
8000f48e:	e9 e2 fd ff 	st.b [%a14]-3,%d2
    boolean   tx_status    = asclin->txInProgress;
8000f492:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000f496:	79 22 0c 00 	ld.b %d2,[%a2]12
8000f49a:	e9 e2 fc ff 	st.b [%a14]-4,%d2
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
8000f49e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000f4a2:	b0 42       	add.a %a2,4
8000f4a4:	d4 22       	ld.a %a2,[%a2]
8000f4a6:	c9 22 18 00 	ld.h %d2,[%a2]24
8000f4aa:	f9 e2 fa ff 	st.h [%a14]-6,%d2

    if (*count != 0)
8000f4ae:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000f4b2:	94 22       	ld.h %d2,[%a2]
8000f4b4:	df 02 73 00 	jeq %d2,0,8000f59a <IfxAsclin_Asc_write+0x122>
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
8000f4b8:	39 e2 fc ff 	ld.bu %d2,[%a14]-4
8000f4bc:	df 02 42 80 	jne %d2,0,8000f540 <IfxAsclin_Asc_write+0xc8>
8000f4c0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000f4c4:	94 22       	ld.h %d2,[%a2]
8000f4c6:	02 23       	mov %d3,%d2
8000f4c8:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8000f4cc:	7f 32 3a 00 	jge %d2,%d3,8000f540 <IfxAsclin_Asc_write+0xc8>
        {
            Ifx_Fifo_write(asclin->tx, data, tx_fifo_size, timeout); /*Fill upto the S/W FIFO size and initiate transmission*/
8000f4d0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000f4d4:	b0 42       	add.a %a2,4
8000f4d6:	54 22       	ld.w %d2,[%a2]
8000f4d8:	c9 e3 fa ff 	ld.h %d3,[%a14]-6
8000f4dc:	09 e6 64 f9 	ld.d %e6,[%a14]-28
8000f4e0:	02 34       	mov %d4,%d3
8000f4e2:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
8000f4e6:	60 24       	mov.a %a4,%d2
8000f4e8:	6d ff b9 b5 	call 8000605a <Ifx_Fifo_write>
            IfxAsclin_Asc_initiateTransmission(asclin);
8000f4ec:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8000f4f0:	6d ff 6b fe 	call 8000f1c6 <IfxAsclin_Asc_initiateTransmission>

            left = Ifx_Fifo_write(asclin->tx, (((const uint8 *)data) + tx_fifo_size), (*count) - tx_fifo_size, timeout);
8000f4f4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000f4f8:	b0 42       	add.a %a2,4
8000f4fa:	54 25       	ld.w %d5,[%a2]
8000f4fc:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8000f500:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8000f504:	0b 23 00 00 	add %d0,%d3,%d2
8000f508:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000f50c:	94 22       	ld.h %d2,[%a2]
8000f50e:	37 02 70 30 	extr.u %d3,%d2,0,16
8000f512:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
8000f516:	0b 23 80 20 	sub %d2,%d3,%d2
8000f51a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f51e:	37 02 50 20 	extr %d2,%d2,0,16
8000f522:	09 e6 64 f9 	ld.d %e6,[%a14]-28
8000f526:	02 24       	mov %d4,%d2
8000f528:	60 05       	mov.a %a5,%d0
8000f52a:	60 54       	mov.a %a4,%d5
8000f52c:	6d ff 97 b5 	call 8000605a <Ifx_Fifo_write>
8000f530:	f9 e2 fe ff 	st.h [%a14]-2,%d2
            IfxAsclin_Asc_initiateTransmission(asclin); /*Will initiate transmission only if txInProgress is False, otherwise interrupts will continue to push data to H/W FIFO*/
8000f534:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8000f538:	6d ff 47 fe 	call 8000f1c6 <IfxAsclin_Asc_initiateTransmission>
8000f53c:	1d 00 17 00 	j 8000f56a <IfxAsclin_Asc_write+0xf2>
        }

        else
        {
            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
8000f540:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000f544:	b0 42       	add.a %a2,4
8000f546:	54 22       	ld.w %d2,[%a2]
8000f548:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000f54c:	94 23       	ld.h %d3,[%a2]
8000f54e:	09 e6 64 f9 	ld.d %e6,[%a14]-28
8000f552:	02 34       	mov %d4,%d3
8000f554:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
8000f558:	60 24       	mov.a %a4,%d2
8000f55a:	6d ff 80 b5 	call 8000605a <Ifx_Fifo_write>
8000f55e:	f9 e2 fe ff 	st.h [%a14]-2,%d2
            IfxAsclin_Asc_initiateTransmission(asclin);
8000f562:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8000f566:	6d ff 30 fe 	call 8000f1c6 <IfxAsclin_Asc_initiateTransmission>
        }

        *count -= left;
8000f56a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000f56e:	94 22       	ld.h %d2,[%a2]
8000f570:	37 02 70 30 	extr.u %d3,%d2,0,16
8000f574:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f578:	0b 23 80 20 	sub %d2,%d3,%d2
8000f57c:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f580:	37 02 50 20 	extr %d2,%d2,0,16
8000f584:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000f588:	b4 22       	st.h [%a2],%d2
        result  = left == 0;
8000f58a:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8000f58e:	8b 02 00 22 	eq %d2,%d2,0
8000f592:	8f f2 0f 21 	and %d2,%d2,255
8000f596:	e9 e2 fd ff 	st.b [%a14]-3,%d2
    }

    return result;
8000f59a:	39 e2 fd ff 	ld.bu %d2,[%a14]-3
}
8000f59e:	00 90       	ret 

8000f5a0 <asclin0TxISR>:
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT(asclin0TxISR, 0, INTPRIO_ASCLIN0_TX);                     /* Adding the Interrupt Service Routine     */

void asclin0TxISR(void)
{
8000f5a0:	40 ae       	mov.aa %a14,%sp
    IfxAsclin_Asc_isrTransmit(&g_asc);
8000f5a2:	91 10 00 27 	movh.a %a2,28673
8000f5a6:	d9 24 c8 ba 	lea %a4,[%a2]-20792 <7000aec8 <g_asc>>
8000f5aa:	6d ff 68 fe 	call 8000f27a <IfxAsclin_Asc_isrTransmit>
}
8000f5ae:	00 00       	nop 
8000f5b0:	0d 00 40 02 	rslcx 
8000f5b4:	00 80       	rfe 

8000f5b6 <initUART>:

void initUART(void)
{
8000f5b6:	40 ae       	mov.aa %a14,%sp
8000f5b8:	20 b8       	sub.a %sp,184
    /* Initialize an instance of IfxAsclin_Asc_Config with default values */
    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, SERIAL_PIN_TX.module);
8000f5ba:	91 00 00 28 	movh.a %a2,32768
8000f5be:	d9 22 2c 14 	lea %a2,[%a2]16492 <8000406c <IfxAsclin0_TX_P14_0_OUT>>
8000f5c2:	54 22       	ld.w %d2,[%a2]
8000f5c4:	d9 e2 f0 df 	lea %a2,[%a14]-144 <8000406c <IfxAsclin0_TX_P14_0_OUT>>
8000f5c8:	60 25       	mov.a %a5,%d2
8000f5ca:	40 24       	mov.aa %a4,%a2
8000f5cc:	6d ff 39 fd 	call 8000f03e <IfxAsclin_Asc_initModuleConfig>

    /* Set the desired baud rate */
    ascConfig.baudrate.baudrate = SERIAL_BAUDRATE;
8000f5d0:	7b 10 7e 24 	movh %d2,18401
8000f5d4:	59 e2 f4 df 	st.w [%a14]-140,%d2

    /* ISR priorities and interrupt target */
    ascConfig.interrupt.txPriority = INTPRIO_ASCLIN0_TX;
8000f5d8:	3b 30 01 20 	mov %d2,19
8000f5dc:	f9 e2 c0 ff 	st.h [%a14]-64,%d2
    reg = __mfcr(CPU_CORE_ID);
8000f5e0:	4d c0 e1 2f 	mfcr %d2,$core_id
8000f5e4:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000f5e8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000f5ec:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000f5f0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000f5f4:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8000f5f8:	82 52       	mov %d2,5
8000f5fa:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000f5fe:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000f602:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8000f606:	0b 32 90 21 	min.u %d2,%d2,%d3
8000f60a:	59 e2 ec ff 	st.w [%a14]-20,%d2
    return res;
8000f60e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
    return (IfxCpu_ResourceCpu)__minu(reg, 5);
8000f612:	00 00       	nop 
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
8000f614:	02 24       	mov %d4,%d2
8000f616:	6d ff fd f2 	call 8000dc10 <IfxCpu_Irq_getTos>
8000f61a:	59 e2 c8 ff 	st.w [%a14]-56,%d2

    /* FIFO configuration */
    ascConfig.txBuffer = &g_ascTxBuffer;
8000f61e:	91 10 00 27 	movh.a %a2,28673
8000f622:	d9 22 e8 ba 	lea %a2,[%a2]-20760 <7000aee8 <g_ascTxBuffer>>
8000f626:	b5 e2 d8 ff 	st.a [%a14]-40 <7000aee8 <g_ascTxBuffer>>,%a2
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
8000f62a:	3b 00 04 20 	mov %d2,64
8000f62e:	f9 e2 d6 ff 	st.h [%a14]-42,%d2

    /* Port pins configuration */
    const IfxAsclin_Asc_Pins pins =
8000f632:	91 10 00 27 	movh.a %a2,28673
8000f636:	d9 23 08 9a 	lea %a3,[%a2]-23992 <7000a248 <IfxGeth_Eth_Phy_Rtl8211f_iPhyInitDone+0x20>>
8000f63a:	d9 e2 cc df 	lea %a2,[%a14]-180 <7000a248 <IfxGeth_Eth_Phy_Rtl8211f_iPhyInitDone+0x20>>
8000f63e:	09 34 48 01 	ld.d %e4,[%a3+]8 <7000a248 <IfxGeth_Eth_Phy_Rtl8211f_iPhyInitDone+0x20>>
8000f642:	89 24 48 01 	st.d [%a2+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000f646:	09 34 48 01 	ld.d %e4,[%a3+]8 <70010008 <ram_heap+0x4f74>>
8000f64a:	89 24 48 01 	st.d [%a2+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000f64e:	09 34 48 01 	ld.d %e4,[%a3+]8 <70010008 <ram_heap+0x4f74>>
8000f652:	89 24 48 01 	st.d [%a2+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000f656:	09 34 48 01 	ld.d %e4,[%a3+]8 <70010008 <ram_heap+0x4f74>>
8000f65a:	89 24 48 01 	st.d [%a2+]8 <70010008 <ram_heap+0x4f74>>,%e4
8000f65e:	44 34       	ld.w %d4,[%a3+]
8000f660:	64 24       	st.w [%a2+],%d4
        &SERIAL_PIN_RX,   IfxPort_InputMode_pullUp,                     /* RX pin not used                          */
        NULL_PTR,         IfxPort_OutputMode_pushPull,                  /* RTS pin not used                         */
        &SERIAL_PIN_TX,   IfxPort_OutputMode_pushPull,                  /* TX pin                                   */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
8000f662:	d9 e2 cc df 	lea %a2,[%a14]-180 <70010008 <ram_heap+0x4f74>>
8000f666:	b5 e2 cc ff 	st.a [%a14]-52 <70010008 <ram_heap+0x4f74>>,%a2

    IfxAsclin_Asc_initModule(&g_asc, &ascConfig);                       /* Initialize module with above parameters  */
8000f66a:	d9 e2 f0 df 	lea %a2,[%a14]-144 <70010008 <ram_heap+0x4f74>>
8000f66e:	40 25       	mov.aa %a5,%a2
8000f670:	91 10 00 27 	movh.a %a2,28673
8000f674:	d9 24 c8 ba 	lea %a4,[%a2]-20792 <7000aec8 <g_asc>>
8000f678:	6d ff 45 f6 	call 8000e302 <IfxAsclin_Asc_initModule>
}
8000f67c:	00 00       	nop 
8000f67e:	00 90       	ret 

8000f680 <sendUARTMessage>:

void sendUARTMessage(char * msg, Ifx_SizeT count)
{
8000f680:	40 ae       	mov.aa %a14,%sp
8000f682:	20 08       	sub.a %sp,8
8000f684:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8000f688:	02 42       	mov %d2,%d4
8000f68a:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
    IfxAsclin_Asc_write(&g_asc, msg, &count, TIME_INFINITE);            /* Transfer of data                         */
8000f68e:	d9 e2 f8 ff 	lea %a2,[%a14]-8
8000f692:	82 f4       	mov %d4,-1
8000f694:	82 f5       	mov %d5,-1
8000f696:	06 f5       	sh %d5,-1
8000f698:	40 26       	mov.aa %a6,%a2
8000f69a:	99 e5 fc ff 	ld.a %a5,[%a14]-4
8000f69e:	91 10 00 27 	movh.a %a2,28673
8000f6a2:	d9 24 c8 ba 	lea %a4,[%a2]-20792 <7000aec8 <g_asc>>
8000f6a6:	6d ff e9 fe 	call 8000f478 <IfxAsclin_Asc_write>
}
8000f6aa:	00 00       	nop 
8000f6ac:	00 90       	ret 

8000f6ae <Ifx_Ssw_clearCpuEndinit>:
    return Ifx_Ssw_getSafetyWatchdogPasswordInline();
}


void Ifx_Ssw_clearCpuEndinit(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
8000f6ae:	40 ae       	mov.aa %a14,%sp
8000f6b0:	20 10       	sub.a %sp,16
8000f6b2:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8000f6b6:	02 42       	mov %d2,%d4
8000f6b8:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
    Ifx_Ssw_clearCpuEndinitInline(watchdog, password);
8000f6bc:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
8000f6c0:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000f6c4:	59 e3 fc ff 	st.w [%a14]-4,%d3
8000f6c8:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    if (watchdog->CON0.B.LCK)
8000f6cc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f6d0:	54 22       	ld.w %d2,[%a2]
8000f6d2:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000f6d6:	8f f2 0f 21 	and %d2,%d2,255
8000f6da:	df 02 15 00 	jeq %d2,0,8000f704 <Ifx_Ssw_clearCpuEndinit+0x56>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f6de:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8000f6e2:	8f 22 00 30 	sh %d3,%d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000f6e6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f6ea:	54 22       	ld.w %d2,[%a2]
8000f6ec:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f6f0:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f6f4:	8f 02 01 20 	sh %d2,%d2,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f6f8:	a6 32       	or %d2,%d3
8000f6fa:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000f6fe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f702:	74 22       	st.w [%a2],%d2
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f704:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8000f708:	8f 22 00 30 	sh %d3,%d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000f70c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f710:	54 22       	ld.w %d2,[%a2]
8000f712:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f716:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f71a:	8f 02 01 20 	sh %d2,%d2,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f71e:	a6 32       	or %d2,%d3
8000f720:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = ((unsigned int)0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000f724:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f728:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
8000f72a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f72e:	54 22       	ld.w %d2,[%a2]
}
8000f730:	00 00       	nop 
8000f732:	00 90       	ret 

8000f734 <Ifx_Ssw_setCpuEndinit>:


void Ifx_Ssw_setCpuEndinit(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
8000f734:	40 ae       	mov.aa %a14,%sp
8000f736:	20 10       	sub.a %sp,16
8000f738:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8000f73c:	02 42       	mov %d2,%d4
8000f73e:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
    Ifx_Ssw_setCpuEndinitInline(watchdog, password);
8000f742:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
8000f746:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000f74a:	59 e3 fc ff 	st.w [%a14]-4,%d3
8000f74e:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    if (watchdog->CON0.B.LCK)
8000f752:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f756:	54 22       	ld.w %d2,[%a2]
8000f758:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000f75c:	8f f2 0f 21 	and %d2,%d2,255
8000f760:	df 02 15 00 	jeq %d2,0,8000f78a <Ifx_Ssw_setCpuEndinit+0x56>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f764:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8000f768:	8f 22 00 30 	sh %d3,%d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000f76c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f770:	54 22       	ld.w %d2,[%a2]
8000f772:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f776:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f77a:	8f 02 01 20 	sh %d2,%d2,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f77e:	a6 32       	or %d2,%d3
8000f780:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000f784:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f788:	74 22       	st.w [%a2],%d2
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f78a:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8000f78e:	8f 22 00 30 	sh %d3,%d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000f792:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f796:	54 22       	ld.w %d2,[%a2]
8000f798:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f79c:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f7a0:	8f 02 01 20 	sh %d2,%d2,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f7a4:	a6 32       	or %d2,%d3
8000f7a6:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000f7aa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f7ae:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
8000f7b0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f7b4:	54 22       	ld.w %d2,[%a2]
}
8000f7b6:	00 00       	nop 
8000f7b8:	00 90       	ret 

8000f7ba <Ifx_Ssw_clearSafetyEndinit>:


void Ifx_Ssw_clearSafetyEndinit(unsigned short password)
{
8000f7ba:	40 ae       	mov.aa %a14,%sp
8000f7bc:	20 10       	sub.a %sp,16
8000f7be:	02 42       	mov %d2,%d4
8000f7c0:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    Ifx_Ssw_clearSafetyEndinitInline(password);
8000f7c4:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8000f7c8:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    if (SCU_WDTS_CON0.B.LCK)
8000f7cc:	91 30 00 2f 	movh.a %a2,61443
8000f7d0:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f7d4:	54 22       	ld.w %d2,[%a2]
8000f7d6:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000f7da:	8f f2 0f 21 	and %d2,%d2,255
8000f7de:	df 02 19 00 	jeq %d2,0,8000f810 <Ifx_Ssw_clearSafetyEndinit+0x56>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f7e2:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f7e6:	8f 22 00 30 	sh %d3,%d2,2
                          ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000f7ea:	91 30 00 2f 	movh.a %a2,61443
8000f7ee:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f7f2:	54 22       	ld.w %d2,[%a2]
8000f7f4:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f7f8:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f7fc:	8f 02 01 20 	sh %d2,%d2,16
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f800:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f802:	91 30 00 2f 	movh.a %a2,61443
8000f806:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f80a:	8f 12 40 21 	or %d2,%d2,1
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f80e:	74 22       	st.w [%a2],%d2
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f810:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f814:	8f 22 00 30 	sh %d3,%d2,2
                      ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000f818:	91 30 00 2f 	movh.a %a2,61443
8000f81c:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f820:	54 22       	ld.w %d2,[%a2]
8000f822:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f826:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f82a:	8f 02 01 20 	sh %d2,%d2,16
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f82e:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = ((unsigned int)0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f830:	91 30 00 2f 	movh.a %a2,61443
8000f834:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f838:	8f 22 40 21 	or %d2,%d2,2
    SCU_WDTS_CON0.U = ((unsigned int)0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f83c:	74 22       	st.w [%a2],%d2
    SCU_WDTS_CON0.U;
8000f83e:	91 30 00 2f 	movh.a %a2,61443
8000f842:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f846:	54 22       	ld.w %d2,[%a2]
}
8000f848:	00 00       	nop 
8000f84a:	00 90       	ret 

8000f84c <Ifx_Ssw_setSafetyEndinit>:


void Ifx_Ssw_setSafetyEndinit(unsigned short password)
{
8000f84c:	40 ae       	mov.aa %a14,%sp
8000f84e:	20 10       	sub.a %sp,16
8000f850:	02 42       	mov %d2,%d4
8000f852:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    Ifx_Ssw_setSafetyEndinitInline(password);
8000f856:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8000f85a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    if (SCU_WDTS_CON0.B.LCK)
8000f85e:	91 30 00 2f 	movh.a %a2,61443
8000f862:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f866:	54 22       	ld.w %d2,[%a2]
8000f868:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000f86c:	8f f2 0f 21 	and %d2,%d2,255
8000f870:	df 02 19 00 	jeq %d2,0,8000f8a2 <Ifx_Ssw_setSafetyEndinit+0x56>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f874:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f878:	8f 22 00 30 	sh %d3,%d2,2
                          ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000f87c:	91 30 00 2f 	movh.a %a2,61443
8000f880:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f884:	54 22       	ld.w %d2,[%a2]
8000f886:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f88a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f88e:	8f 02 01 20 	sh %d2,%d2,16
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f892:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f894:	91 30 00 2f 	movh.a %a2,61443
8000f898:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f89c:	8f 12 40 21 	or %d2,%d2,1
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f8a0:	74 22       	st.w [%a2],%d2
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f8a2:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f8a6:	8f 22 00 30 	sh %d3,%d2,2
                      ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000f8aa:	91 30 00 2f 	movh.a %a2,61443
8000f8ae:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f8b2:	54 22       	ld.w %d2,[%a2]
8000f8b4:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f8b8:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f8bc:	8f 02 01 20 	sh %d2,%d2,16
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f8c0:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f8c2:	91 30 00 2f 	movh.a %a2,61443
8000f8c6:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f8ca:	8f 32 40 21 	or %d2,%d2,3
    SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f8ce:	74 22       	st.w [%a2],%d2
    SCU_WDTS_CON0.U;
8000f8d0:	91 30 00 2f 	movh.a %a2,61443
8000f8d4:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f8d8:	54 22       	ld.w %d2,[%a2]
}
8000f8da:	00 00       	nop 
8000f8dc:	00 90       	ret 

8000f8de <Ifx_Ssw_serviceCpuWatchdog>:


void Ifx_Ssw_serviceCpuWatchdog(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
8000f8de:	40 ae       	mov.aa %a14,%sp
8000f8e0:	20 10       	sub.a %sp,16
8000f8e2:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8000f8e6:	02 42       	mov %d2,%d4
8000f8e8:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
    Ifx_Ssw_setCpuEndinitInline(watchdog, password);
8000f8ec:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
8000f8f0:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8000f8f4:	59 e3 fc ff 	st.w [%a14]-4,%d3
8000f8f8:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    if (watchdog->CON0.B.LCK)
8000f8fc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f900:	54 22       	ld.w %d2,[%a2]
8000f902:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000f906:	8f f2 0f 21 	and %d2,%d2,255
8000f90a:	df 02 15 00 	jeq %d2,0,8000f934 <Ifx_Ssw_serviceCpuWatchdog+0x56>
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f90e:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8000f912:	8f 22 00 30 	sh %d3,%d2,2
                           ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000f916:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f91a:	54 22       	ld.w %d2,[%a2]
8000f91c:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f920:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f924:	8f 02 01 20 	sh %d2,%d2,16
                           ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f928:	a6 32       	or %d2,%d3
8000f92a:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000f92e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f932:	74 22       	st.w [%a2],%d2
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f934:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8000f938:	8f 22 00 30 	sh %d3,%d2,2
                       ((unsigned int)watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000f93c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f940:	54 22       	ld.w %d2,[%a2]
8000f942:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f946:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f94a:	8f 02 01 20 	sh %d2,%d2,16
                       ((unsigned int)password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000f94e:	a6 32       	or %d2,%d3
8000f950:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = ((unsigned int)1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000f954:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f958:	74 22       	st.w [%a2],%d2
    watchdog->CON0.U;
8000f95a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000f95e:	54 22       	ld.w %d2,[%a2]
}
8000f960:	00 00       	nop 
8000f962:	00 90       	ret 

8000f964 <Ifx_Ssw_serviceSafetyWatchdog>:


void Ifx_Ssw_serviceSafetyWatchdog(unsigned short password)
{
8000f964:	40 ae       	mov.aa %a14,%sp
8000f966:	20 10       	sub.a %sp,16
8000f968:	02 42       	mov %d2,%d4
8000f96a:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    Ifx_Ssw_setSafetyEndinitInline(password);
8000f96e:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8000f972:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    if (SCU_WDTS_CON0.B.LCK)
8000f976:	91 30 00 2f 	movh.a %a2,61443
8000f97a:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f97e:	54 22       	ld.w %d2,[%a2]
8000f980:	37 02 e1 20 	extr.u %d2,%d2,1,1
8000f984:	8f f2 0f 21 	and %d2,%d2,255
8000f988:	df 02 19 00 	jeq %d2,0,8000f9ba <Ifx_Ssw_serviceSafetyWatchdog+0x56>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f98c:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f990:	8f 22 00 30 	sh %d3,%d2,2
                          ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000f994:	91 30 00 2f 	movh.a %a2,61443
8000f998:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f99c:	54 22       	ld.w %d2,[%a2]
8000f99e:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f9a2:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f9a6:	8f 02 01 20 	sh %d2,%d2,16
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f9aa:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f9ac:	91 30 00 2f 	movh.a %a2,61443
8000f9b0:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
                          ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f9b4:	8f 12 40 21 	or %d2,%d2,1
        SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f9b8:	74 22       	st.w [%a2],%d2
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f9ba:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8000f9be:	8f 22 00 30 	sh %d3,%d2,2
                      ((unsigned int)SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000f9c2:	91 30 00 2f 	movh.a %a2,61443
8000f9c6:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f9ca:	54 22       	ld.w %d2,[%a2]
8000f9cc:	37 02 70 28 	extr.u %d2,%d2,16,16
8000f9d0:	37 02 70 20 	extr.u %d2,%d2,0,16
8000f9d4:	8f 02 01 20 	sh %d2,%d2,16
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f9d8:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f9da:	91 30 00 2f 	movh.a %a2,61443
8000f9de:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
                      ((unsigned int)password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000f9e2:	8f 32 40 21 	or %d2,%d2,3
    SCU_WDTS_CON0.U = ((unsigned int)1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000f9e6:	74 22       	st.w [%a2],%d2
    SCU_WDTS_CON0.U;
8000f9e8:	91 30 00 2f 	movh.a %a2,61443
8000f9ec:	d9 22 28 a6 	lea %a2,[%a2]25256 <f00362a8 <bmhd_3_copy+0x40c34ca8>>
8000f9f0:	54 22       	ld.w %d2,[%a2]
}
8000f9f2:	00 00       	nop 
8000f9f4:	00 90       	ret 

8000f9f6 <Ifx_Ssw_disableCpuWatchdog>:


void Ifx_Ssw_disableCpuWatchdog(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
8000f9f6:	40 ae       	mov.aa %a14,%sp
8000f9f8:	20 20       	sub.a %sp,32
8000f9fa:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
8000f9fe:	02 42       	mov %d2,%d4
8000fa00:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
    /* Select CPU Watchdog based on Core Id */
    unsigned int    cpuIndex;
    cpuIndex = Ifx_Ssw_MFCR(CPU_CORE_ID);
8000fa04:	4d c0 e1 2f 	mfcr %d2,$core_id
8000fa08:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000fa0c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000fa10:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    cpuIndex = (unsigned int)((unsigned int)cpuIndex >> IFX_CPU_CORE_ID_CORE_ID_OFF) & IFX_CPU_CORE_ID_CORE_ID_MSK;
8000fa14:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fa18:	8f 72 00 21 	and %d2,%d2,7
8000fa1c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000fa20:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fa24:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000fa28:	82 52       	mov %d2,5
8000fa2a:	59 e2 ec ff 	st.w [%a14]-20,%d2
    __asm__ volatile ("min.u %0, %1, %2" : "=d" (res) : "d" (a), "d" (b));
8000fa2e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000fa32:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000fa36:	0b 32 90 21 	min.u %d2,%d2,%d3
8000fa3a:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    return res;
8000fa3e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
    cpuIndex = Ifx_Ssw_MINU(cpuIndex, 5);
8000fa42:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    Ifx_SCU_WDTCPU *wdt = &MODULE_SCU.WDTCPU[cpuIndex];
8000fa46:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fa4a:	53 c2 20 20 	mul %d2,%d2,12
8000fa4e:	1b c2 24 26 	addi %d2,%d2,25164
8000fa52:	9b 32 00 2f 	addih %d2,%d2,61443
8000fa56:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    Ifx_Ssw_clearCpuEndinit(wdt, password);
8000fa5a:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
8000fa5e:	02 24       	mov %d4,%d2
8000fa60:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8000fa64:	6d ff 25 fe 	call 8000f6ae <Ifx_Ssw_clearCpuEndinit>
    wdt->CON1.B.DR = 1U;         /* Set DR bit in Config_1 register */
8000fa68:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000fa6c:	d9 23 04 00 	lea %a3,[%a2]4
8000fa70:	54 32       	ld.w %d2,[%a3]
8000fa72:	b7 12 81 21 	insert %d2,%d2,1,3,1
8000fa76:	b0 42       	add.a %a2,4
8000fa78:	74 22       	st.w [%a2],%d2
    Ifx_Ssw_setCpuEndinit(wdt, password);
8000fa7a:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
8000fa7e:	02 24       	mov %d4,%d2
8000fa80:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8000fa84:	6d ff 58 fe 	call 8000f734 <Ifx_Ssw_setCpuEndinit>
}
8000fa88:	00 00       	nop 
8000fa8a:	00 90       	ret 

8000fa8c <Ifx_Ssw_enableCpuWatchdog>:


void Ifx_Ssw_enableCpuWatchdog(Ifx_SCU_WDTCPU *watchdog, unsigned short password)
{
8000fa8c:	40 ae       	mov.aa %a14,%sp
8000fa8e:	20 20       	sub.a %sp,32
8000fa90:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
8000fa94:	02 42       	mov %d2,%d4
8000fa96:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
    /* Select CPU Watchdog based on Core Id */
    unsigned int    cpuIndex;
    cpuIndex = Ifx_Ssw_MFCR(CPU_CORE_ID);
8000fa9a:	4d c0 e1 2f 	mfcr %d2,$core_id
8000fa9e:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000faa2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000faa6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    cpuIndex = (unsigned int)((unsigned int)cpuIndex >> IFX_CPU_CORE_ID_CORE_ID_OFF) & IFX_CPU_CORE_ID_CORE_ID_MSK;
8000faaa:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000faae:	8f 72 00 21 	and %d2,%d2,7
8000fab2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000fab6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000faba:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000fabe:	82 52       	mov %d2,5
8000fac0:	59 e2 ec ff 	st.w [%a14]-20,%d2
    __asm__ volatile ("min.u %0, %1, %2" : "=d" (res) : "d" (a), "d" (b));
8000fac4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000fac8:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8000facc:	0b 32 90 21 	min.u %d2,%d2,%d3
8000fad0:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    return res;
8000fad4:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
    cpuIndex = Ifx_Ssw_MINU(cpuIndex, 5);
8000fad8:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    Ifx_SCU_WDTCPU *wdt = &MODULE_SCU.WDTCPU[cpuIndex];
8000fadc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fae0:	53 c2 20 20 	mul %d2,%d2,12
8000fae4:	1b c2 24 26 	addi %d2,%d2,25164
8000fae8:	9b 32 00 2f 	addih %d2,%d2,61443
8000faec:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    Ifx_Ssw_clearCpuEndinit(wdt, password);
8000faf0:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
8000faf4:	02 24       	mov %d4,%d2
8000faf6:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8000fafa:	6d ff da fd 	call 8000f6ae <Ifx_Ssw_clearCpuEndinit>
    wdt->CON1.B.DR = 0U;         /* Clear DR bit in Config_1 register */
8000fafe:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8000fb02:	d9 23 04 00 	lea %a3,[%a2]4
8000fb06:	54 32       	ld.w %d2,[%a3]
8000fb08:	8f 82 c0 21 	andn %d2,%d2,8
8000fb0c:	b0 42       	add.a %a2,4
8000fb0e:	74 22       	st.w [%a2],%d2
    Ifx_Ssw_setCpuEndinit(wdt, password);
8000fb10:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
8000fb14:	02 24       	mov %d4,%d2
8000fb16:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8000fb1a:	6d ff 0d fe 	call 8000f734 <Ifx_Ssw_setCpuEndinit>
}
8000fb1e:	00 00       	nop 
8000fb20:	00 90       	ret 

8000fb22 <Ifx_Ssw_disableSafetyWatchdog>:


void Ifx_Ssw_disableSafetyWatchdog(unsigned short password)
{
8000fb22:	40 ae       	mov.aa %a14,%sp
8000fb24:	20 08       	sub.a %sp,8
8000fb26:	02 42       	mov %d2,%d4
8000fb28:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    Ifx_Ssw_clearSafetyEndinit(password);
8000fb2c:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8000fb30:	02 24       	mov %d4,%d2
8000fb32:	6d ff 44 fe 	call 8000f7ba <Ifx_Ssw_clearSafetyEndinit>
    SCU_WDTS_CON1.B.DR = 1U;     /* Set DR bit in Config_1 register */
8000fb36:	91 30 00 2f 	movh.a %a2,61443
8000fb3a:	d9 22 2c a6 	lea %a2,[%a2]25260 <f00362ac <bmhd_3_copy+0x40c34cac>>
8000fb3e:	54 22       	ld.w %d2,[%a2]
8000fb40:	b7 12 81 21 	insert %d2,%d2,1,3,1
8000fb44:	74 22       	st.w [%a2],%d2
    Ifx_Ssw_setSafetyEndinit(password);
8000fb46:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8000fb4a:	02 24       	mov %d4,%d2
8000fb4c:	6d ff 80 fe 	call 8000f84c <Ifx_Ssw_setSafetyEndinit>
}
8000fb50:	00 00       	nop 
8000fb52:	00 90       	ret 

8000fb54 <Ifx_Ssw_enableSafetyWatchdog>:


void Ifx_Ssw_enableSafetyWatchdog(unsigned short password)
{
8000fb54:	40 ae       	mov.aa %a14,%sp
8000fb56:	20 08       	sub.a %sp,8
8000fb58:	02 42       	mov %d2,%d4
8000fb5a:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    Ifx_Ssw_clearSafetyEndinit(password);
8000fb5e:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8000fb62:	02 24       	mov %d4,%d2
8000fb64:	6d ff 2b fe 	call 8000f7ba <Ifx_Ssw_clearSafetyEndinit>
    SCU_WDTS_CON1.B.DR = 0U;     /* Clear DR bit in Config_1 register */
8000fb68:	91 30 00 2f 	movh.a %a2,61443
8000fb6c:	d9 22 2c a6 	lea %a2,[%a2]25260 <f00362ac <bmhd_3_copy+0x40c34cac>>
8000fb70:	54 22       	ld.w %d2,[%a2]
8000fb72:	8f 82 c0 21 	andn %d2,%d2,8
8000fb76:	74 22       	st.w [%a2],%d2
    Ifx_Ssw_setSafetyEndinit(password);
8000fb78:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8000fb7c:	02 24       	mov %d4,%d2
8000fb7e:	6d ff 67 fe 	call 8000f84c <Ifx_Ssw_setSafetyEndinit>
}
8000fb82:	00 00       	nop 
8000fb84:	00 90       	ret 

8000fb86 <Ifx_Ssw_startCore>:


void Ifx_Ssw_startCore(Ifx_CPU *cpu, unsigned int programCounter)
{
8000fb86:	40 ae       	mov.aa %a14,%sp
8000fb88:	20 10       	sub.a %sp,16
8000fb8a:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8000fb8e:	59 e4 f0 ff 	st.w [%a14]-16,%d4
    /* Set the PC */
    cpu->PC.B.PC = (unsigned int)programCounter >> 1U;
8000fb92:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8000fb96:	06 f2       	sh %d2,-1
8000fb98:	82 f3       	mov %d3,-1
8000fb9a:	06 f3       	sh %d3,-1
8000fb9c:	26 23       	and %d3,%d2
8000fb9e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000fba2:	60 22       	mov.a %a2,%d2
8000fba4:	d9 22 c8 8f 	lea %a2,[%a2]-504
8000fba8:	11 22 00 20 	addih.a %a2,%a2,2
8000fbac:	54 22       	ld.w %d2,[%a2]
8000fbae:	37 32 9f 20 	insert %d2,%d2,%d3,1,31
8000fbb2:	74 22       	st.w [%a2],%d2

    /* release boot halt mode if required */
    Ifx_CPU_SYSCON syscon;
    syscon = cpu->SYSCON;
8000fbb4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000fbb8:	60 22       	mov.a %a2,%d2
8000fbba:	d9 22 d4 8f 	lea %a2,[%a2]-492
8000fbbe:	11 22 00 20 	addih.a %a2,%a2,2
8000fbc2:	54 22       	ld.w %d2,[%a2]
8000fbc4:	59 e2 fc ff 	st.w [%a14]-4,%d2

    if (syscon.B.BHALT)
8000fbc8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000fbcc:	37 02 61 2c 	extr.u %d2,%d2,24,1
8000fbd0:	8f f2 0f 21 	and %d2,%d2,255
8000fbd4:	df 02 14 00 	jeq %d2,0,8000fbfc <Ifx_Ssw_startCore+0x76>
    {
        syscon.B.BHALT = 0U;
8000fbd8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000fbdc:	7b 00 f0 3f 	movh %d3,65280
8000fbe0:	c2 f3       	add %d3,-1
8000fbe2:	26 32       	and %d2,%d3
8000fbe4:	59 e2 fc ff 	st.w [%a14]-4,%d2
        cpu->SYSCON    = syscon;
8000fbe8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000fbec:	60 22       	mov.a %a2,%d2
8000fbee:	d9 22 d4 8f 	lea %a2,[%a2]-492
8000fbf2:	11 22 00 20 	addih.a %a2,%a2,2
8000fbf6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000fbfa:	74 22       	st.w [%a2],%d2
    }

}
8000fbfc:	00 00       	nop 
8000fbfe:	00 90       	ret 

8000fc00 <Ifx_Ssw_getStmFrequency>:
    Ifx_Ssw_setCpuEndinit(wdt, cpuWdtPw);
}


float Ifx_Ssw_getStmFrequency(void)
{
8000fc00:	40 ae       	mov.aa %a14,%sp
8000fc02:	20 10       	sub.a %sp,16
    float        oscFreq    = IFX_CFG_SSW_XTAL_FREQUENCY;
8000fc04:	7b 90 b9 24 	movh %d2,19353
8000fc08:	1b 02 68 29 	addi %d2,%d2,-27008
8000fc0c:	59 e2 fc ff 	st.w [%a14]-4,%d2
    float        sourcefreq = IFX_CFG_SSW_EVR_OSC_FREQUENCY;
8000fc10:	7b f0 cb 24 	movh %d2,19647
8000fc14:	1b 02 c2 2b 	addi %d2,%d2,-17376
8000fc18:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    unsigned int insel      = SCU_SYSPLLCON0.B.INSEL;
8000fc1c:	91 30 00 2f 	movh.a %a2,61443
8000fc20:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
8000fc24:	54 22       	ld.w %d2,[%a2]
8000fc26:	37 02 62 2f 	extr.u %d2,%d2,30,2
8000fc2a:	8f f2 0f 21 	and %d2,%d2,255
8000fc2e:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    if (insel == 2U)
8000fc32:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000fc36:	df 22 0a 80 	jne %d2,2,8000fc4a <Ifx_Ssw_getStmFrequency+0x4a>
    {
        oscFreq = IFX_CFG_SSW_SYSCLK_PIN_FREQUENCY;
8000fc3a:	7b 90 b9 24 	movh %d2,19353
8000fc3e:	1b 02 68 29 	addi %d2,%d2,-27008
8000fc42:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000fc46:	1d 00 14 00 	j 8000fc6e <Ifx_Ssw_getStmFrequency+0x6e>
    }
    else if (insel == 1U)
8000fc4a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000fc4e:	df 12 0a 80 	jne %d2,1,8000fc62 <Ifx_Ssw_getStmFrequency+0x62>
    {
        oscFreq = IFX_CFG_SSW_XTAL_FREQUENCY;
8000fc52:	7b 90 b9 24 	movh %d2,19353
8000fc56:	1b 02 68 29 	addi %d2,%d2,-27008
8000fc5a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000fc5e:	1d 00 08 00 	j 8000fc6e <Ifx_Ssw_getStmFrequency+0x6e>
    }
    else
    {
        oscFreq = IFX_CFG_SSW_EVR_OSC_FREQUENCY;
8000fc62:	7b f0 cb 24 	movh %d2,19647
8000fc66:	1b 02 c2 2b 	addi %d2,%d2,-17376
8000fc6a:	59 e2 fc ff 	st.w [%a14]-4,%d2
    }

    if (SCU_CCUCON0.B.CLKSEL != 0U)
8000fc6e:	91 30 00 2f 	movh.a %a2,61443
8000fc72:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000fc76:	54 22       	ld.w %d2,[%a2]
8000fc78:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000fc7c:	8f f2 0f 21 	and %d2,%d2,255
8000fc80:	df 02 2e 00 	jeq %d2,0,8000fcdc <Ifx_Ssw_getStmFrequency+0xdc>
    {
        sourcefreq = (oscFreq * (SCU_SYSPLLCON0.B.NDIV + 1U)) /
8000fc84:	91 30 00 2f 	movh.a %a2,61443
8000fc88:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
8000fc8c:	54 22       	ld.w %d2,[%a2]
8000fc8e:	37 02 e7 24 	extr.u %d2,%d2,9,7
8000fc92:	8f f2 0f 21 	and %d2,%d2,255
8000fc96:	c2 12       	add %d2,1
8000fc98:	4b 02 61 31 	utof %d3,%d2
8000fc9c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000fca0:	4b 23 41 30 	mul.f %d3,%d3,%d2
                     ((SCU_SYSPLLCON0.B.PDIV + 1U) * (SCU_SYSPLLCON1.B.K2DIV + 1U));
8000fca4:	91 30 00 2f 	movh.a %a2,61443
8000fca8:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <bmhd_3_copy+0x40c34a18>>
8000fcac:	54 22       	ld.w %d2,[%a2]
8000fcae:	37 02 63 2c 	extr.u %d2,%d2,24,3
8000fcb2:	8f f2 0f 21 	and %d2,%d2,255
8000fcb6:	1b 12 00 40 	addi %d4,%d2,1
8000fcba:	91 30 00 2f 	movh.a %a2,61443
8000fcbe:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <bmhd_3_copy+0x40c34a1c>>
8000fcc2:	54 22       	ld.w %d2,[%a2]
8000fcc4:	37 02 63 20 	extr.u %d2,%d2,0,3
8000fcc8:	8f f2 0f 21 	and %d2,%d2,255
8000fccc:	c2 12       	add %d2,1
8000fcce:	e2 42       	mul %d2,%d4
        sourcefreq = (oscFreq * (SCU_SYSPLLCON0.B.NDIV + 1U)) /
8000fcd0:	4b 02 61 21 	utof %d2,%d2
8000fcd4:	4b 23 51 20 	div.f %d2,%d3,%d2
8000fcd8:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    }

    return sourcefreq / SCU_CCUCON0.B.STMDIV;
8000fcdc:	91 30 00 2f 	movh.a %a2,61443
8000fce0:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <bmhd_3_copy+0x40c34a30>>
8000fce4:	54 22       	ld.w %d2,[%a2]
8000fce6:	37 02 64 20 	extr.u %d2,%d2,0,4
8000fcea:	8f f2 0f 21 	and %d2,%d2,255
8000fcee:	4b 02 41 21 	itof %d2,%d2
8000fcf2:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8000fcf6:	4b 23 51 20 	div.f %d2,%d3,%d2
}
8000fcfa:	00 90       	ret 

8000fcfc <Ifx_Ssw_doCppInit>:

void Ifx_Ssw_doCppInit(void)
{
8000fcfc:	40 ae       	mov.aa %a14,%sp
8000fcfe:	20 18       	sub.a %sp,24
{
    Ifx_Ssw_CTablePtr pBlockDest, pBlockSrc;
    unsigned int      uiLength, uiCnt;
    unsigned int     *pTable;
    /* clear table */
    pTable = (unsigned int *)&__clear_table;
8000fd00:	91 00 00 28 	movh.a %a2,32768
8000fd04:	d9 22 44 a4 	lea %a2,[%a2]18052 <80004684 <__clear_table>>
8000fd08:	b5 e2 fc ff 	st.a [%a14]-4 <80004684 <__clear_table>>,%a2

    while (pTable)
8000fd0c:	1d 00 58 00 	j 8000fdbc <Ifx_Ssw_doCppInit+0xc0>
    {
        pBlockDest.uiPtr = (unsigned int *)*pTable++;
8000fd10:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000fd14:	80 22       	mov.d %d2,%a2
8000fd16:	c2 42       	add %d2,4
8000fd18:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000fd1c:	54 22       	ld.w %d2,[%a2]
8000fd1e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        uiLength         = *pTable++;
8000fd22:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000fd26:	80 22       	mov.d %d2,%a2
8000fd28:	c2 42       	add %d2,4
8000fd2a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000fd2e:	54 22       	ld.w %d2,[%a2]
8000fd30:	59 e2 f8 ff 	st.w [%a14]-8,%d2

        /* we are finished when length == -1 */
        if (uiLength == 0xFFFFFFFF)
8000fd34:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fd38:	df f2 48 00 	jeq %d2,-1,8000fdc8 <Ifx_Ssw_doCppInit+0xcc>
        {
            break;
        }

        uiCnt = uiLength / 8;
8000fd3c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fd40:	06 d2       	sh %d2,-3
8000fd42:	59 e2 f4 ff 	st.w [%a14]-12,%d2

        while (uiCnt--)
8000fd46:	1d 00 0d 00 	j 8000fd60 <Ifx_Ssw_doCppInit+0x64>
        {
            *pBlockDest.ullPtr++ = 0;
8000fd4a:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
8000fd4e:	80 42       	mov.d %d2,%a4
8000fd50:	1b 82 00 20 	addi %d2,%d2,8
8000fd54:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000fd58:	a0 02       	mov.a %a2,0
8000fd5a:	a0 03       	mov.a %a3,0
8000fd5c:	89 42 c0 09 	st.da [%a4],%a2
        while (uiCnt--)
8000fd60:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000fd64:	1b f2 ff 3f 	addi %d3,%d2,-1
8000fd68:	59 e3 f4 ff 	st.w [%a14]-12,%d3
8000fd6c:	df 02 ef ff 	jne %d2,0,8000fd4a <Ifx_Ssw_doCppInit+0x4e>
        }

        if (uiLength & 0x4)
8000fd70:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fd74:	8f 42 00 21 	and %d2,%d2,4
8000fd78:	df 02 0a 00 	jeq %d2,0,8000fd8c <Ifx_Ssw_doCppInit+0x90>
        {
            *pBlockDest.uiPtr++ = 0;
8000fd7c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000fd80:	80 22       	mov.d %d2,%a2
8000fd82:	c2 42       	add %d2,4
8000fd84:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000fd88:	82 02       	mov %d2,0
8000fd8a:	74 22       	st.w [%a2],%d2
        }

        if (uiLength & 0x2)
8000fd8c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fd90:	8f 22 00 21 	and %d2,%d2,2
8000fd94:	df 02 0a 00 	jeq %d2,0,8000fda8 <Ifx_Ssw_doCppInit+0xac>
        {
            *pBlockDest.usPtr++ = 0;
8000fd98:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000fd9c:	80 22       	mov.d %d2,%a2
8000fd9e:	c2 22       	add %d2,2
8000fda0:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000fda4:	82 02       	mov %d2,0
8000fda6:	b4 22       	st.h [%a2],%d2
        }

        if (uiLength & 0x1)
8000fda8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fdac:	8f 12 00 21 	and %d2,%d2,1
8000fdb0:	df 02 06 00 	jeq %d2,0,8000fdbc <Ifx_Ssw_doCppInit+0xc0>
        {
            *pBlockDest.ucPtr = 0;
8000fdb4:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000fdb8:	82 02       	mov %d2,0
8000fdba:	34 22       	st.b [%a2],%d2
    while (pTable)
8000fdbc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000fdc0:	df 02 a8 ff 	jne %d2,0,8000fd10 <Ifx_Ssw_doCppInit+0x14>
8000fdc4:	1d 00 03 00 	j 8000fdca <Ifx_Ssw_doCppInit+0xce>
            break;
8000fdc8:	00 00       	nop 
        }
    }

    /* copy table */
    pTable = (unsigned int *)&__copy_table;
8000fdca:	91 00 00 28 	movh.a %a2,32768
8000fdce:	d9 22 54 d4 	lea %a2,[%a2]18260 <80004754 <__copy_table>>
8000fdd2:	b5 e2 fc ff 	st.a [%a14]-4 <80004754 <__copy_table>>,%a2

    while (pTable)
8000fdd6:	1d 00 77 00 	j 8000fec4 <Ifx_Ssw_doCppInit+0x1c8>
    {
        pBlockSrc.uiPtr  = (unsigned int *)*pTable++;
8000fdda:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000fdde:	80 22       	mov.d %d2,%a2
8000fde0:	c2 42       	add %d2,4
8000fde2:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000fde6:	54 22       	ld.w %d2,[%a2]
8000fde8:	59 e2 ec ff 	st.w [%a14]-20,%d2
        pBlockDest.uiPtr = (unsigned int *)*pTable++;
8000fdec:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000fdf0:	80 22       	mov.d %d2,%a2
8000fdf2:	c2 42       	add %d2,4
8000fdf4:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000fdf8:	54 22       	ld.w %d2,[%a2]
8000fdfa:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        uiLength         = *pTable++;
8000fdfe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000fe02:	80 22       	mov.d %d2,%a2
8000fe04:	c2 42       	add %d2,4
8000fe06:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000fe0a:	54 22       	ld.w %d2,[%a2]
8000fe0c:	59 e2 f8 ff 	st.w [%a14]-8,%d2

        /* we are finished when length == -1 */
        if (uiLength == 0xFFFFFFFF)
8000fe10:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fe14:	df f2 5e 00 	jeq %d2,-1,8000fed0 <Ifx_Ssw_doCppInit+0x1d4>
        {
            break;
        }

        uiCnt = uiLength / 8;
8000fe18:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fe1c:	06 d2       	sh %d2,-3
8000fe1e:	59 e2 f4 ff 	st.w [%a14]-12,%d2

        while (uiCnt--)
8000fe22:	1d 00 14 00 	j 8000fe4a <Ifx_Ssw_doCppInit+0x14e>
        {
            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;
8000fe26:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000fe2a:	80 22       	mov.d %d2,%a2
8000fe2c:	1b 82 00 20 	addi %d2,%d2,8
8000fe30:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000fe34:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
8000fe38:	80 42       	mov.d %d2,%a4
8000fe3a:	1b 82 00 20 	addi %d2,%d2,8
8000fe3e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000fe42:	09 22 c0 09 	ld.da %a2,[%a2]
8000fe46:	89 42 c0 09 	st.da [%a4],%a2
        while (uiCnt--)
8000fe4a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8000fe4e:	1b f2 ff 3f 	addi %d3,%d2,-1
8000fe52:	59 e3 f4 ff 	st.w [%a14]-12,%d3
8000fe56:	df 02 e8 ff 	jne %d2,0,8000fe26 <Ifx_Ssw_doCppInit+0x12a>
        }

        if (uiLength & 0x4)
8000fe5a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fe5e:	8f 42 00 21 	and %d2,%d2,4
8000fe62:	df 02 10 00 	jeq %d2,0,8000fe82 <Ifx_Ssw_doCppInit+0x186>
        {
            *pBlockDest.uiPtr++ = *pBlockSrc.uiPtr++;
8000fe66:	99 e3 ec ff 	ld.a %a3,[%a14]-20
8000fe6a:	80 32       	mov.d %d2,%a3
8000fe6c:	c2 42       	add %d2,4
8000fe6e:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000fe72:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000fe76:	80 22       	mov.d %d2,%a2
8000fe78:	c2 42       	add %d2,4
8000fe7a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000fe7e:	54 32       	ld.w %d2,[%a3]
8000fe80:	74 22       	st.w [%a2],%d2
        }

        if (uiLength & 0x2)
8000fe82:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000fe86:	8f 22 00 21 	and %d2,%d2,2
8000fe8a:	df 02 11 00 	jeq %d2,0,8000feac <Ifx_Ssw_doCppInit+0x1b0>
        {
            *pBlockDest.usPtr++ = *pBlockSrc.usPtr++;
8000fe8e:	99 e3 ec ff 	ld.a %a3,[%a14]-20
8000fe92:	80 32       	mov.d %d2,%a3
8000fe94:	c2 22       	add %d2,2
8000fe96:	59 e2 ec ff 	st.w [%a14]-20,%d2
8000fe9a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000fe9e:	80 22       	mov.d %d2,%a2
8000fea0:	c2 22       	add %d2,2
8000fea2:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8000fea6:	b9 32 00 00 	ld.hu %d2,[%a3]0
8000feaa:	b4 22       	st.h [%a2],%d2
        }

        if (uiLength & 0x1)
8000feac:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000feb0:	8f 12 00 21 	and %d2,%d2,1
8000feb4:	df 02 08 00 	jeq %d2,0,8000fec4 <Ifx_Ssw_doCppInit+0x1c8>
        {
            *pBlockDest.ucPtr = *pBlockSrc.ucPtr;
8000feb8:	99 e3 ec ff 	ld.a %a3,[%a14]-20
8000febc:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8000fec0:	14 32       	ld.bu %d2,[%a3]
8000fec2:	34 22       	st.b [%a2],%d2
    while (pTable)
8000fec4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8000fec8:	df 02 89 ff 	jne %d2,0,8000fdda <Ifx_Ssw_doCppInit+0xde>
        }
    }
}
8000fecc:	1d 00 03 00 	j 8000fed2 <Ifx_Ssw_doCppInit+0x1d6>
            break;
8000fed0:	00 00       	nop 
}
8000fed2:	00 00       	nop 
	#elif defined(__HIGHTEC__) && !defined(__clang__)
		extern void _init(void); /* cpp initialization */
		_init();
	#elif defined(__GNUC__) && !defined(__HIGHTEC__)
		extern void _init(void); /* cpp initialization */
		_init();
8000fed4:	6d ff 3a ab 	call 80005548 <_init>
	#elif defined(__ghs__)
		extern void _main(void); /* cpp initialization */
		_main();
	#endif
}
8000fed8:	00 00       	nop 
8000feda:	00 90       	ret 

8000fedc <ethernet_input>:
 * @see ETHARP_SUPPORT_VLAN
 * @see LWIP_HOOK_VLAN_CHECK
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
8000fedc:	40 ae       	mov.aa %a14,%sp
8000fede:	20 18       	sub.a %sp,24
8000fee0:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8000fee4:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
  struct eth_hdr *ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
  u16_t next_hdr_offset = SIZEOF_ETH_HDR;
8000fee8:	3b 00 01 20 	mov %d2,16
8000feec:	f9 e2 fe ff 	st.h [%a14]-2,%d2
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  LWIP_ASSERT_CORE_LOCKED();

  if (p->len <= SIZEOF_ETH_HDR) {
8000fef0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000fef4:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8000fef8:	8b 12 a1 22 	ge.u %d2,%d2,17
8000fefc:	df 02 22 80 	jne %d2,0,8000ff40 <ethernet_input+0x64>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
8000ff00:	91 10 00 27 	movh.a %a2,28673
8000ff04:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8000ff08:	b9 22 28 00 	ld.hu %d2,[%a2]40 <70010028 <ram_heap+0x4f94>>
8000ff0c:	c2 12       	add %d2,1
8000ff0e:	37 02 70 20 	extr.u %d2,%d2,0,16
8000ff12:	91 10 00 27 	movh.a %a2,28673
8000ff16:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8000ff1a:	f9 22 28 00 	st.h [%a2]40 <70010028 <ram_heap+0x4f94>>,%d2
    ETHARP_STATS_INC(etharp.drop);
8000ff1e:	91 10 00 27 	movh.a %a2,28673
8000ff22:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8000ff26:	b9 22 1e 00 	ld.hu %d2,[%a2]30 <7001001e <ram_heap+0x4f8a>>
8000ff2a:	c2 12       	add %d2,1
8000ff2c:	37 02 70 20 	extr.u %d2,%d2,0,16
8000ff30:	91 10 00 27 	movh.a %a2,28673
8000ff34:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8000ff38:	f9 22 1e 00 	st.h [%a2]30 <7001001e <ram_heap+0x4f8a>>,%d2
    MIB2_STATS_NETIF_INC(netif, ifinerrors);
    goto free_and_return;
8000ff3c:	1d 00 ee 00 	j 80010118 <ethernet_input+0x23c>
  }

  if (p->if_idx == NETIF_NO_INDEX) {
8000ff40:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000ff44:	39 22 0f 00 	ld.bu %d2,[%a2]15
8000ff48:	df 02 0d 80 	jne %d2,0,8000ff62 <ethernet_input+0x86>
    p->if_idx = netif_get_index(netif);
8000ff4c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8000ff50:	39 22 34 00 	ld.bu %d2,[%a2]52
8000ff54:	c2 12       	add %d2,1
8000ff56:	8f f2 0f 21 	and %d2,%d2,255
8000ff5a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000ff5e:	e9 22 0f 00 	st.b [%a2]15,%d2
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
8000ff62:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000ff66:	b0 42       	add.a %a2,4
8000ff68:	54 22       	ld.w %d2,[%a2]
8000ff6a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
               (unsigned char)ethhdr->dest.addr[3], (unsigned char)ethhdr->dest.addr[4], (unsigned char)ethhdr->dest.addr[5],
               (unsigned char)ethhdr->src.addr[0],  (unsigned char)ethhdr->src.addr[1],  (unsigned char)ethhdr->src.addr[2],
               (unsigned char)ethhdr->src.addr[3],  (unsigned char)ethhdr->src.addr[4],  (unsigned char)ethhdr->src.addr[5],
               lwip_htons(ethhdr->type)));

  type = ethhdr->type;
8000ff6e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000ff72:	39 23 0e 00 	ld.bu %d3,[%a2]14
8000ff76:	39 22 0f 00 	ld.bu %d2,[%a2]15
8000ff7a:	8f 82 00 20 	sh %d2,%d2,8
8000ff7e:	a6 32       	or %d2,%d3
8000ff80:	f9 e2 f6 ff 	st.h [%a14]-10,%d2

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
8000ff84:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000ff88:	39 22 02 00 	ld.bu %d2,[%a2]2
8000ff8c:	8f 12 00 21 	and %d2,%d2,1
8000ff90:	df 02 3d 00 	jeq %d2,0,8001000a <ethernet_input+0x12e>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
8000ff94:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000ff98:	39 22 02 00 	ld.bu %d2,[%a2]2
8000ff9c:	df 12 1e 80 	jne %d2,1,8000ffd8 <ethernet_input+0xfc>
#if LWIP_IPV4
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
8000ffa0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000ffa4:	39 22 03 00 	ld.bu %d2,[%a2]3
8000ffa8:	df 02 31 80 	jne %d2,0,8001000a <ethernet_input+0x12e>
          (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
8000ffac:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8000ffb0:	39 22 04 00 	ld.bu %d2,[%a2]4
      if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
8000ffb4:	8b e2 25 22 	ne %d2,%d2,94
8000ffb8:	df 02 29 80 	jne %d2,0,8001000a <ethernet_input+0x12e>
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
8000ffbc:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000ffc0:	39 22 0d 00 	ld.bu %d2,[%a2]13
8000ffc4:	8f 02 41 21 	or %d2,%d2,16
8000ffc8:	8f f2 0f 21 	and %d2,%d2,255
8000ffcc:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000ffd0:	e9 22 0d 00 	st.b [%a2]13,%d2
8000ffd4:	1d 00 1b 00 	j 8001000a <ethernet_input+0x12e>
             (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
      /* mark the pbuf as link-layer multicast */
      p->flags |= PBUF_FLAG_LLMCAST;
    }
#endif /* LWIP_IPV6 */
    else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
8000ffd8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8000ffdc:	c2 22       	add %d2,2
8000ffde:	82 64       	mov %d4,6
8000ffe0:	91 00 00 28 	movh.a %a2,32768
8000ffe4:	d9 25 50 44 	lea %a5,[%a2]17680 <80004510 <ethbroadcast>>
8000ffe8:	60 24       	mov.a %a4,%d2
8000ffea:	6d 00 2c b9 	call 80027242 <memcmp>
8000ffee:	df 02 0e 80 	jne %d2,0,8001000a <ethernet_input+0x12e>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
8000fff2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8000fff6:	39 22 0d 00 	ld.bu %d2,[%a2]13
8000fffa:	8f 82 40 21 	or %d2,%d2,8
8000fffe:	8f f2 0f 21 	and %d2,%d2,255
80010002:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80010006:	e9 22 0d 00 	st.b [%a2]13,%d2
    }
  }

  switch (type) {
8001000a:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10
8001000e:	8b 82 00 32 	eq %d3,%d2,8
80010012:	df 03 08 80 	jne %d3,0,80010022 <ethernet_input+0x146>
80010016:	3b 80 60 30 	mov %d3,1544
8001001a:	5f 32 1d 00 	jeq %d2,%d3,80010054 <ethernet_input+0x178>
8001001e:	1d 00 54 00 	j 800100c6 <ethernet_input+0x1ea>
#if LWIP_IPV4 && LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
80010022:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80010026:	39 22 31 00 	ld.bu %d2,[%a2]49
8001002a:	8f 82 00 21 	and %d2,%d2,8
8001002e:	df 02 6e 00 	jeq %d2,0,8001010a <ethernet_input+0x22e>
        goto free_and_return;
      }
      /* skip Ethernet header (min. size checked above) */
      if (pbuf_remove_header(p, next_hdr_offset)) {
80010032:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80010036:	02 24       	mov %d4,%d2
80010038:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001003c:	6d 00 e8 4e 	call 80019e0c <pbuf_remove_header>
80010040:	df 02 68 80 	jne %d2,0,80010110 <ethernet_input+0x234>
                     p->tot_len, next_hdr_offset));
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip4_input(p, netif);
80010044:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
80010048:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001004c:	6d 00 18 28 	call 8001507c <ip4_input>
      }
      break;
80010050:	1d 00 5b 00 	j 80010106 <ethernet_input+0x22a>

    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
80010054:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80010058:	39 22 31 00 	ld.bu %d2,[%a2]49
8001005c:	8f 82 00 21 	and %d2,%d2,8
80010060:	df 02 5b 00 	jeq %d2,0,80010116 <ethernet_input+0x23a>
        goto free_and_return;
      }
      /* skip Ethernet header (min. size checked above) */
      if (pbuf_remove_header(p, next_hdr_offset)) {
80010064:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80010068:	02 24       	mov %d4,%d2
8001006a:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001006e:	6d 00 cf 4e 	call 80019e0c <pbuf_remove_header>
80010072:	df 02 22 00 	jeq %d2,0,800100b6 <ethernet_input+0x1da>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                    ("ethernet_input: ARP response packet dropped, too short (%"U16_F"/%"U16_F")\n",
                     p->tot_len, next_hdr_offset));
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
        ETHARP_STATS_INC(etharp.lenerr);
80010076:	91 10 00 27 	movh.a %a2,28673
8001007a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001007e:	b9 22 22 00 	ld.hu %d2,[%a2]34 <70010022 <ram_heap+0x4f8e>>
80010082:	c2 12       	add %d2,1
80010084:	37 02 70 20 	extr.u %d2,%d2,0,16
80010088:	91 10 00 27 	movh.a %a2,28673
8001008c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80010090:	f9 22 22 00 	st.h [%a2]34 <70010022 <ram_heap+0x4f8e>>,%d2
        ETHARP_STATS_INC(etharp.drop);
80010094:	91 10 00 27 	movh.a %a2,28673
80010098:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001009c:	b9 22 1e 00 	ld.hu %d2,[%a2]30 <7001001e <ram_heap+0x4f8a>>
800100a0:	c2 12       	add %d2,1
800100a2:	37 02 70 20 	extr.u %d2,%d2,0,16
800100a6:	91 10 00 27 	movh.a %a2,28673
800100aa:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800100ae:	f9 22 1e 00 	st.h [%a2]30 <7001001e <ram_heap+0x4f8a>>,%d2
        goto free_and_return;
800100b2:	1d 00 33 00 	j 80010118 <ethernet_input+0x23c>
      } else {
        /* pass p to ARP module */
        etharp_input(p, netif);
800100b6:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
800100ba:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800100be:	6d 00 c1 1c 	call 80013a40 <etharp_input>
      }
      break;
800100c2:	1d 00 22 00 	j 80010106 <ethernet_input+0x22a>
#ifdef LWIP_HOOK_UNKNOWN_ETH_PROTOCOL
      if (LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(p, netif) == ERR_OK) {
        break;
      }
#endif
      ETHARP_STATS_INC(etharp.proterr);
800100c6:	91 10 00 27 	movh.a %a2,28673
800100ca:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800100ce:	b9 22 28 00 	ld.hu %d2,[%a2]40 <70010028 <ram_heap+0x4f94>>
800100d2:	c2 12       	add %d2,1
800100d4:	37 02 70 20 	extr.u %d2,%d2,0,16
800100d8:	91 10 00 27 	movh.a %a2,28673
800100dc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800100e0:	f9 22 28 00 	st.h [%a2]40 <70010028 <ram_heap+0x4f94>>,%d2
      ETHARP_STATS_INC(etharp.drop);
800100e4:	91 10 00 27 	movh.a %a2,28673
800100e8:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800100ec:	b9 22 1e 00 	ld.hu %d2,[%a2]30 <7001001e <ram_heap+0x4f8a>>
800100f0:	c2 12       	add %d2,1
800100f2:	37 02 70 20 	extr.u %d2,%d2,0,16
800100f6:	91 10 00 27 	movh.a %a2,28673
800100fa:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800100fe:	f9 22 1e 00 	st.h [%a2]30 <7001001e <ram_heap+0x4f8a>>,%d2
      MIB2_STATS_NETIF_INC(netif, ifinunknownprotos);
      goto free_and_return;
80010102:	1d 00 0b 00 	j 80010118 <ethernet_input+0x23c>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
80010106:	82 02       	mov %d2,0
80010108:	00 90       	ret 
        goto free_and_return;
8001010a:	00 00       	nop 
8001010c:	1d 00 06 00 	j 80010118 <ethernet_input+0x23c>
        goto free_and_return;
80010110:	00 00       	nop 
80010112:	1d 00 03 00 	j 80010118 <ethernet_input+0x23c>
        goto free_and_return;
80010116:	00 00       	nop 

free_and_return:
  pbuf_free(p);
80010118:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001011c:	6d 00 3e 4f 	call 80019f98 <pbuf_free>
  return ERR_OK;
80010120:	82 02       	mov %d2,0
}
80010122:	00 90       	ret 

80010124 <ethernet_output>:
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
err_t
ethernet_output(struct netif * netif, struct pbuf * p,
                const struct eth_addr * src, const struct eth_addr * dst,
                u16_t eth_type) {
80010124:	40 ae       	mov.aa %a14,%sp
80010126:	20 30       	sub.a %sp,48
80010128:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001012c:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
80010130:	b5 e6 ec ff 	st.a [%a14]-20,%a6
80010134:	b5 e7 e8 ff 	st.a [%a14]-24,%a7
80010138:	02 42       	mov %d2,%d4
8001013a:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
  struct eth_hdr *ethhdr;
  u16_t eth_type_be = lwip_htons(eth_type);
8001013e:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
80010142:	02 24       	mov %d4,%d2
80010144:	6d 00 08 3a 	call 80017554 <lwip_htons>
80010148:	f9 e2 fe ff 	st.h [%a14]-2,%d2

    eth_type_be = PP_HTONS(ETHTYPE_VLAN);
  } else
#endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
  {
    if (pbuf_add_header(p, SIZEOF_ETH_HDR) != 0) {
8001014c:	3b 00 01 40 	mov %d4,16
80010150:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80010154:	6d 00 4e 4e 	call 80019df0 <pbuf_add_header>
80010158:	df 02 55 80 	jne %d2,0,80010202 <ethernet_output+0xde>
    }
  }

  LWIP_ASSERT_CORE_LOCKED();

  ethhdr = (struct eth_hdr *)p->payload;
8001015c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80010160:	b0 42       	add.a %a2,4
80010162:	54 22       	ld.w %d2,[%a2]
80010164:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  ethhdr->type = eth_type_be;
80010168:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001016c:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80010170:	8f f2 0f 21 	and %d2,%d2,255
80010174:	82 03       	mov %d3,0
80010176:	a6 32       	or %d2,%d3
80010178:	e9 22 0e 00 	st.b [%a2]14,%d2
8001017c:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80010180:	06 82       	sh %d2,-8
80010182:	37 02 70 20 	extr.u %d2,%d2,0,16
80010186:	82 03       	mov %d3,0
80010188:	a6 32       	or %d2,%d3
8001018a:	e9 22 0f 00 	st.b [%a2]15,%d2
  SMEMCPY(&ethhdr->dest, dst, ETH_HWADDR_LEN);
8001018e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80010192:	c2 22       	add %d2,2
80010194:	82 64       	mov %d4,6
80010196:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
8001019a:	60 24       	mov.a %a4,%d2
8001019c:	6d 00 40 b8 	call 8002721c <memcpy>
  SMEMCPY(&ethhdr->src,  src, ETH_HWADDR_LEN);
800101a0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800101a4:	1b 82 00 20 	addi %d2,%d2,8
800101a8:	82 64       	mov %d4,6
800101aa:	99 e5 ec ff 	ld.a %a5,[%a14]-20
800101ae:	60 24       	mov.a %a4,%d2
800101b0:	6d 00 36 b8 	call 8002721c <memcpy>

  LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
800101b4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800101b8:	39 22 30 00 	ld.bu %d2,[%a2]48
800101bc:	df 62 17 00 	jeq %d2,6,800101ea <ethernet_output+0xc6>
800101c0:	91 00 00 28 	movh.a %a2,32768
800101c4:	d9 22 80 60 	lea %a2,[%a2]2432 <80000980 <IfxCpu_Trap_vectorTable0_end+0x78c>>
800101c8:	b5 a2 08 00 	st.a [%sp]8 <80000980 <IfxCpu_Trap_vectorTable0_end+0x78c>>,%a2
800101cc:	3b 20 13 20 	mov %d2,306
800101d0:	59 a2 04 00 	st.w [%sp]4,%d2
800101d4:	91 00 00 28 	movh.a %a2,32768
800101d8:	d9 22 b0 60 	lea %a2,[%a2]2480 <800009b0 <IfxCpu_Trap_vectorTable0_end+0x7bc>>
800101dc:	f4 a2       	st.a [%sp],%a2
800101de:	91 00 00 28 	movh.a %a2,32768
800101e2:	d9 24 98 50 	lea %a4,[%a2]2392 <80000958 <IfxCpu_Trap_vectorTable0_end+0x764>>
800101e6:	6d ff a8 a8 	call 80005336 <Ifx_Lwip_printf>
              (netif->hwaddr_len == ETH_HWADDR_LEN));
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
              ("ethernet_output: sending packet %p\n", (void *)p));

  /* send the packet */
  return netif->linkoutput(netif, p);
800101ea:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800101ee:	d9 22 18 00 	lea %a2,[%a2]24
800101f2:	d4 22       	ld.a %a2,[%a2]
800101f4:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
800101f8:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800101fc:	2d 02 00 00 	calli %a2
80010200:	00 90       	ret 

pbuf_header_failed:
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
              ("ethernet_output: could not allocate room for header.\n"));
  LINK_STATS_INC(link.lenerr);
80010202:	91 10 00 27 	movh.a %a2,28673
80010206:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001020a:	b9 22 0a 00 	ld.hu %d2,[%a2]10 <7001000a <ram_heap+0x4f76>>
8001020e:	c2 12       	add %d2,1
80010210:	37 02 70 20 	extr.u %d2,%d2,0,16
80010214:	91 10 00 27 	movh.a %a2,28673
80010218:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001021c:	f9 22 0a 00 	st.h [%a2]10 <7001000a <ram_heap+0x4f76>>,%d2
  return ERR_BUF;
80010220:	82 e2       	mov %d2,-2
}
80010222:	00 90       	ret 

80010224 <dhcp_inc_pcb_refcount>:
static void dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out);

/** Ensure DHCP PCB is allocated and bound */
static err_t
dhcp_inc_pcb_refcount(void)
{
80010224:	40 ae       	mov.aa %a14,%sp
80010226:	20 10       	sub.a %sp,16
  if (dhcp_pcb_refcount == 0) {
80010228:	91 10 00 27 	movh.a %a2,28673
8001022c:	d9 22 fc da 	lea %a2,[%a2]-20612 <7000af7c <dhcp_pcb_refcount>>
80010230:	14 22       	ld.bu %d2,[%a2]
80010232:	df 02 6a 80 	jne %d2,0,80010306 <dhcp_inc_pcb_refcount+0xe2>
    LWIP_ASSERT("dhcp_inc_pcb_refcount(): memory leak", dhcp_pcb == NULL);
80010236:	91 10 00 27 	movh.a %a2,28673
8001023a:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
8001023e:	54 22       	ld.w %d2,[%a2]
80010240:	df 02 17 00 	jeq %d2,0,8001026e <dhcp_inc_pcb_refcount+0x4a>
80010244:	91 00 00 28 	movh.a %a2,32768
80010248:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
8001024c:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010250:	3b 50 0e 20 	mov %d2,229
80010254:	59 a2 04 00 	st.w [%sp]4,%d2
80010258:	91 00 00 28 	movh.a %a2,32768
8001025c:	d9 22 b9 80 	lea %a2,[%a2]2617 <80000a39 <IfxCpu_Trap_vectorTable0_end+0x845>>
80010260:	f4 a2       	st.a [%sp],%a2
80010262:	91 00 00 28 	movh.a %a2,32768
80010266:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
8001026a:	6d ff 66 a8 	call 80005336 <Ifx_Lwip_printf>

    /* allocate UDP PCB */
    dhcp_pcb = udp_new();
8001026e:	6d 00 1d af 	call 800260a8 <udp_new>
80010272:	80 22       	mov.d %d2,%a2
80010274:	91 10 00 27 	movh.a %a2,28673
80010278:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
8001027c:	74 22       	st.w [%a2],%d2

    if (dhcp_pcb == NULL) {
8001027e:	91 10 00 27 	movh.a %a2,28673
80010282:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
80010286:	54 22       	ld.w %d2,[%a2]
80010288:	df 02 04 80 	jne %d2,0,80010290 <dhcp_inc_pcb_refcount+0x6c>
      return ERR_MEM;
8001028c:	82 f2       	mov %d2,-1
8001028e:	00 90       	ret 
    }

    ip_set_option(dhcp_pcb, SOF_BROADCAST);
80010290:	91 10 00 27 	movh.a %a2,28673
80010294:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
80010298:	d4 22       	ld.a %a2,[%a2]
8001029a:	39 22 09 00 	ld.bu %d2,[%a2]9 <7000af78 <dhcp_pcb>>
8001029e:	91 10 00 27 	movh.a %a2,28673
800102a2:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
800102a6:	d4 22       	ld.a %a2,[%a2]
800102a8:	8f 02 42 21 	or %d2,%d2,32
800102ac:	8f f2 0f 21 	and %d2,%d2,255
800102b0:	e9 22 09 00 	st.b [%a2]9,%d2

    /* set up local and remote port for the pcb -> listen on all interfaces on all src/dest IPs */
    udp_bind(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_CLIENT);
800102b4:	91 10 00 27 	movh.a %a2,28673
800102b8:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
800102bc:	54 22       	ld.w %d2,[%a2]
800102be:	3b 40 04 40 	mov %d4,68
800102c2:	91 00 00 28 	movh.a %a2,32768
800102c6:	d9 25 5c 44 	lea %a5,[%a2]17692 <8000451c <ip_addr_any>>
800102ca:	60 24       	mov.a %a4,%d2
800102cc:	6d 00 df ac 	call 80025c8a <udp_bind>
    udp_connect(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_SERVER);
800102d0:	91 10 00 27 	movh.a %a2,28673
800102d4:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
800102d8:	54 22       	ld.w %d2,[%a2]
800102da:	3b 30 04 40 	mov %d4,67
800102de:	91 00 00 28 	movh.a %a2,32768
800102e2:	d9 25 5c 44 	lea %a5,[%a2]17692 <8000451c <ip_addr_any>>
800102e6:	60 24       	mov.a %a4,%d2
800102e8:	6d 00 98 ad 	call 80025e18 <udp_connect>
    udp_recv(dhcp_pcb, dhcp_recv, NULL);
800102ec:	91 10 00 27 	movh.a %a2,28673
800102f0:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
800102f4:	54 22       	ld.w %d2,[%a2]
800102f6:	a0 06       	mov.a %a6,0
800102f8:	91 10 00 28 	movh.a %a2,32769
800102fc:	d9 25 b4 b2 	lea %a5,[%a2]10996 <80012af4 <dhcp_recv>>
80010300:	60 24       	mov.a %a4,%d2
80010302:	6d 00 36 ae 	call 80025f6e <udp_recv>
  }

  dhcp_pcb_refcount++;
80010306:	91 10 00 27 	movh.a %a2,28673
8001030a:	d9 22 fc da 	lea %a2,[%a2]-20612 <7000af7c <dhcp_pcb_refcount>>
8001030e:	14 22       	ld.bu %d2,[%a2]
80010310:	c2 12       	add %d2,1
80010312:	8f f2 0f 21 	and %d2,%d2,255
80010316:	91 10 00 27 	movh.a %a2,28673
8001031a:	d9 22 fc da 	lea %a2,[%a2]-20612 <7000af7c <dhcp_pcb_refcount>>
8001031e:	34 22       	st.b [%a2],%d2

  return ERR_OK;
80010320:	82 02       	mov %d2,0
}
80010322:	00 90       	ret 

80010324 <dhcp_dec_pcb_refcount>:

/** Free DHCP PCB if the last netif stops using it */
static void
dhcp_dec_pcb_refcount(void)
{
80010324:	40 ae       	mov.aa %a14,%sp
80010326:	20 10       	sub.a %sp,16
  LWIP_ASSERT("dhcp_pcb_refcount(): refcount error", (dhcp_pcb_refcount > 0));
80010328:	91 10 00 27 	movh.a %a2,28673
8001032c:	d9 22 fc da 	lea %a2,[%a2]-20612 <7000af7c <dhcp_pcb_refcount>>
80010330:	14 22       	ld.bu %d2,[%a2]
80010332:	df 02 17 80 	jne %d2,0,80010360 <dhcp_dec_pcb_refcount+0x3c>
80010336:	91 00 00 28 	movh.a %a2,32768
8001033a:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
8001033e:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010342:	3b f0 0f 20 	mov %d2,255
80010346:	59 a2 04 00 	st.w [%sp]4,%d2
8001034a:	91 00 00 28 	movh.a %a2,32768
8001034e:	d9 22 9e 90 	lea %a2,[%a2]2654 <80000a5e <IfxCpu_Trap_vectorTable0_end+0x86a>>
80010352:	f4 a2       	st.a [%sp],%a2
80010354:	91 00 00 28 	movh.a %a2,32768
80010358:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
8001035c:	6d ff ed a7 	call 80005336 <Ifx_Lwip_printf>
  dhcp_pcb_refcount--;
80010360:	91 10 00 27 	movh.a %a2,28673
80010364:	d9 22 fc da 	lea %a2,[%a2]-20612 <7000af7c <dhcp_pcb_refcount>>
80010368:	14 22       	ld.bu %d2,[%a2]
8001036a:	c2 f2       	add %d2,-1
8001036c:	8f f2 0f 21 	and %d2,%d2,255
80010370:	91 10 00 27 	movh.a %a2,28673
80010374:	d9 22 fc da 	lea %a2,[%a2]-20612 <7000af7c <dhcp_pcb_refcount>>
80010378:	34 22       	st.b [%a2],%d2

  if (dhcp_pcb_refcount == 0) {
8001037a:	91 10 00 27 	movh.a %a2,28673
8001037e:	d9 22 fc da 	lea %a2,[%a2]-20612 <7000af7c <dhcp_pcb_refcount>>
80010382:	14 22       	ld.bu %d2,[%a2]
80010384:	df 02 10 80 	jne %d2,0,800103a4 <dhcp_dec_pcb_refcount+0x80>
    udp_remove(dhcp_pcb);
80010388:	91 10 00 27 	movh.a %a2,28673
8001038c:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
80010390:	54 22       	ld.w %d2,[%a2]
80010392:	60 24       	mov.a %a4,%d2
80010394:	6d 00 1e ae 	call 80025fd0 <udp_remove>
    dhcp_pcb = NULL;
80010398:	91 10 00 27 	movh.a %a2,28673
8001039c:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
800103a0:	82 02       	mov %d2,0
800103a2:	74 22       	st.w [%a2],%d2
  }
}
800103a4:	00 00       	nop 
800103a6:	00 90       	ret 

800103a8 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
800103a8:	40 ae       	mov.aa %a14,%sp
800103aa:	20 10       	sub.a %sp,16
800103ac:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
800103b0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800103b4:	d9 22 20 00 	lea %a2,[%a2]32
800103b8:	54 22       	ld.w %d2,[%a2]
800103ba:	59 e2 fc ff 	st.w [%a14]-4,%d2

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n",
              (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Change to a defined state - set this before assigning the address
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
800103be:	3b c0 00 40 	mov %d4,12
800103c2:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800103c6:	6d 00 64 0d 	call 80011e8e <dhcp_set_state>
  /* remove IP address from interface (must no longer be used, as per RFC2131) */
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
800103ca:	91 00 00 28 	movh.a %a2,32768
800103ce:	d9 27 5c 44 	lea %a7,[%a2]17692 <8000451c <ip_addr_any>>
800103d2:	91 00 00 28 	movh.a %a2,32768
800103d6:	d9 26 5c 44 	lea %a6,[%a2]17692 <8000451c <ip_addr_any>>
800103da:	91 00 00 28 	movh.a %a2,32768
800103de:	d9 25 5c 44 	lea %a5,[%a2]17692 <8000451c <ip_addr_any>>
800103e2:	99 e4 f4 ff 	ld.a %a4,[%a14]-12 <8000451c <ip_addr_any>>
800103e6:	6d 00 91 46 	call 80019108 <netif_set_addr>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
800103ea:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800103ee:	6d 00 f4 06 	call 800111d6 <dhcp_discover>
}
800103f2:	00 00       	nop 
800103f4:	00 90       	ret 

800103f6 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
800103f6:	40 ae       	mov.aa %a14,%sp
800103f8:	20 10       	sub.a %sp,16
800103fa:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
800103fe:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010402:	d9 22 20 00 	lea %a2,[%a2]32
80010406:	54 22       	ld.w %d2,[%a2]
80010408:	59 e2 fc ff 	st.w [%a14]-4,%d2
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
              (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
8001040c:	3b 80 00 40 	mov %d4,8
80010410:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80010414:	6d 00 3d 0d 	call 80011e8e <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
80010418:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001041c:	1b c2 01 20 	addi %d2,%d2,28
80010420:	a0 06       	mov.a %a6,0
80010422:	60 25       	mov.a %a5,%d2
80010424:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010428:	6d 00 99 1e 	call 8001415a <etharp_query>
8001042c:	e9 e2 fb ff 	st.b [%a14]-5,%d2
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  if (dhcp->tries < 255) {
80010430:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010434:	39 22 06 00 	ld.bu %d2,[%a2]6
80010438:	8b f2 0f 22 	eq %d2,%d2,255
8001043c:	df 02 0d 80 	jne %d2,0,80010456 <dhcp_check+0x60>
    dhcp->tries++;
80010440:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010444:	39 22 06 00 	ld.bu %d2,[%a2]6
80010448:	c2 12       	add %d2,1
8001044a:	8f f2 0f 21 	and %d2,%d2,255
8001044e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010452:	e9 22 06 00 	st.b [%a2]6,%d2
  }
  msecs = 500;
80010456:	3b 40 1f 20 	mov %d2,500
8001045a:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
8001045e:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80010462:	1b 32 1f 40 	addi %d4,%d2,499
80010466:	7b 20 06 21 	movh %d2,4194
8001046a:	1b 32 dd 24 	addi %d2,%d2,19923
8001046e:	73 24 6a 20 	mul %e2,%d4,%d2
80010472:	86 b3       	sha %d3,-5
80010474:	8f 14 3e 20 	sha %d2,%d4,-31
80010478:	0b 23 80 20 	sub %d2,%d3,%d2
8001047c:	37 02 70 20 	extr.u %d2,%d2,0,16
80010480:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010484:	f9 22 08 00 	st.h [%a2]8,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
80010488:	00 00       	nop 
8001048a:	00 90       	ret 

8001048c <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif, struct dhcp_msg *msg_in)
{
8001048c:	40 ae       	mov.aa %a14,%sp
8001048e:	20 10       	sub.a %sp,16
80010490:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80010494:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct dhcp *dhcp = netif_dhcp_data(netif);
80010498:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001049c:	d9 22 20 00 	lea %a2,[%a2]32
800104a0:	54 22       	ld.w %d2,[%a2]
800104a2:	59 e2 fc ff 	st.w [%a14]-4,%d2

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
              (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
800104a6:	91 10 00 27 	movh.a %a2,28673
800104aa:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
800104ae:	39 22 02 00 	ld.bu %d2,[%a2]2 <70010002 <ram_heap+0x4f6e>>
800104b2:	df 02 32 00 	jeq %d2,0,80010516 <dhcp_handle_offer+0x8a>
    dhcp->request_timeout = 0; /* stop timer */
800104b6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800104ba:	82 02       	mov %d2,0
800104bc:	f9 22 08 00 	st.h [%a2]8,%d2

    ip_addr_set_ip4_u32(&dhcp->server_ip_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
800104c0:	91 10 00 27 	movh.a %a2,28673
800104c4:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
800104c8:	d9 22 08 00 	lea %a2,[%a2]8 <70010008 <ram_heap+0x4f74>>
800104cc:	54 22       	ld.w %d2,[%a2]
800104ce:	02 24       	mov %d4,%d2
800104d0:	6d 00 5a 38 	call 80017584 <lwip_htonl>
800104d4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800104d8:	d9 22 18 00 	lea %a2,[%a2]24
800104dc:	74 22       	st.w [%a2],%d2
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
                ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
    /* remember offered address */
    ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
800104de:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800104e2:	39 23 10 00 	ld.bu %d3,[%a2]16
800104e6:	39 22 11 00 	ld.bu %d2,[%a2]17
800104ea:	8f 82 00 20 	sh %d2,%d2,8
800104ee:	a6 32       	or %d2,%d3
800104f0:	39 23 12 00 	ld.bu %d3,[%a2]18
800104f4:	8f 03 01 30 	sh %d3,%d3,16
800104f8:	a6 32       	or %d2,%d3
800104fa:	39 23 13 00 	ld.bu %d3,[%a2]19
800104fe:	8f 83 01 30 	sh %d3,%d3,24
80010502:	a6 32       	or %d2,%d3
80010504:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010508:	d9 22 1c 00 	lea %a2,[%a2]28
8001050c:	74 22       	st.w [%a2],%d2
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
                ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
8001050e:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010512:	6d 00 04 00 	call 8001051a <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void *)netif));
  }
}
80010516:	00 00       	nop 
80010518:	00 90       	ret 

8001051a <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
8001051a:	40 ae       	mov.aa %a14,%sp
8001051c:	20 30       	sub.a %sp,48
8001051e:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  u16_t msecs;
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_ERROR("dhcp_select: netif != NULL", (netif != NULL), return ERR_ARG;);
80010522:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80010526:	df 02 1a 80 	jne %d2,0,8001055a <dhcp_select+0x40>
8001052a:	91 00 00 28 	movh.a %a2,32768
8001052e:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80010532:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010536:	3b 70 17 20 	mov %d2,375
8001053a:	59 a2 04 00 	st.w [%sp]4,%d2
8001053e:	91 00 00 28 	movh.a %a2,32768
80010542:	d9 22 82 a0 	lea %a2,[%a2]2690 <80000a82 <IfxCpu_Trap_vectorTable0_end+0x88e>>
80010546:	f4 a2       	st.a [%sp],%a2
80010548:	91 00 00 28 	movh.a %a2,32768
8001054c:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80010550:	6d ff f3 a6 	call 80005336 <Ifx_Lwip_printf>
80010554:	3b 00 ff 2f 	mov %d2,-16
80010558:	00 90       	ret 
  dhcp = netif_dhcp_data(netif);
8001055a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001055e:	d9 22 20 00 	lea %a2,[%a2]32
80010562:	54 22       	ld.w %d2,[%a2]
80010564:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  LWIP_ERROR("dhcp_select: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
80010568:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001056c:	df 02 19 80 	jne %d2,0,8001059e <dhcp_select+0x84>
80010570:	91 00 00 28 	movh.a %a2,32768
80010574:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80010578:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
8001057c:	3b 90 17 20 	mov %d2,377
80010580:	59 a2 04 00 	st.w [%sp]4,%d2
80010584:	91 00 00 28 	movh.a %a2,32768
80010588:	d9 22 9d a0 	lea %a2,[%a2]2717 <80000a9d <IfxCpu_Trap_vectorTable0_end+0x8a9>>
8001058c:	f4 a2       	st.a [%sp],%a2
8001058e:	91 00 00 28 	movh.a %a2,32768
80010592:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80010596:	6d ff d0 a6 	call 80005336 <Ifx_Lwip_printf>
8001059a:	82 a2       	mov %d2,-6
8001059c:	00 90       	ret 

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_STATE_REQUESTING);
8001059e:	82 14       	mov %d4,1
800105a0:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
800105a4:	6d 00 75 0c 	call 80011e8e <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
800105a8:	d9 e2 ec ff 	lea %a2,[%a14]-20
800105ac:	40 26       	mov.aa %a6,%a2
800105ae:	82 34       	mov %d4,3
800105b0:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
800105b4:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800105b8:	6d 00 b4 13 	call 80012d20 <dhcp_create_msg>
800105bc:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
  if (p_out != NULL) {
800105c0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800105c4:	df 02 e5 00 	jeq %d2,0,8001078e <dhcp_select+0x274>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
800105c8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800105cc:	b0 42       	add.a %a2,4
800105ce:	54 22       	ld.w %d2,[%a2]
800105d0:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
800105d4:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800105d8:	02 23       	mov %d3,%d2
800105da:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800105de:	1b 02 0f 20 	addi %d2,%d2,240
800105e2:	82 26       	mov %d6,2
800105e4:	3b 90 03 50 	mov %d5,57
800105e8:	60 24       	mov.a %a4,%d2
800105ea:	02 34       	mov %d4,%d3
800105ec:	6d 00 71 0c 	call 80011ece <dhcp_option>
800105f0:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
800105f4:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800105f8:	02 24       	mov %d4,%d2
800105fa:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800105fe:	1b 02 0f 20 	addi %d2,%d2,240
80010602:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80010606:	b9 23 28 00 	ld.hu %d3,[%a2]40
8001060a:	02 35       	mov %d5,%d3
8001060c:	60 24       	mov.a %a4,%d2
8001060e:	6d 00 e7 0c 	call 80011fdc <dhcp_option_short>
80010612:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    /* MUST request the offered IP address */
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
80010616:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
8001061a:	02 23       	mov %d3,%d2
8001061c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80010620:	1b 02 0f 20 	addi %d2,%d2,240
80010624:	82 46       	mov %d6,4
80010626:	3b 20 03 50 	mov %d5,50
8001062a:	60 24       	mov.a %a4,%d2
8001062c:	02 34       	mov %d4,%d3
8001062e:	6d 00 50 0c 	call 80011ece <dhcp_option>
80010632:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
80010636:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
8001063a:	02 29       	mov %d9,%d2
8001063c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80010640:	1b 02 0f 80 	addi %d8,%d2,240
80010644:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010648:	d9 22 1c 00 	lea %a2,[%a2]28
8001064c:	54 22       	ld.w %d2,[%a2]
8001064e:	02 24       	mov %d4,%d2
80010650:	6d 00 9a 37 	call 80017584 <lwip_htonl>
80010654:	02 25       	mov %d5,%d2
80010656:	60 84       	mov.a %a4,%d8
80010658:	02 94       	mov %d4,%d9
8001065a:	6d 00 10 0d 	call 8001207a <dhcp_option_long>
8001065e:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
80010662:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80010666:	02 23       	mov %d3,%d2
80010668:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001066c:	1b 02 0f 20 	addi %d2,%d2,240
80010670:	82 46       	mov %d6,4
80010672:	3b 60 03 50 	mov %d5,54
80010676:	60 24       	mov.a %a4,%d2
80010678:	02 34       	mov %d4,%d3
8001067a:	6d 00 2a 0c 	call 80011ece <dhcp_option>
8001067e:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
80010682:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80010686:	02 29       	mov %d9,%d2
80010688:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001068c:	1b 02 0f 80 	addi %d8,%d2,240
80010690:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010694:	d9 22 18 00 	lea %a2,[%a2]24
80010698:	54 22       	ld.w %d2,[%a2]
8001069a:	02 24       	mov %d4,%d2
8001069c:	6d 00 74 37 	call 80017584 <lwip_htonl>
800106a0:	02 25       	mov %d5,%d2
800106a2:	60 84       	mov.a %a4,%d8
800106a4:	02 94       	mov %d4,%d9
800106a6:	6d 00 ea 0c 	call 8001207a <dhcp_option_long>
800106aa:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
800106ae:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800106b2:	02 23       	mov %d3,%d2
800106b4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800106b8:	1b 02 0f 20 	addi %d2,%d2,240
800106bc:	82 36       	mov %d6,3
800106be:	3b 70 03 50 	mov %d5,55
800106c2:	60 24       	mov.a %a4,%d2
800106c4:	02 34       	mov %d4,%d3
800106c6:	6d 00 04 0c 	call 80011ece <dhcp_option>
800106ca:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
800106ce:	82 02       	mov %d2,0
800106d0:	e9 e2 ff ff 	st.b [%a14]-1,%d2
800106d4:	1d 00 1e 00 	j 80010710 <dhcp_select+0x1f6>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
800106d8:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800106dc:	02 23       	mov %d3,%d2
800106de:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800106e2:	1b 02 0f 20 	addi %d2,%d2,240
800106e6:	39 e4 ff ff 	ld.bu %d4,[%a14]-1
800106ea:	91 10 00 27 	movh.a %a2,28673
800106ee:	d9 22 a8 4a 	lea %a2,[%a2]-22232 <7000a928 <dhcp_discover_request_options>>
800106f2:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800106f6:	14 24       	ld.bu %d4,[%a2]
800106f8:	02 45       	mov %d5,%d4
800106fa:	60 24       	mov.a %a4,%d2
800106fc:	02 34       	mov %d4,%d3
800106fe:	6d 00 37 0c 	call 80011f6c <dhcp_option_byte>
80010702:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
80010706:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8001070a:	c2 12       	add %d2,1
8001070c:	e9 e2 ff ff 	st.b [%a14]-1,%d2
80010710:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80010714:	bf 32 e2 ff 	jlt.u %d2,3,800106d8 <dhcp_select+0x1be>
    }

#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
80010718:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
8001071c:	02 23       	mov %d3,%d2
8001071e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80010722:	1b 02 0f 20 	addi %d2,%d2,240
80010726:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
8001072a:	60 24       	mov.a %a4,%d2
8001072c:	02 34       	mov %d4,%d3
8001072e:	6d 00 18 0d 	call 8001215e <dhcp_option_hostname>
80010732:	f9 e2 ec ff 	st.h [%a14]-20,%d2
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REQUESTING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
80010736:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
8001073a:	02 23       	mov %d3,%d2
8001073c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80010740:	1b 02 0f 20 	addi %d2,%d2,240
80010744:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80010748:	60 24       	mov.a %a4,%d2
8001074a:	02 34       	mov %d4,%d3
8001074c:	6d 00 60 14 	call 8001300c <dhcp_option_trailer>

    /* send broadcast to any DHCP server */
    result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
80010750:	91 10 00 27 	movh.a %a2,28673
80010754:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
80010758:	54 22       	ld.w %d2,[%a2]
8001075a:	91 00 00 28 	movh.a %a2,32768
8001075e:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80010762:	f4 a2       	st.a [%sp],%a2
80010764:	99 e7 e4 ff 	ld.a %a7,[%a14]-28 <8000451c <ip_addr_any>>
80010768:	3b 30 04 40 	mov %d4,67
8001076c:	91 00 00 28 	movh.a %a2,32768
80010770:	d9 26 60 44 	lea %a6,[%a2]17696 <80004520 <ip_addr_broadcast>>
80010774:	99 e5 f4 ff 	ld.a %a5,[%a14]-12 <80004520 <ip_addr_broadcast>>
80010778:	60 24       	mov.a %a4,%d2
8001077a:	6d 00 c7 a8 	call 80025908 <udp_sendto_if_src>
8001077e:	e9 e2 fe ff 	st.b [%a14]-2,%d2
    pbuf_free(p_out);
80010782:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010786:	6d 00 09 4c 	call 80019f98 <pbuf_free>
8001078a:	1d 00 05 00 	j 80010794 <dhcp_select+0x27a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
    result = ERR_MEM;
8001078e:	82 f2       	mov %d2,-1
80010790:	e9 e2 fe ff 	st.b [%a14]-2,%d2
  }
  if (dhcp->tries < 255) {
80010794:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010798:	39 22 06 00 	ld.bu %d2,[%a2]6
8001079c:	8b f2 0f 22 	eq %d2,%d2,255
800107a0:	df 02 0d 80 	jne %d2,0,800107ba <dhcp_select+0x2a0>
    dhcp->tries++;
800107a4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800107a8:	39 22 06 00 	ld.bu %d2,[%a2]6
800107ac:	c2 12       	add %d2,1
800107ae:	8f f2 0f 21 	and %d2,%d2,255
800107b2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800107b6:	e9 22 06 00 	st.b [%a2]6,%d2
  }
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
800107ba:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800107be:	39 22 06 00 	ld.bu %d2,[%a2]6
800107c2:	ff 62 13 80 	jge.u %d2,6,800107e8 <dhcp_select+0x2ce>
800107c6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800107ca:	39 22 06 00 	ld.bu %d2,[%a2]6
800107ce:	02 23       	mov %d3,%d2
800107d0:	82 12       	mov %d2,1
800107d2:	0f 32 00 20 	sh %d2,%d2,%d3
800107d6:	37 02 70 20 	extr.u %d2,%d2,0,16
800107da:	3b 80 3e 30 	mov %d3,1000
800107de:	e2 32       	mul %d2,%d3
800107e0:	37 02 70 20 	extr.u %d2,%d2,0,16
800107e4:	1d 00 04 00 	j 800107ec <dhcp_select+0x2d2>
800107e8:	bb 00 a6 2e 	mov.u %d2,60000
800107ec:	f9 e2 ee ff 	st.h [%a14]-18,%d2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
800107f0:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
800107f4:	1b 32 1f 40 	addi %d4,%d2,499
800107f8:	7b 20 06 21 	movh %d2,4194
800107fc:	1b 32 dd 24 	addi %d2,%d2,19923
80010800:	73 24 6a 20 	mul %e2,%d4,%d2
80010804:	86 b3       	sha %d3,-5
80010806:	8f 14 3e 20 	sha %d2,%d4,-31
8001080a:	0b 23 80 20 	sub %d2,%d3,%d2
8001080e:	37 02 70 20 	extr.u %d2,%d2,0,16
80010812:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010816:	f9 22 08 00 	st.h [%a2]8,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
8001081a:	79 e2 fe ff 	ld.b %d2,[%a14]-2
}
8001081e:	00 90       	ret 

80010820 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 * Must be called once a minute (see @ref DHCP_COARSE_TIMER_SECS).
 */
void
dhcp_coarse_tmr(void)
{
80010820:	40 ae       	mov.aa %a14,%sp
80010822:	20 08       	sub.a %sp,8
  struct netif *netif;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  NETIF_FOREACH(netif) {
80010824:	91 10 00 27 	movh.a %a2,28673
80010828:	d9 22 48 34 	lea %a2,[%a2]17608 <700144c8 <netif_list>>
8001082c:	54 22       	ld.w %d2,[%a2]
8001082e:	59 e2 fc ff 	st.w [%a14]-4 <700144c8 <netif_list>>,%d2
80010832:	1d 00 6f 00 	j 80010910 <dhcp_coarse_tmr+0xf0>
    /* only act on DHCP configured interfaces */
    struct dhcp *dhcp = netif_dhcp_data(netif);
80010836:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001083a:	d9 22 20 00 	lea %a2,[%a2]32
8001083e:	54 22       	ld.w %d2,[%a2]
80010840:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    if ((dhcp != NULL) && (dhcp->state != DHCP_STATE_OFF)) {
80010844:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80010848:	df 02 5f 00 	jeq %d2,0,80010906 <dhcp_coarse_tmr+0xe6>
8001084c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010850:	39 22 05 00 	ld.bu %d2,[%a2]5
80010854:	df 02 59 00 	jeq %d2,0,80010906 <dhcp_coarse_tmr+0xe6>
      /* compare lease time to expire timeout */
      if (dhcp->t0_timeout && (++dhcp->lease_used == dhcp->t0_timeout)) {
80010858:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001085c:	b9 22 14 00 	ld.hu %d2,[%a2]20
80010860:	df 02 21 00 	jeq %d2,0,800108a2 <dhcp_coarse_tmr+0x82>
80010864:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010868:	b9 22 12 00 	ld.hu %d2,[%a2]18
8001086c:	c2 12       	add %d2,1
8001086e:	37 02 70 20 	extr.u %d2,%d2,0,16
80010872:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010876:	f9 22 12 00 	st.h [%a2]18,%d2
8001087a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001087e:	b9 23 12 00 	ld.hu %d3,[%a2]18
80010882:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010886:	b9 22 14 00 	ld.hu %d2,[%a2]20
8001088a:	5f 23 0c 80 	jne %d3,%d2,800108a2 <dhcp_coarse_tmr+0x82>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t0 timeout\n"));
        /* this clients' lease time has expired */
        dhcp_release_and_stop(netif);
8001088e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80010892:	6d 00 0b 0a 	call 80011ca8 <dhcp_release_and_stop>
        dhcp_start(netif);
80010896:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001089a:	6d 00 b6 02 	call 80010e06 <dhcp_start>
8001089e:	1d 00 34 00 	j 80010906 <dhcp_coarse_tmr+0xe6>
        /* timer is active (non zero), and triggers (zeroes) now? */
      } else if (dhcp->t2_rebind_time && (dhcp->t2_rebind_time-- == 1)) {
800108a2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800108a6:	b9 22 10 00 	ld.hu %d2,[%a2]16
800108aa:	df 02 16 00 	jeq %d2,0,800108d6 <dhcp_coarse_tmr+0xb6>
800108ae:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800108b2:	b9 22 10 00 	ld.hu %d2,[%a2]16
800108b6:	1b f2 ff 3f 	addi %d3,%d2,-1
800108ba:	37 03 70 30 	extr.u %d3,%d3,0,16
800108be:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800108c2:	f9 23 10 00 	st.h [%a2]16,%d3
800108c6:	df 12 08 80 	jne %d2,1,800108d6 <dhcp_coarse_tmr+0xb6>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
800108ca:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800108ce:	6d 00 26 01 	call 80010b1a <dhcp_t2_timeout>
800108d2:	1d 00 1a 00 	j 80010906 <dhcp_coarse_tmr+0xe6>
        /* timer is active (non zero), and triggers (zeroes) now */
      } else if (dhcp->t1_renew_time && (dhcp->t1_renew_time-- == 1)) {
800108d6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800108da:	b9 22 0e 00 	ld.hu %d2,[%a2]14
800108de:	df 02 14 00 	jeq %d2,0,80010906 <dhcp_coarse_tmr+0xe6>
800108e2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800108e6:	b9 22 0e 00 	ld.hu %d2,[%a2]14
800108ea:	1b f2 ff 3f 	addi %d3,%d2,-1
800108ee:	37 03 70 30 	extr.u %d3,%d3,0,16
800108f2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800108f6:	f9 23 0e 00 	st.h [%a2]14,%d3
800108fa:	df 12 06 80 	jne %d2,1,80010906 <dhcp_coarse_tmr+0xe6>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
800108fe:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80010902:	6d 00 c5 00 	call 80010a8c <dhcp_t1_timeout>
  NETIF_FOREACH(netif) {
80010906:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001090a:	54 22       	ld.w %d2,[%a2]
8001090c:	59 e2 fc ff 	st.w [%a14]-4,%d2
80010910:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80010914:	df 02 91 ff 	jne %d2,0,80010836 <dhcp_coarse_tmr+0x16>
      }
    }
  }
}
80010918:	00 00       	nop 
8001091a:	00 00       	nop 
8001091c:	00 90       	ret 

8001091e <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr(void)
{
8001091e:	40 ae       	mov.aa %a14,%sp
80010920:	20 08       	sub.a %sp,8
  struct netif *netif;
  /* loop through netif's */
  NETIF_FOREACH(netif) {
80010922:	91 10 00 27 	movh.a %a2,28673
80010926:	d9 22 48 34 	lea %a2,[%a2]17608 <700144c8 <netif_list>>
8001092a:	54 22       	ld.w %d2,[%a2]
8001092c:	59 e2 fc ff 	st.w [%a14]-4 <700144c8 <netif_list>>,%d2
80010930:	1d 00 3a 00 	j 800109a4 <dhcp_fine_tmr+0x86>
    struct dhcp *dhcp = netif_dhcp_data(netif);
80010934:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010938:	d9 22 20 00 	lea %a2,[%a2]32
8001093c:	54 22       	ld.w %d2,[%a2]
8001093e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    /* only act on DHCP configured interfaces */
    if (dhcp != NULL) {
80010942:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80010946:	df 02 2a 00 	jeq %d2,0,8001099a <dhcp_fine_tmr+0x7c>
      /* timer is active (non zero), and is about to trigger now */
      if (dhcp->request_timeout > 1) {
8001094a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001094e:	b9 22 08 00 	ld.hu %d2,[%a2]8
80010952:	bf 22 0f 80 	jlt.u %d2,2,80010970 <dhcp_fine_tmr+0x52>
        dhcp->request_timeout--;
80010956:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001095a:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001095e:	c2 f2       	add %d2,-1
80010960:	37 02 70 20 	extr.u %d2,%d2,0,16
80010964:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010968:	f9 22 08 00 	st.h [%a2]8,%d2
8001096c:	1d 00 17 00 	j 8001099a <dhcp_fine_tmr+0x7c>
      } else if (dhcp->request_timeout == 1) {
80010970:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010974:	b9 22 08 00 	ld.hu %d2,[%a2]8
80010978:	df 12 11 80 	jne %d2,1,8001099a <dhcp_fine_tmr+0x7c>
        dhcp->request_timeout--;
8001097c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80010980:	b9 22 08 00 	ld.hu %d2,[%a2]8
80010984:	c2 f2       	add %d2,-1
80010986:	37 02 70 20 	extr.u %d2,%d2,0,16
8001098a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001098e:	f9 22 08 00 	st.h [%a2]8,%d2
        /* { dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
80010992:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80010996:	6d 00 0e 00 	call 800109b2 <dhcp_timeout>
  NETIF_FOREACH(netif) {
8001099a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001099e:	54 22       	ld.w %d2,[%a2]
800109a0:	59 e2 fc ff 	st.w [%a14]-4,%d2
800109a4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800109a8:	df 02 c6 ff 	jne %d2,0,80010934 <dhcp_fine_tmr+0x16>
      }
    }
  }
}
800109ac:	00 00       	nop 
800109ae:	00 00       	nop 
800109b0:	00 90       	ret 

800109b2 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
800109b2:	40 ae       	mov.aa %a14,%sp
800109b4:	20 10       	sub.a %sp,16
800109b6:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
800109ba:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800109be:	d9 22 20 00 	lea %a2,[%a2]32
800109c2:	54 22       	ld.w %d2,[%a2]
800109c4:	59 e2 fc ff 	st.w [%a14]-4,%d2

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
800109c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800109cc:	39 22 05 00 	ld.bu %d2,[%a2]5
800109d0:	8b c2 00 22 	eq %d2,%d2,12
800109d4:	df 02 08 80 	jne %d2,0,800109e4 <dhcp_timeout+0x32>
800109d8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800109dc:	39 22 05 00 	ld.bu %d2,[%a2]5
800109e0:	df 62 08 80 	jne %d2,6,800109f0 <dhcp_timeout+0x3e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
800109e4:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800109e8:	6d 00 f7 03 	call 800111d6 <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
800109ec:	1d 00 4e 00 	j 80010a88 <dhcp_timeout+0xd6>
  } else if (dhcp->state == DHCP_STATE_REQUESTING) {
800109f0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800109f4:	39 22 05 00 	ld.bu %d2,[%a2]5
800109f8:	df 12 18 80 	jne %d2,1,80010a28 <dhcp_timeout+0x76>
    if (dhcp->tries <= 5) {
800109fc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010a00:	39 22 06 00 	ld.bu %d2,[%a2]6
80010a04:	ff 62 08 80 	jge.u %d2,6,80010a14 <dhcp_timeout+0x62>
      dhcp_select(netif);
80010a08:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010a0c:	6d ff 87 fd 	call 8001051a <dhcp_select>
}
80010a10:	1d 00 3c 00 	j 80010a88 <dhcp_timeout+0xd6>
      dhcp_release_and_stop(netif);
80010a14:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010a18:	6d 00 48 09 	call 80011ca8 <dhcp_release_and_stop>
      dhcp_start(netif);
80010a1c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010a20:	6d 00 f3 01 	call 80010e06 <dhcp_start>
}
80010a24:	1d 00 32 00 	j 80010a88 <dhcp_timeout+0xd6>
  } else if (dhcp->state == DHCP_STATE_CHECKING) {
80010a28:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010a2c:	39 22 05 00 	ld.bu %d2,[%a2]5
80010a30:	8b 82 20 22 	ne %d2,%d2,8
80010a34:	df 02 14 80 	jne %d2,0,80010a5c <dhcp_timeout+0xaa>
    if (dhcp->tries <= 1) {
80010a38:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010a3c:	39 22 06 00 	ld.bu %d2,[%a2]6
80010a40:	ff 22 08 80 	jge.u %d2,2,80010a50 <dhcp_timeout+0x9e>
      dhcp_check(netif);
80010a44:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010a48:	6d ff d7 fc 	call 800103f6 <dhcp_check>
}
80010a4c:	1d 00 1e 00 	j 80010a88 <dhcp_timeout+0xd6>
      dhcp_bind(netif);
80010a50:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010a54:	6d 00 b4 04 	call 800113bc <dhcp_bind>
}
80010a58:	1d 00 18 00 	j 80010a88 <dhcp_timeout+0xd6>
  } else if (dhcp->state == DHCP_STATE_REBOOTING) {
80010a5c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010a60:	39 22 05 00 	ld.bu %d2,[%a2]5
80010a64:	df 32 12 80 	jne %d2,3,80010a88 <dhcp_timeout+0xd6>
    if (dhcp->tries < REBOOT_TRIES) {
80010a68:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010a6c:	39 22 06 00 	ld.bu %d2,[%a2]6
80010a70:	ff 22 08 80 	jge.u %d2,2,80010a80 <dhcp_timeout+0xce>
      dhcp_reboot(netif);
80010a74:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010a78:	6d 00 fd 07 	call 80011a72 <dhcp_reboot>
}
80010a7c:	1d 00 06 00 	j 80010a88 <dhcp_timeout+0xd6>
      dhcp_discover(netif);
80010a80:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010a84:	6d 00 a9 03 	call 800111d6 <dhcp_discover>
}
80010a88:	00 00       	nop 
80010a8a:	00 90       	ret 

80010a8c <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
80010a8c:	40 ae       	mov.aa %a14,%sp
80010a8e:	20 10       	sub.a %sp,16
80010a90:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
80010a94:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010a98:	d9 22 20 00 	lea %a2,[%a2]32
80010a9c:	54 22       	ld.w %d2,[%a2]
80010a9e:	59 e2 fc ff 	st.w [%a14]-4,%d2

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
80010aa2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010aa6:	39 22 05 00 	ld.bu %d2,[%a2]5
80010aaa:	df 12 10 00 	jeq %d2,1,80010aca <dhcp_t1_timeout+0x3e>
80010aae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010ab2:	39 22 05 00 	ld.bu %d2,[%a2]5
80010ab6:	8b a2 00 22 	eq %d2,%d2,10
80010aba:	df 02 08 80 	jne %d2,0,80010aca <dhcp_t1_timeout+0x3e>
      (dhcp->state == DHCP_STATE_RENEWING)) {
80010abe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010ac2:	39 22 05 00 	ld.bu %d2,[%a2]5
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
80010ac6:	df 52 28 80 	jne %d2,5,80010b16 <dhcp_t1_timeout+0x8a>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_STATE_RENEWING, not DHCP_STATE_BOUND */
    dhcp_renew(netif);
80010aca:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010ace:	6d 00 e3 05 	call 80011694 <dhcp_renew>
    /* Calculate next timeout */
    if (((dhcp->t2_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
80010ad2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010ad6:	b9 22 0c 00 	ld.hu %d2,[%a2]12
80010ada:	02 23       	mov %d3,%d2
80010adc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010ae0:	b9 22 12 00 	ld.hu %d2,[%a2]18
80010ae4:	0b 23 80 20 	sub %d2,%d3,%d2
80010ae8:	bf 22 17 00 	jlt %d2,2,80010b16 <dhcp_t1_timeout+0x8a>
      dhcp->t1_renew_time = (u16_t)((dhcp->t2_timeout - dhcp->lease_used) / 2);
80010aec:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010af0:	b9 22 0c 00 	ld.hu %d2,[%a2]12
80010af4:	02 23       	mov %d3,%d2
80010af6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010afa:	b9 22 12 00 	ld.hu %d2,[%a2]18
80010afe:	0b 23 80 20 	sub %d2,%d3,%d2
80010b02:	8f 12 1e 30 	sh %d3,%d2,-31
80010b06:	42 32       	add %d2,%d3
80010b08:	86 f2       	sha %d2,-1
80010b0a:	37 02 70 20 	extr.u %d2,%d2,0,16
80010b0e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b12:	f9 22 0e 00 	st.h [%a2]14,%d2
    }
  }
}
80010b16:	00 00       	nop 
80010b18:	00 90       	ret 

80010b1a <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
80010b1a:	40 ae       	mov.aa %a14,%sp
80010b1c:	20 10       	sub.a %sp,16
80010b1e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
80010b22:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010b26:	d9 22 20 00 	lea %a2,[%a2]32
80010b2a:	54 22       	ld.w %d2,[%a2]
80010b2c:	59 e2 fc ff 	st.w [%a14]-4,%d2

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
80010b30:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b34:	39 22 05 00 	ld.bu %d2,[%a2]5
80010b38:	df 12 16 00 	jeq %d2,1,80010b64 <dhcp_t2_timeout+0x4a>
80010b3c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b40:	39 22 05 00 	ld.bu %d2,[%a2]5
80010b44:	8b a2 00 22 	eq %d2,%d2,10
80010b48:	df 02 0e 80 	jne %d2,0,80010b64 <dhcp_t2_timeout+0x4a>
      (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
80010b4c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b50:	39 22 05 00 	ld.bu %d2,[%a2]5
  if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
80010b54:	df 52 08 00 	jeq %d2,5,80010b64 <dhcp_t2_timeout+0x4a>
      (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
80010b58:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b5c:	39 22 05 00 	ld.bu %d2,[%a2]5
80010b60:	df 42 28 80 	jne %d2,4,80010bb0 <dhcp_t2_timeout+0x96>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_STATE_REBINDING, not DHCP_STATE_BOUND */
    dhcp_rebind(netif);
80010b64:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010b68:	6d 00 8e 06 	call 80011884 <dhcp_rebind>
    /* Calculate next timeout */
    if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
80010b6c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b70:	b9 22 14 00 	ld.hu %d2,[%a2]20
80010b74:	02 23       	mov %d3,%d2
80010b76:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b7a:	b9 22 12 00 	ld.hu %d2,[%a2]18
80010b7e:	0b 23 80 20 	sub %d2,%d3,%d2
80010b82:	bf 22 17 00 	jlt %d2,2,80010bb0 <dhcp_t2_timeout+0x96>
      dhcp->t2_rebind_time = (u16_t)((dhcp->t0_timeout - dhcp->lease_used) / 2);
80010b86:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b8a:	b9 22 14 00 	ld.hu %d2,[%a2]20
80010b8e:	02 23       	mov %d3,%d2
80010b90:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010b94:	b9 22 12 00 	ld.hu %d2,[%a2]18
80010b98:	0b 23 80 20 	sub %d2,%d3,%d2
80010b9c:	8f 12 1e 30 	sh %d3,%d2,-31
80010ba0:	42 32       	add %d2,%d3
80010ba2:	86 f2       	sha %d2,-1
80010ba4:	37 02 70 20 	extr.u %d2,%d2,0,16
80010ba8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010bac:	f9 22 10 00 	st.h [%a2]16,%d2
    }
  }
}
80010bb0:	00 00       	nop 
80010bb2:	00 90       	ret 

80010bb4 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif, struct dhcp_msg *msg_in)
{
80010bb4:	40 ae       	mov.aa %a14,%sp
80010bb6:	20 10       	sub.a %sp,16
80010bb8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80010bbc:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct dhcp *dhcp = netif_dhcp_data(netif);
80010bc0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010bc4:	d9 22 20 00 	lea %a2,[%a2]32
80010bc8:	54 22       	ld.w %d2,[%a2]
80010bca:	59 e2 fc ff 	st.w [%a14]-4,%d2
#if LWIP_DHCP_GET_NTP_SRV
  ip4_addr_t ntp_server_addrs[LWIP_DHCP_MAX_NTP_SERVERS];
#endif

  /* clear options we might not get from the ACK */
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
80010bce:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010bd2:	82 02       	mov %d2,0
80010bd4:	d9 22 20 00 	lea %a2,[%a2]32
80010bd8:	74 22       	st.w [%a2],%d2
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
80010bda:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010bde:	82 02       	mov %d2,0
80010be0:	d9 22 24 00 	lea %a2,[%a2]36
80010be4:	74 22       	st.w [%a2],%d2
#if LWIP_DHCP_BOOTP_FILE
  ip4_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
80010be6:	91 10 00 27 	movh.a %a2,28673
80010bea:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80010bee:	39 22 03 00 	ld.bu %d2,[%a2]3 <70010003 <ram_heap+0x4f6f>>
80010bf2:	df 02 0e 00 	jeq %d2,0,80010c0e <dhcp_handle_ack+0x5a>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
80010bf6:	91 10 00 27 	movh.a %a2,28673
80010bfa:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
80010bfe:	d9 22 0c 00 	lea %a2,[%a2]12 <7001000c <ram_heap+0x4f78>>
80010c02:	54 22       	ld.w %d2,[%a2]
80010c04:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <7001000c <ram_heap+0x4f78>>
80010c08:	d9 22 28 00 	lea %a2,[%a2]40 <7001000c <ram_heap+0x4f78>>
80010c0c:	74 22       	st.w [%a2],%d2
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
80010c0e:	91 10 00 27 	movh.a %a2,28673
80010c12:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80010c16:	39 22 04 00 	ld.bu %d2,[%a2]4 <70010004 <ram_heap+0x4f70>>
80010c1a:	df 02 10 00 	jeq %d2,0,80010c3a <dhcp_handle_ack+0x86>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
80010c1e:	91 10 00 27 	movh.a %a2,28673
80010c22:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
80010c26:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80010c2a:	54 22       	ld.w %d2,[%a2]
80010c2c:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <70010010 <ram_heap+0x4f7c>>
80010c30:	d9 22 2c 00 	lea %a2,[%a2]44 <70010010 <ram_heap+0x4f7c>>
80010c34:	74 22       	st.w [%a2],%d2
80010c36:	1d 00 0d 00 	j 80010c50 <dhcp_handle_ack+0x9c>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
80010c3a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010c3e:	d9 22 28 00 	lea %a2,[%a2]40
80010c42:	54 22       	ld.w %d2,[%a2]
80010c44:	06 f2       	sh %d2,-1
80010c46:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010c4a:	d9 22 2c 00 	lea %a2,[%a2]44
80010c4e:	74 22       	st.w [%a2],%d2
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
80010c50:	91 10 00 27 	movh.a %a2,28673
80010c54:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80010c58:	39 22 05 00 	ld.bu %d2,[%a2]5 <70010005 <ram_heap+0x4f71>>
80010c5c:	df 02 10 00 	jeq %d2,0,80010c7c <dhcp_handle_ack+0xc8>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
80010c60:	91 10 00 27 	movh.a %a2,28673
80010c64:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
80010c68:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80010c6c:	54 22       	ld.w %d2,[%a2]
80010c6e:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <70010014 <ram_heap+0x4f80>>
80010c72:	d9 22 30 00 	lea %a2,[%a2]48 <70010014 <ram_heap+0x4f80>>
80010c76:	74 22       	st.w [%a2],%d2
80010c78:	1d 00 0f 00 	j 80010c96 <dhcp_handle_ack+0xe2>
  } else {
    /* calculate safe periods for rebinding (offered_t0_lease * 0.875 -> 87.5%)*/
    dhcp->offered_t2_rebind = (dhcp->offered_t0_lease * 7U) / 8U;
80010c7c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010c80:	d9 22 28 00 	lea %a2,[%a2]40
80010c84:	54 22       	ld.w %d2,[%a2]
80010c86:	53 72 20 20 	mul %d2,%d2,7
80010c8a:	06 d2       	sh %d2,-3
80010c8c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010c90:	d9 22 30 00 	lea %a2,[%a2]48
80010c94:	74 22       	st.w [%a2],%d2
  }

  /* (y)our internet address */
  ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
80010c96:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80010c9a:	39 23 10 00 	ld.bu %d3,[%a2]16
80010c9e:	39 22 11 00 	ld.bu %d2,[%a2]17
80010ca2:	8f 82 00 20 	sh %d2,%d2,8
80010ca6:	a6 32       	or %d2,%d3
80010ca8:	39 23 12 00 	ld.bu %d3,[%a2]18
80010cac:	8f 03 01 30 	sh %d3,%d3,16
80010cb0:	a6 32       	or %d2,%d3
80010cb2:	39 23 13 00 	ld.bu %d3,[%a2]19
80010cb6:	8f 83 01 30 	sh %d3,%d3,24
80010cba:	a6 32       	or %d2,%d3
80010cbc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010cc0:	d9 22 1c 00 	lea %a2,[%a2]28
80010cc4:	74 22       	st.w [%a2],%d2
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip4_addr_copy(dhcp->offered_si_addr, msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
80010cc6:	91 10 00 27 	movh.a %a2,28673
80010cca:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80010cce:	39 22 06 00 	ld.bu %d2,[%a2]6 <70010006 <ram_heap+0x4f72>>
80010cd2:	df 02 18 00 	jeq %d2,0,80010d02 <dhcp_handle_ack+0x14e>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
80010cd6:	91 10 00 27 	movh.a %a2,28673
80010cda:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
80010cde:	d9 22 18 00 	lea %a2,[%a2]24 <70010018 <ram_heap+0x4f84>>
80010ce2:	54 22       	ld.w %d2,[%a2]
80010ce4:	02 24       	mov %d4,%d2
80010ce6:	6d 00 4f 34 	call 80017584 <lwip_htonl>
80010cea:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010cee:	d9 22 20 00 	lea %a2,[%a2]32
80010cf2:	74 22       	st.w [%a2],%d2
    dhcp->subnet_mask_given = 1;
80010cf4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010cf8:	82 12       	mov %d2,1
80010cfa:	e9 22 07 00 	st.b [%a2]7,%d2
80010cfe:	1d 00 07 00 	j 80010d0c <dhcp_handle_ack+0x158>
  } else {
    dhcp->subnet_mask_given = 0;
80010d02:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010d06:	82 02       	mov %d2,0
80010d08:	e9 22 07 00 	st.b [%a2]7,%d2
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
80010d0c:	91 10 00 27 	movh.a %a2,28673
80010d10:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80010d14:	39 22 07 00 	ld.bu %d2,[%a2]7 <70010007 <ram_heap+0x4f73>>
80010d18:	df 02 11 00 	jeq %d2,0,80010d3a <dhcp_handle_ack+0x186>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
80010d1c:	91 10 00 27 	movh.a %a2,28673
80010d20:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
80010d24:	d9 22 1c 00 	lea %a2,[%a2]28 <7001001c <ram_heap+0x4f88>>
80010d28:	54 22       	ld.w %d2,[%a2]
80010d2a:	02 24       	mov %d4,%d2
80010d2c:	6d 00 2c 34 	call 80017584 <lwip_htonl>
80010d30:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010d34:	d9 22 24 00 	lea %a2,[%a2]36
80010d38:	74 22       	st.w [%a2],%d2
    ip_addr_t dns_addr;
    ip_addr_set_ip4_u32_val(dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
    dns_setserver(n, &dns_addr);
  }
#endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
}
80010d3a:	00 00       	nop 
80010d3c:	00 90       	ret 

80010d3e <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
80010d3e:	40 ae       	mov.aa %a14,%sp
80010d40:	20 18       	sub.a %sp,24
80010d42:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80010d46:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("netif != NULL", netif != NULL);
80010d4a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80010d4e:	df 02 17 80 	jne %d2,0,80010d7c <dhcp_set_struct+0x3e>
80010d52:	91 00 00 28 	movh.a %a2,32768
80010d56:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80010d5a:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010d5e:	3b 50 2b 20 	mov %d2,693
80010d62:	59 a2 04 00 	st.w [%sp]4,%d2
80010d66:	91 00 00 28 	movh.a %a2,32768
80010d6a:	d9 22 b7 a0 	lea %a2,[%a2]2743 <80000ab7 <IfxCpu_Trap_vectorTable0_end+0x8c3>>
80010d6e:	f4 a2       	st.a [%sp],%a2
80010d70:	91 00 00 28 	movh.a %a2,32768
80010d74:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80010d78:	6d ff df a2 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
80010d7c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80010d80:	df 02 17 80 	jne %d2,0,80010dae <dhcp_set_struct+0x70>
80010d84:	91 00 00 28 	movh.a %a2,32768
80010d88:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80010d8c:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010d90:	3b 60 2b 20 	mov %d2,694
80010d94:	59 a2 04 00 	st.w [%sp]4,%d2
80010d98:	91 00 00 28 	movh.a %a2,32768
80010d9c:	d9 22 85 b0 	lea %a2,[%a2]2757 <80000ac5 <IfxCpu_Trap_vectorTable0_end+0x8d1>>
80010da0:	f4 a2       	st.a [%sp],%a2
80010da2:	91 00 00 28 	movh.a %a2,32768
80010da6:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80010daa:	6d ff c6 a2 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("netif already has a struct dhcp set", netif_dhcp_data(netif) == NULL);
80010dae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010db2:	d9 22 20 00 	lea %a2,[%a2]32
80010db6:	54 22       	ld.w %d2,[%a2]
80010db8:	df 02 17 00 	jeq %d2,0,80010de6 <dhcp_set_struct+0xa8>
80010dbc:	91 00 00 28 	movh.a %a2,32768
80010dc0:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80010dc4:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010dc8:	3b 70 2b 20 	mov %d2,695
80010dcc:	59 a2 04 00 	st.w [%sp]4,%d2
80010dd0:	91 00 00 28 	movh.a %a2,32768
80010dd4:	d9 22 92 b0 	lea %a2,[%a2]2770 <80000ad2 <IfxCpu_Trap_vectorTable0_end+0x8de>>
80010dd8:	f4 a2       	st.a [%sp],%a2
80010dda:	91 00 00 28 	movh.a %a2,32768
80010dde:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80010de2:	6d ff aa a2 	call 80005336 <Ifx_Lwip_printf>

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
80010de6:	3b 40 03 50 	mov %d5,52
80010dea:	82 04       	mov %d4,0
80010dec:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80010df0:	6d 00 20 b2 	call 80027230 <memset>
  /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */
  netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
80010df4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010df8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80010dfc:	d9 22 20 00 	lea %a2,[%a2]32
80010e00:	74 22       	st.w [%a2],%d2
}
80010e02:	00 00       	nop 
80010e04:	00 90       	ret 

80010e06 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
80010e06:	40 ae       	mov.aa %a14,%sp
80010e08:	20 20       	sub.a %sp,32
80010e0a:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct dhcp *dhcp;
  err_t result;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
80010e0e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80010e12:	df 02 1a 80 	jne %d2,0,80010e46 <dhcp_start+0x40>
80010e16:	91 00 00 28 	movh.a %a2,32768
80010e1a:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80010e1e:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010e22:	3b 70 2e 20 	mov %d2,743
80010e26:	59 a2 04 00 	st.w [%sp]4,%d2
80010e2a:	91 00 00 28 	movh.a %a2,32768
80010e2e:	d9 22 b7 a0 	lea %a2,[%a2]2743 <80000ab7 <IfxCpu_Trap_vectorTable0_end+0x8c3>>
80010e32:	f4 a2       	st.a [%sp],%a2
80010e34:	91 00 00 28 	movh.a %a2,32768
80010e38:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80010e3c:	6d ff 7d a2 	call 80005336 <Ifx_Lwip_printf>
80010e40:	3b 00 ff 2f 	mov %d2,-16
80010e44:	00 90       	ret 
  LWIP_ERROR("netif is not up, old style port?", netif_is_up(netif), return ERR_ARG;);
80010e46:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010e4a:	39 22 31 00 	ld.bu %d2,[%a2]49
80010e4e:	8f 12 00 21 	and %d2,%d2,1
80010e52:	df 02 1a 80 	jne %d2,0,80010e86 <dhcp_start+0x80>
80010e56:	91 00 00 28 	movh.a %a2,32768
80010e5a:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80010e5e:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010e62:	3b 80 2e 20 	mov %d2,744
80010e66:	59 a2 04 00 	st.w [%sp]4,%d2
80010e6a:	91 00 00 28 	movh.a %a2,32768
80010e6e:	d9 22 b6 b0 	lea %a2,[%a2]2806 <80000af6 <IfxCpu_Trap_vectorTable0_end+0x902>>
80010e72:	f4 a2       	st.a [%sp],%a2
80010e74:	91 00 00 28 	movh.a %a2,32768
80010e78:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80010e7c:	6d ff 5d a2 	call 80005336 <Ifx_Lwip_printf>
80010e80:	3b 00 ff 2f 	mov %d2,-16
80010e84:	00 90       	ret 
  dhcp = netif_dhcp_data(netif);
80010e86:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010e8a:	d9 22 20 00 	lea %a2,[%a2]32
80010e8e:	54 22       	ld.w %d2,[%a2]
80010e90:	59 e2 fc ff 	st.w [%a14]-4,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
80010e94:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010e98:	b9 22 28 00 	ld.hu %d2,[%a2]40
80010e9c:	3b 00 24 30 	mov %d3,576
80010ea0:	7f 32 04 80 	jge.u %d2,%d3,80010ea8 <dhcp_start+0xa2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
80010ea4:	82 f2       	mov %d2,-1
80010ea6:	00 90       	ret 
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
80010ea8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80010eac:	df 02 17 80 	jne %d2,0,80010eda <dhcp_start+0xd4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): mallocing new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
80010eb0:	3b 40 03 40 	mov %d4,52
80010eb4:	6d 00 87 3a 	call 800183c2 <mem_malloc>
80010eb8:	b5 e2 fc ff 	st.a [%a14]-4,%a2
    if (dhcp == NULL) {
80010ebc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80010ec0:	df 02 04 80 	jne %d2,0,80010ec8 <dhcp_start+0xc2>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
80010ec4:	82 f2       	mov %d2,-1
80010ec6:	00 90       	ret 
    }

    /* store this dhcp client in the netif */
    netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
80010ec8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010ecc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80010ed0:	d9 22 20 00 	lea %a2,[%a2]32
80010ed4:	74 22       	st.w [%a2],%d2
80010ed6:	1d 00 0a 00 	j 80010eea <dhcp_start+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
    /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));

    if (dhcp->pcb_allocated != 0) {
80010eda:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010ede:	39 22 04 00 	ld.bu %d2,[%a2]4
80010ee2:	df 02 04 00 	jeq %d2,0,80010eea <dhcp_start+0xe4>
      dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
80010ee6:	6d ff 1f fa 	call 80010324 <dhcp_dec_pcb_refcount>
    }
    /* dhcp is cleared below, no need to reset flag*/
  }

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
80010eea:	3b 40 03 50 	mov %d5,52
80010eee:	82 04       	mov %d4,0
80010ef0:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80010ef4:	6d 00 9e b1 	call 80027230 <memset>
  /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));

  if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
80010ef8:	6d ff 96 f9 	call 80010224 <dhcp_inc_pcb_refcount>
80010efc:	df 02 04 00 	jeq %d2,0,80010f04 <dhcp_start+0xfe>
    return ERR_MEM;
80010f00:	82 f2       	mov %d2,-1
80010f02:	00 90       	ret 
  }
  dhcp->pcb_allocated = 1;
80010f04:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010f08:	82 12       	mov %d2,1
80010f0a:	e9 22 04 00 	st.b [%a2]4,%d2

  if (!netif_is_link_up(netif)) {
80010f0e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010f12:	39 22 31 00 	ld.bu %d2,[%a2]49
80010f16:	8f 42 00 21 	and %d2,%d2,4
80010f1a:	df 02 09 80 	jne %d2,0,80010f2c <dhcp_start+0x126>
    /* set state INIT and wait for dhcp_network_changed() to call dhcp_discover() */
    dhcp_set_state(dhcp, DHCP_STATE_INIT);
80010f1e:	82 24       	mov %d4,2
80010f20:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80010f24:	6d 00 b5 07 	call 80011e8e <dhcp_set_state>
    return ERR_OK;
80010f28:	82 02       	mov %d2,0
80010f2a:	00 90       	ret 
  }

  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
80010f2c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010f30:	6d 00 53 01 	call 800111d6 <dhcp_discover>
80010f34:	e9 e2 fb ff 	st.b [%a14]-5,%d2
  if (result != ERR_OK) {
80010f38:	79 e2 fb ff 	ld.b %d2,[%a14]-5
80010f3c:	df 02 08 00 	jeq %d2,0,80010f4c <dhcp_start+0x146>
    /* free resources allocated above */
    dhcp_release_and_stop(netif);
80010f40:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010f44:	6d 00 b2 06 	call 80011ca8 <dhcp_release_and_stop>
    return ERR_MEM;
80010f48:	82 f2       	mov %d2,-1
80010f4a:	00 90       	ret 
  }
  return result;
80010f4c:	79 e2 fb ff 	ld.b %d2,[%a14]-5
}
80010f50:	00 90       	ret 

80010f52 <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
80010f52:	40 ae       	mov.aa %a14,%sp
80010f54:	20 20       	sub.a %sp,32
80010f56:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
80010f5a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80010f5e:	d9 22 20 00 	lea %a2,[%a2]32
80010f62:	54 22       	ld.w %d2,[%a2]
80010f64:	59 e2 fc ff 	st.w [%a14]-4,%d2

  if (!dhcp) {
80010f68:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80010f6c:	df 02 44 00 	jeq %d2,0,80010ff4 <dhcp_network_changed+0xa2>
    return;
  }
  switch (dhcp->state) {
80010f70:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010f74:	39 22 05 00 	ld.bu %d2,[%a2]5
80010f78:	8b a2 00 32 	eq %d3,%d2,10
80010f7c:	df 03 0d 80 	jne %d3,0,80010f96 <dhcp_network_changed+0x44>
80010f80:	8b b2 80 32 	ge %d3,%d2,11
80010f84:	df 03 13 80 	jne %d3,0,80010faa <dhcp_network_changed+0x58>
80010f88:	df 02 38 00 	jeq %d2,0,80010ff8 <dhcp_network_changed+0xa6>
80010f8c:	bf 02 0f 00 	jlt %d2,0,80010faa <dhcp_network_changed+0x58>
80010f90:	c2 d2       	add %d2,-3
80010f92:	ff 32 0c 80 	jge.u %d2,3,80010faa <dhcp_network_changed+0x58>
    case DHCP_STATE_REBINDING:
    case DHCP_STATE_RENEWING:
    case DHCP_STATE_BOUND:
    case DHCP_STATE_REBOOTING:
      dhcp->tries = 0;
80010f96:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010f9a:	82 02       	mov %d2,0
80010f9c:	e9 22 06 00 	st.b [%a2]6,%d2
      dhcp_reboot(netif);
80010fa0:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010fa4:	6d 00 67 05 	call 80011a72 <dhcp_reboot>
      break;
80010fa8:	00 90       	ret 
    case DHCP_STATE_OFF:
      /* stay off */
      break;
    default:
      LWIP_ASSERT("invalid dhcp->state", dhcp->state <= DHCP_STATE_BACKING_OFF);
80010faa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010fae:	39 22 05 00 	ld.bu %d2,[%a2]5
80010fb2:	bf d2 17 80 	jlt.u %d2,13,80010fe0 <dhcp_network_changed+0x8e>
80010fb6:	91 00 00 28 	movh.a %a2,32768
80010fba:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80010fbe:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80010fc2:	3b d0 36 20 	mov %d2,877
80010fc6:	59 a2 04 00 	st.w [%sp]4,%d2
80010fca:	91 00 00 28 	movh.a %a2,32768
80010fce:	d9 22 97 c0 	lea %a2,[%a2]2839 <80000b17 <IfxCpu_Trap_vectorTable0_end+0x923>>
80010fd2:	f4 a2       	st.a [%sp],%a2
80010fd4:	91 00 00 28 	movh.a %a2,32768
80010fd8:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80010fdc:	6d ff ad a1 	call 80005336 <Ifx_Lwip_printf>
        autoip_stop(netif);
        dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
      }
#endif /* LWIP_DHCP_AUTOIP_COOP */
      /* ensure we start with short timeouts, even if already discovering */
      dhcp->tries = 0;
80010fe0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80010fe4:	82 02       	mov %d2,0
80010fe6:	e9 22 06 00 	st.b [%a2]6,%d2
      dhcp_discover(netif);
80010fea:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80010fee:	6d 00 f4 00 	call 800111d6 <dhcp_discover>
      break;
80010ff2:	00 90       	ret 
    return;
80010ff4:	00 00       	nop 
80010ff6:	00 90       	ret 
      break;
80010ff8:	00 00       	nop 
  }
}
80010ffa:	00 90       	ret 

80010ffc <dhcp_arp_reply>:
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void
dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr)
{
80010ffc:	40 ae       	mov.aa %a14,%sp
80010ffe:	20 20       	sub.a %sp,32
80011000:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80011004:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct dhcp *dhcp;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
80011008:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001100c:	df 02 18 80 	jne %d2,0,8001103c <dhcp_arp_reply+0x40>
80011010:	91 00 00 28 	movh.a %a2,32768
80011014:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80011018:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
8001101c:	3b b0 38 20 	mov %d2,907
80011020:	59 a2 04 00 	st.w [%sp]4,%d2
80011024:	91 00 00 28 	movh.a %a2,32768
80011028:	d9 22 b7 a0 	lea %a2,[%a2]2743 <80000ab7 <IfxCpu_Trap_vectorTable0_end+0x8c3>>
8001102c:	f4 a2       	st.a [%sp],%a2
8001102e:	91 00 00 28 	movh.a %a2,32768
80011032:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80011036:	6d ff 80 a1 	call 80005336 <Ifx_Lwip_printf>
8001103a:	00 90       	ret 
  dhcp = netif_dhcp_data(netif);
8001103c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80011040:	d9 22 20 00 	lea %a2,[%a2]32
80011044:	54 22       	ld.w %d2,[%a2]
80011046:	59 e2 fc ff 	st.w [%a14]-4,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((dhcp != NULL) && (dhcp->state == DHCP_STATE_CHECKING)) {
8001104a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001104e:	df 02 18 00 	jeq %d2,0,8001107e <dhcp_arp_reply+0x82>
80011052:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011056:	39 22 05 00 	ld.bu %d2,[%a2]5
8001105a:	8b 82 20 22 	ne %d2,%d2,8
8001105e:	df 02 10 80 	jne %d2,0,8001107e <dhcp_arp_reply+0x82>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
                ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip4_addr_cmp(addr, &dhcp->offered_ip_addr)) {
80011062:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80011066:	54 23       	ld.w %d3,[%a2]
80011068:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001106c:	d9 22 1c 00 	lea %a2,[%a2]28
80011070:	54 22       	ld.w %d2,[%a2]
80011072:	5f 23 06 80 	jne %d3,%d2,8001107e <dhcp_arp_reply+0x82>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
                  ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
80011076:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001107a:	6d 00 03 00 	call 80011080 <dhcp_decline>
    }
  }
}
8001107e:	00 90       	ret 

80011080 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
80011080:	40 ae       	mov.aa %a14,%sp
80011082:	20 28       	sub.a %sp,40
80011084:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
80011088:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001108c:	d9 22 20 00 	lea %a2,[%a2]32
80011090:	54 22       	ld.w %d2,[%a2]
80011092:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  u16_t msecs;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
80011096:	3b c0 00 40 	mov %d4,12
8001109a:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001109e:	6d 00 f8 06 	call 80011e8e <dhcp_set_state>
  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DECLINE, &options_out_len);
800110a2:	d9 e2 ec ff 	lea %a2,[%a14]-20
800110a6:	40 26       	mov.aa %a6,%a2
800110a8:	82 44       	mov %d4,4
800110aa:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
800110ae:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800110b2:	6d 00 37 0e 	call 80012d20 <dhcp_create_msg>
800110b6:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
  if (p_out != NULL) {
800110ba:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800110be:	df 02 5a 00 	jeq %d2,0,80011172 <dhcp_decline+0xf2>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
800110c2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800110c6:	b0 42       	add.a %a2,4
800110c8:	54 22       	ld.w %d2,[%a2]
800110ca:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
800110ce:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800110d2:	02 23       	mov %d3,%d2
800110d4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800110d8:	1b 02 0f 20 	addi %d2,%d2,240
800110dc:	82 46       	mov %d6,4
800110de:	3b 20 03 50 	mov %d5,50
800110e2:	60 24       	mov.a %a4,%d2
800110e4:	02 34       	mov %d4,%d3
800110e6:	6d 00 f4 06 	call 80011ece <dhcp_option>
800110ea:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
800110ee:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800110f2:	02 29       	mov %d9,%d2
800110f4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800110f8:	1b 02 0f 80 	addi %d8,%d2,240
800110fc:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011100:	d9 22 1c 00 	lea %a2,[%a2]28
80011104:	54 22       	ld.w %d2,[%a2]
80011106:	02 24       	mov %d4,%d2
80011108:	6d 00 3e 32 	call 80017584 <lwip_htonl>
8001110c:	02 25       	mov %d5,%d2
8001110e:	60 84       	mov.a %a4,%d8
80011110:	02 94       	mov %d4,%d9
80011112:	6d 00 b4 07 	call 8001207a <dhcp_option_long>
80011116:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_BACKING_OFF, msg_out, DHCP_DECLINE, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
8001111a:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
8001111e:	02 23       	mov %d3,%d2
80011120:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011124:	1b 02 0f 20 	addi %d2,%d2,240
80011128:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8001112c:	60 24       	mov.a %a4,%d2
8001112e:	02 34       	mov %d4,%d3
80011130:	6d 00 6e 0f 	call 8001300c <dhcp_option_trailer>

    /* per section 4.4.4, broadcast DECLINE messages */
    result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
80011134:	91 10 00 27 	movh.a %a2,28673
80011138:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
8001113c:	54 22       	ld.w %d2,[%a2]
8001113e:	91 00 00 28 	movh.a %a2,32768
80011142:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80011146:	f4 a2       	st.a [%sp],%a2
80011148:	99 e7 e4 ff 	ld.a %a7,[%a14]-28 <8000451c <ip_addr_any>>
8001114c:	3b 30 04 40 	mov %d4,67
80011150:	91 00 00 28 	movh.a %a2,32768
80011154:	d9 26 60 44 	lea %a6,[%a2]17696 <80004520 <ip_addr_broadcast>>
80011158:	99 e5 f4 ff 	ld.a %a5,[%a14]-12 <80004520 <ip_addr_broadcast>>
8001115c:	60 24       	mov.a %a4,%d2
8001115e:	6d 00 d5 a3 	call 80025908 <udp_sendto_if_src>
80011162:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    pbuf_free(p_out);
80011166:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001116a:	6d 00 17 47 	call 80019f98 <pbuf_free>
8001116e:	1d 00 05 00 	j 80011178 <dhcp_decline+0xf8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_decline: could not allocate DHCP request\n"));
    result = ERR_MEM;
80011172:	82 f2       	mov %d2,-1
80011174:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  }
  if (dhcp->tries < 255) {
80011178:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001117c:	39 22 06 00 	ld.bu %d2,[%a2]6
80011180:	8b f2 0f 22 	eq %d2,%d2,255
80011184:	df 02 0d 80 	jne %d2,0,8001119e <dhcp_decline+0x11e>
    dhcp->tries++;
80011188:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001118c:	39 22 06 00 	ld.bu %d2,[%a2]6
80011190:	c2 12       	add %d2,1
80011192:	8f f2 0f 21 	and %d2,%d2,255
80011196:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001119a:	e9 22 06 00 	st.b [%a2]6,%d2
  }
  msecs = 10 * 1000;
8001119e:	3b 00 71 22 	mov %d2,10000
800111a2:	f9 e2 ee ff 	st.h [%a14]-18,%d2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
800111a6:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
800111aa:	1b 32 1f 40 	addi %d4,%d2,499
800111ae:	7b 20 06 21 	movh %d2,4194
800111b2:	1b 32 dd 24 	addi %d2,%d2,19923
800111b6:	73 24 6a 20 	mul %e2,%d4,%d2
800111ba:	86 b3       	sha %d3,-5
800111bc:	8f 14 3e 20 	sha %d2,%d4,-31
800111c0:	0b 23 80 20 	sub %d2,%d3,%d2
800111c4:	37 02 70 20 	extr.u %d2,%d2,0,16
800111c8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800111cc:	f9 22 08 00 	st.h [%a2]8,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
800111d0:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
800111d4:	00 90       	ret 

800111d6 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
800111d6:	40 ae       	mov.aa %a14,%sp
800111d8:	20 28       	sub.a %sp,40
800111da:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
800111de:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800111e2:	d9 22 20 00 	lea %a2,[%a2]32
800111e6:	54 22       	ld.w %d2,[%a2]
800111e8:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  err_t result = ERR_OK;
800111ec:	82 02       	mov %d2,0
800111ee:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));

  ip4_addr_set_any(&dhcp->offered_ip_addr);
800111f2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800111f6:	82 02       	mov %d2,0
800111f8:	d9 22 1c 00 	lea %a2,[%a2]28
800111fc:	74 22       	st.w [%a2],%d2
  dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
800111fe:	82 64       	mov %d4,6
80011200:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80011204:	6d 00 45 06 	call 80011e8e <dhcp_set_state>
  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER, &options_out_len);
80011208:	d9 e2 e8 ff 	lea %a2,[%a14]-24
8001120c:	40 26       	mov.aa %a6,%a2
8001120e:	82 14       	mov %d4,1
80011210:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80011214:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80011218:	6d 00 84 0d 	call 80012d20 <dhcp_create_msg>
8001121c:	b5 e2 f0 ff 	st.a [%a14]-16,%a2
  if (p_out != NULL) {
80011220:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011224:	df 02 86 00 	jeq %d2,0,80011330 <dhcp_discover+0x15a>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
80011228:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001122c:	b0 42       	add.a %a2,4
8001122e:	54 22       	ld.w %d2,[%a2]
80011230:	59 e2 ec ff 	st.w [%a14]-20,%d2
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
80011234:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
80011238:	02 23       	mov %d3,%d2
8001123a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001123e:	1b 02 0f 20 	addi %d2,%d2,240
80011242:	82 26       	mov %d6,2
80011244:	3b 90 03 50 	mov %d5,57
80011248:	60 24       	mov.a %a4,%d2
8001124a:	02 34       	mov %d4,%d3
8001124c:	6d 00 41 06 	call 80011ece <dhcp_option>
80011250:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
80011254:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
80011258:	02 24       	mov %d4,%d2
8001125a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001125e:	1b 02 0f 20 	addi %d2,%d2,240
80011262:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80011266:	b9 23 28 00 	ld.hu %d3,[%a2]40
8001126a:	02 35       	mov %d5,%d3
8001126c:	60 24       	mov.a %a4,%d2
8001126e:	6d 00 b7 06 	call 80011fdc <dhcp_option_short>
80011272:	f9 e2 e8 ff 	st.h [%a14]-24,%d2

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
80011276:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
8001127a:	02 23       	mov %d3,%d2
8001127c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80011280:	1b 02 0f 20 	addi %d2,%d2,240
80011284:	82 36       	mov %d6,3
80011286:	3b 70 03 50 	mov %d5,55
8001128a:	60 24       	mov.a %a4,%d2
8001128c:	02 34       	mov %d4,%d3
8001128e:	6d 00 20 06 	call 80011ece <dhcp_option>
80011292:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
80011296:	82 02       	mov %d2,0
80011298:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8001129c:	1d 00 1e 00 	j 800112d8 <dhcp_discover+0x102>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
800112a0:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
800112a4:	02 23       	mov %d3,%d2
800112a6:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800112aa:	1b 02 0f 20 	addi %d2,%d2,240
800112ae:	39 e4 ff ff 	ld.bu %d4,[%a14]-1
800112b2:	91 10 00 27 	movh.a %a2,28673
800112b6:	d9 22 a8 4a 	lea %a2,[%a2]-22232 <7000a928 <dhcp_discover_request_options>>
800112ba:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800112be:	14 24       	ld.bu %d4,[%a2]
800112c0:	02 45       	mov %d5,%d4
800112c2:	60 24       	mov.a %a4,%d2
800112c4:	02 34       	mov %d4,%d3
800112c6:	6d 00 53 06 	call 80011f6c <dhcp_option_byte>
800112ca:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
800112ce:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
800112d2:	c2 12       	add %d2,1
800112d4:	e9 e2 ff ff 	st.b [%a14]-1,%d2
800112d8:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
800112dc:	bf 32 e2 ff 	jlt.u %d2,3,800112a0 <dhcp_discover+0xca>
    }
    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_SELECTING, msg_out, DHCP_DISCOVER, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
800112e0:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
800112e4:	02 23       	mov %d3,%d2
800112e6:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800112ea:	1b 02 0f 20 	addi %d2,%d2,240
800112ee:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
800112f2:	60 24       	mov.a %a4,%d2
800112f4:	02 34       	mov %d4,%d3
800112f6:	6d 00 8b 0e 	call 8001300c <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER)\n"));
    udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
800112fa:	91 10 00 27 	movh.a %a2,28673
800112fe:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
80011302:	54 22       	ld.w %d2,[%a2]
80011304:	91 00 00 28 	movh.a %a2,32768
80011308:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
8001130c:	f4 a2       	st.a [%sp],%a2
8001130e:	99 e7 e4 ff 	ld.a %a7,[%a14]-28 <8000451c <ip_addr_any>>
80011312:	3b 30 04 40 	mov %d4,67
80011316:	91 00 00 28 	movh.a %a2,32768
8001131a:	d9 26 60 44 	lea %a6,[%a2]17696 <80004520 <ip_addr_broadcast>>
8001131e:	99 e5 f0 ff 	ld.a %a5,[%a14]-16 <80004520 <ip_addr_broadcast>>
80011322:	60 24       	mov.a %a4,%d2
80011324:	6d 00 f2 a2 	call 80025908 <udp_sendto_if_src>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    pbuf_free(p_out);
80011328:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
8001132c:	6d 00 36 46 	call 80019f98 <pbuf_free>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  if (dhcp->tries < 255) {
80011330:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011334:	39 22 06 00 	ld.bu %d2,[%a2]6
80011338:	8b f2 0f 22 	eq %d2,%d2,255
8001133c:	df 02 0d 80 	jne %d2,0,80011356 <dhcp_discover+0x180>
    dhcp->tries++;
80011340:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011344:	39 22 06 00 	ld.bu %d2,[%a2]6
80011348:	c2 12       	add %d2,1
8001134a:	8f f2 0f 21 	and %d2,%d2,255
8001134e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011352:	e9 22 06 00 	st.b [%a2]6,%d2
  if (dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
80011356:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001135a:	39 22 06 00 	ld.bu %d2,[%a2]6
8001135e:	ff 62 13 80 	jge.u %d2,6,80011384 <dhcp_discover+0x1ae>
80011362:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011366:	39 22 06 00 	ld.bu %d2,[%a2]6
8001136a:	02 23       	mov %d3,%d2
8001136c:	82 12       	mov %d2,1
8001136e:	0f 32 00 20 	sh %d2,%d2,%d3
80011372:	37 02 70 20 	extr.u %d2,%d2,0,16
80011376:	3b 80 3e 30 	mov %d3,1000
8001137a:	e2 32       	mul %d2,%d3
8001137c:	37 02 70 20 	extr.u %d2,%d2,0,16
80011380:	1d 00 04 00 	j 80011388 <dhcp_discover+0x1b2>
80011384:	bb 00 a6 2e 	mov.u %d2,60000
80011388:	f9 e2 ea ff 	st.h [%a14]-22,%d2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
8001138c:	b9 e2 ea ff 	ld.hu %d2,[%a14]-22
80011390:	1b 32 1f 40 	addi %d4,%d2,499
80011394:	7b 20 06 21 	movh %d2,4194
80011398:	1b 32 dd 24 	addi %d2,%d2,19923
8001139c:	73 24 6a 20 	mul %e2,%d4,%d2
800113a0:	86 b3       	sha %d3,-5
800113a2:	8f 14 3e 20 	sha %d2,%d4,-31
800113a6:	0b 23 80 20 	sub %d2,%d3,%d2
800113aa:	37 02 70 20 	extr.u %d2,%d2,0,16
800113ae:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800113b2:	f9 22 08 00 	st.h [%a2]8,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
800113b6:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
}
800113ba:	00 90       	ret 

800113bc <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
800113bc:	40 ae       	mov.aa %a14,%sp
800113be:	20 30       	sub.a %sp,48
800113c0:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  u32_t timeout;
  struct dhcp *dhcp;
  ip4_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
800113c4:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800113c8:	df 02 18 80 	jne %d2,0,800113f8 <dhcp_bind+0x3c>
800113cc:	91 00 00 28 	movh.a %a2,32768
800113d0:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800113d4:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
800113d8:	3b 50 41 20 	mov %d2,1045
800113dc:	59 a2 04 00 	st.w [%sp]4,%d2
800113e0:	91 00 00 28 	movh.a %a2,32768
800113e4:	d9 22 ab c0 	lea %a2,[%a2]2859 <80000b2b <IfxCpu_Trap_vectorTable0_end+0x937>>
800113e8:	f4 a2       	st.a [%sp],%a2
800113ea:	91 00 00 28 	movh.a %a2,32768
800113ee:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
800113f2:	6d ff a2 9f 	call 80005336 <Ifx_Lwip_printf>
800113f6:	00 90       	ret 
  dhcp = netif_dhcp_data(netif);
800113f8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800113fc:	d9 22 20 00 	lea %a2,[%a2]32
80011400:	54 22       	ld.w %d2,[%a2]
80011402:	59 e2 fc ff 	st.w [%a14]-4,%d2
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
80011406:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001140a:	df 02 18 80 	jne %d2,0,8001143a <dhcp_bind+0x7e>
8001140e:	91 00 00 28 	movh.a %a2,32768
80011412:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80011416:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
8001141a:	3b 70 41 20 	mov %d2,1047
8001141e:	59 a2 04 00 	st.w [%sp]4,%d2
80011422:	91 00 00 28 	movh.a %a2,32768
80011426:	d9 22 84 d0 	lea %a2,[%a2]2884 <80000b44 <IfxCpu_Trap_vectorTable0_end+0x950>>
8001142a:	f4 a2       	st.a [%sp],%a2
8001142c:	91 00 00 28 	movh.a %a2,32768
80011430:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80011434:	6d ff 81 9f 	call 80005336 <Ifx_Lwip_printf>
80011438:	00 90       	ret 
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* reset time used of lease */
  dhcp->lease_used = 0;
8001143a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001143e:	82 02       	mov %d2,0
80011440:	f9 22 12 00 	st.h [%a2]18,%d2

  if (dhcp->offered_t0_lease != 0xffffffffUL) {
80011444:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011448:	d9 22 28 00 	lea %a2,[%a2]40
8001144c:	54 22       	ld.w %d2,[%a2]
8001144e:	df f2 30 00 	jeq %d2,-1,800114ae <dhcp_bind+0xf2>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t0 renewal timer %"U32_F" secs\n", dhcp->offered_t0_lease));
    timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
80011452:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011456:	d9 22 28 00 	lea %a2,[%a2]40
8001145a:	54 22       	ld.w %d2,[%a2]
8001145c:	1b e2 01 20 	addi %d2,%d2,30
80011460:	7b 90 88 38 	movh %d3,34953
80011464:	1b 93 88 38 	addi %d3,%d3,-30583
80011468:	73 32 68 20 	mul.u %e2,%d2,%d3
8001146c:	8f b3 1f 20 	sh %d2,%d3,-5
80011470:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    if (timeout > 0xffff) {
80011474:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80011478:	7b 10 00 30 	movh %d3,1
8001147c:	3f 32 06 80 	jlt.u %d2,%d3,80011488 <dhcp_bind+0xcc>
      timeout = 0xffff;
80011480:	bb f0 ff 2f 	mov.u %d2,65535
80011484:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    }
    dhcp->t0_timeout = (u16_t)timeout;
80011488:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001148c:	37 02 70 20 	extr.u %d2,%d2,0,16
80011490:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011494:	f9 22 14 00 	st.h [%a2]20,%d2
    if (dhcp->t0_timeout == 0) {
80011498:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001149c:	b9 22 14 00 	ld.hu %d2,[%a2]20
800114a0:	df 02 07 80 	jne %d2,0,800114ae <dhcp_bind+0xf2>
      dhcp->t0_timeout = 1;
800114a4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800114a8:	82 12       	mov %d2,1
800114aa:	f9 22 14 00 	st.h [%a2]20,%d2
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t0_lease * 1000));
  }

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
800114ae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800114b2:	d9 22 2c 00 	lea %a2,[%a2]44
800114b6:	54 22       	ld.w %d2,[%a2]
800114b8:	df f2 38 00 	jeq %d2,-1,80011528 <dhcp_bind+0x16c>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
800114bc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800114c0:	d9 22 2c 00 	lea %a2,[%a2]44
800114c4:	54 22       	ld.w %d2,[%a2]
800114c6:	1b e2 01 20 	addi %d2,%d2,30
800114ca:	7b 90 88 38 	movh %d3,34953
800114ce:	1b 93 88 38 	addi %d3,%d3,-30583
800114d2:	73 32 68 20 	mul.u %e2,%d2,%d3
800114d6:	8f b3 1f 20 	sh %d2,%d3,-5
800114da:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    if (timeout > 0xffff) {
800114de:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800114e2:	7b 10 00 30 	movh %d3,1
800114e6:	3f 32 06 80 	jlt.u %d2,%d3,800114f2 <dhcp_bind+0x136>
      timeout = 0xffff;
800114ea:	bb f0 ff 2f 	mov.u %d2,65535
800114ee:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    }
    dhcp->t1_timeout = (u16_t)timeout;
800114f2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800114f6:	37 02 70 20 	extr.u %d2,%d2,0,16
800114fa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800114fe:	f9 22 0a 00 	st.h [%a2]10,%d2
    if (dhcp->t1_timeout == 0) {
80011502:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011506:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001150a:	df 02 07 80 	jne %d2,0,80011518 <dhcp_bind+0x15c>
      dhcp->t1_timeout = 1;
8001150e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011512:	82 12       	mov %d2,1
80011514:	f9 22 0a 00 	st.h [%a2]10,%d2
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew * 1000));
    dhcp->t1_renew_time = dhcp->t1_timeout;
80011518:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001151c:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80011520:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011524:	f9 22 0e 00 	st.h [%a2]14,%d2
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
80011528:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001152c:	d9 22 30 00 	lea %a2,[%a2]48
80011530:	54 22       	ld.w %d2,[%a2]
80011532:	df f2 38 00 	jeq %d2,-1,800115a2 <dhcp_bind+0x1e6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
80011536:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001153a:	d9 22 30 00 	lea %a2,[%a2]48
8001153e:	54 22       	ld.w %d2,[%a2]
80011540:	1b e2 01 20 	addi %d2,%d2,30
80011544:	7b 90 88 38 	movh %d3,34953
80011548:	1b 93 88 38 	addi %d3,%d3,-30583
8001154c:	73 32 68 20 	mul.u %e2,%d2,%d3
80011550:	8f b3 1f 20 	sh %d2,%d3,-5
80011554:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    if (timeout > 0xffff) {
80011558:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001155c:	7b 10 00 30 	movh %d3,1
80011560:	3f 32 06 80 	jlt.u %d2,%d3,8001156c <dhcp_bind+0x1b0>
      timeout = 0xffff;
80011564:	bb f0 ff 2f 	mov.u %d2,65535
80011568:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    }
    dhcp->t2_timeout = (u16_t)timeout;
8001156c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80011570:	37 02 70 20 	extr.u %d2,%d2,0,16
80011574:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011578:	f9 22 0c 00 	st.h [%a2]12,%d2
    if (dhcp->t2_timeout == 0) {
8001157c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011580:	b9 22 0c 00 	ld.hu %d2,[%a2]12
80011584:	df 02 07 80 	jne %d2,0,80011592 <dhcp_bind+0x1d6>
      dhcp->t2_timeout = 1;
80011588:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001158c:	82 12       	mov %d2,1
8001158e:	f9 22 0c 00 	st.h [%a2]12,%d2
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind * 1000));
    dhcp->t2_rebind_time = dhcp->t2_timeout;
80011592:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011596:	b9 22 0c 00 	ld.hu %d2,[%a2]12
8001159a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001159e:	f9 22 10 00 	st.h [%a2]16,%d2
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
800115a2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800115a6:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800115aa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800115ae:	b9 22 0c 00 	ld.hu %d2,[%a2]12
800115b2:	3f 23 0d 80 	jlt.u %d3,%d2,800115cc <dhcp_bind+0x210>
800115b6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800115ba:	b9 22 0c 00 	ld.hu %d2,[%a2]12
800115be:	df 02 07 00 	jeq %d2,0,800115cc <dhcp_bind+0x210>
    dhcp->t1_timeout = 0;
800115c2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800115c6:	82 02       	mov %d2,0
800115c8:	f9 22 0a 00 	st.h [%a2]10,%d2
  }

  if (dhcp->subnet_mask_given) {
800115cc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800115d0:	39 22 07 00 	ld.bu %d2,[%a2]7
800115d4:	df 02 0b 00 	jeq %d2,0,800115ea <dhcp_bind+0x22e>
    /* copy offered network mask */
    ip4_addr_copy(sn_mask, dhcp->offered_sn_mask);
800115d8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800115dc:	d9 22 20 00 	lea %a2,[%a2]32
800115e0:	54 22       	ld.w %d2,[%a2]
800115e2:	59 e2 f0 ff 	st.w [%a14]-16,%d2
800115e6:	1d 00 25 00 	j 80011630 <dhcp_bind+0x274>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
800115ea:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800115ee:	60 22       	mov.a %a2,%d2
800115f0:	d9 22 1c 00 	lea %a2,[%a2]28
800115f4:	79 22 00 00 	ld.b %d2,[%a2]0
800115f8:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
    if (first_octet <= 127) {
800115fc:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
80011600:	bf 02 08 00 	jlt %d2,0,80011610 <dhcp_bind+0x254>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
80011604:	3b f0 0f 20 	mov %d2,255
80011608:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8001160c:	1d 00 12 00 	j 80011630 <dhcp_bind+0x274>
    } else if (first_octet >= 192) {
80011610:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
80011614:	8b 02 6c 22 	lt.u %d2,%d2,192
80011618:	df 02 08 80 	jne %d2,0,80011628 <dhcp_bind+0x26c>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
8001161c:	82 f2       	mov %d2,-1
8001161e:	06 82       	sh %d2,-8
80011620:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80011624:	1d 00 06 00 	j 80011630 <dhcp_bind+0x274>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
80011628:	bb f0 ff 2f 	mov.u %d2,65535
8001162c:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    }
  }

  ip4_addr_copy(gw_addr, dhcp->offered_gw_addr);
80011630:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011634:	d9 22 24 00 	lea %a2,[%a2]36
80011638:	54 22       	ld.w %d2,[%a2]
8001163a:	59 e2 ec ff 	st.w [%a14]-20,%d2
  /* gateway address not given? */
  if (ip4_addr_isany_val(gw_addr)) {
8001163e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80011642:	df 02 13 80 	jne %d2,0,80011668 <dhcp_bind+0x2ac>
    /* copy network address */
    ip4_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
80011646:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001164a:	d9 22 1c 00 	lea %a2,[%a2]28
8001164e:	54 23       	ld.w %d3,[%a2]
80011650:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011654:	26 32       	and %d2,%d3
80011656:	59 e2 ec ff 	st.w [%a14]-20,%d2
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
8001165a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001165e:	7b 00 10 30 	movh %d3,256
80011662:	a6 32       	or %d2,%d3
80011664:	59 e2 ec ff 	st.w [%a14]-20,%d2

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F" SN: 0x%08"X32_F" GW: 0x%08"X32_F"\n",
              ip4_addr_get_u32(&dhcp->offered_ip_addr), ip4_addr_get_u32(&sn_mask), ip4_addr_get_u32(&gw_addr)));
  /* netif is now bound to DHCP leased address - set this before assigning the address
     to ensure the callback can use dhcp_supplied_address() */
  dhcp_set_state(dhcp, DHCP_STATE_BOUND);
80011668:	3b a0 00 40 	mov %d4,10
8001166c:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80011670:	6d 00 0f 04 	call 80011e8e <dhcp_set_state>

  netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
80011674:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80011678:	1b c2 01 20 	addi %d2,%d2,28
8001167c:	d9 e3 ec ff 	lea %a3,[%a14]-20
80011680:	d9 e2 f0 ff 	lea %a2,[%a14]-16
80011684:	40 37       	mov.aa %a7,%a3
80011686:	40 26       	mov.aa %a6,%a2
80011688:	60 25       	mov.a %a5,%d2
8001168a:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001168e:	6d 00 3d 3d 	call 80019108 <netif_set_addr>
  /* interface is used by routing now that an address is set */
}
80011692:	00 90       	ret 

80011694 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
80011694:	40 ae       	mov.aa %a14,%sp
80011696:	20 20       	sub.a %sp,32
80011698:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
8001169c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800116a0:	d9 22 20 00 	lea %a2,[%a2]32
800116a4:	54 22       	ld.w %d2,[%a2]
800116a6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_RENEWING);
800116aa:	82 54       	mov %d4,5
800116ac:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
800116b0:	6d 00 ef 03 	call 80011e8e <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
800116b4:	d9 e2 ec ff 	lea %a2,[%a14]-20
800116b8:	40 26       	mov.aa %a6,%a2
800116ba:	82 34       	mov %d4,3
800116bc:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
800116c0:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800116c4:	6d 00 2e 0b 	call 80012d20 <dhcp_create_msg>
800116c8:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
  if (p_out != NULL) {
800116cc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800116d0:	df 02 95 00 	jeq %d2,0,800117fa <dhcp_renew+0x166>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
800116d4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800116d8:	b0 42       	add.a %a2,4
800116da:	54 22       	ld.w %d2,[%a2]
800116dc:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
800116e0:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800116e4:	02 23       	mov %d3,%d2
800116e6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800116ea:	1b 02 0f 20 	addi %d2,%d2,240
800116ee:	82 26       	mov %d6,2
800116f0:	3b 90 03 50 	mov %d5,57
800116f4:	60 24       	mov.a %a4,%d2
800116f6:	02 34       	mov %d4,%d3
800116f8:	6d 00 eb 03 	call 80011ece <dhcp_option>
800116fc:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
80011700:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011704:	02 24       	mov %d4,%d2
80011706:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001170a:	1b 02 0f 20 	addi %d2,%d2,240
8001170e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80011712:	b9 23 28 00 	ld.hu %d3,[%a2]40
80011716:	02 35       	mov %d5,%d3
80011718:	60 24       	mov.a %a4,%d2
8001171a:	6d 00 61 04 	call 80011fdc <dhcp_option_short>
8001171e:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
80011722:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011726:	02 23       	mov %d3,%d2
80011728:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001172c:	1b 02 0f 20 	addi %d2,%d2,240
80011730:	82 36       	mov %d6,3
80011732:	3b 70 03 50 	mov %d5,55
80011736:	60 24       	mov.a %a4,%d2
80011738:	02 34       	mov %d4,%d3
8001173a:	6d 00 ca 03 	call 80011ece <dhcp_option>
8001173e:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
80011742:	82 02       	mov %d2,0
80011744:	e9 e2 fe ff 	st.b [%a14]-2,%d2
80011748:	1d 00 1e 00 	j 80011784 <dhcp_renew+0xf0>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
8001174c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011750:	02 23       	mov %d3,%d2
80011752:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011756:	1b 02 0f 20 	addi %d2,%d2,240
8001175a:	39 e4 fe ff 	ld.bu %d4,[%a14]-2
8001175e:	91 10 00 27 	movh.a %a2,28673
80011762:	d9 22 a8 4a 	lea %a2,[%a2]-22232 <7000a928 <dhcp_discover_request_options>>
80011766:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8001176a:	14 24       	ld.bu %d4,[%a2]
8001176c:	02 45       	mov %d5,%d4
8001176e:	60 24       	mov.a %a4,%d2
80011770:	02 34       	mov %d4,%d3
80011772:	6d 00 fd 03 	call 80011f6c <dhcp_option_byte>
80011776:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
8001177a:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
8001177e:	c2 12       	add %d2,1
80011780:	e9 e2 fe ff 	st.b [%a14]-2,%d2
80011784:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
80011788:	bf 32 e2 ff 	jlt.u %d2,3,8001174c <dhcp_renew+0xb8>
    }

#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
8001178c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011790:	02 23       	mov %d3,%d2
80011792:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011796:	1b 02 0f 20 	addi %d2,%d2,240
8001179a:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
8001179e:	60 24       	mov.a %a4,%d2
800117a0:	02 34       	mov %d4,%d3
800117a2:	6d 00 de 04 	call 8001215e <dhcp_option_hostname>
800117a6:	f9 e2 ec ff 	st.h [%a14]-20,%d2
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_RENEWING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
800117aa:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800117ae:	02 23       	mov %d3,%d2
800117b0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800117b4:	1b 02 0f 20 	addi %d2,%d2,240
800117b8:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
800117bc:	60 24       	mov.a %a4,%d2
800117be:	02 34       	mov %d4,%d3
800117c0:	6d 00 26 0c 	call 8001300c <dhcp_option_trailer>

    result = udp_sendto_if(dhcp_pcb, p_out, &dhcp->server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
800117c4:	91 10 00 27 	movh.a %a2,28673
800117c8:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
800117cc:	54 23       	ld.w %d3,[%a2]
800117ce:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <7000af78 <dhcp_pcb>>
800117d2:	1b 82 01 20 	addi %d2,%d2,24
800117d6:	99 e7 e4 ff 	ld.a %a7,[%a14]-28
800117da:	3b 30 04 40 	mov %d4,67
800117de:	60 26       	mov.a %a6,%d2
800117e0:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
800117e4:	60 34       	mov.a %a4,%d3
800117e6:	6d 00 da 9f 	call 8002579a <udp_sendto_if>
800117ea:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    pbuf_free(p_out);
800117ee:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800117f2:	6d 00 d3 43 	call 80019f98 <pbuf_free>
800117f6:	1d 00 05 00 	j 80011800 <dhcp_renew+0x16c>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
    result = ERR_MEM;
800117fa:	82 f2       	mov %d2,-1
800117fc:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  }
  if (dhcp->tries < 255) {
80011800:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011804:	39 22 06 00 	ld.bu %d2,[%a2]6
80011808:	8b f2 0f 22 	eq %d2,%d2,255
8001180c:	df 02 0d 80 	jne %d2,0,80011826 <dhcp_renew+0x192>
    dhcp->tries++;
80011810:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011814:	39 22 06 00 	ld.bu %d2,[%a2]6
80011818:	c2 12       	add %d2,1
8001181a:	8f f2 0f 21 	and %d2,%d2,255
8001181e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011822:	e9 22 06 00 	st.b [%a2]6,%d2
  }
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000);
80011826:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001182a:	39 22 06 00 	ld.bu %d2,[%a2]6
8001182e:	ff a2 0f 80 	jge.u %d2,10,8001184c <dhcp_renew+0x1b8>
80011832:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011836:	39 22 06 00 	ld.bu %d2,[%a2]6
8001183a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001183e:	3b 00 7d 30 	mov %d3,2000
80011842:	e2 32       	mul %d2,%d3
80011844:	37 02 70 20 	extr.u %d2,%d2,0,16
80011848:	1d 00 04 00 	j 80011850 <dhcp_renew+0x1bc>
8001184c:	3b 00 e2 24 	mov %d2,20000
80011850:	f9 e2 ee ff 	st.h [%a14]-18,%d2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
80011854:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80011858:	1b 32 1f 40 	addi %d4,%d2,499
8001185c:	7b 20 06 21 	movh %d2,4194
80011860:	1b 32 dd 24 	addi %d2,%d2,19923
80011864:	73 24 6a 20 	mul %e2,%d4,%d2
80011868:	86 b3       	sha %d3,-5
8001186a:	8f 14 3e 20 	sha %d2,%d4,-31
8001186e:	0b 23 80 20 	sub %d2,%d3,%d2
80011872:	37 02 70 20 	extr.u %d2,%d2,0,16
80011876:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001187a:	f9 22 08 00 	st.h [%a2]8,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
8001187e:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
80011882:	00 90       	ret 

80011884 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
80011884:	40 ae       	mov.aa %a14,%sp
80011886:	20 20       	sub.a %sp,32
80011888:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
8001188c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80011890:	d9 22 20 00 	lea %a2,[%a2]32
80011894:	54 22       	ld.w %d2,[%a2]
80011896:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_REBINDING);
8001189a:	82 44       	mov %d4,4
8001189c:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
800118a0:	6d 00 f7 02 	call 80011e8e <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
800118a4:	d9 e2 ec ff 	lea %a2,[%a14]-20
800118a8:	40 26       	mov.aa %a6,%a2
800118aa:	82 34       	mov %d4,3
800118ac:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
800118b0:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800118b4:	6d 00 36 0a 	call 80012d20 <dhcp_create_msg>
800118b8:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
  if (p_out != NULL) {
800118bc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800118c0:	df 02 94 00 	jeq %d2,0,800119e8 <dhcp_rebind+0x164>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
800118c4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800118c8:	b0 42       	add.a %a2,4
800118ca:	54 22       	ld.w %d2,[%a2]
800118cc:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
800118d0:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800118d4:	02 23       	mov %d3,%d2
800118d6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800118da:	1b 02 0f 20 	addi %d2,%d2,240
800118de:	82 26       	mov %d6,2
800118e0:	3b 90 03 50 	mov %d5,57
800118e4:	60 24       	mov.a %a4,%d2
800118e6:	02 34       	mov %d4,%d3
800118e8:	6d 00 f3 02 	call 80011ece <dhcp_option>
800118ec:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
800118f0:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800118f4:	02 24       	mov %d4,%d2
800118f6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800118fa:	1b 02 0f 20 	addi %d2,%d2,240
800118fe:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80011902:	b9 23 28 00 	ld.hu %d3,[%a2]40
80011906:	02 35       	mov %d5,%d3
80011908:	60 24       	mov.a %a4,%d2
8001190a:	6d 00 69 03 	call 80011fdc <dhcp_option_short>
8001190e:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
80011912:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011916:	02 23       	mov %d3,%d2
80011918:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001191c:	1b 02 0f 20 	addi %d2,%d2,240
80011920:	82 36       	mov %d6,3
80011922:	3b 70 03 50 	mov %d5,55
80011926:	60 24       	mov.a %a4,%d2
80011928:	02 34       	mov %d4,%d3
8001192a:	6d 00 d2 02 	call 80011ece <dhcp_option>
8001192e:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
80011932:	82 02       	mov %d2,0
80011934:	e9 e2 fe ff 	st.b [%a14]-2,%d2
80011938:	1d 00 1e 00 	j 80011974 <dhcp_rebind+0xf0>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
8001193c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011940:	02 23       	mov %d3,%d2
80011942:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011946:	1b 02 0f 20 	addi %d2,%d2,240
8001194a:	39 e4 fe ff 	ld.bu %d4,[%a14]-2
8001194e:	91 10 00 27 	movh.a %a2,28673
80011952:	d9 22 a8 4a 	lea %a2,[%a2]-22232 <7000a928 <dhcp_discover_request_options>>
80011956:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8001195a:	14 24       	ld.bu %d4,[%a2]
8001195c:	02 45       	mov %d5,%d4
8001195e:	60 24       	mov.a %a4,%d2
80011960:	02 34       	mov %d4,%d3
80011962:	6d 00 05 03 	call 80011f6c <dhcp_option_byte>
80011966:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
8001196a:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
8001196e:	c2 12       	add %d2,1
80011970:	e9 e2 fe ff 	st.b [%a14]-2,%d2
80011974:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
80011978:	bf 32 e2 ff 	jlt.u %d2,3,8001193c <dhcp_rebind+0xb8>
    }

#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
8001197c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011980:	02 23       	mov %d3,%d2
80011982:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011986:	1b 02 0f 20 	addi %d2,%d2,240
8001198a:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
8001198e:	60 24       	mov.a %a4,%d2
80011990:	02 34       	mov %d4,%d3
80011992:	6d 00 e6 03 	call 8001215e <dhcp_option_hostname>
80011996:	f9 e2 ec ff 	st.h [%a14]-20,%d2
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REBINDING, msg_out, DHCP_DISCOVER, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
8001199a:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
8001199e:	02 23       	mov %d3,%d2
800119a0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800119a4:	1b 02 0f 20 	addi %d2,%d2,240
800119a8:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
800119ac:	60 24       	mov.a %a4,%d2
800119ae:	02 34       	mov %d4,%d3
800119b0:	6d 00 2e 0b 	call 8001300c <dhcp_option_trailer>

    /* broadcast to server */
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
800119b4:	91 10 00 27 	movh.a %a2,28673
800119b8:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
800119bc:	54 22       	ld.w %d2,[%a2]
800119be:	99 e7 e4 ff 	ld.a %a7,[%a14]-28 <7000af78 <dhcp_pcb>>
800119c2:	3b 30 04 40 	mov %d4,67
800119c6:	91 00 00 28 	movh.a %a2,32768
800119ca:	d9 26 60 44 	lea %a6,[%a2]17696 <80004520 <ip_addr_broadcast>>
800119ce:	99 e5 f4 ff 	ld.a %a5,[%a14]-12 <80004520 <ip_addr_broadcast>>
800119d2:	60 24       	mov.a %a4,%d2
800119d4:	6d 00 e3 9e 	call 8002579a <udp_sendto_if>
800119d8:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    pbuf_free(p_out);
800119dc:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800119e0:	6d 00 dc 42 	call 80019f98 <pbuf_free>
800119e4:	1d 00 05 00 	j 800119ee <dhcp_rebind+0x16a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
    result = ERR_MEM;
800119e8:	82 f2       	mov %d2,-1
800119ea:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  }
  if (dhcp->tries < 255) {
800119ee:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800119f2:	39 22 06 00 	ld.bu %d2,[%a2]6
800119f6:	8b f2 0f 22 	eq %d2,%d2,255
800119fa:	df 02 0d 80 	jne %d2,0,80011a14 <dhcp_rebind+0x190>
    dhcp->tries++;
800119fe:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011a02:	39 22 06 00 	ld.bu %d2,[%a2]6
80011a06:	c2 12       	add %d2,1
80011a08:	8f f2 0f 21 	and %d2,%d2,255
80011a0c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011a10:	e9 22 06 00 	st.b [%a2]6,%d2
  }
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
80011a14:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011a18:	39 22 06 00 	ld.bu %d2,[%a2]6
80011a1c:	ff a2 0f 80 	jge.u %d2,10,80011a3a <dhcp_rebind+0x1b6>
80011a20:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011a24:	39 22 06 00 	ld.bu %d2,[%a2]6
80011a28:	37 02 70 20 	extr.u %d2,%d2,0,16
80011a2c:	3b 80 3e 30 	mov %d3,1000
80011a30:	e2 32       	mul %d2,%d3
80011a32:	37 02 70 20 	extr.u %d2,%d2,0,16
80011a36:	1d 00 04 00 	j 80011a3e <dhcp_rebind+0x1ba>
80011a3a:	3b 00 71 22 	mov %d2,10000
80011a3e:	f9 e2 ee ff 	st.h [%a14]-18,%d2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
80011a42:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80011a46:	1b 32 1f 40 	addi %d4,%d2,499
80011a4a:	7b 20 06 21 	movh %d2,4194
80011a4e:	1b 32 dd 24 	addi %d2,%d2,19923
80011a52:	73 24 6a 20 	mul %e2,%d4,%d2
80011a56:	86 b3       	sha %d3,-5
80011a58:	8f 14 3e 20 	sha %d2,%d4,-31
80011a5c:	0b 23 80 20 	sub %d2,%d3,%d2
80011a60:	37 02 70 20 	extr.u %d2,%d2,0,16
80011a64:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011a68:	f9 22 08 00 	st.h [%a2]8,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
80011a6c:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
80011a70:	00 90       	ret 

80011a72 <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
80011a72:	40 ae       	mov.aa %a14,%sp
80011a74:	20 20       	sub.a %sp,32
80011a76:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
80011a7a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80011a7e:	d9 22 20 00 	lea %a2,[%a2]32
80011a82:	54 22       	ld.w %d2,[%a2]
80011a84:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  u8_t i;
  struct pbuf *p_out;
  u16_t options_out_len;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_STATE_REBOOTING);
80011a88:	82 34       	mov %d4,3
80011a8a:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80011a8e:	6d 00 00 02 	call 80011e8e <dhcp_set_state>

  /* create and initialize the DHCP message header */
  p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
80011a92:	d9 e2 ec ff 	lea %a2,[%a14]-20
80011a96:	40 26       	mov.aa %a6,%a2
80011a98:	82 34       	mov %d4,3
80011a9a:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80011a9e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80011aa2:	6d 00 3f 09 	call 80012d20 <dhcp_create_msg>
80011aa6:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
  if (p_out != NULL) {
80011aaa:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80011aae:	df 02 b8 00 	jeq %d2,0,80011c1e <dhcp_reboot+0x1ac>
    struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
80011ab2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80011ab6:	b0 42       	add.a %a2,4
80011ab8:	54 22       	ld.w %d2,[%a2]
80011aba:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
80011abe:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011ac2:	02 23       	mov %d3,%d2
80011ac4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011ac8:	1b 02 0f 20 	addi %d2,%d2,240
80011acc:	82 26       	mov %d6,2
80011ace:	3b 90 03 50 	mov %d5,57
80011ad2:	60 24       	mov.a %a4,%d2
80011ad4:	02 34       	mov %d4,%d3
80011ad6:	6d 00 fc 01 	call 80011ece <dhcp_option>
80011ada:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
80011ade:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011ae2:	02 23       	mov %d3,%d2
80011ae4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011ae8:	1b 02 0f 20 	addi %d2,%d2,240
80011aec:	3b 00 24 50 	mov %d5,576
80011af0:	60 24       	mov.a %a4,%d2
80011af2:	02 34       	mov %d4,%d3
80011af4:	6d 00 74 02 	call 80011fdc <dhcp_option_short>
80011af8:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
80011afc:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011b00:	02 23       	mov %d3,%d2
80011b02:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011b06:	1b 02 0f 20 	addi %d2,%d2,240
80011b0a:	82 46       	mov %d6,4
80011b0c:	3b 20 03 50 	mov %d5,50
80011b10:	60 24       	mov.a %a4,%d2
80011b12:	02 34       	mov %d4,%d3
80011b14:	6d 00 dd 01 	call 80011ece <dhcp_option>
80011b18:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
80011b1c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011b20:	02 29       	mov %d9,%d2
80011b22:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011b26:	1b 02 0f 80 	addi %d8,%d2,240
80011b2a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011b2e:	d9 22 1c 00 	lea %a2,[%a2]28
80011b32:	54 22       	ld.w %d2,[%a2]
80011b34:	02 24       	mov %d4,%d2
80011b36:	6d 00 27 2d 	call 80017584 <lwip_htonl>
80011b3a:	02 25       	mov %d5,%d2
80011b3c:	60 84       	mov.a %a4,%d8
80011b3e:	02 94       	mov %d4,%d9
80011b40:	6d 00 9d 02 	call 8001207a <dhcp_option_long>
80011b44:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
80011b48:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011b4c:	02 23       	mov %d3,%d2
80011b4e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011b52:	1b 02 0f 20 	addi %d2,%d2,240
80011b56:	82 36       	mov %d6,3
80011b58:	3b 70 03 50 	mov %d5,55
80011b5c:	60 24       	mov.a %a4,%d2
80011b5e:	02 34       	mov %d4,%d3
80011b60:	6d 00 b7 01 	call 80011ece <dhcp_option>
80011b64:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
80011b68:	82 02       	mov %d2,0
80011b6a:	e9 e2 fe ff 	st.b [%a14]-2,%d2
80011b6e:	1d 00 1e 00 	j 80011baa <dhcp_reboot+0x138>
      options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
80011b72:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011b76:	02 23       	mov %d3,%d2
80011b78:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011b7c:	1b 02 0f 20 	addi %d2,%d2,240
80011b80:	39 e4 fe ff 	ld.bu %d4,[%a14]-2
80011b84:	91 10 00 27 	movh.a %a2,28673
80011b88:	d9 22 a8 4a 	lea %a2,[%a2]-22232 <7000a928 <dhcp_discover_request_options>>
80011b8c:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80011b90:	14 24       	ld.bu %d4,[%a2]
80011b92:	02 45       	mov %d5,%d4
80011b94:	60 24       	mov.a %a4,%d2
80011b96:	02 34       	mov %d4,%d3
80011b98:	6d 00 ea 01 	call 80011f6c <dhcp_option_byte>
80011b9c:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
80011ba0:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
80011ba4:	c2 12       	add %d2,1
80011ba6:	e9 e2 fe ff 	st.b [%a14]-2,%d2
80011baa:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
80011bae:	bf 32 e2 ff 	jlt.u %d2,3,80011b72 <dhcp_reboot+0x100>
    }

#if LWIP_NETIF_HOSTNAME
    options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
80011bb2:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011bb6:	02 23       	mov %d3,%d2
80011bb8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011bbc:	1b 02 0f 20 	addi %d2,%d2,240
80011bc0:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
80011bc4:	60 24       	mov.a %a4,%d2
80011bc6:	02 34       	mov %d4,%d3
80011bc8:	6d 00 cb 02 	call 8001215e <dhcp_option_hostname>
80011bcc:	f9 e2 ec ff 	st.h [%a14]-20,%d2
#endif /* LWIP_NETIF_HOSTNAME */

    LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REBOOTING, msg_out, DHCP_REQUEST, &options_out_len);
    dhcp_option_trailer(options_out_len, msg_out->options, p_out);
80011bd0:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80011bd4:	02 23       	mov %d3,%d2
80011bd6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011bda:	1b 02 0f 20 	addi %d2,%d2,240
80011bde:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80011be2:	60 24       	mov.a %a4,%d2
80011be4:	02 34       	mov %d4,%d3
80011be6:	6d 00 13 0a 	call 8001300c <dhcp_option_trailer>

    /* broadcast to server */
    result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
80011bea:	91 10 00 27 	movh.a %a2,28673
80011bee:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
80011bf2:	54 22       	ld.w %d2,[%a2]
80011bf4:	99 e7 e4 ff 	ld.a %a7,[%a14]-28 <7000af78 <dhcp_pcb>>
80011bf8:	3b 30 04 40 	mov %d4,67
80011bfc:	91 00 00 28 	movh.a %a2,32768
80011c00:	d9 26 60 44 	lea %a6,[%a2]17696 <80004520 <ip_addr_broadcast>>
80011c04:	99 e5 f4 ff 	ld.a %a5,[%a14]-12 <80004520 <ip_addr_broadcast>>
80011c08:	60 24       	mov.a %a4,%d2
80011c0a:	6d 00 c8 9d 	call 8002579a <udp_sendto_if>
80011c0e:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    pbuf_free(p_out);
80011c12:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80011c16:	6d 00 c1 41 	call 80019f98 <pbuf_free>
80011c1a:	1d 00 05 00 	j 80011c24 <dhcp_reboot+0x1b2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
    result = ERR_MEM;
80011c1e:	82 f2       	mov %d2,-1
80011c20:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  }
  if (dhcp->tries < 255) {
80011c24:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011c28:	39 22 06 00 	ld.bu %d2,[%a2]6
80011c2c:	8b f2 0f 22 	eq %d2,%d2,255
80011c30:	df 02 0d 80 	jne %d2,0,80011c4a <dhcp_reboot+0x1d8>
    dhcp->tries++;
80011c34:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011c38:	39 22 06 00 	ld.bu %d2,[%a2]6
80011c3c:	c2 12       	add %d2,1
80011c3e:	8f f2 0f 21 	and %d2,%d2,255
80011c42:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011c46:	e9 22 06 00 	st.b [%a2]6,%d2
  }
  msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
80011c4a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011c4e:	39 22 06 00 	ld.bu %d2,[%a2]6
80011c52:	ff a2 0f 80 	jge.u %d2,10,80011c70 <dhcp_reboot+0x1fe>
80011c56:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011c5a:	39 22 06 00 	ld.bu %d2,[%a2]6
80011c5e:	37 02 70 20 	extr.u %d2,%d2,0,16
80011c62:	3b 80 3e 30 	mov %d3,1000
80011c66:	e2 32       	mul %d2,%d3
80011c68:	37 02 70 20 	extr.u %d2,%d2,0,16
80011c6c:	1d 00 04 00 	j 80011c74 <dhcp_reboot+0x202>
80011c70:	3b 00 71 22 	mov %d2,10000
80011c74:	f9 e2 ee ff 	st.h [%a14]-18,%d2
  dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
80011c78:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80011c7c:	1b 32 1f 40 	addi %d4,%d2,499
80011c80:	7b 20 06 21 	movh %d2,4194
80011c84:	1b 32 dd 24 	addi %d2,%d2,19923
80011c88:	73 24 6a 20 	mul %e2,%d4,%d2
80011c8c:	86 b3       	sha %d3,-5
80011c8e:	8f 14 3e 20 	sha %d2,%d4,-31
80011c92:	0b 23 80 20 	sub %d2,%d3,%d2
80011c96:	37 02 70 20 	extr.u %d2,%d2,0,16
80011c9a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011c9e:	f9 22 08 00 	st.h [%a2]8,%d2
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
80011ca2:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
80011ca6:	00 90       	ret 

80011ca8 <dhcp_release_and_stop>:
 *
 * @param netif network interface
 */
void
dhcp_release_and_stop(struct netif *netif)
{
80011ca8:	40 ae       	mov.aa %a14,%sp
80011caa:	20 20       	sub.a %sp,32
80011cac:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  struct dhcp *dhcp = netif_dhcp_data(netif);
80011cb0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80011cb4:	d9 22 20 00 	lea %a2,[%a2]32
80011cb8:	54 22       	ld.w %d2,[%a2]
80011cba:	59 e2 fc ff 	st.w [%a14]-4,%d2
  ip_addr_t server_ip_addr;

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release_and_stop()\n"));
  if (dhcp == NULL) {
80011cbe:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80011cc2:	df 02 e2 00 	jeq %d2,0,80011e86 <dhcp_release_and_stop+0x1de>
    return;
  }

  /* already off? -> nothing to do */
  if (dhcp->state == DHCP_STATE_OFF) {
80011cc6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011cca:	39 22 05 00 	ld.bu %d2,[%a2]5
80011cce:	df 02 de 00 	jeq %d2,0,80011e8a <dhcp_release_and_stop+0x1e2>
    return;
  }

  ip_addr_copy(server_ip_addr, dhcp->server_ip_addr);
80011cd2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011cd6:	d9 22 18 00 	lea %a2,[%a2]24
80011cda:	54 22       	ld.w %d2,[%a2]
80011cdc:	59 e2 f0 ff 	st.w [%a14]-16,%d2

  /* clean old DHCP offer */
  ip_addr_set_zero_ip4(&dhcp->server_ip_addr);
80011ce0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011ce4:	82 02       	mov %d2,0
80011ce6:	d9 22 18 00 	lea %a2,[%a2]24
80011cea:	74 22       	st.w [%a2],%d2
  ip4_addr_set_zero(&dhcp->offered_ip_addr);
80011cec:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011cf0:	82 02       	mov %d2,0
80011cf2:	d9 22 1c 00 	lea %a2,[%a2]28
80011cf6:	74 22       	st.w [%a2],%d2
  ip4_addr_set_zero(&dhcp->offered_sn_mask);
80011cf8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011cfc:	82 02       	mov %d2,0
80011cfe:	d9 22 20 00 	lea %a2,[%a2]32
80011d02:	74 22       	st.w [%a2],%d2
  ip4_addr_set_zero(&dhcp->offered_gw_addr);
80011d04:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d08:	82 02       	mov %d2,0
80011d0a:	d9 22 24 00 	lea %a2,[%a2]36
80011d0e:	74 22       	st.w [%a2],%d2
#if LWIP_DHCP_BOOTP_FILE
  ip4_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
80011d10:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d14:	82 02       	mov %d2,0
80011d16:	d9 22 30 00 	lea %a2,[%a2]48
80011d1a:	74 22       	st.w [%a2],%d2
80011d1c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d20:	d9 22 30 00 	lea %a2,[%a2]48
80011d24:	54 22       	ld.w %d2,[%a2]
80011d26:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d2a:	d9 22 2c 00 	lea %a2,[%a2]44
80011d2e:	74 22       	st.w [%a2],%d2
80011d30:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d34:	d9 22 2c 00 	lea %a2,[%a2]44
80011d38:	54 22       	ld.w %d2,[%a2]
80011d3a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d3e:	d9 22 28 00 	lea %a2,[%a2]40
80011d42:	74 22       	st.w [%a2],%d2
  dhcp->t1_renew_time = dhcp->t2_rebind_time = dhcp->lease_used = dhcp->t0_timeout = 0;
80011d44:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d48:	82 02       	mov %d2,0
80011d4a:	f9 22 14 00 	st.h [%a2]20,%d2
80011d4e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d52:	b9 22 14 00 	ld.hu %d2,[%a2]20
80011d56:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d5a:	f9 22 12 00 	st.h [%a2]18,%d2
80011d5e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d62:	b9 22 12 00 	ld.hu %d2,[%a2]18
80011d66:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d6a:	f9 22 10 00 	st.h [%a2]16,%d2
80011d6e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d72:	b9 22 10 00 	ld.hu %d2,[%a2]16
80011d76:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011d7a:	f9 22 0e 00 	st.h [%a2]14,%d2

  /* send release message when current IP was assigned via DHCP */
  if (dhcp_supplied_address(netif)) {
80011d7e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80011d82:	6d 00 8b 09 	call 80013098 <dhcp_supplied_address>
80011d86:	df 02 5d 00 	jeq %d2,0,80011e40 <dhcp_release_and_stop+0x198>
    /* create and initialize the DHCP message header */
    struct pbuf *p_out;
    u16_t options_out_len;
    p_out = dhcp_create_msg(netif, dhcp, DHCP_RELEASE, &options_out_len);
80011d8a:	d9 e2 ee ff 	lea %a2,[%a14]-18
80011d8e:	40 26       	mov.aa %a6,%a2
80011d90:	82 74       	mov %d4,7
80011d92:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80011d96:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80011d9a:	6d 00 c3 07 	call 80012d20 <dhcp_create_msg>
80011d9e:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
    if (p_out != NULL) {
80011da2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80011da6:	df 02 4d 00 	jeq %d2,0,80011e40 <dhcp_release_and_stop+0x198>
      struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
80011daa:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80011dae:	b0 42       	add.a %a2,4
80011db0:	54 22       	ld.w %d2,[%a2]
80011db2:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
80011db6:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80011dba:	02 23       	mov %d3,%d2
80011dbc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80011dc0:	1b 02 0f 20 	addi %d2,%d2,240
80011dc4:	82 46       	mov %d6,4
80011dc6:	3b 60 03 50 	mov %d5,54
80011dca:	60 24       	mov.a %a4,%d2
80011dcc:	02 34       	mov %d4,%d3
80011dce:	6d 00 80 00 	call 80011ece <dhcp_option>
80011dd2:	f9 e2 ee ff 	st.h [%a14]-18,%d2
      options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
80011dd6:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80011dda:	02 29       	mov %d9,%d2
80011ddc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80011de0:	1b 02 0f 80 	addi %d8,%d2,240
80011de4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80011de8:	02 24       	mov %d4,%d2
80011dea:	6d 00 cd 2b 	call 80017584 <lwip_htonl>
80011dee:	02 25       	mov %d5,%d2
80011df0:	60 84       	mov.a %a4,%d8
80011df2:	02 94       	mov %d4,%d9
80011df4:	6d 00 43 01 	call 8001207a <dhcp_option_long>
80011df8:	f9 e2 ee ff 	st.h [%a14]-18,%d2

      LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, dhcp->state, msg_out, DHCP_RELEASE, &options_out_len);
      dhcp_option_trailer(options_out_len, msg_out->options, p_out);
80011dfc:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80011e00:	02 23       	mov %d3,%d2
80011e02:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80011e06:	1b 02 0f 20 	addi %d2,%d2,240
80011e0a:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80011e0e:	60 24       	mov.a %a4,%d2
80011e10:	02 34       	mov %d4,%d3
80011e12:	6d 00 fd 08 	call 8001300c <dhcp_option_trailer>

      udp_sendto_if(dhcp_pcb, p_out, &server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
80011e16:	91 10 00 27 	movh.a %a2,28673
80011e1a:	d9 22 f8 da 	lea %a2,[%a2]-20616 <7000af78 <dhcp_pcb>>
80011e1e:	54 22       	ld.w %d2,[%a2]
80011e20:	d9 e2 f0 ff 	lea %a2,[%a14]-16 <7000af78 <dhcp_pcb>>
80011e24:	99 e7 e4 ff 	ld.a %a7,[%a14]-28 <7000af78 <dhcp_pcb>>
80011e28:	3b 30 04 40 	mov %d4,67
80011e2c:	40 26       	mov.aa %a6,%a2
80011e2e:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80011e32:	60 24       	mov.a %a4,%d2
80011e34:	6d 00 b3 9c 	call 8002579a <udp_sendto_if>
      pbuf_free(p_out);
80011e38:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80011e3c:	6d 00 ae 40 	call 80019f98 <pbuf_free>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
    }
  }

  /* remove IP address from interface (prevents routing from selecting this interface) */
  netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
80011e40:	91 00 00 28 	movh.a %a2,32768
80011e44:	d9 27 5c 44 	lea %a7,[%a2]17692 <8000451c <ip_addr_any>>
80011e48:	91 00 00 28 	movh.a %a2,32768
80011e4c:	d9 26 5c 44 	lea %a6,[%a2]17692 <8000451c <ip_addr_any>>
80011e50:	91 00 00 28 	movh.a %a2,32768
80011e54:	d9 25 5c 44 	lea %a5,[%a2]17692 <8000451c <ip_addr_any>>
80011e58:	99 e4 e4 ff 	ld.a %a4,[%a14]-28 <8000451c <ip_addr_any>>
80011e5c:	6d 00 56 39 	call 80019108 <netif_set_addr>
    autoip_stop(netif);
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  dhcp_set_state(dhcp, DHCP_STATE_OFF);
80011e60:	82 04       	mov %d4,0
80011e62:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80011e66:	6d 00 14 00 	call 80011e8e <dhcp_set_state>

  if (dhcp->pcb_allocated != 0) {
80011e6a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011e6e:	39 22 04 00 	ld.bu %d2,[%a2]4
80011e72:	df 02 0d 00 	jeq %d2,0,80011e8c <dhcp_release_and_stop+0x1e4>
    dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
80011e76:	6d ff 57 f2 	call 80010324 <dhcp_dec_pcb_refcount>
    dhcp->pcb_allocated = 0;
80011e7a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011e7e:	82 02       	mov %d2,0
80011e80:	e9 22 04 00 	st.b [%a2]4,%d2
80011e84:	00 90       	ret 
    return;
80011e86:	00 00       	nop 
80011e88:	00 90       	ret 
    return;
80011e8a:	00 00       	nop 
  }
}
80011e8c:	00 90       	ret 

80011e8e <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
80011e8e:	40 ae       	mov.aa %a14,%sp
80011e90:	20 08       	sub.a %sp,8
80011e92:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80011e96:	02 42       	mov %d2,%d4
80011e98:	e9 e2 f8 ff 	st.b [%a14]-8,%d2
  if (new_state != dhcp->state) {
80011e9c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011ea0:	39 22 05 00 	ld.bu %d2,[%a2]5
80011ea4:	39 e3 f8 ff 	ld.bu %d3,[%a14]-8
80011ea8:	5f 23 12 00 	jeq %d3,%d2,80011ecc <dhcp_set_state+0x3e>
    dhcp->state = new_state;
80011eac:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011eb0:	79 e2 f8 ff 	ld.b %d2,[%a14]-8
80011eb4:	e9 22 05 00 	st.b [%a2]5,%d2
    dhcp->tries = 0;
80011eb8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011ebc:	82 02       	mov %d2,0
80011ebe:	e9 22 06 00 	st.b [%a2]6,%d2
    dhcp->request_timeout = 0;
80011ec2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80011ec6:	82 02       	mov %d2,0
80011ec8:	f9 22 08 00 	st.h [%a2]8,%d2
  }
}
80011ecc:	00 90       	ret 

80011ece <dhcp_option>:
 * DHCP message.
 *
 */
static u16_t
dhcp_option(u16_t options_out_len, u8_t *options, u8_t option_type, u8_t option_len)
{
80011ece:	40 ae       	mov.aa %a14,%sp
80011ed0:	20 20       	sub.a %sp,32
80011ed2:	02 42       	mov %d2,%d4
80011ed4:	b5 e4 f8 ff 	st.a [%a14]-8,%a4
80011ed8:	02 54       	mov %d4,%d5
80011eda:	02 63       	mov %d3,%d6
80011edc:	f9 e2 fc ff 	st.h [%a14]-4,%d2
80011ee0:	02 42       	mov %d2,%d4
80011ee2:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
80011ee6:	02 32       	mov %d2,%d3
80011ee8:	e9 e2 f0 ff 	st.b [%a14]-16,%d2
  LWIP_ASSERT("dhcp_option: options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
80011eec:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80011ef0:	39 e3 f0 ff 	ld.bu %d3,[%a14]-16
80011ef4:	42 32       	add %d2,%d3
80011ef6:	c2 22       	add %d2,2
80011ef8:	8b 52 64 22 	lt.u %d2,%d2,69
80011efc:	df 02 17 80 	jne %d2,0,80011f2a <dhcp_option+0x5c>
80011f00:	91 00 00 28 	movh.a %a2,32768
80011f04:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80011f08:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80011f0c:	3b a0 59 20 	mov %d2,1434
80011f10:	59 a2 04 00 	st.w [%sp]4,%d2
80011f14:	91 00 00 28 	movh.a %a2,32768
80011f18:	d9 22 9c d0 	lea %a2,[%a2]2908 <80000b5c <IfxCpu_Trap_vectorTable0_end+0x968>>
80011f1c:	f4 a2       	st.a [%sp],%a2
80011f1e:	91 00 00 28 	movh.a %a2,32768
80011f22:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80011f26:	6d ff 08 9a 	call 80005336 <Ifx_Lwip_printf>
  options[options_out_len++] = option_type;
80011f2a:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80011f2e:	1b 12 00 30 	addi %d3,%d2,1
80011f32:	f9 e3 fc ff 	st.h [%a14]-4,%d3
80011f36:	02 23       	mov %d3,%d2
80011f38:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80011f3c:	60 22       	mov.a %a2,%d2
80011f3e:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80011f42:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80011f46:	34 22       	st.b [%a2],%d2
  options[options_out_len++] = option_len;
80011f48:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80011f4c:	1b 12 00 30 	addi %d3,%d2,1
80011f50:	f9 e3 fc ff 	st.h [%a14]-4,%d3
80011f54:	02 23       	mov %d3,%d2
80011f56:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80011f5a:	60 22       	mov.a %a2,%d2
80011f5c:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80011f60:	79 e2 f0 ff 	ld.b %d2,[%a14]-16
80011f64:	34 22       	st.b [%a2],%d2
  return options_out_len;
80011f66:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
}
80011f6a:	00 90       	ret 

80011f6c <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static u16_t
dhcp_option_byte(u16_t options_out_len, u8_t *options, u8_t value)
{
80011f6c:	40 ae       	mov.aa %a14,%sp
80011f6e:	20 20       	sub.a %sp,32
80011f70:	02 42       	mov %d2,%d4
80011f72:	b5 e4 f8 ff 	st.a [%a14]-8,%a4
80011f76:	02 53       	mov %d3,%d5
80011f78:	f9 e2 fc ff 	st.h [%a14]-4,%d2
80011f7c:	02 32       	mov %d2,%d3
80011f7e:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
  LWIP_ASSERT("dhcp_option_byte: options_out_len < DHCP_OPTIONS_LEN", options_out_len < DHCP_OPTIONS_LEN);
80011f82:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80011f86:	8b 42 64 22 	lt.u %d2,%d2,68
80011f8a:	df 02 17 80 	jne %d2,0,80011fb8 <dhcp_option_byte+0x4c>
80011f8e:	91 00 00 28 	movh.a %a2,32768
80011f92:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80011f96:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80011f9a:	3b 60 5a 20 	mov %d2,1446
80011f9e:	59 a2 04 00 	st.w [%sp]4,%d2
80011fa2:	91 00 00 28 	movh.a %a2,32768
80011fa6:	d9 22 9e e0 	lea %a2,[%a2]2974 <80000b9e <IfxCpu_Trap_vectorTable0_end+0x9aa>>
80011faa:	f4 a2       	st.a [%sp],%a2
80011fac:	91 00 00 28 	movh.a %a2,32768
80011fb0:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80011fb4:	6d ff c1 99 	call 80005336 <Ifx_Lwip_printf>
  options[options_out_len++] = value;
80011fb8:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80011fbc:	1b 12 00 30 	addi %d3,%d2,1
80011fc0:	f9 e3 fc ff 	st.h [%a14]-4,%d3
80011fc4:	02 23       	mov %d3,%d2
80011fc6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80011fca:	60 22       	mov.a %a2,%d2
80011fcc:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80011fd0:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
80011fd4:	34 22       	st.b [%a2],%d2
  return options_out_len;
80011fd6:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
}
80011fda:	00 90       	ret 

80011fdc <dhcp_option_short>:

static u16_t
dhcp_option_short(u16_t options_out_len, u8_t *options, u16_t value)
{
80011fdc:	40 ae       	mov.aa %a14,%sp
80011fde:	20 20       	sub.a %sp,32
80011fe0:	02 42       	mov %d2,%d4
80011fe2:	b5 e4 f8 ff 	st.a [%a14]-8,%a4
80011fe6:	02 53       	mov %d3,%d5
80011fe8:	f9 e2 fc ff 	st.h [%a14]-4,%d2
80011fec:	02 32       	mov %d2,%d3
80011fee:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
  LWIP_ASSERT("dhcp_option_short: options_out_len + 2 <= DHCP_OPTIONS_LEN", options_out_len + 2U <= DHCP_OPTIONS_LEN);
80011ff2:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80011ff6:	c2 22       	add %d2,2
80011ff8:	8b 52 64 22 	lt.u %d2,%d2,69
80011ffc:	df 02 17 80 	jne %d2,0,8001202a <dhcp_option_short+0x4e>
80012000:	91 00 00 28 	movh.a %a2,32768
80012004:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80012008:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
8001200c:	3b e0 5a 20 	mov %d2,1454
80012010:	59 a2 04 00 	st.w [%sp]4,%d2
80012014:	91 00 00 28 	movh.a %a2,32768
80012018:	d9 22 93 f0 	lea %a2,[%a2]3027 <80000bd3 <IfxCpu_Trap_vectorTable0_end+0x9df>>
8001201c:	f4 a2       	st.a [%sp],%a2
8001201e:	91 00 00 28 	movh.a %a2,32768
80012022:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012026:	6d ff 88 99 	call 80005336 <Ifx_Lwip_printf>
  options[options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
8001202a:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8001202e:	06 82       	sh %d2,-8
80012030:	37 02 70 40 	extr.u %d4,%d2,0,16
80012034:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80012038:	1b 12 00 30 	addi %d3,%d2,1
8001203c:	f9 e3 fc ff 	st.h [%a14]-4,%d3
80012040:	02 23       	mov %d3,%d2
80012042:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80012046:	60 22       	mov.a %a2,%d2
80012048:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8001204c:	8f f4 0f 21 	and %d2,%d4,255
80012050:	34 22       	st.b [%a2],%d2
  options[options_out_len++] = (u8_t) (value & 0x00ffU);
80012052:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80012056:	1b 12 00 30 	addi %d3,%d2,1
8001205a:	f9 e3 fc ff 	st.h [%a14]-4,%d3
8001205e:	02 23       	mov %d3,%d2
80012060:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80012064:	60 22       	mov.a %a2,%d2
80012066:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8001206a:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12
8001206e:	8f f2 0f 21 	and %d2,%d2,255
80012072:	34 22       	st.b [%a2],%d2
  return options_out_len;
80012074:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
}
80012078:	00 90       	ret 

8001207a <dhcp_option_long>:

static u16_t
dhcp_option_long(u16_t options_out_len, u8_t *options, u32_t value)
{
8001207a:	40 ae       	mov.aa %a14,%sp
8001207c:	20 20       	sub.a %sp,32
8001207e:	02 42       	mov %d2,%d4
80012080:	b5 e4 f8 ff 	st.a [%a14]-8,%a4
80012084:	59 e5 f4 ff 	st.w [%a14]-12,%d5
80012088:	f9 e2 fc ff 	st.h [%a14]-4,%d2
  LWIP_ASSERT("dhcp_option_long: options_out_len + 4 <= DHCP_OPTIONS_LEN", options_out_len + 4U <= DHCP_OPTIONS_LEN);
8001208c:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80012090:	c2 42       	add %d2,4
80012092:	8b 52 64 22 	lt.u %d2,%d2,69
80012096:	df 02 17 80 	jne %d2,0,800120c4 <dhcp_option_long+0x4a>
8001209a:	91 00 00 28 	movh.a %a2,32768
8001209e:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800120a2:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
800120a6:	3b 70 5b 20 	mov %d2,1463
800120aa:	59 a2 04 00 	st.w [%sp]4,%d2
800120ae:	91 00 00 28 	movh.a %a2,32768
800120b2:	d9 22 ce 00 	lea %a2,[%a2]3086 <80000c0e <IfxCpu_Trap_vectorTable0_end+0xa1a>>
800120b6:	f4 a2       	st.a [%sp],%a2
800120b8:	91 00 00 28 	movh.a %a2,32768
800120bc:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
800120c0:	6d ff 3b 99 	call 80005336 <Ifx_Lwip_printf>
  options[options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
800120c4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800120c8:	8f 82 1e 40 	sh %d4,%d2,-24
800120cc:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800120d0:	1b 12 00 30 	addi %d3,%d2,1
800120d4:	f9 e3 fc ff 	st.h [%a14]-4,%d3
800120d8:	02 23       	mov %d3,%d2
800120da:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800120de:	60 22       	mov.a %a2,%d2
800120e0:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
800120e4:	8f f4 0f 21 	and %d2,%d4,255
800120e8:	34 22       	st.b [%a2],%d2
  options[options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
800120ea:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800120ee:	8f 02 1f 40 	sh %d4,%d2,-16
800120f2:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800120f6:	1b 12 00 30 	addi %d3,%d2,1
800120fa:	f9 e3 fc ff 	st.h [%a14]-4,%d3
800120fe:	02 23       	mov %d3,%d2
80012100:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80012104:	60 22       	mov.a %a2,%d2
80012106:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8001210a:	8f f4 0f 21 	and %d2,%d4,255
8001210e:	34 22       	st.b [%a2],%d2
  options[options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
80012110:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80012114:	8f 82 1f 40 	sh %d4,%d2,-8
80012118:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8001211c:	1b 12 00 30 	addi %d3,%d2,1
80012120:	f9 e3 fc ff 	st.h [%a14]-4,%d3
80012124:	02 23       	mov %d3,%d2
80012126:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001212a:	60 22       	mov.a %a2,%d2
8001212c:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80012130:	8f f4 0f 21 	and %d2,%d4,255
80012134:	34 22       	st.b [%a2],%d2
  options[options_out_len++] = (u8_t)((value & 0x000000ffUL));
80012136:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8001213a:	1b 12 00 30 	addi %d3,%d2,1
8001213e:	f9 e3 fc ff 	st.h [%a14]-4,%d3
80012142:	02 23       	mov %d3,%d2
80012144:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80012148:	60 22       	mov.a %a2,%d2
8001214a:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8001214e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80012152:	8f f2 0f 21 	and %d2,%d2,255
80012156:	34 22       	st.b [%a2],%d2
  return options_out_len;
80012158:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
}
8001215c:	00 90       	ret 

8001215e <dhcp_option_hostname>:

#if LWIP_NETIF_HOSTNAME
static u16_t
dhcp_option_hostname(u16_t options_out_len, u8_t *options, struct netif *netif)
{
8001215e:	40 ae       	mov.aa %a14,%sp
80012160:	20 30       	sub.a %sp,48
80012162:	02 42       	mov %d2,%d4
80012164:	b5 e4 e8 ff 	st.a [%a14]-24,%a4
80012168:	b5 e5 e4 ff 	st.a [%a14]-28,%a5
8001216c:	f9 e2 ec ff 	st.h [%a14]-20,%d2
  if (netif->hostname != NULL) {
80012170:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80012174:	d9 22 24 00 	lea %a2,[%a2]36
80012178:	54 22       	ld.w %d2,[%a2]
8001217a:	df 02 89 00 	jeq %d2,0,8001228c <dhcp_option_hostname+0x12e>
    size_t namelen = strlen(netif->hostname);
8001217e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80012182:	d9 22 24 00 	lea %a2,[%a2]36
80012186:	54 22       	ld.w %d2,[%a2]
80012188:	60 24       	mov.a %a4,%d2
8001218a:	6d 00 5a b2 	call 8002863e <strlen>
8001218e:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    if (namelen > 0) {
80012192:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80012196:	df 02 7b 00 	jeq %d2,0,8001228c <dhcp_option_hostname+0x12e>
      size_t len;
      const char *p = netif->hostname;
8001219a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001219e:	d9 22 24 00 	lea %a2,[%a2]36
800121a2:	54 22       	ld.w %d2,[%a2]
800121a4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      /* Shrink len to available bytes (need 2 bytes for OPTION_HOSTNAME
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - options_out_len - 3;
800121a8:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800121ac:	8b 12 04 21 	rsub %d2,%d2,65
800121b0:	59 e2 f0 ff 	st.w [%a14]-16,%d2
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
800121b4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800121b8:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
800121bc:	7f 23 17 80 	jge.u %d3,%d2,800121ea <dhcp_option_hostname+0x8c>
800121c0:	91 00 00 28 	movh.a %a2,32768
800121c4:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800121c8:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
800121cc:	3b b0 5c 20 	mov %d2,1483
800121d0:	59 a2 04 00 	st.w [%sp]4,%d2
800121d4:	91 00 00 28 	movh.a %a2,32768
800121d8:	d9 22 c8 10 	lea %a2,[%a2]3144 <80000c48 <IfxCpu_Trap_vectorTable0_end+0xa54>>
800121dc:	f4 a2       	st.a [%sp],%a2
800121de:	91 00 00 28 	movh.a %a2,32768
800121e2:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
800121e6:	6d ff a8 98 	call 80005336 <Ifx_Lwip_printf>
      len = LWIP_MIN(namelen, available);
800121ea:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
800121ee:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800121f2:	0b 23 90 21 	min.u %d2,%d3,%d2
800121f6:	59 e2 fc ff 	st.w [%a14]-4,%d2
      LWIP_ASSERT("DHCP: hostname is too long!", len <= 0xFF);
800121fa:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800121fe:	8b 02 70 22 	lt.u %d2,%d2,256
80012202:	df 02 17 80 	jne %d2,0,80012230 <dhcp_option_hostname+0xd2>
80012206:	91 00 00 28 	movh.a %a2,32768
8001220a:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
8001220e:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80012212:	3b d0 5c 20 	mov %d2,1485
80012216:	59 a2 04 00 	st.w [%sp]4,%d2
8001221a:	91 00 00 28 	movh.a %a2,32768
8001221e:	d9 22 c8 10 	lea %a2,[%a2]3144 <80000c48 <IfxCpu_Trap_vectorTable0_end+0xa54>>
80012222:	f4 a2       	st.a [%sp],%a2
80012224:	91 00 00 28 	movh.a %a2,32768
80012228:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
8001222c:	6d ff 85 98 	call 80005336 <Ifx_Lwip_printf>
      options_out_len = dhcp_option(options_out_len, options, DHCP_OPTION_HOSTNAME, (u8_t)len);
80012230:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80012234:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80012238:	8f f3 0f 31 	and %d3,%d3,255
8001223c:	02 36       	mov %d6,%d3
8001223e:	3b c0 00 50 	mov %d5,12
80012242:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80012246:	02 24       	mov %d4,%d2
80012248:	6d ff 43 fe 	call 80011ece <dhcp_option>
8001224c:	f9 e2 ec ff 	st.h [%a14]-20,%d2
      while (len--) {
80012250:	1d 00 16 00 	j 8001227c <dhcp_option_hostname+0x11e>
        options_out_len = dhcp_option_byte(options_out_len, options, *p++);
80012254:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80012258:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001225c:	80 23       	mov.d %d3,%a2
8001225e:	c2 13       	add %d3,1
80012260:	59 e3 f8 ff 	st.w [%a14]-8,%d3
80012264:	79 23 00 00 	ld.b %d3,[%a2]0
80012268:	8f f3 0f 31 	and %d3,%d3,255
8001226c:	02 35       	mov %d5,%d3
8001226e:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80012272:	02 24       	mov %d4,%d2
80012274:	6d ff 7c fe 	call 80011f6c <dhcp_option_byte>
80012278:	f9 e2 ec ff 	st.h [%a14]-20,%d2
      while (len--) {
8001227c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80012280:	1b f2 ff 3f 	addi %d3,%d2,-1
80012284:	59 e3 fc ff 	st.w [%a14]-4,%d3
80012288:	df 02 e6 ff 	jne %d2,0,80012254 <dhcp_option_hostname+0xf6>
      }
    }
  }
  return options_out_len;
8001228c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
}
80012290:	00 90       	ret 
	...

80012294 <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct pbuf *p, struct dhcp *dhcp)
{
80012294:	40 ae       	mov.aa %a14,%sp
80012296:	20 58       	sub.a %sp,88
80012298:	b5 e4 fc ef 	st.a [%a14]-68,%a4
8001229c:	b5 e5 f8 ef 	st.a [%a14]-72,%a5
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
800122a0:	82 02       	mov %d2,0
800122a2:	59 e2 e8 ff 	st.w [%a14]-24,%d2
  int parse_sname_as_options = 0;
800122a6:	82 02       	mov %d2,0
800122a8:	59 e2 e4 ff 	st.w [%a14]-28,%d2
#endif

  LWIP_UNUSED_ARG(dhcp);

  /* clear received options */
  dhcp_clear_all_options(dhcp);
800122ac:	3b 80 00 50 	mov %d5,8
800122b0:	82 04       	mov %d4,0
800122b2:	91 10 00 27 	movh.a %a2,28673
800122b6:	d9 24 f0 da 	lea %a4,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
800122ba:	6d 00 bb a7 	call 80027230 <memset>
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
800122be:	99 e2 fc ef 	ld.a %a2,[%a14]-68
800122c2:	b9 22 0a 00 	ld.hu %d2,[%a2]10
800122c6:	8b c2 a2 22 	ge.u %d2,%d2,44
800122ca:	df 02 04 80 	jne %d2,0,800122d2 <dhcp_parse_reply+0x3e>
    return ERR_BUF;
800122ce:	82 e2       	mov %d2,-2
800122d0:	00 90       	ret 
  }
  msg_in = (struct dhcp_msg *)p->payload;
800122d2:	99 e2 fc ef 	ld.a %a2,[%a14]-68
800122d6:	b0 42       	add.a %a2,4
800122d8:	54 22       	ld.w %d2,[%a2]
800122da:	59 e2 d4 ff 	st.w [%a14]-44,%d2
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
800122de:	3b 00 0f 20 	mov %d2,240
800122e2:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
800122e6:	99 e2 fc ef 	ld.a %a2,[%a14]-68
800122ea:	c9 22 08 00 	ld.h %d2,[%a2]8
800122ee:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
again:
  q = p;
800122f2:	19 e2 fc ef 	ld.w %d2,[%a14]-68
800122f6:	59 e2 ec ff 	st.w [%a14]-20,%d2
  while ((q != NULL) && (options_idx >= q->len)) {
800122fa:	1d 00 1b 00 	j 80012330 <dhcp_parse_reply+0x9c>
    options_idx = (u16_t)(options_idx - q->len);
800122fe:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80012302:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80012306:	c9 e3 f4 ff 	ld.h %d3,[%a14]-12
8001230a:	0b 23 80 20 	sub %d2,%d3,%d2
8001230e:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    options_idx_max = (u16_t)(options_idx_max - q->len);
80012312:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80012316:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001231a:	c9 e3 f2 ff 	ld.h %d3,[%a14]-14
8001231e:	0b 23 80 20 	sub %d2,%d3,%d2
80012322:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
    q = q->next;
80012326:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001232a:	54 22       	ld.w %d2,[%a2]
8001232c:	59 e2 ec ff 	st.w [%a14]-20,%d2
  while ((q != NULL) && (options_idx >= q->len)) {
80012330:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80012334:	df 02 0a 00 	jeq %d2,0,80012348 <dhcp_parse_reply+0xb4>
80012338:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001233c:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80012340:	b9 e3 f4 ff 	ld.hu %d3,[%a14]-12
80012344:	7f 23 dd ff 	jge.u %d3,%d2,800122fe <dhcp_parse_reply+0x6a>
  }
  if (q == NULL) {
80012348:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001234c:	df 02 04 80 	jne %d2,0,80012354 <dhcp_parse_reply+0xc0>
    return ERR_BUF;
80012350:	82 e2       	mov %d2,-2
80012352:	00 90       	ret 
  }
  offset = options_idx;
80012354:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12
80012358:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  offset_max = options_idx_max;
8001235c:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80012360:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
  options = (u8_t *)q->payload;
80012364:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80012368:	b0 42       	add.a %a2,4
8001236a:	54 22       	ld.w %d2,[%a2]
8001236c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
80012370:	1d 00 57 03 	j 80012a1e <dhcp_parse_reply+0x78a>
    u8_t op = options[offset];
80012374:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80012378:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8001237c:	60 32       	mov.a %a2,%d3
8001237e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80012382:	79 22 00 00 	ld.b %d2,[%a2]0
80012386:	e9 e2 d3 ff 	st.b [%a14]-45,%d2
    u8_t len;
    u8_t decode_len = 0;
8001238a:	82 02       	mov %d2,0
8001238c:	e9 e2 e2 ff 	st.b [%a14]-30,%d2
    int decode_idx = -1;
80012390:	82 f2       	mov %d2,-1
80012392:	59 e2 dc ff 	st.w [%a14]-36,%d2
    u16_t val_offset = (u16_t)(offset + 2);
80012396:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001239a:	c2 22       	add %d2,2
8001239c:	f9 e2 da ff 	st.h [%a14]-38,%d2
    if (val_offset < offset) {
800123a0:	b9 e3 da ff 	ld.hu %d3,[%a14]-38
800123a4:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800123a8:	7f 23 04 80 	jge.u %d3,%d2,800123b0 <dhcp_parse_reply+0x11c>
      /* overflow */
      return ERR_BUF;
800123ac:	82 e2       	mov %d2,-2
800123ae:	00 90       	ret 
    }
    /* len byte might be in the next pbuf */
    if ((offset + 1) < q->len) {
800123b0:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800123b4:	c2 12       	add %d2,1
800123b6:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800123ba:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800123be:	7f 32 10 00 	jge %d2,%d3,800123de <dhcp_parse_reply+0x14a>
      len = options[offset + 1];
800123c2:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800123c6:	c2 12       	add %d2,1
800123c8:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
800123cc:	60 32       	mov.a %a2,%d3
800123ce:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800123d2:	79 22 00 00 	ld.b %d2,[%a2]0
800123d6:	e9 e2 e3 ff 	st.b [%a14]-29,%d2
800123da:	1d 00 12 00 	j 800123fe <dhcp_parse_reply+0x16a>
    } else {
      len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
800123de:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800123e2:	54 22       	ld.w %d2,[%a2]
800123e4:	df 02 0a 00 	jeq %d2,0,800123f8 <dhcp_parse_reply+0x164>
800123e8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800123ec:	d4 22       	ld.a %a2,[%a2]
800123ee:	b0 42       	add.a %a2,4
800123f0:	d4 22       	ld.a %a2,[%a2]
800123f2:	14 22       	ld.bu %d2,[%a2]
800123f4:	1d 00 03 00 	j 800123fa <dhcp_parse_reply+0x166>
800123f8:	82 02       	mov %d2,0
800123fa:	e9 e2 e3 ff 	st.b [%a14]-29,%d2
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
800123fe:	79 e2 e3 ff 	ld.b %d2,[%a14]-29
80012402:	e9 e2 e2 ff 	st.b [%a14]-30,%d2
    switch (op) {
80012406:	39 e2 d3 ff 	ld.bu %d2,[%a14]-45
8001240a:	91 10 00 28 	movh.a %a2,32769
8001240e:	d9 22 60 02 	lea %a2,[%a2]9248 <80012420 <dhcp_parse_reply+0x18c>>
80012412:	8b c2 a3 32 	ge.u %d3,%d2,60
80012416:	df 03 a8 81 	jne %d3,0,80012766 <dhcp_parse_reply+0x4d2>
8001241a:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
8001241e:	dc 02       	ji %a2
80012420:	1d 00 78 00 	j 80012510 <dhcp_parse_reply+0x27c>
80012424:	1d 00 7f 00 	j 80012522 <dhcp_parse_reply+0x28e>
80012428:	1d 00 9f 01 	j 80012766 <dhcp_parse_reply+0x4d2>
8001242c:	1d 00 9b 00 	j 80012562 <dhcp_parse_reply+0x2ce>
80012430:	1d 00 9b 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012434:	1d 00 99 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012438:	1d 00 97 01 	j 80012766 <dhcp_parse_reply+0x4d2>
8001243c:	1d 00 95 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012440:	1d 00 93 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012444:	1d 00 91 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012448:	1d 00 8f 01 	j 80012766 <dhcp_parse_reply+0x4d2>
8001244c:	1d 00 8d 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012450:	1d 00 8b 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012454:	1d 00 89 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012458:	1d 00 87 01 	j 80012766 <dhcp_parse_reply+0x4d2>
8001245c:	1d 00 85 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012460:	1d 00 83 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012464:	1d 00 81 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012468:	1d 00 7f 01 	j 80012766 <dhcp_parse_reply+0x4d2>
8001246c:	1d 00 7d 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012470:	1d 00 7b 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012474:	1d 00 79 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012478:	1d 00 77 01 	j 80012766 <dhcp_parse_reply+0x4d2>
8001247c:	1d 00 75 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012480:	1d 00 73 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012484:	1d 00 71 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012488:	1d 00 6f 01 	j 80012766 <dhcp_parse_reply+0x4d2>
8001248c:	1d 00 6d 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012490:	1d 00 6b 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012494:	1d 00 69 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012498:	1d 00 67 01 	j 80012766 <dhcp_parse_reply+0x4d2>
8001249c:	1d 00 65 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124a0:	1d 00 63 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124a4:	1d 00 61 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124a8:	1d 00 5f 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124ac:	1d 00 5d 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124b0:	1d 00 5b 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124b4:	1d 00 59 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124b8:	1d 00 57 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124bc:	1d 00 55 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124c0:	1d 00 53 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124c4:	1d 00 51 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124c8:	1d 00 4f 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124cc:	1d 00 4d 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124d0:	1d 00 4b 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124d4:	1d 00 49 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124d8:	1d 00 47 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124dc:	1d 00 45 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124e0:	1d 00 43 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124e4:	1d 00 41 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124e8:	1d 00 3f 01 	j 80012766 <dhcp_parse_reply+0x4d2>
800124ec:	1d 00 60 00 	j 800125ac <dhcp_parse_reply+0x318>
800124f0:	1d 00 7e 00 	j 800125ec <dhcp_parse_reply+0x358>
800124f4:	1d 00 b9 00 	j 80012666 <dhcp_parse_reply+0x3d2>
800124f8:	1d 00 d7 00 	j 800126a6 <dhcp_parse_reply+0x412>
800124fc:	1d 00 35 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012500:	1d 00 33 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012504:	1d 00 31 01 	j 80012766 <dhcp_parse_reply+0x4d2>
80012508:	1d 00 ef 00 	j 800126e6 <dhcp_parse_reply+0x452>
8001250c:	1d 00 0d 01 	j 80012726 <dhcp_parse_reply+0x492>
      /* case(DHCP_OPTION_END): handled above */
      case (DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
80012510:	82 02       	mov %d2,0
80012512:	e9 e2 e3 ff 	st.b [%a14]-29,%d2
80012516:	79 e2 e3 ff 	ld.b %d2,[%a14]-29
8001251a:	e9 e2 e2 ff 	st.b [%a14]-30,%d2
        /* will be increased below */
        break;
8001251e:	1d 00 28 01 	j 8001276e <dhcp_parse_reply+0x4da>
      case (DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
80012522:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
80012526:	df 42 19 00 	jeq %d2,4,80012558 <dhcp_parse_reply+0x2c4>
8001252a:	91 00 00 28 	movh.a %a2,32768
8001252e:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80012532:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80012536:	3b e0 62 20 	mov %d2,1582
8001253a:	59 a2 04 00 	st.w [%sp]4,%d2
8001253e:	91 00 00 28 	movh.a %a2,32768
80012542:	d9 22 e4 10 	lea %a2,[%a2]3172 <80000c64 <IfxCpu_Trap_vectorTable0_end+0xa70>>
80012546:	f4 a2       	st.a [%sp],%a2
80012548:	91 00 00 28 	movh.a %a2,32768
8001254c:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012550:	6d ff f3 96 	call 80005336 <Ifx_Lwip_printf>
80012554:	82 a2       	mov %d2,-6
80012556:	00 90       	ret 
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
80012558:	82 62       	mov %d2,6
8001255a:	59 e2 dc ff 	st.w [%a14]-36,%d2
        break;
8001255e:	1d 00 08 01 	j 8001276e <dhcp_parse_reply+0x4da>
      case (DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
80012562:	82 42       	mov %d2,4
80012564:	e9 e2 e2 ff 	st.b [%a14]-30,%d2
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
80012568:	39 e3 e3 ff 	ld.bu %d3,[%a14]-29
8001256c:	39 e2 e2 ff 	ld.bu %d2,[%a14]-30
80012570:	7f 23 19 80 	jge.u %d3,%d2,800125a2 <dhcp_parse_reply+0x30e>
80012574:	91 00 00 28 	movh.a %a2,32768
80012578:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
8001257c:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80012580:	3b 30 63 20 	mov %d2,1587
80012584:	59 a2 04 00 	st.w [%sp]4,%d2
80012588:	91 00 00 28 	movh.a %a2,32768
8001258c:	d9 22 ed 10 	lea %a2,[%a2]3181 <80000c6d <IfxCpu_Trap_vectorTable0_end+0xa79>>
80012590:	f4 a2       	st.a [%sp],%a2
80012592:	91 00 00 28 	movh.a %a2,32768
80012596:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
8001259a:	6d ff ce 96 	call 80005336 <Ifx_Lwip_printf>
8001259e:	82 a2       	mov %d2,-6
800125a0:	00 90       	ret 
        decode_idx = DHCP_OPTION_IDX_ROUTER;
800125a2:	82 72       	mov %d2,7
800125a4:	59 e2 dc ff 	st.w [%a14]-36,%d2
        break;
800125a8:	1d 00 e3 00 	j 8001276e <dhcp_parse_reply+0x4da>
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
        break;
#endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
      case (DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
800125ac:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
800125b0:	df 42 19 00 	jeq %d2,4,800125e2 <dhcp_parse_reply+0x34e>
800125b4:	91 00 00 28 	movh.a %a2,32768
800125b8:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800125bc:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
800125c0:	3b 10 64 20 	mov %d2,1601
800125c4:	59 a2 04 00 	st.w [%sp]4,%d2
800125c8:	91 00 00 28 	movh.a %a2,32768
800125cc:	d9 22 e4 10 	lea %a2,[%a2]3172 <80000c64 <IfxCpu_Trap_vectorTable0_end+0xa70>>
800125d0:	f4 a2       	st.a [%sp],%a2
800125d2:	91 00 00 28 	movh.a %a2,32768
800125d6:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
800125da:	6d ff ae 96 	call 80005336 <Ifx_Lwip_printf>
800125de:	82 a2       	mov %d2,-6
800125e0:	00 90       	ret 
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
800125e2:	82 32       	mov %d2,3
800125e4:	59 e2 dc ff 	st.w [%a14]-36,%d2
        break;
800125e8:	1d 00 c3 00 	j 8001276e <dhcp_parse_reply+0x4da>
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_NTP_SERVER;
        break;
#endif /* LWIP_DHCP_GET_NTP_SRV*/
      case (DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
800125ec:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
800125f0:	df 12 19 00 	jeq %d2,1,80012622 <dhcp_parse_reply+0x38e>
800125f4:	91 00 00 28 	movh.a %a2,32768
800125f8:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800125fc:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80012600:	3b f0 64 20 	mov %d2,1615
80012604:	59 a2 04 00 	st.w [%sp]4,%d2
80012608:	91 00 00 28 	movh.a %a2,32768
8001260c:	d9 22 ff 10 	lea %a2,[%a2]3199 <80000c7f <IfxCpu_Trap_vectorTable0_end+0xa8b>>
80012610:	f4 a2       	st.a [%sp],%a2
80012612:	91 00 00 28 	movh.a %a2,32768
80012616:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
8001261a:	6d ff 8e 96 	call 80005336 <Ifx_Lwip_printf>
8001261e:	82 a2       	mov %d2,-6
80012620:	00 90       	ret 
        /* decode overload only in options, not in file/sname: invalid packet */
        LWIP_ERROR("overload in file/sname", options_idx == DHCP_OPTIONS_OFS, return ERR_VAL;);
80012622:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
80012626:	8b 02 0f 22 	eq %d2,%d2,240
8001262a:	df 02 19 80 	jne %d2,0,8001265c <dhcp_parse_reply+0x3c8>
8001262e:	91 00 00 28 	movh.a %a2,32768
80012632:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80012636:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
8001263a:	3b 10 65 20 	mov %d2,1617
8001263e:	59 a2 04 00 	st.w [%sp]4,%d2
80012642:	91 00 00 28 	movh.a %a2,32768
80012646:	d9 22 c8 20 	lea %a2,[%a2]3208 <80000c88 <IfxCpu_Trap_vectorTable0_end+0xa94>>
8001264a:	f4 a2       	st.a [%sp],%a2
8001264c:	91 00 00 28 	movh.a %a2,32768
80012650:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012654:	6d ff 71 96 	call 80005336 <Ifx_Lwip_printf>
80012658:	82 a2       	mov %d2,-6
8001265a:	00 90       	ret 
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
8001265c:	82 02       	mov %d2,0
8001265e:	59 e2 dc ff 	st.w [%a14]-36,%d2
        break;
80012662:	1d 00 86 00 	j 8001276e <dhcp_parse_reply+0x4da>
      case (DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
80012666:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
8001266a:	df 12 19 00 	jeq %d2,1,8001269c <dhcp_parse_reply+0x408>
8001266e:	91 00 00 28 	movh.a %a2,32768
80012672:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80012676:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
8001267a:	3b 50 65 20 	mov %d2,1621
8001267e:	59 a2 04 00 	st.w [%sp]4,%d2
80012682:	91 00 00 28 	movh.a %a2,32768
80012686:	d9 22 ff 10 	lea %a2,[%a2]3199 <80000c7f <IfxCpu_Trap_vectorTable0_end+0xa8b>>
8001268a:	f4 a2       	st.a [%sp],%a2
8001268c:	91 00 00 28 	movh.a %a2,32768
80012690:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012694:	6d ff 51 96 	call 80005336 <Ifx_Lwip_printf>
80012698:	82 a2       	mov %d2,-6
8001269a:	00 90       	ret 
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
8001269c:	82 12       	mov %d2,1
8001269e:	59 e2 dc ff 	st.w [%a14]-36,%d2
        break;
800126a2:	1d 00 66 00 	j 8001276e <dhcp_parse_reply+0x4da>
      case (DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
800126a6:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
800126aa:	df 42 19 00 	jeq %d2,4,800126dc <dhcp_parse_reply+0x448>
800126ae:	91 00 00 28 	movh.a %a2,32768
800126b2:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800126b6:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
800126ba:	3b 90 65 20 	mov %d2,1625
800126be:	59 a2 04 00 	st.w [%sp]4,%d2
800126c2:	91 00 00 28 	movh.a %a2,32768
800126c6:	d9 22 e4 10 	lea %a2,[%a2]3172 <80000c64 <IfxCpu_Trap_vectorTable0_end+0xa70>>
800126ca:	f4 a2       	st.a [%sp],%a2
800126cc:	91 00 00 28 	movh.a %a2,32768
800126d0:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
800126d4:	6d ff 31 96 	call 80005336 <Ifx_Lwip_printf>
800126d8:	82 a2       	mov %d2,-6
800126da:	00 90       	ret 
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
800126dc:	82 22       	mov %d2,2
800126de:	59 e2 dc ff 	st.w [%a14]-36,%d2
        break;
800126e2:	1d 00 46 00 	j 8001276e <dhcp_parse_reply+0x4da>
      case (DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
800126e6:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
800126ea:	df 42 19 00 	jeq %d2,4,8001271c <dhcp_parse_reply+0x488>
800126ee:	91 00 00 28 	movh.a %a2,32768
800126f2:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800126f6:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
800126fa:	3b d0 65 20 	mov %d2,1629
800126fe:	59 a2 04 00 	st.w [%sp]4,%d2
80012702:	91 00 00 28 	movh.a %a2,32768
80012706:	d9 22 e4 10 	lea %a2,[%a2]3172 <80000c64 <IfxCpu_Trap_vectorTable0_end+0xa70>>
8001270a:	f4 a2       	st.a [%sp],%a2
8001270c:	91 00 00 28 	movh.a %a2,32768
80012710:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012714:	6d ff 11 96 	call 80005336 <Ifx_Lwip_printf>
80012718:	82 a2       	mov %d2,-6
8001271a:	00 90       	ret 
        decode_idx = DHCP_OPTION_IDX_T1;
8001271c:	82 42       	mov %d2,4
8001271e:	59 e2 dc ff 	st.w [%a14]-36,%d2
        break;
80012722:	1d 00 26 00 	j 8001276e <dhcp_parse_reply+0x4da>
      case (DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
80012726:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
8001272a:	df 42 19 00 	jeq %d2,4,8001275c <dhcp_parse_reply+0x4c8>
8001272e:	91 00 00 28 	movh.a %a2,32768
80012732:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80012736:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
8001273a:	3b 10 66 20 	mov %d2,1633
8001273e:	59 a2 04 00 	st.w [%sp]4,%d2
80012742:	91 00 00 28 	movh.a %a2,32768
80012746:	d9 22 e4 10 	lea %a2,[%a2]3172 <80000c64 <IfxCpu_Trap_vectorTable0_end+0xa70>>
8001274a:	f4 a2       	st.a [%sp],%a2
8001274c:	91 00 00 28 	movh.a %a2,32768
80012750:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012754:	6d ff f1 95 	call 80005336 <Ifx_Lwip_printf>
80012758:	82 a2       	mov %d2,-6
8001275a:	00 90       	ret 
        decode_idx = DHCP_OPTION_IDX_T2;
8001275c:	82 52       	mov %d2,5
8001275e:	59 e2 dc ff 	st.w [%a14]-36,%d2
        break;
80012762:	1d 00 06 00 	j 8001276e <dhcp_parse_reply+0x4da>
      default:
        decode_len = 0;
80012766:	82 02       	mov %d2,0
80012768:	e9 e2 e2 ff 	st.b [%a14]-30,%d2
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", (u16_t)op));
        LWIP_HOOK_DHCP_PARSE_OPTION(ip_current_netif(), dhcp, dhcp->state, msg_in,
                                    dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE) ? (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE) : 0,
                                    op, len, q, val_offset);
        break;
8001276c:	00 00       	nop 
    }
    if (op == DHCP_OPTION_PAD) {
8001276e:	39 e2 d3 ff 	ld.bu %d2,[%a14]-45
80012772:	df 02 09 80 	jne %d2,0,80012784 <dhcp_parse_reply+0x4f0>
      offset++;
80012776:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8001277a:	c2 12       	add %d2,1
8001277c:	f9 e2 fe ff 	st.h [%a14]-2,%d2
80012780:	1d 00 03 01 	j 80012986 <dhcp_parse_reply+0x6f2>
    } else {
      if (offset + len + 2 > 0xFFFF) {
80012784:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80012788:	39 e3 e3 ff 	ld.bu %d3,[%a14]-29
8001278c:	42 32       	add %d2,%d3
8001278e:	bb e0 ff 3f 	mov.u %d3,65534
80012792:	3f 32 04 00 	jlt %d2,%d3,8001279a <dhcp_parse_reply+0x506>
        /* overflow */
        return ERR_BUF;
80012796:	82 e2       	mov %d2,-2
80012798:	00 90       	ret 
      }
      offset = (u16_t)(offset + len + 2);
8001279a:	39 e2 e3 ff 	ld.bu %d2,[%a14]-29
8001279e:	37 02 70 30 	extr.u %d3,%d2,0,16
800127a2:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800127a6:	42 32       	add %d2,%d3
800127a8:	37 02 70 20 	extr.u %d2,%d2,0,16
800127ac:	c2 22       	add %d2,2
800127ae:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      if (decode_len > 0) {
800127b2:	39 e2 e2 ff 	ld.bu %d2,[%a14]-30
800127b6:	df 02 e8 00 	jeq %d2,0,80012986 <dhcp_parse_reply+0x6f2>
        u32_t value = 0;
800127ba:	82 02       	mov %d2,0
800127bc:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        u16_t copy_len;
decode_next:
        LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
800127c0:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800127c4:	bf 02 08 00 	jlt %d2,0,800127d4 <dhcp_parse_reply+0x540>
800127c8:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800127cc:	8b 82 40 22 	lt %d2,%d2,8
800127d0:	df 02 17 80 	jne %d2,0,800127fe <dhcp_parse_reply+0x56a>
800127d4:	91 00 00 28 	movh.a %a2,32768
800127d8:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800127dc:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
800127e0:	3b 80 67 20 	mov %d2,1656
800127e4:	59 a2 04 00 	st.w [%sp]4,%d2
800127e8:	91 00 00 28 	movh.a %a2,32768
800127ec:	d9 22 df 20 	lea %a2,[%a2]3231 <80000c9f <IfxCpu_Trap_vectorTable0_end+0xaab>>
800127f0:	f4 a2       	st.a [%sp],%a2
800127f2:	91 00 00 28 	movh.a %a2,32768
800127f6:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
800127fa:	6d ff 9e 95 	call 80005336 <Ifx_Lwip_printf>
        if (!dhcp_option_given(dhcp, decode_idx)) {
800127fe:	91 10 00 27 	movh.a %a2,28673
80012802:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80012806:	19 e2 dc ff 	ld.w %d2,[%a14]-36 <7000af70 <dhcp_rx_options_given>>
8001280a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8001280e:	14 22       	ld.bu %d2,[%a2]
80012810:	df 02 bb 80 	jne %d2,0,80012986 <dhcp_parse_reply+0x6f2>
          copy_len = LWIP_MIN(decode_len, 4);
80012814:	39 e2 e2 ff 	ld.bu %d2,[%a14]-30
80012818:	8b 42 20 23 	min.u %d2,%d2,4
8001281c:	8f f2 0f 21 	and %d2,%d2,255
80012820:	f9 e2 d0 ff 	st.h [%a14]-48,%d2
          if (pbuf_copy_partial(q, &value, copy_len, val_offset) != copy_len) {
80012824:	b9 e2 d0 ff 	ld.hu %d2,[%a14]-48
80012828:	b9 e3 da ff 	ld.hu %d3,[%a14]-38
8001282c:	d9 e2 c4 ff 	lea %a2,[%a14]-60
80012830:	02 35       	mov %d5,%d3
80012832:	02 24       	mov %d4,%d2
80012834:	40 25       	mov.aa %a5,%a2
80012836:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001283a:	6d 00 da 3e 	call 8001a5ee <pbuf_copy_partial>
8001283e:	02 23       	mov %d3,%d2
80012840:	b9 e2 d0 ff 	ld.hu %d2,[%a14]-48
80012844:	5f 32 04 00 	jeq %d2,%d3,8001284c <dhcp_parse_reply+0x5b8>
            return ERR_BUF;
80012848:	82 e2       	mov %d2,-2
8001284a:	00 90       	ret 
          }
          if (decode_len > 4) {
8001284c:	39 e2 e2 ff 	ld.bu %d2,[%a14]-30
80012850:	bf 52 58 80 	jlt.u %d2,5,80012900 <dhcp_parse_reply+0x66c>
            /* decode more than one u32_t */
            u16_t next_val_offset;
            LWIP_ERROR("decode_len %% 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
80012854:	79 e2 e2 ff 	ld.b %d2,[%a14]-30
80012858:	8f 32 00 21 	and %d2,%d2,3
8001285c:	8f f2 0f 21 	and %d2,%d2,255
80012860:	df 02 19 00 	jeq %d2,0,80012892 <dhcp_parse_reply+0x5fe>
80012864:	91 00 00 28 	movh.a %a2,32768
80012868:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
8001286c:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80012870:	3b 10 68 20 	mov %d2,1665
80012874:	59 a2 04 00 	st.w [%sp]4,%d2
80012878:	91 00 00 28 	movh.a %a2,32768
8001287c:	d9 22 f0 20 	lea %a2,[%a2]3248 <80000cb0 <IfxCpu_Trap_vectorTable0_end+0xabc>>
80012880:	f4 a2       	st.a [%sp],%a2
80012882:	91 00 00 28 	movh.a %a2,32768
80012886:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
8001288a:	6d ff 56 95 	call 80005336 <Ifx_Lwip_printf>
8001288e:	82 a2       	mov %d2,-6
80012890:	00 90       	ret 
            dhcp_got_option(dhcp, decode_idx);
80012892:	91 10 00 27 	movh.a %a2,28673
80012896:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
8001289a:	19 e2 dc ff 	ld.w %d2,[%a14]-36 <7000af70 <dhcp_rx_options_given>>
8001289e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800128a2:	82 12       	mov %d2,1
800128a4:	34 22       	st.b [%a2],%d2
            dhcp_set_option_value(dhcp, decode_idx, lwip_htonl(value));
800128a6:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
800128aa:	02 24       	mov %d4,%d2
800128ac:	6d 00 6c 26 	call 80017584 <lwip_htonl>
800128b0:	02 23       	mov %d3,%d2
800128b2:	91 10 00 27 	movh.a %a2,28673
800128b6:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
800128ba:	19 e2 dc ff 	ld.w %d2,[%a14]-36 <7000af50 <dhcp_rx_options_val>>
800128be:	06 22       	sh %d2,2
800128c0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800128c4:	74 23       	st.w [%a2],%d3
            decode_len = (u8_t)(decode_len - 4);
800128c6:	79 e2 e2 ff 	ld.b %d2,[%a14]-30
800128ca:	c2 c2       	add %d2,-4
800128cc:	e9 e2 e2 ff 	st.b [%a14]-30,%d2
            next_val_offset = (u16_t)(val_offset + 4);
800128d0:	c9 e2 da ff 	ld.h %d2,[%a14]-38
800128d4:	c2 42       	add %d2,4
800128d6:	f9 e2 ce ff 	st.h [%a14]-50,%d2
            if (next_val_offset < val_offset) {
800128da:	b9 e3 ce ff 	ld.hu %d3,[%a14]-50
800128de:	b9 e2 da ff 	ld.hu %d2,[%a14]-38
800128e2:	7f 23 04 80 	jge.u %d3,%d2,800128ea <dhcp_parse_reply+0x656>
              /* overflow */
              return ERR_BUF;
800128e6:	82 e2       	mov %d2,-2
800128e8:	00 90       	ret 
            }
            val_offset = next_val_offset;
800128ea:	c9 e2 ce ff 	ld.h %d2,[%a14]-50
800128ee:	f9 e2 da ff 	st.h [%a14]-38,%d2
            decode_idx++;
800128f2:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800128f6:	c2 12       	add %d2,1
800128f8:	59 e2 dc ff 	st.w [%a14]-36,%d2
            goto decode_next;
800128fc:	1d ff 62 ff 	j 800127c0 <dhcp_parse_reply+0x52c>
          } else if (decode_len == 4) {
80012900:	39 e2 e2 ff 	ld.bu %d2,[%a14]-30
80012904:	df 42 0b 80 	jne %d2,4,8001291a <dhcp_parse_reply+0x686>
            value = lwip_ntohl(value);
80012908:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8001290c:	02 24       	mov %d4,%d2
8001290e:	6d 00 3b 26 	call 80017584 <lwip_htonl>
80012912:	59 e2 c4 ff 	st.w [%a14]-60,%d2
80012916:	1d 00 22 00 	j 8001295a <dhcp_parse_reply+0x6c6>
          } else {
            LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
8001291a:	39 e2 e2 ff 	ld.bu %d2,[%a14]-30
8001291e:	df 12 19 00 	jeq %d2,1,80012950 <dhcp_parse_reply+0x6bc>
80012922:	91 00 00 28 	movh.a %a2,32768
80012926:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
8001292a:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
8001292e:	3b 00 69 20 	mov %d2,1680
80012932:	59 a2 04 00 	st.w [%sp]4,%d2
80012936:	91 00 00 28 	movh.a %a2,32768
8001293a:	d9 22 c5 30 	lea %a2,[%a2]3269 <80000cc5 <IfxCpu_Trap_vectorTable0_end+0xad1>>
8001293e:	f4 a2       	st.a [%sp],%a2
80012940:	91 00 00 28 	movh.a %a2,32768
80012944:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012948:	6d ff f7 94 	call 80005336 <Ifx_Lwip_printf>
8001294c:	82 a2       	mov %d2,-6
8001294e:	00 90       	ret 
            value = ((u8_t *)&value)[0];
80012950:	d9 e2 c4 ff 	lea %a2,[%a14]-60
80012954:	14 22       	ld.bu %d2,[%a2]
80012956:	59 e2 c4 ff 	st.w [%a14]-60,%d2
          }
          dhcp_got_option(dhcp, decode_idx);
8001295a:	91 10 00 27 	movh.a %a2,28673
8001295e:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80012962:	19 e2 dc ff 	ld.w %d2,[%a14]-36 <7000af70 <dhcp_rx_options_given>>
80012966:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8001296a:	82 12       	mov %d2,1
8001296c:	34 22       	st.b [%a2],%d2
          dhcp_set_option_value(dhcp, decode_idx, value);
8001296e:	19 e3 c4 ff 	ld.w %d3,[%a14]-60
80012972:	91 10 00 27 	movh.a %a2,28673
80012976:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
8001297a:	19 e2 dc ff 	ld.w %d2,[%a14]-36 <7000af50 <dhcp_rx_options_val>>
8001297e:	06 22       	sh %d2,2
80012980:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80012984:	74 23       	st.w [%a2],%d3
        }
      }
    }
    if (offset >= q->len) {
80012986:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001298a:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001298e:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80012992:	3f 23 46 80 	jlt.u %d3,%d2,80012a1e <dhcp_parse_reply+0x78a>
      offset = (u16_t)(offset - q->len);
80012996:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001299a:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001299e:	c9 e3 fe ff 	ld.h %d3,[%a14]-2
800129a2:	0b 23 80 20 	sub %d2,%d3,%d2
800129a6:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      offset_max = (u16_t)(offset_max - q->len);
800129aa:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800129ae:	b9 22 0a 00 	ld.hu %d2,[%a2]10
800129b2:	c9 e3 f6 ff 	ld.h %d3,[%a14]-10
800129b6:	0b 23 80 20 	sub %d2,%d3,%d2
800129ba:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
      if (offset < offset_max) {
800129be:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
800129c2:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10
800129c6:	7f 23 2a 80 	jge.u %d3,%d2,80012a1a <dhcp_parse_reply+0x786>
        q = q->next;
800129ca:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800129ce:	54 22       	ld.w %d2,[%a2]
800129d0:	59 e2 ec ff 	st.w [%a14]-20,%d2
        LWIP_ERROR("next pbuf was null", q != NULL, return ERR_VAL;);
800129d4:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800129d8:	df 02 19 80 	jne %d2,0,80012a0a <dhcp_parse_reply+0x776>
800129dc:	91 00 00 28 	movh.a %a2,32768
800129e0:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
800129e4:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
800129e8:	3b d0 69 20 	mov %d2,1693
800129ec:	59 a2 04 00 	st.w [%sp]4,%d2
800129f0:	91 00 00 28 	movh.a %a2,32768
800129f4:	d9 22 d8 30 	lea %a2,[%a2]3288 <80000cd8 <IfxCpu_Trap_vectorTable0_end+0xae4>>
800129f8:	f4 a2       	st.a [%sp],%a2
800129fa:	91 00 00 28 	movh.a %a2,32768
800129fe:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012a02:	6d ff 9a 94 	call 80005336 <Ifx_Lwip_printf>
80012a06:	82 a2       	mov %d2,-6
80012a08:	00 90       	ret 
        options = (u8_t *)q->payload;
80012a0a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80012a0e:	b0 42       	add.a %a2,4
80012a10:	54 22       	ld.w %d2,[%a2]
80012a12:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80012a16:	1d 00 04 00 	j 80012a1e <dhcp_parse_reply+0x78a>
      } else {
        /* We've run out of bytes, probably no end marker. Don't proceed. */
        return ERR_BUF;
80012a1a:	82 e2       	mov %d2,-2
80012a1c:	00 90       	ret 
  while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
80012a1e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80012a22:	df 02 14 00 	jeq %d2,0,80012a4a <dhcp_parse_reply+0x7b6>
80012a26:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80012a2a:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10
80012a2e:	7f 23 0e 80 	jge.u %d3,%d2,80012a4a <dhcp_parse_reply+0x7b6>
80012a32:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80012a36:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80012a3a:	60 32       	mov.a %a2,%d3
80012a3c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80012a40:	14 22       	ld.bu %d2,[%a2]
80012a42:	8b f2 2f 22 	ne %d2,%d2,255
80012a46:	df 02 97 fc 	jne %d2,0,80012374 <dhcp_parse_reply+0xe0>
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
80012a4a:	91 10 00 27 	movh.a %a2,28673
80012a4e:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80012a52:	14 22       	ld.bu %d2,[%a2]
80012a54:	df 02 2b 00 	jeq %d2,0,80012aaa <dhcp_parse_reply+0x816>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
80012a58:	91 10 00 27 	movh.a %a2,28673
80012a5c:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
80012a60:	54 22       	ld.w %d2,[%a2]
80012a62:	59 e2 c8 ff 	st.w [%a14]-56 <7000af50 <dhcp_rx_options_val>>,%d2
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
80012a66:	91 10 00 27 	movh.a %a2,28673
80012a6a:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80012a6e:	82 02       	mov %d2,0
80012a70:	34 22       	st.b [%a2],%d2
    if (overload == DHCP_OVERLOAD_FILE) {
80012a72:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
80012a76:	df 12 07 80 	jne %d2,1,80012a84 <dhcp_parse_reply+0x7f0>
      parse_file_as_options = 1;
80012a7a:	82 12       	mov %d2,1
80012a7c:	59 e2 e8 ff 	st.w [%a14]-24,%d2
80012a80:	1d 00 15 00 	j 80012aaa <dhcp_parse_reply+0x816>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
80012a84:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
80012a88:	df 22 07 80 	jne %d2,2,80012a96 <dhcp_parse_reply+0x802>
      parse_sname_as_options = 1;
80012a8c:	82 12       	mov %d2,1
80012a8e:	59 e2 e4 ff 	st.w [%a14]-28,%d2
80012a92:	1d 00 0c 00 	j 80012aaa <dhcp_parse_reply+0x816>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
80012a96:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
80012a9a:	df 32 08 80 	jne %d2,3,80012aaa <dhcp_parse_reply+0x816>
      parse_sname_as_options = 1;
80012a9e:	82 12       	mov %d2,1
80012aa0:	59 e2 e4 ff 	st.w [%a14]-28,%d2
      parse_file_as_options = 1;
80012aa4:	82 12       	mov %d2,1
80012aa6:	59 e2 e8 ff 	st.w [%a14]-24,%d2
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("invalid overload option: %d\n", (int)overload));
    }
  }
  if (parse_file_as_options) {
80012aaa:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80012aae:	df 02 0f 00 	jeq %d2,0,80012acc <dhcp_parse_reply+0x838>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
80012ab2:	82 02       	mov %d2,0
80012ab4:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    options_idx = DHCP_FILE_OFS;
80012ab8:	3b c0 06 20 	mov %d2,108
80012abc:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
80012ac0:	3b c0 0e 20 	mov %d2,236
80012ac4:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
#if LWIP_DHCP_BOOTP_FILE
    file_overloaded = 1;
#endif
    goto again;
80012ac8:	1d ff 15 fc 	j 800122f2 <dhcp_parse_reply+0x5e>
  } else if (parse_sname_as_options) {
80012acc:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80012ad0:	df 02 0f 00 	jeq %d2,0,80012aee <dhcp_parse_reply+0x85a>
    parse_sname_as_options = 0;
80012ad4:	82 02       	mov %d2,0
80012ad6:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    options_idx = DHCP_SNAME_OFS;
80012ada:	3b c0 02 20 	mov %d2,44
80012ade:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
80012ae2:	3b c0 06 20 	mov %d2,108
80012ae6:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
    goto again;
80012aea:	1d ff 04 fc 	j 800122f2 <dhcp_parse_reply+0x5e>
    }
    /* make sure the string is really NULL-terminated */
    dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
  }
#endif /* LWIP_DHCP_BOOTP_FILE */ 
  return ERR_OK;
80012aee:	82 02       	mov %d2,0
}
80012af0:	00 90       	ret 
	...

80012af4 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
80012af4:	40 ae       	mov.aa %a14,%sp
80012af6:	20 30       	sub.a %sp,48
80012af8:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80012afc:	b5 e5 e0 ff 	st.a [%a14]-32,%a5
80012b00:	b5 e6 dc ff 	st.a [%a14]-36,%a6
80012b04:	b5 e7 d8 ff 	st.a [%a14]-40,%a7
80012b08:	02 42       	mov %d2,%d4
80012b0a:	f9 e2 d4 ff 	st.h [%a14]-44,%d2
  struct netif *netif = ip_current_input_netif();
80012b0e:	91 10 00 27 	movh.a %a2,28673
80012b12:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80012b16:	b0 42       	add.a %a2,4
80012b18:	54 22       	ld.w %d2,[%a2]
80012b1a:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  struct dhcp *dhcp = netif_dhcp_data(netif);
80012b1e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012b22:	d9 22 20 00 	lea %a2,[%a2]32
80012b26:	54 22       	ld.w %d2,[%a2]
80012b28:	59 e2 f0 ff 	st.w [%a14]-16,%d2
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
80012b2c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80012b30:	b0 42       	add.a %a2,4
80012b32:	54 22       	ld.w %d2,[%a2]
80012b34:	59 e2 ec ff 	st.w [%a14]-20,%d2
  struct dhcp_msg *msg_in;

  LWIP_UNUSED_ARG(arg);

  /* Caught DHCP message from netif that does not have DHCP enabled? -> not interested */
  if ((dhcp == NULL) || (dhcp->pcb_allocated == 0)) {
80012b38:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80012b3c:	df 02 ec 00 	jeq %d2,0,80012d14 <dhcp_recv+0x220>
80012b40:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012b44:	39 22 04 00 	ld.bu %d2,[%a2]4
80012b48:	df 02 e6 00 	jeq %d2,0,80012d14 <dhcp_recv+0x220>
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  if (p->len < DHCP_MIN_REPLY_LEN) {
80012b4c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80012b50:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80012b54:	8b c2 a2 22 	ge.u %d2,%d2,44
80012b58:	df 02 de 00 	jeq %d2,0,80012d14 <dhcp_recv+0x220>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
80012b5c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80012b60:	14 22       	ld.bu %d2,[%a2]
80012b62:	df 22 d9 80 	jne %d2,2,80012d14 <dhcp_recv+0x220>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
80012b66:	82 02       	mov %d2,0
80012b68:	e9 e2 eb ff 	st.b [%a14]-21,%d2
80012b6c:	1d 00 1b 00 	j 80012ba2 <dhcp_recv+0xae>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
80012b70:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80012b74:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80012b78:	60 32       	mov.a %a2,%d3
80012b7a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80012b7e:	39 23 2a 00 	ld.bu %d3,[%a2]42
80012b82:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80012b86:	19 e4 ec ff 	ld.w %d4,[%a14]-20
80012b8a:	60 42       	mov.a %a2,%d4
80012b8c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80012b90:	39 22 1c 00 	ld.bu %d2,[%a2]28
80012b94:	5f 23 c0 80 	jne %d3,%d2,80012d14 <dhcp_recv+0x220>
  for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
80012b98:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80012b9c:	c2 12       	add %d2,1
80012b9e:	e9 e2 eb ff 	st.b [%a14]-21,%d2
80012ba2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012ba6:	39 22 30 00 	ld.bu %d2,[%a2]48
80012baa:	39 e3 eb ff 	ld.bu %d3,[%a14]-21
80012bae:	7f 23 06 80 	jge.u %d3,%d2,80012bba <dhcp_recv+0xc6>
80012bb2:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80012bb6:	bf 62 dd ff 	jlt.u %d2,6,80012b70 <dhcp_recv+0x7c>
                   (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (lwip_ntohl(reply_msg->xid) != dhcp->xid) {
80012bba:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80012bbe:	39 23 04 00 	ld.bu %d3,[%a2]4
80012bc2:	39 22 05 00 	ld.bu %d2,[%a2]5
80012bc6:	8f 82 00 20 	sh %d2,%d2,8
80012bca:	a6 32       	or %d2,%d3
80012bcc:	39 23 06 00 	ld.bu %d3,[%a2]6
80012bd0:	8f 03 01 30 	sh %d3,%d3,16
80012bd4:	a6 32       	or %d2,%d3
80012bd6:	39 23 07 00 	ld.bu %d3,[%a2]7
80012bda:	8f 83 01 30 	sh %d3,%d3,24
80012bde:	a6 32       	or %d2,%d3
80012be0:	02 24       	mov %d4,%d2
80012be2:	6d 00 d1 24 	call 80017584 <lwip_htonl>
80012be6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012bea:	54 23       	ld.w %d3,[%a2]
80012bec:	5f 32 94 80 	jne %d2,%d3,80012d14 <dhcp_recv+0x220>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n", lwip_ntohl(reply_msg->xid), dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(p, dhcp) != ERR_OK) {
80012bf0:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
80012bf4:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80012bf8:	6d ff 4e fb 	call 80012294 <dhcp_parse_reply>
80012bfc:	df 02 8c 80 	jne %d2,0,80012d14 <dhcp_recv+0x220>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
80012c00:	91 10 00 27 	movh.a %a2,28673
80012c04:	d9 22 f0 da 	lea %a2,[%a2]-20624 <7000af70 <dhcp_rx_options_given>>
80012c08:	39 22 01 00 	ld.bu %d2,[%a2]1 <70010001 <ram_heap+0x4f6d>>
80012c0c:	df 02 84 00 	jeq %d2,0,80012d14 <dhcp_recv+0x220>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  msg_in = (struct dhcp_msg *)p->payload;
80012c10:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80012c14:	b0 42       	add.a %a2,4
80012c16:	54 22       	ld.w %d2,[%a2]
80012c18:	59 e2 fc ff 	st.w [%a14]-4,%d2
  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
80012c1c:	91 10 00 27 	movh.a %a2,28673
80012c20:	d9 22 d0 da 	lea %a2,[%a2]-20656 <7000af50 <dhcp_rx_options_val>>
80012c24:	b0 42       	add.a %a2,4
80012c26:	54 22       	ld.w %d2,[%a2]
80012c28:	e9 e2 fb ff 	st.b [%a14]-5,%d2
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
80012c2c:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80012c30:	df 52 40 80 	jne %d2,5,80012cb0 <dhcp_recv+0x1bc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_STATE_REQUESTING) {
80012c34:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012c38:	39 22 05 00 	ld.bu %d2,[%a2]5
80012c3c:	df 12 1c 80 	jne %d2,1,80012c74 <dhcp_recv+0x180>
      dhcp_handle_ack(netif, msg_in);
80012c40:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80012c44:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80012c48:	6d ff b6 ef 	call 80010bb4 <dhcp_handle_ack>
#if DHCP_DOES_ARP_CHECK
      if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
80012c4c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012c50:	39 22 31 00 	ld.bu %d2,[%a2]49
80012c54:	8f 82 00 21 	and %d2,%d2,8
80012c58:	df 02 08 00 	jeq %d2,0,80012c68 <dhcp_recv+0x174>
        /* check if the acknowledged lease address is already in use */
        dhcp_check(netif);
80012c5c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80012c60:	6d ff cb eb 	call 800103f6 <dhcp_check>
80012c64:	1d 00 58 00 	j 80012d14 <dhcp_recv+0x220>
      } else {
        /* bind interface to the acknowledged lease address */
        dhcp_bind(netif);
80012c68:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80012c6c:	6d ff a8 f3 	call 800113bc <dhcp_bind>
80012c70:	1d 00 52 00 	j 80012d14 <dhcp_recv+0x220>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
80012c74:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012c78:	39 22 05 00 	ld.bu %d2,[%a2]5
80012c7c:	df 32 0e 00 	jeq %d2,3,80012c98 <dhcp_recv+0x1a4>
80012c80:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012c84:	39 22 05 00 	ld.bu %d2,[%a2]5
80012c88:	df 42 08 00 	jeq %d2,4,80012c98 <dhcp_recv+0x1a4>
             (dhcp->state == DHCP_STATE_RENEWING)) {
80012c8c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012c90:	39 22 05 00 	ld.bu %d2,[%a2]5
    else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
80012c94:	df 52 40 80 	jne %d2,5,80012d14 <dhcp_recv+0x220>
      dhcp_handle_ack(netif, msg_in);
80012c98:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80012c9c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80012ca0:	6d ff 8a ef 	call 80010bb4 <dhcp_handle_ack>
      dhcp_bind(netif);
80012ca4:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80012ca8:	6d ff 8a f3 	call 800113bc <dhcp_bind>
80012cac:	1d 00 34 00 	j 80012d14 <dhcp_recv+0x220>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
80012cb0:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80012cb4:	df 62 20 80 	jne %d2,6,80012cf4 <dhcp_recv+0x200>
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
80012cb8:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012cbc:	39 22 05 00 	ld.bu %d2,[%a2]5
  else if ((msg_type == DHCP_NAK) &&
80012cc0:	df 32 14 00 	jeq %d2,3,80012ce8 <dhcp_recv+0x1f4>
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
80012cc4:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012cc8:	39 22 05 00 	ld.bu %d2,[%a2]5
80012ccc:	df 12 0e 00 	jeq %d2,1,80012ce8 <dhcp_recv+0x1f4>
            (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
80012cd0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012cd4:	39 22 05 00 	ld.bu %d2,[%a2]5
           ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
80012cd8:	df 42 08 00 	jeq %d2,4,80012ce8 <dhcp_recv+0x1f4>
            (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
80012cdc:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012ce0:	39 22 05 00 	ld.bu %d2,[%a2]5
80012ce4:	df 52 08 80 	jne %d2,5,80012cf4 <dhcp_recv+0x200>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
80012ce8:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80012cec:	6d ff 5e eb 	call 800103a8 <dhcp_handle_nak>
80012cf0:	1d 00 12 00 	j 80012d14 <dhcp_recv+0x220>
  }
  /* received a DHCP_OFFER in DHCP_STATE_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_STATE_SELECTING)) {
80012cf4:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80012cf8:	df 22 0e 80 	jne %d2,2,80012d14 <dhcp_recv+0x220>
80012cfc:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80012d00:	39 22 05 00 	ld.bu %d2,[%a2]5
80012d04:	df 62 08 80 	jne %d2,6,80012d14 <dhcp_recv+0x220>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_STATE_SELECTING state\n"));
    /* remember offered lease */
    dhcp_handle_offer(netif, msg_in);
80012d08:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80012d0c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80012d10:	6d ff be eb 	call 8001048c <dhcp_handle_offer>
  }

free_pbuf_and_return:
  pbuf_free(p);
80012d14:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80012d18:	6d 00 40 39 	call 80019f98 <pbuf_free>
}
80012d1c:	00 00       	nop 
80012d1e:	00 90       	ret 

80012d20 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static struct pbuf *
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type, u16_t *options_out_len)
{
80012d20:	40 ae       	mov.aa %a14,%sp
80012d22:	20 30       	sub.a %sp,48
80012d24:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80012d28:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80012d2c:	02 42       	mov %d2,%d4
80012d2e:	b5 e6 e0 ff 	st.a [%a14]-32,%a6
80012d32:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return NULL;);
80012d36:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80012d3a:	df 02 1a 80 	jne %d2,0,80012d6e <dhcp_create_msg+0x4e>
80012d3e:	91 00 00 28 	movh.a %a2,32768
80012d42:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80012d46:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80012d4a:	3b 90 76 20 	mov %d2,1897
80012d4e:	59 a2 04 00 	st.w [%sp]4,%d2
80012d52:	91 00 00 28 	movh.a %a2,32768
80012d56:	d9 22 eb 30 	lea %a2,[%a2]3307 <80000ceb <IfxCpu_Trap_vectorTable0_end+0xaf7>>
80012d5a:	f4 a2       	st.a [%sp],%a2
80012d5c:	91 00 00 28 	movh.a %a2,32768
80012d60:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012d64:	6d ff e9 92 	call 80005336 <Ifx_Lwip_printf>
80012d68:	82 02       	mov %d2,0
80012d6a:	1d 00 4f 01 	j 80013008 <dhcp_create_msg+0x2e8>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return NULL;);
80012d6e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80012d72:	df 02 1a 80 	jne %d2,0,80012da6 <dhcp_create_msg+0x86>
80012d76:	91 00 00 28 	movh.a %a2,32768
80012d7a:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80012d7e:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80012d82:	3b a0 76 20 	mov %d2,1898
80012d86:	59 a2 04 00 	st.w [%sp]4,%d2
80012d8a:	91 00 00 28 	movh.a %a2,32768
80012d8e:	d9 22 ca 40 	lea %a2,[%a2]3338 <80000d0a <IfxCpu_Trap_vectorTable0_end+0xb16>>
80012d92:	f4 a2       	st.a [%sp],%a2
80012d94:	91 00 00 28 	movh.a %a2,32768
80012d98:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012d9c:	6d ff cd 92 	call 80005336 <Ifx_Lwip_printf>
80012da0:	82 02       	mov %d2,0
80012da2:	1d 00 33 01 	j 80013008 <dhcp_create_msg+0x2e8>
  p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
80012da6:	3b 00 28 60 	mov %d6,640
80012daa:	3b 40 13 50 	mov %d5,308
80012dae:	3b 80 03 40 	mov %d4,56
80012db2:	6d 00 97 34 	call 800196e0 <pbuf_alloc>
80012db6:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  if (p_out == NULL) {
80012dba:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80012dbe:	df 02 05 80 	jne %d2,0,80012dc8 <dhcp_create_msg+0xa8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("dhcp_create_msg(): could not allocate pbuf\n"));
    return NULL;
80012dc2:	82 02       	mov %d2,0
80012dc4:	1d 00 22 01 	j 80013008 <dhcp_create_msg+0x2e8>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
80012dc8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80012dcc:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80012dd0:	8b 42 b3 22 	ge.u %d2,%d2,308
80012dd4:	df 02 17 80 	jne %d2,0,80012e02 <dhcp_create_msg+0xe2>
80012dd8:	91 00 00 28 	movh.a %a2,32768
80012ddc:	d9 22 89 80 	lea %a2,[%a2]2569 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>
80012de0:	b5 a2 08 00 	st.a [%sp]8 <80000a09 <IfxCpu_Trap_vectorTable0_end+0x815>>,%a2
80012de4:	3b 10 77 20 	mov %d2,1905
80012de8:	59 a2 04 00 	st.w [%sp]4,%d2
80012dec:	91 00 00 28 	movh.a %a2,32768
80012df0:	d9 22 e8 40 	lea %a2,[%a2]3368 <80000d28 <IfxCpu_Trap_vectorTable0_end+0xb34>>
80012df4:	f4 a2       	st.a [%sp],%a2
80012df6:	91 00 00 28 	movh.a %a2,32768
80012dfa:	d9 24 a1 70 	lea %a4,[%a2]2529 <800009e1 <IfxCpu_Trap_vectorTable0_end+0x7ed>>
80012dfe:	6d ff 9c 92 	call 80005336 <Ifx_Lwip_printf>
              (p_out->len >= sizeof(struct dhcp_msg)));

  /* DHCP_REQUEST should reuse 'xid' from DHCPOFFER */
  if ((message_type != DHCP_REQUEST) || (dhcp->state == DHCP_STATE_REBOOTING)) {
80012e02:	39 e2 e4 ff 	ld.bu %d2,[%a14]-28
80012e06:	df 32 08 80 	jne %d2,3,80012e16 <dhcp_create_msg+0xf6>
80012e0a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80012e0e:	39 22 05 00 	ld.bu %d2,[%a2]5
80012e12:	df 32 1b 80 	jne %d2,3,80012e48 <dhcp_create_msg+0x128>
    /* reuse transaction identifier in retransmissions */
    if (dhcp->tries == 0) {
80012e16:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80012e1a:	39 22 06 00 	ld.bu %d2,[%a2]6
80012e1e:	df 02 0d 80 	jne %d2,0,80012e38 <dhcp_create_msg+0x118>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
      xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
      xid++;
80012e22:	91 10 00 27 	movh.a %a2,28673
80012e26:	d9 22 ac 4a 	lea %a2,[%a2]-22228 <7000a92c <xid.0>>
80012e2a:	54 22       	ld.w %d2,[%a2]
80012e2c:	c2 12       	add %d2,1
80012e2e:	91 10 00 27 	movh.a %a2,28673
80012e32:	d9 22 ac 4a 	lea %a2,[%a2]-22228 <7000a92c <xid.0>>
80012e36:	74 22       	st.w [%a2],%d2
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    }
    dhcp->xid = xid;
80012e38:	91 10 00 27 	movh.a %a2,28673
80012e3c:	d9 22 ac 4a 	lea %a2,[%a2]-22228 <7000a92c <xid.0>>
80012e40:	54 22       	ld.w %d2,[%a2]
80012e42:	99 e2 e8 ff 	ld.a %a2,[%a14]-24 <7000a92c <xid.0>>
80012e46:	74 22       	st.w [%a2],%d2
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  msg_out = (struct dhcp_msg *)p_out->payload;
80012e48:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <7000a92c <xid.0>>
80012e4c:	b0 42       	add.a %a2,4
80012e4e:	54 22       	ld.w %d2,[%a2]
80012e50:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  memset(msg_out, 0, sizeof(struct dhcp_msg));
80012e54:	3b 40 13 50 	mov %d5,308
80012e58:	82 04       	mov %d4,0
80012e5a:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80012e5e:	6d 00 e9 a1 	call 80027230 <memset>

  msg_out->op = DHCP_BOOTREQUEST;
80012e62:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012e66:	82 12       	mov %d2,1
80012e68:	34 22       	st.b [%a2],%d2
  /* @todo: make link layer independent */
  msg_out->htype = LWIP_IANA_HWTYPE_ETHERNET;
80012e6a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012e6e:	82 12       	mov %d2,1
80012e70:	e9 22 01 00 	st.b [%a2]1,%d2
  msg_out->hlen = netif->hwaddr_len;
80012e74:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80012e78:	39 22 30 00 	ld.bu %d2,[%a2]48
80012e7c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012e80:	e9 22 02 00 	st.b [%a2]2,%d2
  msg_out->xid = lwip_htonl(dhcp->xid);
80012e84:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80012e88:	54 22       	ld.w %d2,[%a2]
80012e8a:	02 24       	mov %d4,%d2
80012e8c:	6d 00 7c 23 	call 80017584 <lwip_htonl>
80012e90:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012e94:	8f f2 0f 31 	and %d3,%d2,255
80012e98:	82 04       	mov %d4,0
80012e9a:	a6 43       	or %d3,%d4
80012e9c:	e9 23 04 00 	st.b [%a2]4,%d3
80012ea0:	8f 82 1f 30 	sh %d3,%d2,-8
80012ea4:	8f f3 0f 31 	and %d3,%d3,255
80012ea8:	82 04       	mov %d4,0
80012eaa:	a6 43       	or %d3,%d4
80012eac:	e9 23 05 00 	st.b [%a2]5,%d3
80012eb0:	8f 02 1f 30 	sh %d3,%d2,-16
80012eb4:	8f f3 0f 31 	and %d3,%d3,255
80012eb8:	82 04       	mov %d4,0
80012eba:	a6 43       	or %d3,%d4
80012ebc:	e9 23 06 00 	st.b [%a2]6,%d3
80012ec0:	8f 82 1e 20 	sh %d2,%d2,-24
80012ec4:	82 03       	mov %d3,0
80012ec6:	a6 32       	or %d2,%d3
80012ec8:	e9 22 07 00 	st.b [%a2]7,%d2
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
80012ecc:	39 e2 e4 ff 	ld.bu %d2,[%a14]-28
80012ed0:	8b 82 00 22 	eq %d2,%d2,8
80012ed4:	df 02 1a 80 	jne %d2,0,80012f08 <dhcp_create_msg+0x1e8>
80012ed8:	39 e2 e4 ff 	ld.bu %d2,[%a14]-28
80012edc:	df 42 16 00 	jeq %d2,4,80012f08 <dhcp_create_msg+0x1e8>
80012ee0:	39 e2 e4 ff 	ld.bu %d2,[%a14]-28
80012ee4:	df 72 12 00 	jeq %d2,7,80012f08 <dhcp_create_msg+0x1e8>
80012ee8:	39 e2 e4 ff 	ld.bu %d2,[%a14]-28
80012eec:	df 32 31 80 	jne %d2,3,80012f4e <dhcp_create_msg+0x22e>
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
       ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
80012ef0:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80012ef4:	39 22 05 00 	ld.bu %d2,[%a2]5
      ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
80012ef8:	df 52 08 00 	jeq %d2,5,80012f08 <dhcp_create_msg+0x1e8>
       ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
80012efc:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80012f00:	39 22 05 00 	ld.bu %d2,[%a2]5
80012f04:	df 42 25 80 	jne %d2,4,80012f4e <dhcp_create_msg+0x22e>
    ip4_addr_copy(msg_out->ciaddr, *netif_ip4_addr(netif));
80012f08:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80012f0c:	60 22       	mov.a %a2,%d2
80012f0e:	b0 42       	add.a %a2,4
80012f10:	54 22       	ld.w %d2,[%a2]
80012f12:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012f16:	8f f2 0f 31 	and %d3,%d2,255
80012f1a:	82 04       	mov %d4,0
80012f1c:	a6 43       	or %d3,%d4
80012f1e:	e9 23 0c 00 	st.b [%a2]12,%d3
80012f22:	8f 82 1f 30 	sh %d3,%d2,-8
80012f26:	8f f3 0f 31 	and %d3,%d3,255
80012f2a:	82 04       	mov %d4,0
80012f2c:	a6 43       	or %d3,%d4
80012f2e:	e9 23 0d 00 	st.b [%a2]13,%d3
80012f32:	8f 02 1f 30 	sh %d3,%d2,-16
80012f36:	8f f3 0f 31 	and %d3,%d3,255
80012f3a:	82 04       	mov %d4,0
80012f3c:	a6 43       	or %d3,%d4
80012f3e:	e9 23 0e 00 	st.b [%a2]14,%d3
80012f42:	8f 82 1e 20 	sh %d2,%d2,-24
80012f46:	82 03       	mov %d3,0
80012f48:	a6 32       	or %d2,%d3
80012f4a:	e9 22 0f 00 	st.b [%a2]15,%d2
  }
  for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
80012f4e:	82 02       	mov %d2,0
80012f50:	f9 e2 fe ff 	st.h [%a14]-2,%d2
80012f54:	1d 00 19 00 	j 80012f86 <dhcp_create_msg+0x266>
    /* copy netif hardware address (padded with zeroes through memset already) */
    msg_out->chaddr[i] = netif->hwaddr[i];
80012f58:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80012f5c:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80012f60:	19 e4 ec ff 	ld.w %d4,[%a14]-20
80012f64:	60 42       	mov.a %a2,%d4
80012f66:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80012f6a:	39 22 2a 00 	ld.bu %d2,[%a2]42
80012f6e:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
80012f72:	60 42       	mov.a %a2,%d4
80012f74:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80012f78:	e9 22 1c 00 	st.b [%a2]28,%d2
  for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
80012f7c:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80012f80:	c2 12       	add %d2,1
80012f82:	f9 e2 fe ff 	st.h [%a14]-2,%d2
80012f86:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80012f8a:	bf 62 e7 ff 	jlt.u %d2,6,80012f58 <dhcp_create_msg+0x238>
  }
  msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
80012f8e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80012f92:	82 02       	mov %d2,0
80012f94:	8f 32 46 21 	or %d2,%d2,99
80012f98:	e9 22 2c 30 	st.b [%a2]236,%d2
80012f9c:	82 02       	mov %d2,0
80012f9e:	8f d2 e7 21 	orn %d2,%d2,125
80012fa2:	e9 22 2d 30 	st.b [%a2]237,%d2
80012fa6:	82 02       	mov %d2,0
80012fa8:	8f 32 45 21 	or %d2,%d2,83
80012fac:	e9 22 2e 30 	st.b [%a2]238,%d2
80012fb0:	82 02       	mov %d2,0
80012fb2:	8f 32 46 21 	or %d2,%d2,99
80012fb6:	e9 22 2f 30 	st.b [%a2]239,%d2
  /* Add option MESSAGE_TYPE */
  options_out_len_loc = dhcp_option(0, msg_out->options, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
80012fba:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80012fbe:	1b 02 0f 20 	addi %d2,%d2,240
80012fc2:	82 16       	mov %d6,1
80012fc4:	3b 50 03 50 	mov %d5,53
80012fc8:	60 24       	mov.a %a4,%d2
80012fca:	82 04       	mov %d4,0
80012fcc:	6d ff 81 f7 	call 80011ece <dhcp_option>
80012fd0:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
  options_out_len_loc = dhcp_option_byte(options_out_len_loc, msg_out->options, message_type);
80012fd4:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
80012fd8:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80012fdc:	1b 03 0f 40 	addi %d4,%d3,240
80012fe0:	39 e3 e4 ff 	ld.bu %d3,[%a14]-28
80012fe4:	02 35       	mov %d5,%d3
80012fe6:	60 44       	mov.a %a4,%d4
80012fe8:	02 24       	mov %d4,%d2
80012fea:	6d ff c1 f7 	call 80011f6c <dhcp_option_byte>
80012fee:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
  if (options_out_len) {
80012ff2:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80012ff6:	df 02 07 00 	jeq %d2,0,80013004 <dhcp_create_msg+0x2e4>
    *options_out_len = options_out_len_loc;
80012ffa:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80012ffe:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80013002:	b4 22       	st.h [%a2],%d2
  }
  return p_out;
80013004:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
}
80013008:	60 22       	mov.a %a2,%d2
8001300a:	00 90       	ret 

8001300c <dhcp_option_trailer>:
 * Adds the END option to the DHCP message, and if
 * necessary, up to three padding bytes.
 */
static void
dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out)
{
8001300c:	40 ae       	mov.aa %a14,%sp
8001300e:	20 10       	sub.a %sp,16
80013010:	02 42       	mov %d2,%d4
80013012:	b5 e4 f8 ff 	st.a [%a14]-8,%a4
80013016:	b5 e5 f4 ff 	st.a [%a14]-12,%a5
8001301a:	f9 e2 fc ff 	st.h [%a14]-4,%d2
  options[options_out_len++] = DHCP_OPTION_END;
8001301e:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80013022:	1b 12 00 30 	addi %d3,%d2,1
80013026:	f9 e3 fc ff 	st.h [%a14]-4,%d3
8001302a:	02 23       	mov %d3,%d2
8001302c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80013030:	60 22       	mov.a %a2,%d2
80013032:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80013036:	82 f2       	mov %d2,-1
80013038:	34 22       	st.b [%a2],%d2
  /* packet is too small, or not 4 byte aligned? */
  while (((options_out_len < DHCP_MIN_OPTIONS_LEN) || (options_out_len & 3)) &&
8001303a:	1d 00 10 00 	j 8001305a <dhcp_option_trailer+0x4e>
         (options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    options[options_out_len++] = 0;
8001303e:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80013042:	1b 12 00 30 	addi %d3,%d2,1
80013046:	f9 e3 fc ff 	st.h [%a14]-4,%d3
8001304a:	02 23       	mov %d3,%d2
8001304c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80013050:	60 22       	mov.a %a2,%d2
80013052:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80013056:	82 02       	mov %d2,0
80013058:	34 22       	st.b [%a2],%d2
  while (((options_out_len < DHCP_MIN_OPTIONS_LEN) || (options_out_len & 3)) &&
8001305a:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8001305e:	8b 42 64 22 	lt.u %d2,%d2,68
80013062:	df 02 08 80 	jne %d2,0,80013072 <dhcp_option_trailer+0x66>
80013066:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8001306a:	8f 32 00 21 	and %d2,%d2,3
8001306e:	df 02 08 00 	jeq %d2,0,8001307e <dhcp_option_trailer+0x72>
80013072:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80013076:	8b 42 64 22 	lt.u %d2,%d2,68
8001307a:	df 02 e2 ff 	jne %d2,0,8001303e <dhcp_option_trailer+0x32>
  }
  /* shrink the pbuf to the actual content length */
  pbuf_realloc(p_out, (u16_t)(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + options_out_len));
8001307e:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80013082:	1b 02 0f 20 	addi %d2,%d2,240
80013086:	37 02 70 20 	extr.u %d2,%d2,0,16
8001308a:	02 24       	mov %d4,%d2
8001308c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80013090:	6d 00 35 35 	call 80019afa <pbuf_realloc>
}
80013094:	00 00       	nop 
80013096:	00 90       	ret 

80013098 <dhcp_supplied_address>:
 * @return 1 if DHCP supplied netif->ip_addr (states BOUND or RENEWING),
 *         0 otherwise
 */
u8_t
dhcp_supplied_address(const struct netif *netif)
{
80013098:	40 ae       	mov.aa %a14,%sp
8001309a:	20 10       	sub.a %sp,16
8001309c:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
800130a0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800130a4:	df 02 2b 00 	jeq %d2,0,800130fa <dhcp_supplied_address+0x62>
800130a8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800130ac:	d9 22 20 00 	lea %a2,[%a2]32
800130b0:	54 22       	ld.w %d2,[%a2]
800130b2:	df 02 24 00 	jeq %d2,0,800130fa <dhcp_supplied_address+0x62>
    struct dhcp *dhcp = netif_dhcp_data(netif);
800130b6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800130ba:	d9 22 20 00 	lea %a2,[%a2]32
800130be:	54 22       	ld.w %d2,[%a2]
800130c0:	59 e2 fc ff 	st.w [%a14]-4,%d2
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
800130c4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800130c8:	39 22 05 00 	ld.bu %d2,[%a2]5
800130cc:	8b a2 00 22 	eq %d2,%d2,10
800130d0:	df 02 0e 80 	jne %d2,0,800130ec <dhcp_supplied_address+0x54>
800130d4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800130d8:	39 22 05 00 	ld.bu %d2,[%a2]5
800130dc:	df 52 08 00 	jeq %d2,5,800130ec <dhcp_supplied_address+0x54>
           (dhcp->state == DHCP_STATE_REBINDING);
800130e0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800130e4:	39 22 05 00 	ld.bu %d2,[%a2]5
    return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
800130e8:	df 42 05 80 	jne %d2,4,800130f2 <dhcp_supplied_address+0x5a>
800130ec:	82 12       	mov %d2,1
800130ee:	1d 00 03 00 	j 800130f4 <dhcp_supplied_address+0x5c>
800130f2:	82 02       	mov %d2,0
800130f4:	8f f2 0f 21 	and %d2,%d2,255
800130f8:	00 90       	ret 
  }
  return 0;
800130fa:	82 02       	mov %d2,0
}
800130fc:	00 90       	ret 

800130fe <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
800130fe:	40 ae       	mov.aa %a14,%sp
80013100:	20 08       	sub.a %sp,8
80013102:	59 e4 fc ff 	st.w [%a14]-4,%d4
  /* remove from SNMP ARP index tree */
  mib2_remove_arp_entry(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
80013106:	91 10 00 27 	movh.a %a2,28673
8001310a:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001310e:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
80013112:	53 82 21 20 	mul %d2,%d2,24
80013116:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8001311a:	54 22       	ld.w %d2,[%a2]
8001311c:	df 02 1c 00 	jeq %d2,0,80013154 <etharp_free_entry+0x56>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
80013120:	91 10 00 27 	movh.a %a2,28673
80013124:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013128:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
8001312c:	53 82 21 20 	mul %d2,%d2,24
80013130:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80013134:	54 22       	ld.w %d2,[%a2]
80013136:	60 24       	mov.a %a4,%d2
80013138:	6d 00 30 37 	call 80019f98 <pbuf_free>
    arp_table[i].q = NULL;
8001313c:	91 10 00 27 	movh.a %a2,28673
80013140:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013144:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
80013148:	53 82 21 20 	mul %d2,%d2,24
8001314c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80013150:	82 02       	mov %d2,0
80013152:	74 22       	st.w [%a2],%d2
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
80013154:	91 10 00 27 	movh.a %a2,28673
80013158:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001315c:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
80013160:	53 82 21 20 	mul %d2,%d2,24
80013164:	80 23       	mov.d %d3,%a2
80013166:	42 23       	add %d3,%d2
80013168:	02 32       	mov %d2,%d3
8001316a:	60 22       	mov.a %a2,%d2
8001316c:	d9 22 14 00 	lea %a2,[%a2]20
80013170:	82 02       	mov %d2,0
80013172:	34 22       	st.b [%a2],%d2
#ifdef LWIP_DEBUG
  /* for debugging, clean out the complete entry */
  arp_table[i].ctime = 0;
80013174:	91 10 00 27 	movh.a %a2,28673
80013178:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001317c:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
80013180:	53 82 21 20 	mul %d2,%d2,24
80013184:	80 23       	mov.d %d3,%a2
80013186:	42 23       	add %d3,%d2
80013188:	02 32       	mov %d2,%d3
8001318a:	60 22       	mov.a %a2,%d2
8001318c:	d9 22 12 00 	lea %a2,[%a2]18
80013190:	82 02       	mov %d2,0
80013192:	b4 22       	st.h [%a2],%d2
  arp_table[i].netif = NULL;
80013194:	91 10 00 27 	movh.a %a2,28673
80013198:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001319c:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
800131a0:	53 82 21 20 	mul %d2,%d2,24
800131a4:	80 23       	mov.d %d3,%a2
800131a6:	42 23       	add %d3,%d2
800131a8:	02 32       	mov %d2,%d3
800131aa:	60 22       	mov.a %a2,%d2
800131ac:	d9 22 08 00 	lea %a2,[%a2]8
800131b0:	82 02       	mov %d2,0
800131b2:	74 22       	st.w [%a2],%d2
  ip4_addr_set_zero(&arp_table[i].ipaddr);
800131b4:	91 10 00 27 	movh.a %a2,28673
800131b8:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800131bc:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
800131c0:	53 82 21 20 	mul %d2,%d2,24
800131c4:	80 23       	mov.d %d3,%a2
800131c6:	42 23       	add %d3,%d2
800131c8:	02 32       	mov %d2,%d3
800131ca:	60 22       	mov.a %a2,%d2
800131cc:	b0 42       	add.a %a2,4
800131ce:	82 02       	mov %d2,0
800131d0:	74 22       	st.w [%a2],%d2
  arp_table[i].ethaddr = ethzero;
800131d2:	91 10 00 27 	movh.a %a2,28673
800131d6:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800131da:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
800131de:	53 82 21 20 	mul %d2,%d2,24
800131e2:	80 23       	mov.d %d3,%a2
800131e4:	42 23       	add %d3,%d2
800131e6:	02 32       	mov %d2,%d3
800131e8:	1b c2 00 20 	addi %d2,%d2,12
800131ec:	91 00 00 28 	movh.a %a2,32768
800131f0:	d9 23 56 44 	lea %a3,[%a2]17686 <80004516 <ethzero>>
800131f4:	60 22       	mov.a %a2,%d2
800131f6:	04 32       	ld.bu %d2,[%a3+]
800131f8:	24 22       	st.b [%a2+],%d2
800131fa:	04 32       	ld.bu %d2,[%a3+]
800131fc:	24 22       	st.b [%a2+],%d2
800131fe:	04 32       	ld.bu %d2,[%a3+]
80013200:	24 22       	st.b [%a2+],%d2
80013202:	04 32       	ld.bu %d2,[%a3+]
80013204:	24 22       	st.b [%a2+],%d2
80013206:	04 32       	ld.bu %d2,[%a3+]
80013208:	24 22       	st.b [%a2+],%d2
8001320a:	04 32       	ld.bu %d2,[%a3+]
8001320c:	24 22       	st.b [%a2+],%d2
#endif /* LWIP_DEBUG */
}
8001320e:	00 00       	nop 
80013210:	00 90       	ret 

80013212 <etharp_tmr>:
 * This function should be called every ARP_TMR_INTERVAL milliseconds (1 second),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
80013212:	40 ae       	mov.aa %a14,%sp
80013214:	20 08       	sub.a %sp,8
  int i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
80013216:	82 02       	mov %d2,0
80013218:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001321c:	1d 00 f1 00 	j 800133fe <etharp_tmr+0x1ec>
    u8_t state = arp_table[i].state;
80013220:	91 10 00 27 	movh.a %a2,28673
80013224:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013228:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
8001322c:	53 82 21 20 	mul %d2,%d2,24
80013230:	80 23       	mov.d %d3,%a2
80013232:	42 23       	add %d3,%d2
80013234:	02 32       	mov %d2,%d3
80013236:	60 22       	mov.a %a2,%d2
80013238:	d9 22 14 00 	lea %a2,[%a2]20
8001323c:	79 22 00 00 	ld.b %d2,[%a2]0
80013240:	e9 e2 fb ff 	st.b [%a14]-5,%d2
    if (state != ETHARP_STATE_EMPTY
80013244:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80013248:	df 02 d6 00 	jeq %d2,0,800133f4 <etharp_tmr+0x1e2>
#if ETHARP_SUPPORT_STATIC_ENTRIES
        && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
       ) {
      arp_table[i].ctime++;
8001324c:	91 10 00 27 	movh.a %a2,28673
80013250:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013254:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
80013258:	53 82 21 20 	mul %d2,%d2,24
8001325c:	80 23       	mov.d %d3,%a2
8001325e:	42 23       	add %d3,%d2
80013260:	02 32       	mov %d2,%d3
80013262:	60 22       	mov.a %a2,%d2
80013264:	d9 22 12 00 	lea %a2,[%a2]18
80013268:	b9 22 00 00 	ld.hu %d2,[%a2]0
8001326c:	c2 12       	add %d2,1
8001326e:	37 02 70 20 	extr.u %d2,%d2,0,16
80013272:	91 10 00 27 	movh.a %a2,28673
80013276:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001327a:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <7000af80 <arp_table>>
8001327e:	53 83 21 30 	mul %d3,%d3,24
80013282:	80 24       	mov.d %d4,%a2
80013284:	42 34       	add %d4,%d3
80013286:	02 43       	mov %d3,%d4
80013288:	60 32       	mov.a %a2,%d3
8001328a:	d9 22 12 00 	lea %a2,[%a2]18
8001328e:	b4 22       	st.h [%a2],%d2
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
80013290:	91 10 00 27 	movh.a %a2,28673
80013294:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013298:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
8001329c:	53 82 21 20 	mul %d2,%d2,24
800132a0:	80 23       	mov.d %d3,%a2
800132a2:	42 23       	add %d3,%d2
800132a4:	02 32       	mov %d2,%d3
800132a6:	60 22       	mov.a %a2,%d2
800132a8:	d9 22 12 00 	lea %a2,[%a2]18
800132ac:	b9 22 00 00 	ld.hu %d2,[%a2]0
800132b0:	8b c2 b2 22 	ge.u %d2,%d2,300
800132b4:	df 02 25 80 	jne %d2,0,800132fe <etharp_tmr+0xec>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
800132b8:	91 10 00 27 	movh.a %a2,28673
800132bc:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800132c0:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
800132c4:	53 82 21 20 	mul %d2,%d2,24
800132c8:	80 23       	mov.d %d3,%a2
800132ca:	42 23       	add %d3,%d2
800132cc:	02 32       	mov %d2,%d3
800132ce:	60 22       	mov.a %a2,%d2
800132d0:	d9 22 14 00 	lea %a2,[%a2]20
800132d4:	14 22       	ld.bu %d2,[%a2]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
800132d6:	df 12 1a 80 	jne %d2,1,8001330a <etharp_tmr+0xf8>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
800132da:	91 10 00 27 	movh.a %a2,28673
800132de:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800132e2:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
800132e6:	53 82 21 20 	mul %d2,%d2,24
800132ea:	80 23       	mov.d %d3,%a2
800132ec:	42 23       	add %d3,%d2
800132ee:	02 32       	mov %d2,%d3
800132f0:	60 22       	mov.a %a2,%d2
800132f2:	d9 22 12 00 	lea %a2,[%a2]18
800132f6:	b9 22 00 00 	ld.hu %d2,[%a2]0
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
800132fa:	bf 52 08 80 	jlt.u %d2,5,8001330a <etharp_tmr+0xf8>
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %d.\n",
                                   arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
800132fe:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80013302:	6d ff fe fe 	call 800130fe <etharp_free_entry>
80013306:	1d 00 77 00 	j 800133f4 <etharp_tmr+0x1e2>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_1) {
8001330a:	91 10 00 27 	movh.a %a2,28673
8001330e:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013312:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
80013316:	53 82 21 20 	mul %d2,%d2,24
8001331a:	80 23       	mov.d %d3,%a2
8001331c:	42 23       	add %d3,%d2
8001331e:	02 32       	mov %d2,%d3
80013320:	60 22       	mov.a %a2,%d2
80013322:	d9 22 14 00 	lea %a2,[%a2]20
80013326:	14 22       	ld.bu %d2,[%a2]
80013328:	df 32 14 80 	jne %d2,3,80013350 <etharp_tmr+0x13e>
        /* Don't send more than one request every 2 seconds. */
        arp_table[i].state = ETHARP_STATE_STABLE_REREQUESTING_2;
8001332c:	91 10 00 27 	movh.a %a2,28673
80013330:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013334:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
80013338:	53 82 21 20 	mul %d2,%d2,24
8001333c:	80 23       	mov.d %d3,%a2
8001333e:	42 23       	add %d3,%d2
80013340:	02 32       	mov %d2,%d3
80013342:	60 22       	mov.a %a2,%d2
80013344:	d9 22 14 00 	lea %a2,[%a2]20
80013348:	82 42       	mov %d2,4
8001334a:	34 22       	st.b [%a2],%d2
8001334c:	1d 00 54 00 	j 800133f4 <etharp_tmr+0x1e2>
      } else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING_2) {
80013350:	91 10 00 27 	movh.a %a2,28673
80013354:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013358:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
8001335c:	53 82 21 20 	mul %d2,%d2,24
80013360:	80 23       	mov.d %d3,%a2
80013362:	42 23       	add %d3,%d2
80013364:	02 32       	mov %d2,%d3
80013366:	60 22       	mov.a %a2,%d2
80013368:	d9 22 14 00 	lea %a2,[%a2]20
8001336c:	14 22       	ld.bu %d2,[%a2]
8001336e:	df 42 14 80 	jne %d2,4,80013396 <etharp_tmr+0x184>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
80013372:	91 10 00 27 	movh.a %a2,28673
80013376:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001337a:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
8001337e:	53 82 21 20 	mul %d2,%d2,24
80013382:	80 23       	mov.d %d3,%a2
80013384:	42 23       	add %d3,%d2
80013386:	02 32       	mov %d2,%d3
80013388:	60 22       	mov.a %a2,%d2
8001338a:	d9 22 14 00 	lea %a2,[%a2]20
8001338e:	82 22       	mov %d2,2
80013390:	34 22       	st.b [%a2],%d2
80013392:	1d 00 31 00 	j 800133f4 <etharp_tmr+0x1e2>
      } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
80013396:	91 10 00 27 	movh.a %a2,28673
8001339a:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001339e:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
800133a2:	53 82 21 20 	mul %d2,%d2,24
800133a6:	80 23       	mov.d %d3,%a2
800133a8:	42 23       	add %d3,%d2
800133aa:	02 32       	mov %d2,%d3
800133ac:	60 22       	mov.a %a2,%d2
800133ae:	d9 22 14 00 	lea %a2,[%a2]20
800133b2:	14 22       	ld.bu %d2,[%a2]
800133b4:	df 12 20 80 	jne %d2,1,800133f4 <etharp_tmr+0x1e2>
        /* still pending, resend an ARP query */
        etharp_request(arp_table[i].netif, &arp_table[i].ipaddr);
800133b8:	91 10 00 27 	movh.a %a2,28673
800133bc:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800133c0:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000af80 <arp_table>>
800133c4:	53 82 21 20 	mul %d2,%d2,24
800133c8:	80 23       	mov.d %d3,%a2
800133ca:	42 23       	add %d3,%d2
800133cc:	02 32       	mov %d2,%d3
800133ce:	60 22       	mov.a %a2,%d2
800133d0:	d9 22 08 00 	lea %a2,[%a2]8
800133d4:	54 23       	ld.w %d3,[%a2]
800133d6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800133da:	53 82 21 20 	mul %d2,%d2,24
800133de:	c2 42       	add %d2,4
800133e0:	91 10 00 27 	movh.a %a2,28673
800133e4:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800133e8:	80 24       	mov.d %d4,%a2
800133ea:	42 42       	add %d2,%d4
800133ec:	60 25       	mov.a %a5,%d2
800133ee:	60 34       	mov.a %a4,%d3
800133f0:	6d 00 d8 09 	call 800147a0 <etharp_request>
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
800133f4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800133f8:	c2 12       	add %d2,1
800133fa:	59 e2 fc ff 	st.w [%a14]-4,%d2
800133fe:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80013402:	8b a2 40 22 	lt %d2,%d2,10
80013406:	df 02 0d ff 	jne %d2,0,80013220 <etharp_tmr+0xe>
      }
    }
  }
}
8001340a:	00 00       	nop 
8001340c:	00 00       	nop 
8001340e:	00 90       	ret 

80013410 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s16_t
etharp_find_entry(const ip4_addr_t *ipaddr, u8_t flags, struct netif *netif)
{
80013410:	40 ae       	mov.aa %a14,%sp
80013412:	20 38       	sub.a %sp,56
80013414:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80013418:	02 42       	mov %d2,%d4
8001341a:	b5 e5 dc ff 	st.a [%a14]-36,%a5
8001341e:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
  s16_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
80013422:	3b a0 00 20 	mov %d2,10
80013426:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
8001342a:	3b a0 00 20 	mov %d2,10
8001342e:	f9 e2 fa ff 	st.h [%a14]-6,%d2
  s16_t empty = ARP_TABLE_SIZE;
80013432:	3b a0 00 20 	mov %d2,10
80013436:	f9 e2 fc ff 	st.h [%a14]-4,%d2
  s16_t i = 0;
8001343a:	82 02       	mov %d2,0
8001343c:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  /* oldest entry with packets on queue */
  s16_t old_queue = ARP_TABLE_SIZE;
80013440:	3b a0 00 20 	mov %d2,10
80013444:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
  /* its age */
  u16_t age_queue = 0, age_pending = 0, age_stable = 0;
80013448:	82 02       	mov %d2,0
8001344a:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
8001344e:	82 02       	mov %d2,0
80013450:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
80013454:	82 02       	mov %d2,0
80013456:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
8001345a:	82 02       	mov %d2,0
8001345c:	f9 e2 fe ff 	st.h [%a14]-2,%d2
80013460:	1d 00 11 01 	j 80013682 <etharp_find_entry+0x272>
    u8_t state = arp_table[i].state;
80013464:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013468:	91 10 00 27 	movh.a %a2,28673
8001346c:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013470:	53 82 21 20 	mul %d2,%d2,24
80013474:	80 23       	mov.d %d3,%a2
80013476:	42 23       	add %d3,%d2
80013478:	02 32       	mov %d2,%d3
8001347a:	60 22       	mov.a %a2,%d2
8001347c:	d9 22 14 00 	lea %a2,[%a2]20
80013480:	79 22 00 00 	ld.b %d2,[%a2]0
80013484:	e9 e2 ef ff 	st.b [%a14]-17,%d2
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
80013488:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
8001348c:	8b a2 20 22 	ne %d2,%d2,10
80013490:	df 02 0c 80 	jne %d2,0,800134a8 <etharp_find_entry+0x98>
80013494:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
80013498:	df 02 08 80 	jne %d2,0,800134a8 <etharp_find_entry+0x98>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %d\n", (int)i));
      /* remember first empty entry */
      empty = i;
8001349c:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800134a0:	f9 e2 fc ff 	st.h [%a14]-4,%d2
800134a4:	1d 00 e8 00 	j 80013674 <etharp_find_entry+0x264>
    } else if (state != ETHARP_STATE_EMPTY) {
800134a8:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
800134ac:	df 02 e4 00 	jeq %d2,0,80013674 <etharp_find_entry+0x264>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
800134b0:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
800134b4:	df 12 1b 00 	jeq %d2,1,800134ea <etharp_find_entry+0xda>
800134b8:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
800134bc:	ff 22 17 80 	jge.u %d2,2,800134ea <etharp_find_entry+0xda>
800134c0:	91 00 00 28 	movh.a %a2,32768
800134c4:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
800134c8:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
800134cc:	3b 30 12 20 	mov %d2,291
800134d0:	59 a2 04 00 	st.w [%sp]4,%d2
800134d4:	91 00 00 28 	movh.a %a2,32768
800134d8:	d9 22 c2 70 	lea %a2,[%a2]3522 <80000dc2 <IfxCpu_Trap_vectorTable0_end+0xbce>>
800134dc:	f4 a2       	st.a [%sp],%a2
800134de:	91 00 00 28 	movh.a %a2,32768
800134e2:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
800134e6:	6d ff 28 8f 	call 80005336 <Ifx_Lwip_printf>
                  state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip4_addr_cmp(ipaddr, &arp_table[i].ipaddr)
800134ea:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800134ee:	df 02 2f 00 	jeq %d2,0,8001354c <etharp_find_entry+0x13c>
800134f2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800134f6:	54 23       	ld.w %d3,[%a2]
800134f8:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800134fc:	91 10 00 27 	movh.a %a2,28673
80013500:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013504:	53 82 21 20 	mul %d2,%d2,24
80013508:	80 24       	mov.d %d4,%a2
8001350a:	42 24       	add %d4,%d2
8001350c:	02 42       	mov %d2,%d4
8001350e:	60 22       	mov.a %a2,%d2
80013510:	b0 42       	add.a %a2,4
80013512:	54 22       	ld.w %d2,[%a2]
80013514:	5f 23 1c 80 	jne %d3,%d2,8001354c <etharp_find_entry+0x13c>
#if ETHARP_TABLE_MATCH_NETIF
          && ((netif == NULL) || (netif == arp_table[i].netif))
80013518:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8001351c:	df 02 15 00 	jeq %d2,0,80013546 <etharp_find_entry+0x136>
80013520:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013524:	91 10 00 27 	movh.a %a2,28673
80013528:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001352c:	53 82 21 20 	mul %d2,%d2,24
80013530:	80 23       	mov.d %d3,%a2
80013532:	42 23       	add %d3,%d2
80013534:	02 32       	mov %d2,%d3
80013536:	60 22       	mov.a %a2,%d2
80013538:	d9 22 08 00 	lea %a2,[%a2]8
8001353c:	54 22       	ld.w %d2,[%a2]
8001353e:	19 e3 dc ff 	ld.w %d3,[%a14]-36
80013542:	5f 23 05 80 	jne %d3,%d2,8001354c <etharp_find_entry+0x13c>
#endif /* ETHARP_TABLE_MATCH_NETIF */
         ) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %d\n", (int)i));
        /* found exact IP address match, simply bail out */
        return i;
80013546:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001354a:	00 90       	ret 
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
8001354c:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
80013550:	df 12 65 80 	jne %d2,1,8001361a <etharp_find_entry+0x20a>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
80013554:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013558:	91 10 00 27 	movh.a %a2,28673
8001355c:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013560:	53 82 21 20 	mul %d2,%d2,24
80013564:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80013568:	54 22       	ld.w %d2,[%a2]
8001356a:	df 02 2d 00 	jeq %d2,0,800135c4 <etharp_find_entry+0x1b4>
          if (arp_table[i].ctime >= age_queue) {
8001356e:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013572:	91 10 00 27 	movh.a %a2,28673
80013576:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001357a:	53 82 21 20 	mul %d2,%d2,24
8001357e:	80 23       	mov.d %d3,%a2
80013580:	42 23       	add %d3,%d2
80013582:	02 32       	mov %d2,%d3
80013584:	60 22       	mov.a %a2,%d2
80013586:	d9 22 12 00 	lea %a2,[%a2]18
8001358a:	b9 23 00 00 	ld.hu %d3,[%a2]0
8001358e:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
80013592:	3f 23 71 80 	jlt.u %d3,%d2,80013674 <etharp_find_entry+0x264>
            old_queue = i;
80013596:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001359a:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
            age_queue = arp_table[i].ctime;
8001359e:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800135a2:	91 10 00 27 	movh.a %a2,28673
800135a6:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800135aa:	53 82 21 20 	mul %d2,%d2,24
800135ae:	80 23       	mov.d %d3,%a2
800135b0:	42 23       	add %d3,%d2
800135b2:	02 32       	mov %d2,%d3
800135b4:	60 22       	mov.a %a2,%d2
800135b6:	d9 22 12 00 	lea %a2,[%a2]18
800135ba:	94 22       	ld.h %d2,[%a2]
800135bc:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
800135c0:	1d 00 5a 00 	j 80013674 <etharp_find_entry+0x264>
          }
        } else
          /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
800135c4:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800135c8:	91 10 00 27 	movh.a %a2,28673
800135cc:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800135d0:	53 82 21 20 	mul %d2,%d2,24
800135d4:	80 23       	mov.d %d3,%a2
800135d6:	42 23       	add %d3,%d2
800135d8:	02 32       	mov %d2,%d3
800135da:	60 22       	mov.a %a2,%d2
800135dc:	d9 22 12 00 	lea %a2,[%a2]18
800135e0:	b9 23 00 00 	ld.hu %d3,[%a2]0
800135e4:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
800135e8:	3f 23 46 80 	jlt.u %d3,%d2,80013674 <etharp_find_entry+0x264>
            old_pending = i;
800135ec:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800135f0:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
            age_pending = arp_table[i].ctime;
800135f4:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800135f8:	91 10 00 27 	movh.a %a2,28673
800135fc:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013600:	53 82 21 20 	mul %d2,%d2,24
80013604:	80 23       	mov.d %d3,%a2
80013606:	42 23       	add %d3,%d2
80013608:	02 32       	mov %d2,%d3
8001360a:	60 22       	mov.a %a2,%d2
8001360c:	d9 22 12 00 	lea %a2,[%a2]18
80013610:	94 22       	ld.h %d2,[%a2]
80013612:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
80013616:	1d 00 2f 00 	j 80013674 <etharp_find_entry+0x264>
          }
        }
        /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
8001361a:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
8001361e:	bf 22 2b 80 	jlt.u %d2,2,80013674 <etharp_find_entry+0x264>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
80013622:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013626:	91 10 00 27 	movh.a %a2,28673
8001362a:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001362e:	53 82 21 20 	mul %d2,%d2,24
80013632:	80 23       	mov.d %d3,%a2
80013634:	42 23       	add %d3,%d2
80013636:	02 32       	mov %d2,%d3
80013638:	60 22       	mov.a %a2,%d2
8001363a:	d9 22 12 00 	lea %a2,[%a2]18
8001363e:	b9 23 00 00 	ld.hu %d3,[%a2]0
80013642:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
80013646:	3f 23 17 80 	jlt.u %d3,%d2,80013674 <etharp_find_entry+0x264>
            old_stable = i;
8001364a:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001364e:	f9 e2 fa ff 	st.h [%a14]-6,%d2
            age_stable = arp_table[i].ctime;
80013652:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013656:	91 10 00 27 	movh.a %a2,28673
8001365a:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001365e:	53 82 21 20 	mul %d2,%d2,24
80013662:	80 23       	mov.d %d3,%a2
80013664:	42 23       	add %d3,%d2
80013666:	02 32       	mov %d2,%d3
80013668:	60 22       	mov.a %a2,%d2
8001366a:	d9 22 12 00 	lea %a2,[%a2]18
8001366e:	94 22       	ld.h %d2,[%a2]
80013670:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
80013674:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80013678:	c2 12       	add %d2,1
8001367a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001367e:	f9 e2 fe ff 	st.h [%a14]-2,%d2
80013682:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013686:	8b a2 40 22 	lt %d2,%d2,10
8001368a:	df 02 ed fe 	jne %d2,0,80013464 <etharp_find_entry+0x54>
    }
  }
  /* { we have no match } => try to create a new entry */

  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
8001368e:	39 e2 e0 ff 	ld.bu %d2,[%a14]-32
80013692:	8f 22 00 21 	and %d2,%d2,2
80013696:	df 02 0e 80 	jne %d2,0,800136b2 <etharp_find_entry+0x2a2>
8001369a:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
8001369e:	8b a2 20 22 	ne %d2,%d2,10
800136a2:	df 02 0a 80 	jne %d2,0,800136b6 <etharp_find_entry+0x2a6>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
800136a6:	39 e2 e0 ff 	ld.bu %d2,[%a14]-32
800136aa:	8f 12 00 21 	and %d2,%d2,1
800136ae:	df 02 04 80 	jne %d2,0,800136b6 <etharp_find_entry+0x2a6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s16_t)ERR_MEM;
800136b2:	82 f2       	mov %d2,-1
800136b4:	00 90       	ret 
   *
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
800136b6:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
800136ba:	8b a2 80 22 	ge %d2,%d2,10
800136be:	df 02 08 80 	jne %d2,0,800136ce <etharp_find_entry+0x2be>
    i = empty;
800136c2:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
800136c6:	f9 e2 fe ff 	st.h [%a14]-2,%d2
800136ca:	1d 00 6a 00 	j 8001379e <etharp_find_entry+0x38e>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %d\n", (int)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
800136ce:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
800136d2:	8b a2 80 22 	ge %d2,%d2,10
800136d6:	df 02 2a 80 	jne %d2,0,8001372a <etharp_find_entry+0x31a>
      /* recycle oldest stable*/
      i = old_stable;
800136da:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
800136de:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %d\n", (int)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
800136e2:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800136e6:	91 10 00 27 	movh.a %a2,28673
800136ea:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800136ee:	53 82 21 20 	mul %d2,%d2,24
800136f2:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800136f6:	54 22       	ld.w %d2,[%a2]
800136f8:	df 02 33 00 	jeq %d2,0,8001375e <etharp_find_entry+0x34e>
800136fc:	91 00 00 28 	movh.a %a2,32768
80013700:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
80013704:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80013708:	3b d0 16 20 	mov %d2,365
8001370c:	59 a2 04 00 	st.w [%sp]4,%d2
80013710:	91 00 00 28 	movh.a %a2,32768
80013714:	d9 22 c0 80 	lea %a2,[%a2]3584 <80000e00 <IfxCpu_Trap_vectorTable0_end+0xc0c>>
80013718:	f4 a2       	st.a [%sp],%a2
8001371a:	91 00 00 28 	movh.a %a2,32768
8001371e:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80013722:	6d ff 0a 8e 	call 80005336 <Ifx_Lwip_printf>
80013726:	1d 00 1c 00 	j 8001375e <etharp_find_entry+0x34e>
      /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
8001372a:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
8001372e:	8b a2 80 22 	ge %d2,%d2,10
80013732:	df 02 08 80 	jne %d2,0,80013742 <etharp_find_entry+0x332>
      /* recycle oldest pending */
      i = old_pending;
80013736:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
8001373a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
8001373e:	1d 00 10 00 	j 8001375e <etharp_find_entry+0x34e>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %d (without queue)\n", (int)i));
      /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
80013742:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
80013746:	8b a2 80 22 	ge %d2,%d2,10
8001374a:	df 02 08 80 	jne %d2,0,8001375a <etharp_find_entry+0x34a>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
8001374e:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
80013752:	f9 e2 fe ff 	st.h [%a14]-2,%d2
80013756:	1d 00 04 00 	j 8001375e <etharp_find_entry+0x34e>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %d, freeing packet queue %p\n", (int)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s16_t)ERR_MEM;
8001375a:	82 f2       	mov %d2,-1
8001375c:	00 90       	ret 
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
8001375e:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013762:	8b a2 40 22 	lt %d2,%d2,10
80013766:	df 02 17 80 	jne %d2,0,80013794 <etharp_find_entry+0x384>
8001376a:	91 00 00 28 	movh.a %a2,32768
8001376e:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
80013772:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80013776:	3b f0 17 20 	mov %d2,383
8001377a:	59 a2 04 00 	st.w [%sp]4,%d2
8001377e:	91 00 00 28 	movh.a %a2,32768
80013782:	d9 22 d7 80 	lea %a2,[%a2]3607 <80000e17 <IfxCpu_Trap_vectorTable0_end+0xc23>>
80013786:	f4 a2       	st.a [%sp],%a2
80013788:	91 00 00 28 	movh.a %a2,32768
8001378c:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80013790:	6d ff d3 8d 	call 80005336 <Ifx_Lwip_printf>
    etharp_free_entry(i);
80013794:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013798:	02 24       	mov %d4,%d2
8001379a:	6d ff b2 fc 	call 800130fe <etharp_free_entry>
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
8001379e:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800137a2:	8b a2 40 22 	lt %d2,%d2,10
800137a6:	df 02 17 80 	jne %d2,0,800137d4 <etharp_find_entry+0x3c4>
800137aa:	91 00 00 28 	movh.a %a2,32768
800137ae:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
800137b2:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
800137b6:	3b 30 18 20 	mov %d2,387
800137ba:	59 a2 04 00 	st.w [%sp]4,%d2
800137be:	91 00 00 28 	movh.a %a2,32768
800137c2:	d9 22 d7 80 	lea %a2,[%a2]3607 <80000e17 <IfxCpu_Trap_vectorTable0_end+0xc23>>
800137c6:	f4 a2       	st.a [%sp],%a2
800137c8:	91 00 00 28 	movh.a %a2,32768
800137cc:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
800137d0:	6d ff b3 8d 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
800137d4:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800137d8:	91 10 00 27 	movh.a %a2,28673
800137dc:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800137e0:	53 82 21 20 	mul %d2,%d2,24
800137e4:	80 23       	mov.d %d3,%a2
800137e6:	42 23       	add %d3,%d2
800137e8:	02 32       	mov %d2,%d3
800137ea:	60 22       	mov.a %a2,%d2
800137ec:	d9 22 14 00 	lea %a2,[%a2]20
800137f0:	14 22       	ld.bu %d2,[%a2]
800137f2:	df 02 17 00 	jeq %d2,0,80013820 <etharp_find_entry+0x410>
800137f6:	91 00 00 28 	movh.a %a2,32768
800137fa:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
800137fe:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80013802:	3b 40 18 20 	mov %d2,388
80013806:	59 a2 04 00 	st.w [%sp]4,%d2
8001380a:	91 00 00 28 	movh.a %a2,32768
8001380e:	d9 22 ea 80 	lea %a2,[%a2]3626 <80000e2a <IfxCpu_Trap_vectorTable0_end+0xc36>>
80013812:	f4 a2       	st.a [%sp],%a2
80013814:	91 00 00 28 	movh.a %a2,32768
80013818:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
8001381c:	6d ff 8d 8d 	call 80005336 <Ifx_Lwip_printf>
              arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
80013820:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80013824:	df 02 13 00 	jeq %d2,0,8001384a <etharp_find_entry+0x43a>
    /* set IP address */
    ip4_addr_copy(arp_table[i].ipaddr, *ipaddr);
80013828:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001382c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80013830:	54 23       	ld.w %d3,[%a2]
80013832:	91 10 00 27 	movh.a %a2,28673
80013836:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001383a:	53 82 21 20 	mul %d2,%d2,24
8001383e:	80 24       	mov.d %d4,%a2
80013840:	42 24       	add %d4,%d2
80013842:	02 42       	mov %d2,%d4
80013844:	60 22       	mov.a %a2,%d2
80013846:	b0 42       	add.a %a2,4
80013848:	74 23       	st.w [%a2],%d3
  }
  arp_table[i].ctime = 0;
8001384a:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001384e:	91 10 00 27 	movh.a %a2,28673
80013852:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013856:	53 82 21 20 	mul %d2,%d2,24
8001385a:	80 23       	mov.d %d3,%a2
8001385c:	42 23       	add %d3,%d2
8001385e:	02 32       	mov %d2,%d3
80013860:	60 22       	mov.a %a2,%d2
80013862:	d9 22 12 00 	lea %a2,[%a2]18
80013866:	82 02       	mov %d2,0
80013868:	b4 22       	st.h [%a2],%d2
#if ETHARP_TABLE_MATCH_NETIF
  arp_table[i].netif = netif;
8001386a:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001386e:	91 10 00 27 	movh.a %a2,28673
80013872:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013876:	53 82 21 20 	mul %d2,%d2,24
8001387a:	80 23       	mov.d %d3,%a2
8001387c:	42 23       	add %d3,%d2
8001387e:	02 32       	mov %d2,%d3
80013880:	60 22       	mov.a %a2,%d2
80013882:	d9 22 08 00 	lea %a2,[%a2]8
80013886:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8001388a:	74 22       	st.w [%a2],%d2
#endif /* ETHARP_TABLE_MATCH_NETIF */
  return (s16_t)i;
8001388c:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
}
80013890:	00 90       	ret 

80013892 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, const ip4_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
80013892:	40 ae       	mov.aa %a14,%sp
80013894:	20 28       	sub.a %sp,40
80013896:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001389a:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
8001389e:	b5 e6 ec ff 	st.a [%a14]-20,%a6
800138a2:	02 42       	mov %d2,%d4
800138a4:	e9 e2 e8 ff 	st.b [%a14]-24,%d2
  s16_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETH_HWADDR_LEN", netif->hwaddr_len == ETH_HWADDR_LEN);
800138a8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800138ac:	39 22 30 00 	ld.bu %d2,[%a2]48
800138b0:	df 62 17 00 	jeq %d2,6,800138de <etharp_update_arp_entry+0x4c>
800138b4:	91 00 00 28 	movh.a %a2,32768
800138b8:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
800138bc:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
800138c0:	3b 90 1a 20 	mov %d2,425
800138c4:	59 a2 04 00 	st.w [%sp]4,%d2
800138c8:	91 00 00 28 	movh.a %a2,32768
800138cc:	d9 22 d3 90 	lea %a2,[%a2]3667 <80000e53 <IfxCpu_Trap_vectorTable0_end+0xc5f>>
800138d0:	f4 a2       	st.a [%sp],%a2
800138d2:	91 00 00 28 	movh.a %a2,32768
800138d6:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
800138da:	6d ff 2e 8d 	call 80005336 <Ifx_Lwip_printf>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
              ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
              (u16_t)ethaddr->addr[0], (u16_t)ethaddr->addr[1], (u16_t)ethaddr->addr[2],
              (u16_t)ethaddr->addr[3], (u16_t)ethaddr->addr[4], (u16_t)ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip4_addr_isany(ipaddr) ||
800138de:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800138e2:	df 02 1a 00 	jeq %d2,0,80013916 <etharp_update_arp_entry+0x84>
800138e6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800138ea:	54 22       	ld.w %d2,[%a2]
800138ec:	df 02 15 00 	jeq %d2,0,80013916 <etharp_update_arp_entry+0x84>
      ip4_addr_isbroadcast(ipaddr, netif) ||
800138f0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800138f4:	54 22       	ld.w %d2,[%a2]
800138f6:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800138fa:	02 24       	mov %d4,%d2
800138fc:	6d 00 a8 11 	call 80015c4c <ip4_addr_isbroadcast_u32>
  if (ip4_addr_isany(ipaddr) ||
80013900:	df 02 0b 80 	jne %d2,0,80013916 <etharp_update_arp_entry+0x84>
      ip4_addr_ismulticast(ipaddr)) {
80013904:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80013908:	54 22       	ld.w %d2,[%a2]
8001390a:	8f 02 0f 21 	and %d2,%d2,240
      ip4_addr_isbroadcast(ipaddr, netif) ||
8001390e:	8b 02 2e 22 	ne %d2,%d2,224
80013912:	df 02 05 80 	jne %d2,0,8001391c <etharp_update_arp_entry+0x8a>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
80013916:	3b 00 ff 2f 	mov %d2,-16
8001391a:	00 90       	ret 
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags, netif);
8001391c:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
80013920:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80013924:	02 24       	mov %d4,%d2
80013926:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
8001392a:	6d ff 73 fd 	call 80013410 <etharp_find_entry>
8001392e:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  /* bail out if no entry could be found */
  if (i < 0) {
80013932:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013936:	ff 02 07 00 	jge %d2,0,80013944 <etharp_update_arp_entry+0xb2>
    return (err_t)i;
8001393a:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001393e:	37 02 48 20 	extr %d2,%d2,0,8
80013942:	00 90       	ret 
    return ERR_VAL;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
80013944:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013948:	91 10 00 27 	movh.a %a2,28673
8001394c:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013950:	53 82 21 20 	mul %d2,%d2,24
80013954:	80 23       	mov.d %d3,%a2
80013956:	42 23       	add %d3,%d2
80013958:	02 32       	mov %d2,%d3
8001395a:	60 22       	mov.a %a2,%d2
8001395c:	d9 22 14 00 	lea %a2,[%a2]20
80013960:	82 22       	mov %d2,2
80013962:	34 22       	st.b [%a2],%d2
  }

  /* record network interface */
  arp_table[i].netif = netif;
80013964:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013968:	91 10 00 27 	movh.a %a2,28673
8001396c:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013970:	53 82 21 20 	mul %d2,%d2,24
80013974:	80 23       	mov.d %d3,%a2
80013976:	42 23       	add %d3,%d2
80013978:	02 32       	mov %d2,%d3
8001397a:	60 22       	mov.a %a2,%d2
8001397c:	d9 22 08 00 	lea %a2,[%a2]8
80013980:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80013984:	74 22       	st.w [%a2],%d2
  /* insert in SNMP ARP index tree */
  mib2_add_arp_entry(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", i));
  /* update address */
  SMEMCPY(&arp_table[i].ethaddr, ethaddr, ETH_HWADDR_LEN);
80013986:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001398a:	53 82 21 20 	mul %d2,%d2,24
8001398e:	1b c2 00 20 	addi %d2,%d2,12
80013992:	91 10 00 27 	movh.a %a2,28673
80013996:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001399a:	80 23       	mov.d %d3,%a2
8001399c:	42 32       	add %d2,%d3
8001399e:	82 64       	mov %d4,6
800139a0:	99 e5 ec ff 	ld.a %a5,[%a14]-20
800139a4:	60 24       	mov.a %a4,%d2
800139a6:	6d 00 3b 9c 	call 8002721c <memcpy>
  /* reset time stamp */
  arp_table[i].ctime = 0;
800139aa:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800139ae:	91 10 00 27 	movh.a %a2,28673
800139b2:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800139b6:	53 82 21 20 	mul %d2,%d2,24
800139ba:	80 23       	mov.d %d3,%a2
800139bc:	42 23       	add %d3,%d2
800139be:	02 32       	mov %d2,%d3
800139c0:	60 22       	mov.a %a2,%d2
800139c2:	d9 22 12 00 	lea %a2,[%a2]18
800139c6:	82 02       	mov %d2,0
800139c8:	b4 22       	st.h [%a2],%d2
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
800139ca:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800139ce:	91 10 00 27 	movh.a %a2,28673
800139d2:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800139d6:	53 82 21 20 	mul %d2,%d2,24
800139da:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800139de:	54 22       	ld.w %d2,[%a2]
800139e0:	df 02 2e 00 	jeq %d2,0,80013a3c <etharp_update_arp_entry+0x1aa>
    struct pbuf *p = arp_table[i].q;
800139e4:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800139e8:	91 10 00 27 	movh.a %a2,28673
800139ec:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800139f0:	53 82 21 20 	mul %d2,%d2,24
800139f4:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800139f8:	54 22       	ld.w %d2,[%a2]
800139fa:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    arp_table[i].q = NULL;
800139fe:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80013a02:	91 10 00 27 	movh.a %a2,28673
80013a06:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013a0a:	53 82 21 20 	mul %d2,%d2,24
80013a0e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80013a12:	82 02       	mov %d2,0
80013a14:	74 22       	st.w [%a2],%d2
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    ethernet_output(netif, p, (struct eth_addr *)(netif->hwaddr), ethaddr, ETHTYPE_IP);
80013a16:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80013a1a:	1b a2 02 20 	addi %d2,%d2,42
80013a1e:	3b 00 80 40 	mov %d4,2048
80013a22:	99 e7 ec ff 	ld.a %a7,[%a14]-20
80013a26:	60 26       	mov.a %a6,%d2
80013a28:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80013a2c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80013a30:	6d ff 7a e3 	call 80010124 <ethernet_output>
    /* free the queued IP packet */
    pbuf_free(p);
80013a34:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80013a38:	6d 00 b0 32 	call 80019f98 <pbuf_free>
  }
  return ERR_OK;
80013a3c:	82 02       	mov %d2,0
}
80013a3e:	00 90       	ret 

80013a40 <etharp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_input(struct pbuf *p, struct netif *netif)
{
80013a40:	40 ae       	mov.aa %a14,%sp
80013a42:	20 28       	sub.a %sp,40
80013a44:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80013a48:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
  ip4_addr_t sipaddr, dipaddr;
  u8_t for_us;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
80013a4c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80013a50:	df 02 18 80 	jne %d2,0,80013a80 <etharp_input+0x40>
80013a54:	91 00 00 28 	movh.a %a2,32768
80013a58:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
80013a5c:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80013a60:	3b a0 28 20 	mov %d2,650
80013a64:	59 a2 04 00 	st.w [%sp]4,%d2
80013a68:	91 00 00 28 	movh.a %a2,32768
80013a6c:	d9 22 e8 a0 	lea %a2,[%a2]3752 <80000ea8 <IfxCpu_Trap_vectorTable0_end+0xcb4>>
80013a70:	f4 a2       	st.a [%sp],%a2
80013a72:	91 00 00 28 	movh.a %a2,32768
80013a76:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80013a7a:	6d ff 5e 8c 	call 80005336 <Ifx_Lwip_printf>
80013a7e:	00 90       	ret 

  hdr = (struct etharp_hdr *)p->payload;
80013a80:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80013a84:	b0 42       	add.a %a2,4
80013a86:	54 22       	ld.w %d2,[%a2]
80013a88:	59 e2 fc ff 	st.w [%a14]-4,%d2

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
80013a8c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80013a90:	14 23       	ld.bu %d3,[%a2]
80013a92:	39 22 01 00 	ld.bu %d2,[%a2]1
80013a96:	8f 82 00 20 	sh %d2,%d2,8
80013a9a:	a6 32       	or %d2,%d3
80013a9c:	37 02 70 20 	extr.u %d2,%d2,0,16
80013aa0:	3b 00 10 30 	mov %d3,256
80013aa4:	5f 32 1d 80 	jne %d2,%d3,80013ade <etharp_input+0x9e>
      (hdr->hwlen != ETH_HWADDR_LEN) ||
80013aa8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80013aac:	39 22 04 00 	ld.bu %d2,[%a2]4
  if ((hdr->hwtype != PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET)) ||
80013ab0:	df 62 17 80 	jne %d2,6,80013ade <etharp_input+0x9e>
      (hdr->protolen != sizeof(ip4_addr_t)) ||
80013ab4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80013ab8:	39 22 05 00 	ld.bu %d2,[%a2]5
      (hdr->hwlen != ETH_HWADDR_LEN) ||
80013abc:	df 42 11 80 	jne %d2,4,80013ade <etharp_input+0x9e>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
80013ac0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80013ac4:	39 23 02 00 	ld.bu %d3,[%a2]2
80013ac8:	39 22 03 00 	ld.bu %d2,[%a2]3
80013acc:	8f 82 00 20 	sh %d2,%d2,8
80013ad0:	a6 32       	or %d2,%d3
80013ad2:	37 02 70 20 	extr.u %d2,%d2,0,16
      (hdr->protolen != sizeof(ip4_addr_t)) ||
80013ad6:	8b 82 00 22 	eq %d2,%d2,8
80013ada:	df 02 25 80 	jne %d2,0,80013b24 <etharp_input+0xe4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
                ("etharp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
                 hdr->hwtype, (u16_t)hdr->hwlen, hdr->proto, (u16_t)hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
80013ade:	91 10 00 27 	movh.a %a2,28673
80013ae2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80013ae6:	b9 22 28 00 	ld.hu %d2,[%a2]40 <70010028 <ram_heap+0x4f94>>
80013aea:	c2 12       	add %d2,1
80013aec:	37 02 70 20 	extr.u %d2,%d2,0,16
80013af0:	91 10 00 27 	movh.a %a2,28673
80013af4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80013af8:	f9 22 28 00 	st.h [%a2]40 <70010028 <ram_heap+0x4f94>>,%d2
    ETHARP_STATS_INC(etharp.drop);
80013afc:	91 10 00 27 	movh.a %a2,28673
80013b00:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80013b04:	b9 22 1e 00 	ld.hu %d2,[%a2]30 <7001001e <ram_heap+0x4f8a>>
80013b08:	c2 12       	add %d2,1
80013b0a:	37 02 70 20 	extr.u %d2,%d2,0,16
80013b0e:	91 10 00 27 	movh.a %a2,28673
80013b12:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80013b16:	f9 22 1e 00 	st.h [%a2]30 <7001001e <ram_heap+0x4f8a>>,%d2
    pbuf_free(p);
80013b1a:	99 e4 ec ff 	ld.a %a4,[%a14]-20 <7001001e <ram_heap+0x4f8a>>
80013b1e:	6d 00 3d 32 	call 80019f98 <pbuf_free>
    return;
80013b22:	00 90       	ret 
  }
  ETHARP_STATS_INC(etharp.recv);
80013b24:	91 10 00 27 	movh.a %a2,28673
80013b28:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80013b2c:	b9 22 1a 00 	ld.hu %d2,[%a2]26 <7001001a <ram_heap+0x4f86>>
80013b30:	c2 12       	add %d2,1
80013b32:	37 02 70 20 	extr.u %d2,%d2,0,16
80013b36:	91 10 00 27 	movh.a %a2,28673
80013b3a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80013b3e:	f9 22 1a 00 	st.h [%a2]26 <7001001a <ram_heap+0x4f86>>,%d2
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&sipaddr, &hdr->sipaddr);
80013b42:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7001001a <ram_heap+0x4f86>>
80013b46:	1b e2 00 20 	addi %d2,%d2,14
80013b4a:	d9 e2 f4 ff 	lea %a2,[%a14]-12
80013b4e:	82 44       	mov %d4,4
80013b50:	60 25       	mov.a %a5,%d2
80013b52:	40 24       	mov.aa %a4,%a2
80013b54:	6d 00 64 9b 	call 8002721c <memcpy>
  IPADDR_WORDALIGNED_COPY_TO_IP4_ADDR_T(&dipaddr, &hdr->dipaddr);
80013b58:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80013b5c:	1b 82 01 20 	addi %d2,%d2,24
80013b60:	d9 e2 f0 ff 	lea %a2,[%a14]-16
80013b64:	82 44       	mov %d4,4
80013b66:	60 25       	mov.a %a5,%d2
80013b68:	40 24       	mov.aa %a4,%a2
80013b6a:	6d 00 59 9b 	call 8002721c <memcpy>

  /* this interface is not configured? */
  if (ip4_addr_isany_val(*netif_ip4_addr(netif))) {
80013b6e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80013b72:	60 22       	mov.a %a2,%d2
80013b74:	b0 42       	add.a %a2,4
80013b76:	54 22       	ld.w %d2,[%a2]
80013b78:	df 02 07 80 	jne %d2,0,80013b86 <etharp_input+0x146>
    for_us = 0;
80013b7c:	82 02       	mov %d2,0
80013b7e:	e9 e2 fb ff 	st.b [%a14]-5,%d2
80013b82:	1d 00 0f 00 	j 80013ba0 <etharp_input+0x160>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip4_addr_cmp(&dipaddr, netif_ip4_addr(netif));
80013b86:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80013b8a:	19 e3 e8 ff 	ld.w %d3,[%a14]-24
80013b8e:	60 32       	mov.a %a2,%d3
80013b90:	b0 42       	add.a %a2,4
80013b92:	54 23       	ld.w %d3,[%a2]
80013b94:	0b 32 00 21 	eq %d2,%d2,%d3
80013b98:	8f f2 0f 21 	and %d2,%d2,255
80013b9c:	e9 e2 fb ff 	st.b [%a14]-5,%d2
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
80013ba0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80013ba4:	1b 82 00 30 	addi %d3,%d2,8
80013ba8:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80013bac:	df 02 05 00 	jeq %d2,0,80013bb6 <etharp_input+0x176>
80013bb0:	82 12       	mov %d2,1
80013bb2:	1d 00 03 00 	j 80013bb8 <etharp_input+0x178>
80013bb6:	82 22       	mov %d2,2
80013bb8:	d9 e2 f4 ff 	lea %a2,[%a14]-12
80013bbc:	02 24       	mov %d4,%d2
80013bbe:	60 36       	mov.a %a6,%d3
80013bc0:	40 25       	mov.aa %a5,%a2
80013bc2:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80013bc6:	6d ff 66 fe 	call 80013892 <etharp_update_arp_entry>
                          for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
80013bca:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80013bce:	39 23 06 00 	ld.bu %d3,[%a2]6
80013bd2:	39 22 07 00 	ld.bu %d2,[%a2]7
80013bd6:	8f 82 00 20 	sh %d2,%d2,8
80013bda:	a6 32       	or %d2,%d3
80013bdc:	37 02 70 20 	extr.u %d2,%d2,0,16
80013be0:	3b 00 10 30 	mov %d3,256
80013be4:	5f 32 08 00 	jeq %d2,%d3,80013bf4 <etharp_input+0x1b4>
80013be8:	3b 00 20 30 	mov %d3,512
80013bec:	5f 32 2d 00 	jeq %d2,%d3,80013c46 <etharp_input+0x206>
80013bf0:	1d 00 34 00 	j 80013c58 <etharp_input+0x218>
       * reply. In any case, we time-stamp any existing ARP entry,
       * and possibly send out an IP packet that was queued on it. */

      LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: incoming ARP request\n"));
      /* ARP request for our address? */
      if (for_us) {
80013bf4:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80013bf8:	df 02 41 00 	jeq %d2,0,80013c7a <etharp_input+0x23a>
        /* send ARP response */
        etharp_raw(netif,
                   (struct eth_addr *)netif->hwaddr, &hdr->shwaddr,
80013bfc:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80013c00:	1b a2 02 20 	addi %d2,%d2,42
80013c04:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80013c08:	1b 83 00 30 	addi %d3,%d3,8
                   (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif),
80013c0c:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
80013c10:	1b a4 02 50 	addi %d5,%d4,42
80013c14:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
80013c18:	1b 44 00 60 	addi %d6,%d4,4
                   &hdr->shwaddr, &sipaddr,
80013c1c:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80013c20:	1b 84 00 40 	addi %d4,%d4,8
        etharp_raw(netif,
80013c24:	d9 e2 f4 ff 	lea %a2,[%a14]-12
80013c28:	b5 a2 08 00 	st.a [%sp]8,%a2
80013c2c:	59 a4 04 00 	st.w [%sp]4,%d4
80013c30:	74 a6       	st.w [%sp],%d6
80013c32:	82 24       	mov %d4,2
80013c34:	60 57       	mov.a %a7,%d5
80013c36:	60 36       	mov.a %a6,%d3
80013c38:	60 25       	mov.a %a5,%d2
80013c3a:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80013c3e:	6d 00 86 04 	call 8001454a <etharp_raw>
        /* request was not directed to us */
      } else {
        /* { for_us == 0 and netif->ip_addr.addr != 0 } */
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP request was not for us.\n"));
      }
      break;
80013c42:	1d 00 1c 00 	j 80013c7a <etharp_input+0x23a>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
      /* DHCP wants to know about ARP replies from any host with an
       * IP address also offered to us by the DHCP server. We do not
       * want to take a duplicate IP address on a single network.
       * @todo How should we handle redundant (fail-over) interfaces? */
      dhcp_arp_reply(netif, &sipaddr);
80013c46:	d9 e2 f4 ff 	lea %a2,[%a14]-12
80013c4a:	40 25       	mov.aa %a5,%a2
80013c4c:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80013c50:	6d ff d6 e9 	call 80010ffc <dhcp_arp_reply>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
      break;
80013c54:	1d 00 14 00 	j 80013c7c <etharp_input+0x23c>
    default:
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_input: ARP unknown opcode type %"S16_F"\n", lwip_htons(hdr->opcode)));
      ETHARP_STATS_INC(etharp.err);
80013c58:	91 10 00 27 	movh.a %a2,28673
80013c5c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80013c60:	b9 22 2c 00 	ld.hu %d2,[%a2]44 <7001002c <ram_heap+0x4f98>>
80013c64:	c2 12       	add %d2,1
80013c66:	37 02 70 20 	extr.u %d2,%d2,0,16
80013c6a:	91 10 00 27 	movh.a %a2,28673
80013c6e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80013c72:	f9 22 2c 00 	st.h [%a2]44 <7001002c <ram_heap+0x4f98>>,%d2
      break;
80013c76:	1d 00 03 00 	j 80013c7c <etharp_input+0x23c>
      break;
80013c7a:	00 00       	nop 
  }
  /* free ARP packet */
  pbuf_free(p);
80013c7c:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80013c80:	6d 00 8c 31 	call 80019f98 <pbuf_free>
}
80013c84:	00 90       	ret 

80013c86 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, netif_addr_idx_t arp_idx)
{
80013c86:	40 ae       	mov.aa %a14,%sp
80013c88:	20 20       	sub.a %sp,32
80013c8a:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80013c8e:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
80013c92:	02 42       	mov %d2,%d4
80013c94:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
80013c98:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013c9c:	91 10 00 27 	movh.a %a2,28673
80013ca0:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013ca4:	53 82 21 20 	mul %d2,%d2,24
80013ca8:	80 23       	mov.d %d3,%a2
80013caa:	42 23       	add %d3,%d2
80013cac:	02 32       	mov %d2,%d3
80013cae:	60 22       	mov.a %a2,%d2
80013cb0:	d9 22 14 00 	lea %a2,[%a2]20
80013cb4:	14 22       	ld.bu %d2,[%a2]
80013cb6:	ff 22 17 80 	jge.u %d2,2,80013ce4 <etharp_output_to_arp_index+0x5e>
80013cba:	91 00 00 28 	movh.a %a2,32768
80013cbe:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
80013cc2:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80013cc6:	3b e0 2e 20 	mov %d2,750
80013cca:	59 a2 04 00 	st.w [%sp]4,%d2
80013cce:	91 00 00 28 	movh.a %a2,32768
80013cd2:	d9 22 c6 b0 	lea %a2,[%a2]3782 <80000ec6 <IfxCpu_Trap_vectorTable0_end+0xcd2>>
80013cd6:	f4 a2       	st.a [%sp],%a2
80013cd8:	91 00 00 28 	movh.a %a2,32768
80013cdc:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80013ce0:	6d ff 2b 8b 	call 80005336 <Ifx_Lwip_printf>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if (arp_table[arp_idx].state == ETHARP_STATE_STABLE) {
80013ce4:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013ce8:	91 10 00 27 	movh.a %a2,28673
80013cec:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013cf0:	53 82 21 20 	mul %d2,%d2,24
80013cf4:	80 23       	mov.d %d3,%a2
80013cf6:	42 23       	add %d3,%d2
80013cf8:	02 32       	mov %d2,%d3
80013cfa:	60 22       	mov.a %a2,%d2
80013cfc:	d9 22 14 00 	lea %a2,[%a2]20
80013d00:	14 22       	ld.bu %d2,[%a2]
80013d02:	df 22 7d 80 	jne %d2,2,80013dfc <etharp_output_to_arp_index+0x176>
    if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_BROADCAST) {
80013d06:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013d0a:	91 10 00 27 	movh.a %a2,28673
80013d0e:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013d12:	53 82 21 20 	mul %d2,%d2,24
80013d16:	80 23       	mov.d %d3,%a2
80013d18:	42 23       	add %d3,%d2
80013d1a:	02 32       	mov %d2,%d3
80013d1c:	60 22       	mov.a %a2,%d2
80013d1e:	d9 22 12 00 	lea %a2,[%a2]18
80013d22:	b9 22 00 00 	ld.hu %d2,[%a2]0
80013d26:	8b d2 71 22 	lt.u %d2,%d2,285
80013d2a:	df 02 26 80 	jne %d2,0,80013d76 <etharp_output_to_arp_index+0xf0>
      /* issue a standard request using broadcast */
      if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
80013d2e:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013d32:	53 82 21 20 	mul %d2,%d2,24
80013d36:	c2 42       	add %d2,4
80013d38:	91 10 00 27 	movh.a %a2,28673
80013d3c:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013d40:	80 23       	mov.d %d3,%a2
80013d42:	42 32       	add %d2,%d3
80013d44:	60 25       	mov.a %a5,%d2
80013d46:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80013d4a:	6d 00 2b 05 	call 800147a0 <etharp_request>
80013d4e:	df 02 57 80 	jne %d2,0,80013dfc <etharp_output_to_arp_index+0x176>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
80013d52:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013d56:	91 10 00 27 	movh.a %a2,28673
80013d5a:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013d5e:	53 82 21 20 	mul %d2,%d2,24
80013d62:	80 23       	mov.d %d3,%a2
80013d64:	42 23       	add %d3,%d2
80013d66:	02 32       	mov %d2,%d3
80013d68:	60 22       	mov.a %a2,%d2
80013d6a:	d9 22 14 00 	lea %a2,[%a2]20
80013d6e:	82 32       	mov %d2,3
80013d70:	34 22       	st.b [%a2],%d2
80013d72:	1d 00 45 00 	j 80013dfc <etharp_output_to_arp_index+0x176>
      }
    } else if (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED_UNICAST) {
80013d76:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013d7a:	91 10 00 27 	movh.a %a2,28673
80013d7e:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013d82:	53 82 21 20 	mul %d2,%d2,24
80013d86:	80 23       	mov.d %d3,%a2
80013d88:	42 23       	add %d3,%d2
80013d8a:	02 32       	mov %d2,%d3
80013d8c:	60 22       	mov.a %a2,%d2
80013d8e:	d9 22 12 00 	lea %a2,[%a2]18
80013d92:	b9 22 00 00 	ld.hu %d2,[%a2]0
80013d96:	8b e2 70 22 	lt.u %d2,%d2,270
80013d9a:	df 02 31 80 	jne %d2,0,80013dfc <etharp_output_to_arp_index+0x176>
      /* issue a unicast request (for 15 seconds) to prevent unnecessary broadcast */
      if (etharp_request_dst(netif, &arp_table[arp_idx].ipaddr, &arp_table[arp_idx].ethaddr) == ERR_OK) {
80013d9e:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013da2:	53 82 21 20 	mul %d2,%d2,24
80013da6:	c2 42       	add %d2,4
80013da8:	91 10 00 27 	movh.a %a2,28673
80013dac:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013db0:	80 23       	mov.d %d3,%a2
80013db2:	42 23       	add %d3,%d2
80013db4:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013db8:	53 82 21 20 	mul %d2,%d2,24
80013dbc:	1b c2 00 20 	addi %d2,%d2,12
80013dc0:	91 10 00 27 	movh.a %a2,28673
80013dc4:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013dc8:	80 24       	mov.d %d4,%a2
80013dca:	42 42       	add %d2,%d4
80013dcc:	60 26       	mov.a %a6,%d2
80013dce:	60 35       	mov.a %a5,%d3
80013dd0:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80013dd4:	6d 00 be 04 	call 80014750 <etharp_request_dst>
80013dd8:	df 02 12 80 	jne %d2,0,80013dfc <etharp_output_to_arp_index+0x176>
        arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING_1;
80013ddc:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013de0:	91 10 00 27 	movh.a %a2,28673
80013de4:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013de8:	53 82 21 20 	mul %d2,%d2,24
80013dec:	80 23       	mov.d %d3,%a2
80013dee:	42 23       	add %d3,%d2
80013df0:	02 32       	mov %d2,%d3
80013df2:	60 22       	mov.a %a2,%d2
80013df4:	d9 22 14 00 	lea %a2,[%a2]20
80013df8:	82 32       	mov %d2,3
80013dfa:	34 22       	st.b [%a2],%d2
      }
    }
  }

  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), &arp_table[arp_idx].ethaddr, ETHTYPE_IP);
80013dfc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80013e00:	1b a2 02 30 	addi %d3,%d2,42
80013e04:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80013e08:	53 82 21 20 	mul %d2,%d2,24
80013e0c:	1b c2 00 20 	addi %d2,%d2,12
80013e10:	91 10 00 27 	movh.a %a2,28673
80013e14:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013e18:	80 24       	mov.d %d4,%a2
80013e1a:	42 42       	add %d2,%d4
80013e1c:	3b 00 80 40 	mov %d4,2048
80013e20:	60 27       	mov.a %a7,%d2
80013e22:	60 36       	mov.a %a6,%d3
80013e24:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80013e28:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80013e2c:	6d ff 7c e1 	call 80010124 <ethernet_output>
}
80013e30:	00 90       	ret 

80013e32 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or ethernet_output().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr)
{
80013e32:	40 ae       	mov.aa %a14,%sp
80013e34:	20 30       	sub.a %sp,48
80013e36:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80013e3a:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80013e3e:	b5 e6 e4 ff 	st.a [%a14]-28,%a6
  const struct eth_addr *dest;
  struct eth_addr mcastaddr;
  const ip4_addr_t *dst_addr = ipaddr;
80013e42:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80013e46:	59 e2 f8 ff 	st.w [%a14]-8,%d2

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("netif != NULL", netif != NULL);
80013e4a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80013e4e:	df 02 17 80 	jne %d2,0,80013e7c <etharp_output+0x4a>
80013e52:	91 00 00 28 	movh.a %a2,32768
80013e56:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
80013e5a:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80013e5e:	3b e0 31 20 	mov %d2,798
80013e62:	59 a2 04 00 	st.w [%sp]4,%d2
80013e66:	91 00 00 28 	movh.a %a2,32768
80013e6a:	d9 22 e8 a0 	lea %a2,[%a2]3752 <80000ea8 <IfxCpu_Trap_vectorTable0_end+0xcb4>>
80013e6e:	f4 a2       	st.a [%sp],%a2
80013e70:	91 00 00 28 	movh.a %a2,32768
80013e74:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80013e78:	6d ff 5f 8a 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("q != NULL", q != NULL);
80013e7c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80013e80:	df 02 17 80 	jne %d2,0,80013eae <etharp_output+0x7c>
80013e84:	91 00 00 28 	movh.a %a2,32768
80013e88:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
80013e8c:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80013e90:	3b f0 31 20 	mov %d2,799
80013e94:	59 a2 04 00 	st.w [%sp]4,%d2
80013e98:	91 00 00 28 	movh.a %a2,32768
80013e9c:	d9 22 f6 b0 	lea %a2,[%a2]3830 <80000ef6 <IfxCpu_Trap_vectorTable0_end+0xd02>>
80013ea0:	f4 a2       	st.a [%sp],%a2
80013ea2:	91 00 00 28 	movh.a %a2,32768
80013ea6:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80013eaa:	6d ff 46 8a 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
80013eae:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80013eb2:	df 02 17 80 	jne %d2,0,80013ee0 <etharp_output+0xae>
80013eb6:	91 00 00 28 	movh.a %a2,32768
80013eba:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
80013ebe:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80013ec2:	3b 00 32 20 	mov %d2,800
80013ec6:	59 a2 04 00 	st.w [%sp]4,%d2
80013eca:	91 00 00 28 	movh.a %a2,32768
80013ece:	d9 22 d9 a0 	lea %a2,[%a2]3737 <80000e99 <IfxCpu_Trap_vectorTable0_end+0xca5>>
80013ed2:	f4 a2       	st.a [%sp],%a2
80013ed4:	91 00 00 28 	movh.a %a2,32768
80013ed8:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80013edc:	6d ff 2d 8a 	call 80005336 <Ifx_Lwip_printf>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip4_addr_isbroadcast(ipaddr, netif)) {
80013ee0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80013ee4:	54 22       	ld.w %d2,[%a2]
80013ee6:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80013eea:	02 24       	mov %d4,%d2
80013eec:	6d 00 b0 0e 	call 80015c4c <ip4_addr_isbroadcast_u32>
80013ef0:	df 02 0a 00 	jeq %d2,0,80013f04 <etharp_output+0xd2>
    /* broadcast on Ethernet also */
    dest = (const struct eth_addr *)&ethbroadcast;
80013ef4:	91 00 00 28 	movh.a %a2,32768
80013ef8:	d9 22 50 44 	lea %a2,[%a2]17680 <80004510 <ethbroadcast>>
80013efc:	b5 e2 fc ff 	st.a [%a14]-4 <80004510 <ethbroadcast>>,%a2
80013f00:	1d 00 1d 01 	j 8001413a <etharp_output+0x308>
    /* multicast destination IP address? */
  } else if (ip4_addr_ismulticast(ipaddr)) {
80013f04:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80013f08:	54 22       	ld.w %d2,[%a2]
80013f0a:	8f 02 0f 21 	and %d2,%d2,240
80013f0e:	8b 02 2e 22 	ne %d2,%d2,224
80013f12:	df 02 2b 80 	jne %d2,0,80013f68 <etharp_output+0x136>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_IP4_MULTICAST_ADDR_0;
80013f16:	82 12       	mov %d2,1
80013f18:	e9 e2 f1 ff 	st.b [%a14]-15,%d2
    mcastaddr.addr[1] = LL_IP4_MULTICAST_ADDR_1;
80013f1c:	82 02       	mov %d2,0
80013f1e:	e9 e2 f2 ff 	st.b [%a14]-14,%d2
    mcastaddr.addr[2] = LL_IP4_MULTICAST_ADDR_2;
80013f22:	3b e0 05 20 	mov %d2,94
80013f26:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
80013f2a:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80013f2e:	60 22       	mov.a %a2,%d2
80013f30:	b0 12       	add.a %a2,1
80013f32:	14 22       	ld.bu %d2,[%a2]
80013f34:	8f f2 07 21 	and %d2,%d2,127
80013f38:	8f f2 0f 21 	and %d2,%d2,255
80013f3c:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
80013f40:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80013f44:	60 22       	mov.a %a2,%d2
80013f46:	b0 22       	add.a %a2,2
80013f48:	14 22       	ld.bu %d2,[%a2]
80013f4a:	e9 e2 f5 ff 	st.b [%a14]-11,%d2
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
80013f4e:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80013f52:	60 22       	mov.a %a2,%d2
80013f54:	b0 32       	add.a %a2,3
80013f56:	14 22       	ld.bu %d2,[%a2]
80013f58:	e9 e2 f6 ff 	st.b [%a14]-10,%d2
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
80013f5c:	d9 e2 f1 ff 	lea %a2,[%a14]-15
80013f60:	b5 e2 fc ff 	st.a [%a14]-4,%a2
80013f64:	1d 00 eb 00 	j 8001413a <etharp_output+0x308>
    /* unicast destination IP address? */
  } else {
    netif_addr_idx_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
80013f68:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80013f6c:	54 23       	ld.w %d3,[%a2]
80013f6e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80013f72:	60 22       	mov.a %a2,%d2
80013f74:	b0 42       	add.a %a2,4
80013f76:	54 22       	ld.w %d2,[%a2]
80013f78:	c6 32       	xor %d2,%d3
80013f7a:	19 e3 ec ff 	ld.w %d3,[%a14]-20
80013f7e:	60 32       	mov.a %a2,%d3
80013f80:	d9 22 08 00 	lea %a2,[%a2]8
80013f84:	54 23       	ld.w %d3,[%a2]
80013f86:	26 32       	and %d2,%d3
80013f88:	df 02 1e 00 	jeq %d2,0,80013fc4 <etharp_output+0x192>
        !ip4_addr_islinklocal(ipaddr)) {
80013f8c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80013f90:	54 22       	ld.w %d2,[%a2]
80013f92:	bb f0 ff 3f 	mov.u %d3,65535
80013f96:	26 32       	and %d2,%d3
    if (!ip4_addr_netcmp(ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif)) &&
80013f98:	bb 90 ea 3f 	mov.u %d3,65193
80013f9c:	5f 32 14 00 	jeq %d2,%d3,80013fc4 <etharp_output+0x192>
        dst_addr = LWIP_HOOK_ETHARP_GET_GW(netif, ipaddr);
        if (dst_addr == NULL)
#endif /* LWIP_HOOK_ETHARP_GET_GW */
        {
          /* interface has default gateway? */
          if (!ip4_addr_isany_val(*netif_ip4_gw(netif))) {
80013fa0:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80013fa4:	60 22       	mov.a %a2,%d2
80013fa6:	d9 22 0c 00 	lea %a2,[%a2]12
80013faa:	54 22       	ld.w %d2,[%a2]
80013fac:	df 02 0a 00 	jeq %d2,0,80013fc0 <etharp_output+0x18e>
            /* send to hardware address of default gateway IP address */
            dst_addr = netif_ip4_gw(netif);
80013fb0:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80013fb4:	1b c2 00 20 	addi %d2,%d2,12
80013fb8:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80013fbc:	1d 00 04 00 	j 80013fc4 <etharp_output+0x192>
            /* no default gateway available */
          } else {
            /* no route to destination error (default gateway missing) */
            return ERR_RTE;
80013fc0:	82 c2       	mov %d2,-4
80013fc2:	00 90       	ret 
    if (netif->hints != NULL) {
      /* per-pcb cached entry was given */
      netif_addr_idx_t etharp_cached_entry = netif->hints->addr_hint;
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
80013fc4:	91 10 00 27 	movh.a %a2,28673
80013fc8:	d9 22 30 1b 	lea %a2,[%a2]-20368 <7000b070 <etharp_cached_entry>>
80013fcc:	14 22       	ld.bu %d2,[%a2]
80013fce:	91 10 00 27 	movh.a %a2,28673
80013fd2:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013fd6:	53 82 21 20 	mul %d2,%d2,24
80013fda:	80 23       	mov.d %d3,%a2
80013fdc:	42 23       	add %d3,%d2
80013fde:	02 32       	mov %d2,%d3
80013fe0:	60 22       	mov.a %a2,%d2
80013fe2:	d9 22 14 00 	lea %a2,[%a2]20
80013fe6:	14 22       	ld.bu %d2,[%a2]
80013fe8:	bf 22 4a 80 	jlt.u %d2,2,8001407c <etharp_output+0x24a>
#if ETHARP_TABLE_MATCH_NETIF
            (arp_table[etharp_cached_entry].netif == netif) &&
80013fec:	91 10 00 27 	movh.a %a2,28673
80013ff0:	d9 22 30 1b 	lea %a2,[%a2]-20368 <7000b070 <etharp_cached_entry>>
80013ff4:	14 22       	ld.bu %d2,[%a2]
80013ff6:	91 10 00 27 	movh.a %a2,28673
80013ffa:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80013ffe:	53 82 21 20 	mul %d2,%d2,24
80014002:	80 23       	mov.d %d3,%a2
80014004:	42 23       	add %d3,%d2
80014006:	02 32       	mov %d2,%d3
80014008:	60 22       	mov.a %a2,%d2
8001400a:	d9 22 08 00 	lea %a2,[%a2]8
8001400e:	54 22       	ld.w %d2,[%a2]
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
80014010:	19 e3 ec ff 	ld.w %d3,[%a14]-20
80014014:	5f 23 34 80 	jne %d3,%d2,8001407c <etharp_output+0x24a>
#endif
            (ip4_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
80014018:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001401c:	54 23       	ld.w %d3,[%a2]
8001401e:	91 10 00 27 	movh.a %a2,28673
80014022:	d9 22 30 1b 	lea %a2,[%a2]-20368 <7000b070 <etharp_cached_entry>>
80014026:	14 22       	ld.bu %d2,[%a2]
80014028:	91 10 00 27 	movh.a %a2,28673
8001402c:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80014030:	53 82 21 20 	mul %d2,%d2,24
80014034:	80 24       	mov.d %d4,%a2
80014036:	42 24       	add %d4,%d2
80014038:	02 42       	mov %d2,%d4
8001403a:	60 22       	mov.a %a2,%d2
8001403c:	b0 42       	add.a %a2,4
8001403e:	54 22       	ld.w %d2,[%a2]
            (arp_table[etharp_cached_entry].netif == netif) &&
80014040:	5f 23 1e 80 	jne %d3,%d2,8001407c <etharp_output+0x24a>
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
80014044:	91 10 00 27 	movh.a %a2,28673
80014048:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001404c:	b9 22 2e 00 	ld.hu %d2,[%a2]46 <7001002e <ram_heap+0x4f9a>>
80014050:	c2 12       	add %d2,1
80014052:	37 02 70 20 	extr.u %d2,%d2,0,16
80014056:	91 10 00 27 	movh.a %a2,28673
8001405a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001405e:	f9 22 2e 00 	st.h [%a2]46 <7001002e <ram_heap+0x4f9a>>,%d2
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
80014062:	91 10 00 27 	movh.a %a2,28673
80014066:	d9 22 30 1b 	lea %a2,[%a2]-20368 <7000b070 <etharp_cached_entry>>
8001406a:	14 22       	ld.bu %d2,[%a2]
8001406c:	02 24       	mov %d4,%d2
8001406e:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
80014072:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80014076:	6d ff 08 fe 	call 80013c86 <etharp_output_to_arp_index>
8001407a:	00 90       	ret 
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
8001407c:	82 02       	mov %d2,0
8001407e:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
80014082:	1d 00 4f 00 	j 80014120 <etharp_output+0x2ee>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
80014086:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
8001408a:	91 10 00 27 	movh.a %a2,28673
8001408e:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80014092:	53 82 21 20 	mul %d2,%d2,24
80014096:	80 23       	mov.d %d3,%a2
80014098:	42 23       	add %d3,%d2
8001409a:	02 32       	mov %d2,%d3
8001409c:	60 22       	mov.a %a2,%d2
8001409e:	d9 22 14 00 	lea %a2,[%a2]20
800140a2:	14 22       	ld.bu %d2,[%a2]
800140a4:	bf 22 39 80 	jlt.u %d2,2,80014116 <etharp_output+0x2e4>
#if ETHARP_TABLE_MATCH_NETIF
          (arp_table[i].netif == netif) &&
800140a8:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
800140ac:	91 10 00 27 	movh.a %a2,28673
800140b0:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800140b4:	53 82 21 20 	mul %d2,%d2,24
800140b8:	80 23       	mov.d %d3,%a2
800140ba:	42 23       	add %d3,%d2
800140bc:	02 32       	mov %d2,%d3
800140be:	60 22       	mov.a %a2,%d2
800140c0:	d9 22 08 00 	lea %a2,[%a2]8
800140c4:	54 22       	ld.w %d2,[%a2]
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
800140c6:	19 e3 ec ff 	ld.w %d3,[%a14]-20
800140ca:	5f 23 26 80 	jne %d3,%d2,80014116 <etharp_output+0x2e4>
#endif
          (ip4_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
800140ce:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800140d2:	54 23       	ld.w %d3,[%a2]
800140d4:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
800140d8:	91 10 00 27 	movh.a %a2,28673
800140dc:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800140e0:	53 82 21 20 	mul %d2,%d2,24
800140e4:	80 24       	mov.d %d4,%a2
800140e6:	42 24       	add %d4,%d2
800140e8:	02 42       	mov %d2,%d4
800140ea:	60 22       	mov.a %a2,%d2
800140ec:	b0 42       	add.a %a2,4
800140ee:	54 22       	ld.w %d2,[%a2]
          (arp_table[i].netif == netif) &&
800140f0:	5f 23 13 80 	jne %d3,%d2,80014116 <etharp_output+0x2e4>
        /* found an existing, stable entry */
        ETHARP_SET_ADDRHINT(netif, i);
800140f4:	91 10 00 27 	movh.a %a2,28673
800140f8:	d9 22 30 1b 	lea %a2,[%a2]-20368 <7000b070 <etharp_cached_entry>>
800140fc:	79 e2 f7 ff 	ld.b %d2,[%a14]-9 <7000b070 <etharp_cached_entry>>
80014100:	34 22       	st.b [%a2],%d2
        return etharp_output_to_arp_index(netif, q, i);
80014102:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9 <7000b070 <etharp_cached_entry>>
80014106:	02 24       	mov %d4,%d2
80014108:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
8001410c:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80014110:	6d ff bb fd 	call 80013c86 <etharp_output_to_arp_index>
80014114:	00 90       	ret 
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
80014116:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
8001411a:	c2 12       	add %d2,1
8001411c:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
80014120:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
80014124:	bf a2 b1 ff 	jlt.u %d2,10,80014086 <etharp_output+0x254>
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
80014128:	99 e6 e8 ff 	ld.a %a6,[%a14]-24
8001412c:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80014130:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80014134:	6d 00 13 00 	call 8001415a <etharp_query>
80014138:	00 90       	ret 
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return ethernet_output(netif, q, (struct eth_addr *)(netif->hwaddr), dest, ETHTYPE_IP);
8001413a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001413e:	1b a2 02 20 	addi %d2,%d2,42
80014142:	3b 00 80 40 	mov %d4,2048
80014146:	99 e7 fc ff 	ld.a %a7,[%a14]-4
8001414a:	60 26       	mov.a %a6,%d2
8001414c:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
80014150:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80014154:	6d ff e8 df 	call 80010124 <ethernet_output>
}
80014158:	00 90       	ret 

8001415a <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q)
{
8001415a:	40 ae       	mov.aa %a14,%sp
8001415c:	20 38       	sub.a %sp,56
8001415e:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80014162:	b5 e5 e0 ff 	st.a [%a14]-32,%a5
80014166:	b5 e6 dc ff 	st.a [%a14]-36,%a6
  struct eth_addr *srcaddr = (struct eth_addr *)netif->hwaddr;
8001416a:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8001416e:	1b a2 02 20 	addi %d2,%d2,42
80014172:	59 e2 ec ff 	st.w [%a14]-20,%d2
  err_t result = ERR_MEM;
80014176:	82 f2       	mov %d2,-1
80014178:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  int is_new_entry = 0;
8001417c:	82 02       	mov %d2,0
8001417e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  s16_t i_err;
  netif_addr_idx_t i;

  /* non-unicast address? */
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
80014182:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80014186:	54 22       	ld.w %d2,[%a2]
80014188:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001418c:	02 24       	mov %d4,%d2
8001418e:	6d 00 5f 0d 	call 80015c4c <ip4_addr_isbroadcast_u32>
80014192:	df 02 14 80 	jne %d2,0,800141ba <etharp_query+0x60>
      ip4_addr_ismulticast(ipaddr) ||
80014196:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8001419a:	54 22       	ld.w %d2,[%a2]
8001419c:	8f 02 0f 21 	and %d2,%d2,240
  if (ip4_addr_isbroadcast(ipaddr, netif) ||
800141a0:	8b 02 0e 22 	eq %d2,%d2,224
800141a4:	df 02 0b 80 	jne %d2,0,800141ba <etharp_query+0x60>
      ip4_addr_ismulticast(ipaddr) ||
800141a8:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800141ac:	df 02 07 00 	jeq %d2,0,800141ba <etharp_query+0x60>
      ip4_addr_isany(ipaddr)) {
800141b0:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
800141b4:	54 22       	ld.w %d2,[%a2]
800141b6:	df 02 05 80 	jne %d2,0,800141c0 <etharp_query+0x66>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
800141ba:	3b 00 ff 2f 	mov %d2,-16
800141be:	00 90       	ret 
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i_err = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD, netif);
800141c0:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
800141c4:	82 14       	mov %d4,1
800141c6:	99 e4 e0 ff 	ld.a %a4,[%a14]-32
800141ca:	6d ff 23 f9 	call 80013410 <etharp_find_entry>
800141ce:	f9 e2 ea ff 	st.h [%a14]-22,%d2

  /* could not find or create entry? */
  if (i_err < 0) {
800141d2:	c9 e2 ea ff 	ld.h %d2,[%a14]-22
800141d6:	ff 02 1a 00 	jge %d2,0,8001420a <etharp_query+0xb0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
800141da:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800141de:	df 02 11 00 	jeq %d2,0,80014200 <etharp_query+0xa6>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
800141e2:	91 10 00 27 	movh.a %a2,28673
800141e6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800141ea:	b9 22 24 00 	ld.hu %d2,[%a2]36 <70010024 <ram_heap+0x4f90>>
800141ee:	c2 12       	add %d2,1
800141f0:	37 02 70 20 	extr.u %d2,%d2,0,16
800141f4:	91 10 00 27 	movh.a %a2,28673
800141f8:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800141fc:	f9 22 24 00 	st.h [%a2]36 <70010024 <ram_heap+0x4f90>>,%d2
    }
    return (err_t)i_err;
80014200:	c9 e2 ea ff 	ld.h %d2,[%a14]-22 <70010024 <ram_heap+0x4f90>>
80014204:	37 02 48 20 	extr %d2,%d2,0,8
80014208:	00 90       	ret 
  }
  LWIP_ASSERT("type overflow", (size_t)i_err < NETIF_ADDR_IDX_MAX);
8001420a:	b9 e2 ea ff 	ld.hu %d2,[%a14]-22
8001420e:	8b f2 67 22 	lt.u %d2,%d2,127
80014212:	df 02 17 80 	jne %d2,0,80014240 <etharp_query+0xe6>
80014216:	91 00 00 28 	movh.a %a2,32768
8001421a:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
8001421e:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80014222:	3b 10 3c 20 	mov %d2,961
80014226:	59 a2 04 00 	st.w [%sp]4,%d2
8001422a:	91 00 00 28 	movh.a %a2,32768
8001422e:	d9 22 c0 c0 	lea %a2,[%a2]3840 <80000f00 <IfxCpu_Trap_vectorTable0_end+0xd0c>>
80014232:	f4 a2       	st.a [%sp],%a2
80014234:	91 00 00 28 	movh.a %a2,32768
80014238:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
8001423c:	6d ff 7d 88 	call 80005336 <Ifx_Lwip_printf>
  i = (netif_addr_idx_t)i_err;
80014240:	c9 e2 ea ff 	ld.h %d2,[%a14]-22
80014244:	e9 e2 e9 ff 	st.b [%a14]-23,%d2

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
80014248:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
8001424c:	91 10 00 27 	movh.a %a2,28673
80014250:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80014254:	53 82 21 20 	mul %d2,%d2,24
80014258:	80 23       	mov.d %d3,%a2
8001425a:	42 23       	add %d3,%d2
8001425c:	02 32       	mov %d2,%d3
8001425e:	60 22       	mov.a %a2,%d2
80014260:	d9 22 14 00 	lea %a2,[%a2]20
80014264:	14 22       	ld.bu %d2,[%a2]
80014266:	df 02 26 80 	jne %d2,0,800142b2 <etharp_query+0x158>
    is_new_entry = 1;
8001426a:	82 12       	mov %d2,1
8001426c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    arp_table[i].state = ETHARP_STATE_PENDING;
80014270:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
80014274:	91 10 00 27 	movh.a %a2,28673
80014278:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001427c:	53 82 21 20 	mul %d2,%d2,24
80014280:	80 23       	mov.d %d3,%a2
80014282:	42 23       	add %d3,%d2
80014284:	02 32       	mov %d2,%d3
80014286:	60 22       	mov.a %a2,%d2
80014288:	d9 22 14 00 	lea %a2,[%a2]20
8001428c:	82 12       	mov %d2,1
8001428e:	34 22       	st.b [%a2],%d2
    /* record network interface for re-sending arp request in etharp_tmr */
    arp_table[i].netif = netif;
80014290:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
80014294:	91 10 00 27 	movh.a %a2,28673
80014298:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001429c:	53 82 21 20 	mul %d2,%d2,24
800142a0:	80 23       	mov.d %d3,%a2
800142a2:	42 23       	add %d3,%d2
800142a4:	02 32       	mov %d2,%d3
800142a6:	60 22       	mov.a %a2,%d2
800142a8:	d9 22 08 00 	lea %a2,[%a2]8
800142ac:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800142b0:	74 22       	st.w [%a2],%d2
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
800142b2:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
800142b6:	91 10 00 27 	movh.a %a2,28673
800142ba:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800142be:	53 82 21 20 	mul %d2,%d2,24
800142c2:	80 23       	mov.d %d3,%a2
800142c4:	42 23       	add %d3,%d2
800142c6:	02 32       	mov %d2,%d3
800142c8:	60 22       	mov.a %a2,%d2
800142ca:	d9 22 14 00 	lea %a2,[%a2]20
800142ce:	14 22       	ld.bu %d2,[%a2]
800142d0:	df 12 28 00 	jeq %d2,1,80014320 <etharp_query+0x1c6>
800142d4:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
800142d8:	91 10 00 27 	movh.a %a2,28673
800142dc:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800142e0:	53 82 21 20 	mul %d2,%d2,24
800142e4:	80 23       	mov.d %d3,%a2
800142e6:	42 23       	add %d3,%d2
800142e8:	02 32       	mov %d2,%d3
800142ea:	60 22       	mov.a %a2,%d2
800142ec:	d9 22 14 00 	lea %a2,[%a2]20
800142f0:	14 22       	ld.bu %d2,[%a2]
800142f2:	ff 22 17 80 	jge.u %d2,2,80014320 <etharp_query+0x1c6>
800142f6:	91 00 00 28 	movh.a %a2,32768
800142fa:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
800142fe:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80014302:	3b d0 3c 20 	mov %d2,973
80014306:	59 a2 04 00 	st.w [%sp]4,%d2
8001430a:	91 00 00 28 	movh.a %a2,32768
8001430e:	d9 22 ce c0 	lea %a2,[%a2]3854 <80000f0e <IfxCpu_Trap_vectorTable0_end+0xd1a>>
80014312:	f4 a2       	st.a [%sp],%a2
80014314:	91 00 00 28 	movh.a %a2,32768
80014318:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
8001431c:	6d ff 0d 88 	call 80005336 <Ifx_Lwip_printf>
              ((arp_table[i].state == ETHARP_STATE_PENDING) ||
               (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a new entry? or an implicit query request? */
  if (is_new_entry || (q == NULL)) {
80014320:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80014324:	df 02 06 80 	jne %d2,0,80014330 <etharp_query+0x1d6>
80014328:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8001432c:	df 02 11 80 	jne %d2,0,8001434e <etharp_query+0x1f4>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
80014330:	99 e5 e0 ff 	ld.a %a5,[%a14]-32
80014334:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80014338:	6d 00 34 02 	call 800147a0 <etharp_request>
8001433c:	e9 e2 ff ff 	st.b [%a14]-1,%d2
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
80014340:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80014344:	df 02 05 80 	jne %d2,0,8001434e <etharp_query+0x1f4>
      return result;
80014348:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001434c:	00 90       	ret 
    }
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
8001434e:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80014352:	df 02 17 80 	jne %d2,0,80014380 <etharp_query+0x226>
80014356:	91 00 00 28 	movh.a %a2,32768
8001435a:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
8001435e:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80014362:	3b 10 3e 20 	mov %d2,993
80014366:	59 a2 04 00 	st.w [%sp]4,%d2
8001436a:	91 00 00 28 	movh.a %a2,32768
8001436e:	d9 22 f6 b0 	lea %a2,[%a2]3830 <80000ef6 <IfxCpu_Trap_vectorTable0_end+0xd02>>
80014372:	f4 a2       	st.a [%sp],%a2
80014374:	91 00 00 28 	movh.a %a2,32768
80014378:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
8001437c:	6d ff dd 87 	call 80005336 <Ifx_Lwip_printf>
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
80014380:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
80014384:	91 10 00 27 	movh.a %a2,28673
80014388:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
8001438c:	53 82 21 20 	mul %d2,%d2,24
80014390:	80 23       	mov.d %d3,%a2
80014392:	42 23       	add %d3,%d2
80014394:	02 32       	mov %d2,%d3
80014396:	60 22       	mov.a %a2,%d2
80014398:	d9 22 14 00 	lea %a2,[%a2]20
8001439c:	14 22       	ld.bu %d2,[%a2]
8001439e:	bf 22 24 80 	jlt.u %d2,2,800143e6 <etharp_query+0x28c>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_ADDRHINT(netif, i);
800143a2:	91 10 00 27 	movh.a %a2,28673
800143a6:	d9 22 30 1b 	lea %a2,[%a2]-20368 <7000b070 <etharp_cached_entry>>
800143aa:	79 e2 e9 ff 	ld.b %d2,[%a14]-23 <7000b070 <etharp_cached_entry>>
800143ae:	34 22       	st.b [%a2],%d2
    /* send the packet */
    result = ethernet_output(netif, q, srcaddr, &(arp_table[i].ethaddr), ETHTYPE_IP);
800143b0:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23 <7000b070 <etharp_cached_entry>>
800143b4:	53 82 21 20 	mul %d2,%d2,24
800143b8:	1b c2 00 20 	addi %d2,%d2,12
800143bc:	91 10 00 27 	movh.a %a2,28673
800143c0:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800143c4:	80 23       	mov.d %d3,%a2
800143c6:	42 32       	add %d2,%d3
800143c8:	3b 00 80 40 	mov %d4,2048
800143cc:	60 27       	mov.a %a7,%d2
800143ce:	99 e6 ec ff 	ld.a %a6,[%a14]-20
800143d2:	99 e5 dc ff 	ld.a %a5,[%a14]-36
800143d6:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800143da:	6d ff a5 de 	call 80010124 <ethernet_output>
800143de:	e9 e2 ff ff 	st.b [%a14]-1,%d2
800143e2:	1d 00 b1 00 	j 80014544 <etharp_query+0x3ea>
    /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
800143e6:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
800143ea:	91 10 00 27 	movh.a %a2,28673
800143ee:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800143f2:	53 82 21 20 	mul %d2,%d2,24
800143f6:	80 23       	mov.d %d3,%a2
800143f8:	42 23       	add %d3,%d2
800143fa:	02 32       	mov %d2,%d3
800143fc:	60 22       	mov.a %a2,%d2
800143fe:	d9 22 14 00 	lea %a2,[%a2]20
80014402:	14 22       	ld.bu %d2,[%a2]
80014404:	df 12 a0 80 	jne %d2,1,80014544 <etharp_query+0x3ea>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
80014408:	82 02       	mov %d2,0
8001440a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    /* IF q includes a pbuf that must be copied, copy the whole chain into a
     * new PBUF_RAM. See the definition of PBUF_NEEDS_COPY for details. */
    p = q;
8001440e:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80014412:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    while (p) {
80014416:	1d 00 38 00 	j 80014486 <etharp_query+0x32c>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
8001441a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001441e:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80014422:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014426:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001442a:	5f 23 1c 80 	jne %d3,%d2,80014462 <etharp_query+0x308>
8001442e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014432:	54 22       	ld.w %d2,[%a2]
80014434:	df 02 17 00 	jeq %d2,0,80014462 <etharp_query+0x308>
80014438:	91 00 00 28 	movh.a %a2,32768
8001443c:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
80014440:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80014444:	3b 10 3f 20 	mov %d2,1009
80014448:	59 a2 04 00 	st.w [%sp]4,%d2
8001444c:	91 00 00 28 	movh.a %a2,32768
80014450:	d9 22 f6 c0 	lea %a2,[%a2]3894 <80000f36 <IfxCpu_Trap_vectorTable0_end+0xd42>>
80014454:	f4 a2       	st.a [%sp],%a2
80014456:	91 00 00 28 	movh.a %a2,32768
8001445a:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
8001445e:	6d ff 6c 87 	call 80005336 <Ifx_Lwip_printf>
      if (PBUF_NEEDS_COPY(p)) {
80014462:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014466:	39 22 0c 00 	ld.bu %d2,[%a2]12
8001446a:	8f 02 04 21 	and %d2,%d2,64
8001446e:	df 02 07 00 	jeq %d2,0,8001447c <etharp_query+0x322>
        copy_needed = 1;
80014472:	82 12       	mov %d2,1
80014474:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        break;
80014478:	1d 00 0b 00 	j 8001448e <etharp_query+0x334>
      }
      p = p->next;
8001447c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014480:	54 22       	ld.w %d2,[%a2]
80014482:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    while (p) {
80014486:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001448a:	df 02 c8 ff 	jne %d2,0,8001441a <etharp_query+0x2c0>
    }
    if (copy_needed) {
8001448e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80014492:	df 02 0e 00 	jeq %d2,0,800144ae <etharp_query+0x354>
      /* copy the whole packet into new pbufs */
      p = pbuf_clone(PBUF_LINK, PBUF_RAM, q);
80014496:	99 e4 dc ff 	ld.a %a4,[%a14]-36
8001449a:	3b 00 28 50 	mov %d5,640
8001449e:	3b 00 01 40 	mov %d4,16
800144a2:	6d 00 5e 31 	call 8001a75e <pbuf_clone>
800144a6:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
800144aa:	1d 00 0a 00 	j 800144be <etharp_query+0x364>
    } else {
      /* referencing the old pbuf is enough */
      p = q;
800144ae:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800144b2:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      pbuf_ref(p);
800144b6:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800144ba:	6d 00 6c 2e 	call 8001a192 <pbuf_ref>
    }
    /* packet could be taken over? */
    if (p != NULL) {
800144be:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800144c2:	df 02 2f 00 	jeq %d2,0,80014520 <etharp_query+0x3c6>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
      }
#else /* ARP_QUEUEING */
      /* always queue one packet per ARP request only, freeing a previously queued packet */
      if (arp_table[i].q != NULL) {
800144c6:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
800144ca:	91 10 00 27 	movh.a %a2,28673
800144ce:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800144d2:	53 82 21 20 	mul %d2,%d2,24
800144d6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800144da:	54 22       	ld.w %d2,[%a2]
800144dc:	df 02 10 00 	jeq %d2,0,800144fc <etharp_query+0x3a2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"U16_F"\n", (void *)q, (u16_t)i));
        pbuf_free(arp_table[i].q);
800144e0:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
800144e4:	91 10 00 27 	movh.a %a2,28673
800144e8:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
800144ec:	53 82 21 20 	mul %d2,%d2,24
800144f0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800144f4:	54 22       	ld.w %d2,[%a2]
800144f6:	60 24       	mov.a %a4,%d2
800144f8:	6d 00 50 2d 	call 80019f98 <pbuf_free>
      }
      arp_table[i].q = p;
800144fc:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
80014500:	91 10 00 27 	movh.a %a2,28673
80014504:	d9 22 c0 ea 	lea %a2,[%a2]-20608 <7000af80 <arp_table>>
80014508:	53 82 21 20 	mul %d2,%d2,24
8001450c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80014510:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80014514:	74 22       	st.w [%a2],%d2
      result = ERR_OK;
80014516:	82 02       	mov %d2,0
80014518:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8001451c:	1d 00 14 00 	j 80014544 <etharp_query+0x3ea>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"U16_F"\n", (void *)q, (u16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
80014520:	91 10 00 27 	movh.a %a2,28673
80014524:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014528:	b9 22 24 00 	ld.hu %d2,[%a2]36 <70010024 <ram_heap+0x4f90>>
8001452c:	c2 12       	add %d2,1
8001452e:	37 02 70 20 	extr.u %d2,%d2,0,16
80014532:	91 10 00 27 	movh.a %a2,28673
80014536:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001453a:	f9 22 24 00 	st.h [%a2]36 <70010024 <ram_heap+0x4f90>>,%d2
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
8001453e:	82 f2       	mov %d2,-1
80014540:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    }
  }
  return result;
80014544:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
80014548:	00 90       	ret 

8001454a <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip4_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip4_addr_t *ipdst_addr,
           const u16_t opcode)
{
8001454a:	40 ae       	mov.aa %a14,%sp
8001454c:	20 38       	sub.a %sp,56
8001454e:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80014552:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80014556:	b5 e6 e4 ff 	st.a [%a14]-28,%a6
8001455a:	b5 e7 e0 ff 	st.a [%a14]-32,%a7
8001455e:	02 42       	mov %d2,%d4
80014560:	f9 e2 dc ff 	st.h [%a14]-36,%d2
  struct pbuf *p;
  err_t result = ERR_OK;
80014564:	82 02       	mov %d2,0
80014566:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  struct etharp_hdr *hdr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
8001456a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001456e:	df 02 17 80 	jne %d2,0,8001459c <etharp_raw+0x52>
80014572:	91 00 00 28 	movh.a %a2,32768
80014576:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
8001457a:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
8001457e:	3b 70 45 20 	mov %d2,1111
80014582:	59 a2 04 00 	st.w [%sp]4,%d2
80014586:	91 00 00 28 	movh.a %a2,32768
8001458a:	d9 22 e8 a0 	lea %a2,[%a2]3752 <80000ea8 <IfxCpu_Trap_vectorTable0_end+0xcb4>>
8001458e:	f4 a2       	st.a [%sp],%a2
80014590:	91 00 00 28 	movh.a %a2,32768
80014594:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80014598:	6d ff cf 86 	call 80005336 <Ifx_Lwip_printf>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, SIZEOF_ETHARP_HDR, PBUF_RAM);
8001459c:	3b 00 28 60 	mov %d6,640
800145a0:	3b c0 01 50 	mov %d5,28
800145a4:	3b 00 01 40 	mov %d4,16
800145a8:	6d 00 9c 28 	call 800196e0 <pbuf_alloc>
800145ac:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
800145b0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800145b4:	df 02 13 80 	jne %d2,0,800145da <etharp_raw+0x90>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
                ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
800145b8:	91 10 00 27 	movh.a %a2,28673
800145bc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800145c0:	b9 22 24 00 	ld.hu %d2,[%a2]36 <70010024 <ram_heap+0x4f90>>
800145c4:	c2 12       	add %d2,1
800145c6:	37 02 70 20 	extr.u %d2,%d2,0,16
800145ca:	91 10 00 27 	movh.a %a2,28673
800145ce:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800145d2:	f9 22 24 00 	st.h [%a2]36 <70010024 <ram_heap+0x4f90>>,%d2
    return ERR_MEM;
800145d6:	82 f2       	mov %d2,-1
800145d8:	00 90       	ret 
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
800145da:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800145de:	b9 22 0a 00 	ld.hu %d2,[%a2]10
800145e2:	8b c2 a1 22 	ge.u %d2,%d2,28
800145e6:	df 02 17 80 	jne %d2,0,80014614 <etharp_raw+0xca>
800145ea:	91 00 00 28 	movh.a %a2,32768
800145ee:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
800145f2:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
800145f6:	3b 20 46 20 	mov %d2,1122
800145fa:	59 a2 04 00 	st.w [%sp]4,%d2
800145fe:	91 00 00 28 	movh.a %a2,32768
80014602:	d9 22 d0 d0 	lea %a2,[%a2]3920 <80000f50 <IfxCpu_Trap_vectorTable0_end+0xd5c>>
80014606:	f4 a2       	st.a [%sp],%a2
80014608:	91 00 00 28 	movh.a %a2,32768
8001460c:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
80014610:	6d ff 93 86 	call 80005336 <Ifx_Lwip_printf>
              (p->len >= SIZEOF_ETHARP_HDR));

  hdr = (struct etharp_hdr *)p->payload;
80014614:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80014618:	b0 42       	add.a %a2,4
8001461a:	54 22       	ld.w %d2,[%a2]
8001461c:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = lwip_htons(opcode);
80014620:	b9 e2 dc ff 	ld.hu %d2,[%a14]-36
80014624:	02 24       	mov %d4,%d2
80014626:	6d 00 97 17 	call 80017554 <lwip_htons>
8001462a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001462e:	8f f2 0f 31 	and %d3,%d2,255
80014632:	82 04       	mov %d4,0
80014634:	a6 43       	or %d3,%d4
80014636:	e9 23 06 00 	st.b [%a2]6,%d3
8001463a:	06 82       	sh %d2,-8
8001463c:	37 02 70 20 	extr.u %d2,%d2,0,16
80014640:	82 03       	mov %d3,0
80014642:	a6 32       	or %d2,%d3
80014644:	e9 22 07 00 	st.b [%a2]7,%d2

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETH_HWADDR_LEN for etharp!",
80014648:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001464c:	39 22 30 00 	ld.bu %d2,[%a2]48
80014650:	df 62 17 00 	jeq %d2,6,8001467e <etharp_raw+0x134>
80014654:	91 00 00 28 	movh.a %a2,32768
80014658:	d9 22 d0 60 	lea %a2,[%a2]3472 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>
8001465c:	b5 a2 08 00 	st.a [%sp]8 <80000d90 <IfxCpu_Trap_vectorTable0_end+0xb9c>>,%a2
80014660:	3b 90 46 20 	mov %d2,1129
80014664:	59 a2 04 00 	st.w [%sp]4,%d2
80014668:	91 00 00 28 	movh.a %a2,32768
8001466c:	d9 22 c1 e0 	lea %a2,[%a2]3969 <80000f81 <IfxCpu_Trap_vectorTable0_end+0xd8d>>
80014670:	f4 a2       	st.a [%sp],%a2
80014672:	91 00 00 28 	movh.a %a2,32768
80014676:	d9 24 e8 50 	lea %a4,[%a2]3432 <80000d68 <IfxCpu_Trap_vectorTable0_end+0xb74>>
8001467a:	6d ff 5e 86 	call 80005336 <Ifx_Lwip_printf>
              (netif->hwaddr_len == ETH_HWADDR_LEN));

  /* Write the ARP MAC-Addresses */
  SMEMCPY(&hdr->shwaddr, hwsrc_addr, ETH_HWADDR_LEN);
8001467e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80014682:	1b 82 00 20 	addi %d2,%d2,8
80014686:	82 64       	mov %d4,6
80014688:	99 e5 e0 ff 	ld.a %a5,[%a14]-32
8001468c:	60 24       	mov.a %a4,%d2
8001468e:	6d 00 c7 95 	call 8002721c <memcpy>
  SMEMCPY(&hdr->dhwaddr, hwdst_addr, ETH_HWADDR_LEN);
80014692:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80014696:	1b 22 01 20 	addi %d2,%d2,18
8001469a:	82 64       	mov %d4,6
8001469c:	99 e5 04 00 	ld.a %a5,[%a14]4
800146a0:	60 24       	mov.a %a4,%d2
800146a2:	6d 00 bd 95 	call 8002721c <memcpy>
  /* Copy struct ip4_addr_wordaligned to aligned ip4_addr, to support compilers without
   * structure packing. */
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->sipaddr, ipsrc_addr);
800146a6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800146aa:	1b e2 00 20 	addi %d2,%d2,14
800146ae:	82 44       	mov %d4,4
800146b0:	d4 e5       	ld.a %a5,[%a14]
800146b2:	60 24       	mov.a %a4,%d2
800146b4:	6d 00 b4 95 	call 8002721c <memcpy>
  IPADDR_WORDALIGNED_COPY_FROM_IP4_ADDR_T(&hdr->dipaddr, ipdst_addr);
800146b8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800146bc:	1b 82 01 20 	addi %d2,%d2,24
800146c0:	82 44       	mov %d4,4
800146c2:	99 e5 08 00 	ld.a %a5,[%a14]8
800146c6:	60 24       	mov.a %a4,%d2
800146c8:	6d 00 aa 95 	call 8002721c <memcpy>

  hdr->hwtype = PP_HTONS(LWIP_IANA_HWTYPE_ETHERNET);
800146cc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800146d0:	82 02       	mov %d2,0
800146d2:	34 22       	st.b [%a2],%d2
800146d4:	82 02       	mov %d2,0
800146d6:	8f 12 40 21 	or %d2,%d2,1
800146da:	e9 22 01 00 	st.b [%a2]1,%d2
  hdr->proto = PP_HTONS(ETHTYPE_IP);
800146de:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800146e2:	82 02       	mov %d2,0
800146e4:	8f 82 40 21 	or %d2,%d2,8
800146e8:	e9 22 02 00 	st.b [%a2]2,%d2
800146ec:	82 02       	mov %d2,0
800146ee:	e9 22 03 00 	st.b [%a2]3,%d2
  /* set hwlen and protolen */
  hdr->hwlen = ETH_HWADDR_LEN;
800146f2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800146f6:	82 62       	mov %d2,6
800146f8:	e9 22 04 00 	st.b [%a2]4,%d2
  hdr->protolen = sizeof(ip4_addr_t);
800146fc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014700:	82 42       	mov %d2,4
80014702:	e9 22 05 00 	st.b [%a2]5,%d2
  if (ip4_addr_islinklocal(ipsrc_addr)) {
    ethernet_output(netif, p, ethsrc_addr, &ethbroadcast, ETHTYPE_ARP);
  } else
#endif /* LWIP_AUTOIP */
  {
    ethernet_output(netif, p, ethsrc_addr, ethdst_addr, ETHTYPE_ARP);
80014706:	3b 60 80 40 	mov %d4,2054
8001470a:	99 e7 e4 ff 	ld.a %a7,[%a14]-28
8001470e:	99 e6 e8 ff 	ld.a %a6,[%a14]-24
80014712:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80014716:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001471a:	6d ff 05 dd 	call 80010124 <ethernet_output>
  }

  ETHARP_STATS_INC(etharp.xmit);
8001471e:	91 10 00 27 	movh.a %a2,28673
80014722:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014726:	b9 22 18 00 	ld.hu %d2,[%a2]24 <70010018 <ram_heap+0x4f84>>
8001472a:	c2 12       	add %d2,1
8001472c:	37 02 70 20 	extr.u %d2,%d2,0,16
80014730:	91 10 00 27 	movh.a %a2,28673
80014734:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014738:	f9 22 18 00 	st.h [%a2]24 <70010018 <ram_heap+0x4f84>>,%d2
  /* free ARP query packet */
  pbuf_free(p);
8001473c:	99 e4 f8 ff 	ld.a %a4,[%a14]-8 <70010018 <ram_heap+0x4f84>>
80014740:	6d 00 2c 2c 	call 80019f98 <pbuf_free>
  p = NULL;
80014744:	82 02       	mov %d2,0
80014746:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  /* could not allocate pbuf for ARP request */

  return result;
8001474a:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
8001474e:	00 90       	ret 

80014750 <etharp_request_dst>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
static err_t
etharp_request_dst(struct netif *netif, const ip4_addr_t *ipaddr, const struct eth_addr *hw_dst_addr)
{
80014750:	40 ae       	mov.aa %a14,%sp
80014752:	20 20       	sub.a %sp,32
80014754:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80014758:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
8001475c:	b5 e6 f4 ff 	st.a [%a14]-12,%a6
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
80014760:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80014764:	1b a2 02 20 	addi %d2,%d2,42
                    (struct eth_addr *)netif->hwaddr, netif_ip4_addr(netif), &ethzero,
80014768:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8001476c:	1b a3 02 30 	addi %d3,%d3,42
80014770:	19 e4 fc ff 	ld.w %d4,[%a14]-4
80014774:	c2 44       	add %d4,4
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, hw_dst_addr,
80014776:	19 e5 f8 ff 	ld.w %d5,[%a14]-8
8001477a:	59 a5 08 00 	st.w [%sp]8,%d5
8001477e:	91 00 00 28 	movh.a %a2,32768
80014782:	d9 22 56 44 	lea %a2,[%a2]17686 <80004516 <ethzero>>
80014786:	b5 a2 04 00 	st.a [%sp]4 <80004516 <ethzero>>,%a2
8001478a:	74 a4       	st.w [%sp],%d4
8001478c:	82 14       	mov %d4,1
8001478e:	60 37       	mov.a %a7,%d3
80014790:	99 e6 f4 ff 	ld.a %a6,[%a14]-12
80014794:	60 25       	mov.a %a5,%d2
80014796:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001479a:	6d ff d8 fe 	call 8001454a <etharp_raw>
                    ipaddr, ARP_REQUEST);
}
8001479e:	00 90       	ret 

800147a0 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, const ip4_addr_t *ipaddr)
{
800147a0:	40 ae       	mov.aa %a14,%sp
800147a2:	20 08       	sub.a %sp,8
800147a4:	b5 e4 fc ff 	st.a [%a14]-4,%a4
800147a8:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_request_dst(netif, ipaddr, &ethbroadcast);
800147ac:	91 00 00 28 	movh.a %a2,32768
800147b0:	d9 26 50 44 	lea %a6,[%a2]17680 <80004510 <ethbroadcast>>
800147b4:	99 e5 f8 ff 	ld.a %a5,[%a14]-8 <80004510 <ethbroadcast>>
800147b8:	99 e4 fc ff 	ld.a %a4,[%a14]-4 <80004510 <ethbroadcast>>
800147bc:	6d ff ca ff 	call 80014750 <etharp_request_dst>
}
800147c0:	00 90       	ret 

800147c2 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the icmp header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
800147c2:	40 ae       	mov.aa %a14,%sp
800147c4:	20 38       	sub.a %sp,56
800147c6:	b5 e4 dc ff 	st.a [%a14]-36,%a4
800147ca:	b5 e5 d8 ff 	st.a [%a14]-40,%a5
  struct icmp_echo_hdr *iecho;
  const struct ip_hdr *iphdr_in;
  u16_t hlen;
  const ip4_addr_t *src;

  ICMP_STATS_INC(icmp.recv);
800147ce:	91 10 00 27 	movh.a %a2,28673
800147d2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800147d6:	b9 22 22 10 	ld.hu %d2,[%a2]98 <70010062 <ram_heap+0x4fce>>
800147da:	c2 12       	add %d2,1
800147dc:	37 02 70 20 	extr.u %d2,%d2,0,16
800147e0:	91 10 00 27 	movh.a %a2,28673
800147e4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800147e8:	f9 22 22 10 	st.h [%a2]98 <70010062 <ram_heap+0x4fce>>,%d2
  MIB2_STATS_INC(mib2.icmpinmsgs);

  iphdr_in = ip4_current_header();
800147ec:	91 10 00 27 	movh.a %a2,28673
800147f0:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800147f4:	d9 22 08 00 	lea %a2,[%a2]8 <70010008 <ram_heap+0x4f74>>
800147f8:	54 22       	ld.w %d2,[%a2]
800147fa:	59 e2 fc ff 	st.w [%a14]-4 <70010008 <ram_heap+0x4f74>>,%d2
  hlen = IPH_HL_BYTES(iphdr_in);
800147fe:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <70010008 <ram_heap+0x4f74>>
80014802:	14 22       	ld.bu %d2,[%a2]
80014804:	8f f2 00 21 	and %d2,%d2,15
80014808:	8f f2 0f 21 	and %d2,%d2,255
8001480c:	06 22       	sh %d2,2
8001480e:	8f f2 0f 21 	and %d2,%d2,255
80014812:	f9 e2 fa ff 	st.h [%a14]-6,%d2
  if (hlen < IP_HLEN) {
80014816:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8001481a:	8b 42 a1 22 	ge.u %d2,%d2,20
8001481e:	df 02 23 02 	jeq %d2,0,80014c64 <icmp_input+0x4a2>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
    goto lenerr;
  }
  if (p->len < sizeof(u16_t) * 2) {
80014822:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80014826:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001482a:	bf 42 20 82 	jlt.u %d2,4,80014c6a <icmp_input+0x4a8>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
8001482e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80014832:	b0 42       	add.a %a2,4
80014834:	d4 22       	ld.a %a2,[%a2]
80014836:	79 22 00 00 	ld.b %d2,[%a2]0
8001483a:	e9 e2 f9 ff 	st.b [%a14]-7,%d2
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload) + 1);
8001483e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80014842:	b0 42       	add.a %a2,4
80014844:	d4 22       	ld.a %a2,[%a2]
80014846:	79 22 01 00 	ld.b %d2,[%a2]1
8001484a:	e9 e2 f8 ff 	st.b [%a14]-8,%d2
  /* if debug is enabled but debug statement below is somehow disabled: */
  LWIP_UNUSED_ARG(code);
#endif /* LWIP_DEBUG */
  switch (type) {
8001484e:	39 e2 f9 ff 	ld.bu %d2,[%a14]-7
80014852:	df 02 00 02 	jeq %d2,0,80014c52 <icmp_input+0x490>
80014856:	8b 82 00 22 	eq %d2,%d2,8
8001485a:	df 02 dc 01 	jeq %d2,0,80014c12 <icmp_input+0x450>
         (as obviously, an echo request has been sent, too). */
      MIB2_STATS_INC(mib2.icmpinechoreps);
      break;
    case ICMP_ECHO:
      MIB2_STATS_INC(mib2.icmpinechos);
      src = ip4_current_dest_addr();
8001485e:	91 10 00 27 	movh.a %a2,28673
80014862:	d9 22 10 2b 	lea %a2,[%a2]-20336 <7000b090 <ip_data+0x14>>
80014866:	b5 e2 f4 ff 	st.a [%a14]-12 <7000b090 <ip_data+0x14>>,%a2
      /* multicast destination address? */
      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
8001486a:	91 10 00 27 	movh.a %a2,28673
8001486e:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80014872:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80014876:	54 22       	ld.w %d2,[%a2]
80014878:	8f 02 0f 21 	and %d2,%d2,240
8001487c:	8b 02 2e 22 	ne %d2,%d2,224
80014880:	df 02 0d 02 	jeq %d2,0,80014c9a <icmp_input+0x4d8>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
        goto icmperr;
#endif /* LWIP_MULTICAST_PING */
      }
      /* broadcast destination address? */
      if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
80014884:	91 10 00 27 	movh.a %a2,28673
80014888:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001488c:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80014890:	54 22       	ld.w %d2,[%a2]
80014892:	91 10 00 27 	movh.a %a2,28673
80014896:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001489a:	54 23       	ld.w %d3,[%a2]
8001489c:	60 34       	mov.a %a4,%d3
8001489e:	02 24       	mov %d4,%d2
800148a0:	6d 00 d6 09 	call 80015c4c <ip4_addr_isbroadcast_u32>
800148a4:	df 02 fe 81 	jne %d2,0,80014ca0 <icmp_input+0x4de>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
        goto icmperr;
#endif /* LWIP_BROADCAST_PING */
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
      if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
800148a8:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800148ac:	b9 22 08 00 	ld.hu %d2,[%a2]8
800148b0:	bf 82 e0 81 	jlt.u %d2,8,80014c70 <icmp_input+0x4ae>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
        goto lenerr;
      }
#if CHECKSUM_CHECK_ICMP
      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
        if (inet_chksum_pbuf(p) != 0) {
800148b4:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800148b8:	6d 00 48 18 	call 80017948 <inet_chksum_pbuf>
800148bc:	df 02 16 00 	jeq %d2,0,800148e8 <icmp_input+0x126>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
          pbuf_free(p);
800148c0:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800148c4:	6d 00 6a 2b 	call 80019f98 <pbuf_free>
          ICMP_STATS_INC(icmp.chkerr);
800148c8:	91 10 00 27 	movh.a %a2,28673
800148cc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800148d0:	b9 22 28 10 	ld.hu %d2,[%a2]104 <70010068 <ram_heap+0x4fd4>>
800148d4:	c2 12       	add %d2,1
800148d6:	37 02 70 20 	extr.u %d2,%d2,0,16
800148da:	91 10 00 27 	movh.a %a2,28673
800148de:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800148e2:	f9 22 28 10 	st.h [%a2]104 <70010068 <ram_heap+0x4fd4>>,%d2
          MIB2_STATS_INC(mib2.icmpinerrors);
          return;
800148e6:	00 90       	ret 
        }
      }
#endif
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
      if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
800148e8:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
800148ec:	1b 02 01 20 	addi %d2,%d2,16
800148f0:	02 24       	mov %d4,%d2
800148f2:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800148f6:	6d 00 7d 2a 	call 80019df0 <pbuf_add_header>
800148fa:	df 02 7b 00 	jeq %d2,0,800149f0 <icmp_input+0x22e>
        /* p is not big enough to contain link headers
         * allocate a new one and copy p into it
         */
        struct pbuf *r;
        u16_t alloc_len = (u16_t)(p->tot_len + hlen);
800148fe:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80014902:	b9 23 08 00 	ld.hu %d3,[%a2]8
80014906:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
8001490a:	42 32       	add %d2,%d3
8001490c:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
        if (alloc_len < p->tot_len) {
80014910:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80014914:	b9 22 08 00 	ld.hu %d2,[%a2]8
80014918:	b9 e3 f2 ff 	ld.hu %d3,[%a14]-14
8001491c:	3f 23 c5 81 	jlt.u %d3,%d2,80014ca6 <icmp_input+0x4e4>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
          goto icmperr;
        }
        /* allocate new packet buffer with space for link headers */
        r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
80014920:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
80014924:	3b 00 28 60 	mov %d6,640
80014928:	02 25       	mov %d5,%d2
8001492a:	3b 00 01 40 	mov %d4,16
8001492e:	6d 00 d9 26 	call 800196e0 <pbuf_alloc>
80014932:	b5 e2 ec ff 	st.a [%a14]-20,%a2
        if (r == NULL) {
80014936:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001493a:	df 02 b9 01 	jeq %d2,0,80014cac <icmp_input+0x4ea>
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
          goto icmperr;
        }
        if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
8001493e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80014942:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80014946:	02 23       	mov %d3,%d2
80014948:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8001494c:	1b 82 00 20 	addi %d2,%d2,8
80014950:	7f 23 08 80 	jge.u %d3,%d2,80014960 <icmp_input+0x19e>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
          pbuf_free(r);
80014954:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80014958:	6d 00 20 2b 	call 80019f98 <pbuf_free>
          goto icmperr;
8001495c:	1d 00 a9 01 	j 80014cae <icmp_input+0x4ec>
        }
        /* copy the ip header */
        MEMCPY(r->payload, iphdr_in, hlen);
80014960:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80014964:	b0 42       	add.a %a2,4
80014966:	54 23       	ld.w %d3,[%a2]
80014968:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8001496c:	02 24       	mov %d4,%d2
8001496e:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80014972:	60 34       	mov.a %a4,%d3
80014974:	6d 00 54 94 	call 8002721c <memcpy>
        /* switch r->payload back to icmp header (cannot fail) */
        if (pbuf_remove_header(r, hlen)) {
80014978:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8001497c:	02 24       	mov %d4,%d2
8001497e:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80014982:	6d 00 45 2a 	call 80019e0c <pbuf_remove_header>
80014986:	df 02 1d 00 	jeq %d2,0,800149c0 <icmp_input+0x1fe>
          LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
8001498a:	91 00 00 28 	movh.a %a2,32768
8001498e:	d9 22 ea f0 	lea %a2,[%a2]4074 <80000fea <IfxCpu_Trap_vectorTable0_end+0xdf6>>
80014992:	b5 a2 08 00 	st.a [%sp]8 <80000fea <IfxCpu_Trap_vectorTable0_end+0xdf6>>,%a2
80014996:	3b 60 0b 20 	mov %d2,182
8001499a:	59 a2 04 00 	st.w [%sp]4,%d2
8001499e:	91 00 00 28 	movh.a %a2,32768
800149a2:	d9 22 1a 01 	lea %a2,[%a2]4122 <8000101a <IfxCpu_Trap_vectorTable0_end+0xe26>>
800149a6:	f4 a2       	st.a [%sp],%a2
800149a8:	91 00 00 28 	movh.a %a2,32768
800149ac:	d9 24 c2 f0 	lea %a4,[%a2]4034 <80000fc2 <IfxCpu_Trap_vectorTable0_end+0xdce>>
800149b0:	6d ff c3 84 	call 80005336 <Ifx_Lwip_printf>
          pbuf_free(r);
800149b4:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800149b8:	6d 00 f0 2a 	call 80019f98 <pbuf_free>
          goto icmperr;
800149bc:	1d 00 79 01 	j 80014cae <icmp_input+0x4ec>
        }
        /* copy the rest of the packet without ip header */
        if (pbuf_copy(r, p) != ERR_OK) {
800149c0:	99 e5 dc ff 	ld.a %a5,[%a14]-36
800149c4:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800149c8:	6d 00 b8 2c 	call 8001a338 <pbuf_copy>
800149cc:	df 02 08 00 	jeq %d2,0,800149dc <icmp_input+0x21a>
          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
          pbuf_free(r);
800149d0:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800149d4:	6d 00 e2 2a 	call 80019f98 <pbuf_free>
          goto icmperr;
800149d8:	1d 00 6b 01 	j 80014cae <icmp_input+0x4ec>
        }
        /* free the original p */
        pbuf_free(p);
800149dc:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800149e0:	6d 00 dc 2a 	call 80019f98 <pbuf_free>
        /* we now have an identical copy of p that has room for link headers */
        p = r;
800149e4:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800149e8:	59 e2 dc ff 	st.w [%a14]-36,%d2
800149ec:	1d 00 24 00 	j 80014a34 <icmp_input+0x272>
      } else {
        /* restore p->payload to point to icmp header (cannot fail) */
        if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
800149f0:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
800149f4:	1b 02 01 20 	addi %d2,%d2,16
800149f8:	02 24       	mov %d4,%d2
800149fa:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800149fe:	6d 00 07 2a 	call 80019e0c <pbuf_remove_header>
80014a02:	df 02 19 00 	jeq %d2,0,80014a34 <icmp_input+0x272>
          LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
80014a06:	91 00 00 28 	movh.a %a2,32768
80014a0a:	d9 22 ea f0 	lea %a2,[%a2]4074 <80000fea <IfxCpu_Trap_vectorTable0_end+0xdf6>>
80014a0e:	b5 a2 08 00 	st.a [%sp]8 <80000fea <IfxCpu_Trap_vectorTable0_end+0xdf6>>,%a2
80014a12:	3b 70 0c 20 	mov %d2,199
80014a16:	59 a2 04 00 	st.w [%sp]4,%d2
80014a1a:	91 00 00 28 	movh.a %a2,32768
80014a1e:	d9 22 0f 11 	lea %a2,[%a2]4175 <8000104f <IfxCpu_Trap_vectorTable0_end+0xe5b>>
80014a22:	f4 a2       	st.a [%sp],%a2
80014a24:	91 00 00 28 	movh.a %a2,32768
80014a28:	d9 24 c2 f0 	lea %a4,[%a2]4034 <80000fc2 <IfxCpu_Trap_vectorTable0_end+0xdce>>
80014a2c:	6d ff 85 84 	call 80005336 <Ifx_Lwip_printf>
          goto icmperr;
80014a30:	1d 00 3f 01 	j 80014cae <icmp_input+0x4ec>
      }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
      /* At this point, all checks are OK. */
      /* We generate an answer by switching the dest and src ip addresses,
       * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
      iecho = (struct icmp_echo_hdr *)p->payload;
80014a34:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80014a38:	b0 42       	add.a %a2,4
80014a3a:	54 22       	ld.w %d2,[%a2]
80014a3c:	59 e2 e8 ff 	st.w [%a14]-24,%d2
      if (pbuf_add_header(p, hlen)) {
80014a40:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80014a44:	02 24       	mov %d4,%d2
80014a46:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80014a4a:	6d 00 d3 29 	call 80019df0 <pbuf_add_header>
80014a4e:	df 02 05 81 	jne %d2,0,80014c58 <icmp_input+0x496>
        LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
      } else {
        err_t ret;
        struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
80014a52:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80014a56:	b0 42       	add.a %a2,4
80014a58:	54 22       	ld.w %d2,[%a2]
80014a5a:	59 e2 e4 ff 	st.w [%a14]-28,%d2
        ip4_addr_copy(iphdr->src, *src);
80014a5e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014a62:	54 22       	ld.w %d2,[%a2]
80014a64:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80014a68:	8f f2 0f 31 	and %d3,%d2,255
80014a6c:	82 04       	mov %d4,0
80014a6e:	a6 43       	or %d3,%d4
80014a70:	e9 23 0c 00 	st.b [%a2]12,%d3
80014a74:	8f 82 1f 30 	sh %d3,%d2,-8
80014a78:	8f f3 0f 31 	and %d3,%d3,255
80014a7c:	82 04       	mov %d4,0
80014a7e:	a6 43       	or %d3,%d4
80014a80:	e9 23 0d 00 	st.b [%a2]13,%d3
80014a84:	8f 02 1f 30 	sh %d3,%d2,-16
80014a88:	8f f3 0f 31 	and %d3,%d3,255
80014a8c:	82 04       	mov %d4,0
80014a8e:	a6 43       	or %d3,%d4
80014a90:	e9 23 0e 00 	st.b [%a2]14,%d3
80014a94:	8f 82 1e 20 	sh %d2,%d2,-24
80014a98:	82 03       	mov %d3,0
80014a9a:	a6 32       	or %d2,%d3
80014a9c:	e9 22 0f 00 	st.b [%a2]15,%d2
        ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
80014aa0:	91 10 00 27 	movh.a %a2,28673
80014aa4:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80014aa8:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80014aac:	54 22       	ld.w %d2,[%a2]
80014aae:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <70010010 <ram_heap+0x4f7c>>
80014ab2:	8f f2 0f 31 	and %d3,%d2,255
80014ab6:	82 04       	mov %d4,0
80014ab8:	a6 43       	or %d3,%d4
80014aba:	e9 23 10 00 	st.b [%a2]16,%d3
80014abe:	8f 82 1f 30 	sh %d3,%d2,-8
80014ac2:	8f f3 0f 31 	and %d3,%d3,255
80014ac6:	82 04       	mov %d4,0
80014ac8:	a6 43       	or %d3,%d4
80014aca:	e9 23 11 00 	st.b [%a2]17,%d3
80014ace:	8f 02 1f 30 	sh %d3,%d2,-16
80014ad2:	8f f3 0f 31 	and %d3,%d3,255
80014ad6:	82 04       	mov %d4,0
80014ad8:	a6 43       	or %d3,%d4
80014ada:	e9 23 12 00 	st.b [%a2]18,%d3
80014ade:	8f 82 1e 20 	sh %d2,%d2,-24
80014ae2:	82 03       	mov %d3,0
80014ae4:	a6 32       	or %d2,%d3
80014ae6:	e9 22 13 00 	st.b [%a2]19,%d2
        ICMPH_TYPE_SET(iecho, ICMP_ER);
80014aea:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80014aee:	82 02       	mov %d2,0
80014af0:	34 22       	st.b [%a2],%d2
#if CHECKSUM_GEN_ICMP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
          /* adjust the checksum */
          if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
80014af2:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80014af6:	39 23 02 00 	ld.bu %d3,[%a2]2
80014afa:	39 22 03 00 	ld.bu %d2,[%a2]3
80014afe:	8f 82 00 20 	sh %d2,%d2,8
80014b02:	a6 32       	or %d2,%d3
80014b04:	37 02 70 20 	extr.u %d2,%d2,0,16
80014b08:	bb 80 ff 3f 	mov.u %d3,65528
80014b0c:	3f 32 22 80 	jlt.u %d2,%d3,80014b50 <icmp_input+0x38e>
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
80014b10:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80014b14:	39 23 02 00 	ld.bu %d3,[%a2]2
80014b18:	39 22 03 00 	ld.bu %d2,[%a2]3
80014b1c:	8f 82 00 20 	sh %d2,%d2,8
80014b20:	a6 32       	or %d2,%d3
80014b22:	37 02 70 20 	extr.u %d2,%d2,0,16
80014b26:	1b 92 00 20 	addi %d2,%d2,9
80014b2a:	37 02 70 20 	extr.u %d2,%d2,0,16
80014b2e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80014b32:	8f f2 0f 31 	and %d3,%d2,255
80014b36:	82 04       	mov %d4,0
80014b38:	a6 43       	or %d3,%d4
80014b3a:	e9 23 02 00 	st.b [%a2]2,%d3
80014b3e:	06 82       	sh %d2,-8
80014b40:	37 02 70 20 	extr.u %d2,%d2,0,16
80014b44:	82 03       	mov %d3,0
80014b46:	a6 32       	or %d2,%d3
80014b48:	e9 22 03 00 	st.b [%a2]3,%d2
80014b4c:	1d 00 20 00 	j 80014b8c <icmp_input+0x3ca>
          } else {
            iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
80014b50:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80014b54:	39 23 02 00 	ld.bu %d3,[%a2]2
80014b58:	39 22 03 00 	ld.bu %d2,[%a2]3
80014b5c:	8f 82 00 20 	sh %d2,%d2,8
80014b60:	a6 32       	or %d2,%d3
80014b62:	37 02 70 20 	extr.u %d2,%d2,0,16
80014b66:	1b 82 00 20 	addi %d2,%d2,8
80014b6a:	37 02 70 20 	extr.u %d2,%d2,0,16
80014b6e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80014b72:	8f f2 0f 31 	and %d3,%d2,255
80014b76:	82 04       	mov %d4,0
80014b78:	a6 43       	or %d3,%d4
80014b7a:	e9 23 02 00 	st.b [%a2]2,%d3
80014b7e:	06 82       	sh %d2,-8
80014b80:	37 02 70 20 	extr.u %d2,%d2,0,16
80014b84:	82 03       	mov %d3,0
80014b86:	a6 32       	or %d2,%d3
80014b88:	e9 22 03 00 	st.b [%a2]3,%d2
#else /* CHECKSUM_GEN_ICMP */
        iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

        /* Set the correct TTL and recalculate the header checksum. */
        IPH_TTL_SET(iphdr, ICMP_TTL);
80014b8c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80014b90:	82 f2       	mov %d2,-1
80014b92:	e9 22 08 00 	st.b [%a2]8,%d2
        IPH_CHKSUM_SET(iphdr, 0);
80014b96:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80014b9a:	82 02       	mov %d2,0
80014b9c:	e9 22 0a 00 	st.b [%a2]10,%d2
80014ba0:	82 02       	mov %d2,0
80014ba2:	e9 22 0b 00 	st.b [%a2]11,%d2
#if CHECKSUM_GEN_IP
        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
80014ba6:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80014baa:	02 24       	mov %d4,%d2
80014bac:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80014bb0:	6d 00 ba 16 	call 80017924 <inet_chksum>
80014bb4:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80014bb8:	8f f2 0f 31 	and %d3,%d2,255
80014bbc:	82 04       	mov %d4,0
80014bbe:	a6 43       	or %d3,%d4
80014bc0:	e9 23 0a 00 	st.b [%a2]10,%d3
80014bc4:	06 82       	sh %d2,-8
80014bc6:	37 02 70 20 	extr.u %d2,%d2,0,16
80014bca:	82 03       	mov %d3,0
80014bcc:	a6 32       	or %d2,%d3
80014bce:	e9 22 0b 00 	st.b [%a2]11,%d2
        }
#endif /* CHECKSUM_GEN_IP */

        ICMP_STATS_INC(icmp.xmit);
80014bd2:	91 10 00 27 	movh.a %a2,28673
80014bd6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014bda:	b9 22 20 10 	ld.hu %d2,[%a2]96 <70010060 <ram_heap+0x4fcc>>
80014bde:	c2 12       	add %d2,1
80014be0:	37 02 70 20 	extr.u %d2,%d2,0,16
80014be4:	91 10 00 27 	movh.a %a2,28673
80014be8:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014bec:	f9 22 20 10 	st.h [%a2]96 <70010060 <ram_heap+0x4fcc>>,%d2
        MIB2_STATS_INC(mib2.icmpoutmsgs);
        /* increase number of echo replies attempted to send */
        MIB2_STATS_INC(mib2.icmpoutechoreps);

        /* send an ICMP packet */
        ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
80014bf0:	99 e7 d8 ff 	ld.a %a7,[%a14]-40 <70010060 <ram_heap+0x4fcc>>
80014bf4:	82 16       	mov %d6,1
80014bf6:	82 05       	mov %d5,0
80014bf8:	3b f0 0f 40 	mov %d4,255
80014bfc:	a0 06       	mov.a %a6,0
80014bfe:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80014c02:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80014c06:	6d 00 29 05 	call 80015658 <ip4_output_if>
80014c0a:	e9 e2 e3 ff 	st.b [%a14]-29,%d2
                            ICMP_TTL, 0, IP_PROTO_ICMP, inp);
        if (ret != ERR_OK) {
          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
        }
      }
      break;
80014c0e:	1d 00 25 00 	j 80014c58 <icmp_input+0x496>
      } else if (type == ICMP_AMR) {
        MIB2_STATS_INC(mib2.icmpinaddrmaskreps);
      }
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
                               (s16_t)type, (s16_t)code));
      ICMP_STATS_INC(icmp.proterr);
80014c12:	91 10 00 27 	movh.a %a2,28673
80014c16:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014c1a:	b9 22 30 10 	ld.hu %d2,[%a2]112 <70010070 <ram_heap+0x4fdc>>
80014c1e:	c2 12       	add %d2,1
80014c20:	37 02 70 20 	extr.u %d2,%d2,0,16
80014c24:	91 10 00 27 	movh.a %a2,28673
80014c28:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014c2c:	f9 22 30 10 	st.h [%a2]112 <70010070 <ram_heap+0x4fdc>>,%d2
      ICMP_STATS_INC(icmp.drop);
80014c30:	91 10 00 27 	movh.a %a2,28673
80014c34:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014c38:	b9 22 26 10 	ld.hu %d2,[%a2]102 <70010066 <ram_heap+0x4fd2>>
80014c3c:	c2 12       	add %d2,1
80014c3e:	37 02 70 20 	extr.u %d2,%d2,0,16
80014c42:	91 10 00 27 	movh.a %a2,28673
80014c46:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014c4a:	f9 22 26 10 	st.h [%a2]102 <70010066 <ram_heap+0x4fd2>>,%d2
80014c4e:	1d 00 06 00 	j 80014c5a <icmp_input+0x498>
      break;
80014c52:	00 00       	nop 
80014c54:	1d 00 03 00 	j 80014c5a <icmp_input+0x498>
      break;
80014c58:	00 00       	nop 
  }
  pbuf_free(p);
80014c5a:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80014c5e:	6d 00 9d 29 	call 80019f98 <pbuf_free>
  return;
80014c62:	00 90       	ret 
    goto lenerr;
80014c64:	00 00       	nop 
80014c66:	1d 00 06 00 	j 80014c72 <icmp_input+0x4b0>
    goto lenerr;
80014c6a:	00 00       	nop 
80014c6c:	1d 00 03 00 	j 80014c72 <icmp_input+0x4b0>
        goto lenerr;
80014c70:	00 00       	nop 
lenerr:
  pbuf_free(p);
80014c72:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80014c76:	6d 00 91 29 	call 80019f98 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
80014c7a:	91 10 00 27 	movh.a %a2,28673
80014c7e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014c82:	b9 22 2a 10 	ld.hu %d2,[%a2]106 <7001006a <ram_heap+0x4fd6>>
80014c86:	c2 12       	add %d2,1
80014c88:	37 02 70 20 	extr.u %d2,%d2,0,16
80014c8c:	91 10 00 27 	movh.a %a2,28673
80014c90:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014c94:	f9 22 2a 10 	st.h [%a2]106 <7001006a <ram_heap+0x4fd6>>,%d2
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
80014c98:	00 90       	ret 
        goto icmperr;
80014c9a:	00 00       	nop 
80014c9c:	1d 00 09 00 	j 80014cae <icmp_input+0x4ec>
        goto icmperr;
80014ca0:	00 00       	nop 
80014ca2:	1d 00 06 00 	j 80014cae <icmp_input+0x4ec>
          goto icmperr;
80014ca6:	00 00       	nop 
80014ca8:	1d 00 03 00 	j 80014cae <icmp_input+0x4ec>
          goto icmperr;
80014cac:	00 00       	nop 
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
icmperr:
  pbuf_free(p);
80014cae:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80014cb2:	6d 00 73 29 	call 80019f98 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
80014cb6:	91 10 00 27 	movh.a %a2,28673
80014cba:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014cbe:	b9 22 34 10 	ld.hu %d2,[%a2]116 <70010074 <ram_heap+0x4fe0>>
80014cc2:	c2 12       	add %d2,1
80014cc4:	37 02 70 20 	extr.u %d2,%d2,0,16
80014cc8:	91 10 00 27 	movh.a %a2,28673
80014ccc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014cd0:	f9 22 34 10 	st.h [%a2]116 <70010074 <ram_heap+0x4fe0>>,%d2
  MIB2_STATS_INC(mib2.icmpinerrors);
  return;
80014cd4:	00 00       	nop 
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
}
80014cd6:	00 90       	ret 

80014cd8 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
80014cd8:	40 ae       	mov.aa %a14,%sp
80014cda:	20 08       	sub.a %sp,8
80014cdc:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80014ce0:	59 e4 f8 ff 	st.w [%a14]-8,%d4
  MIB2_STATS_INC(mib2.icmpoutdestunreachs);
  icmp_send_response(p, ICMP_DUR, t);
80014ce4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80014ce8:	8f f2 0f 21 	and %d2,%d2,255
80014cec:	02 25       	mov %d5,%d2
80014cee:	82 34       	mov %d4,3
80014cf0:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80014cf4:	6d 00 17 00 	call 80014d22 <icmp_send_response>
}
80014cf8:	00 00       	nop 
80014cfa:	00 90       	ret 

80014cfc <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
80014cfc:	40 ae       	mov.aa %a14,%sp
80014cfe:	20 08       	sub.a %sp,8
80014d00:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80014d04:	59 e4 f8 ff 	st.w [%a14]-8,%d4
  MIB2_STATS_INC(mib2.icmpouttimeexcds);
  icmp_send_response(p, ICMP_TE, t);
80014d08:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80014d0c:	8f f2 0f 21 	and %d2,%d2,255
80014d10:	02 25       	mov %d5,%d2
80014d12:	3b b0 00 40 	mov %d4,11
80014d16:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80014d1a:	6d 00 04 00 	call 80014d22 <icmp_send_response>
}
80014d1e:	00 00       	nop 
80014d20:	00 90       	ret 

80014d22 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
80014d22:	40 ae       	mov.aa %a14,%sp
80014d24:	20 38       	sub.a %sp,56
80014d26:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80014d2a:	02 42       	mov %d2,%d4
80014d2c:	02 53       	mov %d3,%d5
80014d2e:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
80014d32:	02 32       	mov %d2,%d3
80014d34:	e9 e2 dc ff 	st.b [%a14]-36,%d2

  /* increase number of messages attempted to send */
  MIB2_STATS_INC(mib2.icmpoutmsgs);

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
80014d38:	3b 00 28 60 	mov %d6,640
80014d3c:	3b 40 02 50 	mov %d5,36
80014d40:	3b 40 02 40 	mov %d4,36
80014d44:	6d 00 ce 24 	call 800196e0 <pbuf_alloc>
80014d48:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
                 PBUF_RAM);
  if (q == NULL) {
80014d4c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80014d50:	df 02 b8 00 	jeq %d2,0,80014ec0 <icmp_send_response+0x19e>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    MIB2_STATS_INC(mib2.icmpouterrors);
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
80014d54:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80014d58:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80014d5c:	8b 42 a2 22 	ge.u %d2,%d2,36
80014d60:	df 02 17 80 	jne %d2,0,80014d8e <icmp_send_response+0x6c>
80014d64:	91 00 00 28 	movh.a %a2,32768
80014d68:	d9 22 ea f0 	lea %a2,[%a2]4074 <80000fea <IfxCpu_Trap_vectorTable0_end+0xdf6>>
80014d6c:	b5 a2 08 00 	st.a [%sp]8 <80000fea <IfxCpu_Trap_vectorTable0_end+0xdf6>>,%a2
80014d70:	3b 80 16 20 	mov %d2,360
80014d74:	59 a2 04 00 	st.w [%sp]4,%d2
80014d78:	91 00 00 28 	movh.a %a2,32768
80014d7c:	d9 22 01 21 	lea %a2,[%a2]4225 <80001081 <IfxCpu_Trap_vectorTable0_end+0xe8d>>
80014d80:	f4 a2       	st.a [%sp],%a2
80014d82:	91 00 00 28 	movh.a %a2,32768
80014d86:	d9 24 c2 f0 	lea %a4,[%a2]4034 <80000fc2 <IfxCpu_Trap_vectorTable0_end+0xdce>>
80014d8a:	6d ff d6 82 	call 80005336 <Ifx_Lwip_printf>
              (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
80014d8e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80014d92:	b0 42       	add.a %a2,4
80014d94:	54 22       	ld.w %d2,[%a2]
80014d96:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
80014d9a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80014d9e:	b0 42       	add.a %a2,4
80014da0:	54 22       	ld.w %d2,[%a2]
80014da2:	59 e2 f0 ff 	st.w [%a14]-16,%d2
  icmphdr->type = type;
80014da6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80014daa:	79 e2 e0 ff 	ld.b %d2,[%a14]-32
80014dae:	34 22       	st.b [%a2],%d2
  icmphdr->code = code;
80014db0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80014db4:	79 e2 dc ff 	ld.b %d2,[%a14]-36
80014db8:	e9 22 01 00 	st.b [%a2]1,%d2
  icmphdr->id = 0;
80014dbc:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80014dc0:	82 02       	mov %d2,0
80014dc2:	e9 22 04 00 	st.b [%a2]4,%d2
80014dc6:	82 02       	mov %d2,0
80014dc8:	e9 22 05 00 	st.b [%a2]5,%d2
  icmphdr->seqno = 0;
80014dcc:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80014dd0:	82 02       	mov %d2,0
80014dd2:	e9 22 06 00 	st.b [%a2]6,%d2
80014dd6:	82 02       	mov %d2,0
80014dd8:	e9 22 07 00 	st.b [%a2]7,%d2

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
80014ddc:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80014de0:	b0 42       	add.a %a2,4
80014de2:	54 22       	ld.w %d2,[%a2]
80014de4:	1b 82 00 20 	addi %d2,%d2,8
80014de8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80014dec:	b0 42       	add.a %a2,4
80014dee:	54 23       	ld.w %d3,[%a2]
80014df0:	3b c0 01 40 	mov %d4,28
80014df4:	60 35       	mov.a %a5,%d3
80014df6:	60 24       	mov.a %a4,%d2
80014df8:	6d 00 12 92 	call 8002721c <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  ip4_addr_copy(iphdr_src, iphdr->src);
80014dfc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014e00:	39 23 0c 00 	ld.bu %d3,[%a2]12
80014e04:	39 22 0d 00 	ld.bu %d2,[%a2]13
80014e08:	8f 82 00 20 	sh %d2,%d2,8
80014e0c:	a6 32       	or %d2,%d3
80014e0e:	39 23 0e 00 	ld.bu %d3,[%a2]14
80014e12:	8f 03 01 30 	sh %d3,%d3,16
80014e16:	a6 32       	or %d2,%d3
80014e18:	39 23 0f 00 	ld.bu %d3,[%a2]15
80014e1c:	8f 83 01 30 	sh %d3,%d3,24
80014e20:	a6 32       	or %d2,%d3
80014e22:	59 e2 ec ff 	st.w [%a14]-20,%d2
    ip4_addr_t iphdr_dst;
    ip4_addr_copy(iphdr_dst, iphdr->dest);
    netif = ip4_route_src(&iphdr_dst, &iphdr_src);
  }
#else
  netif = ip4_route(&iphdr_src);
80014e26:	d9 e2 ec ff 	lea %a2,[%a14]-20
80014e2a:	40 24       	mov.aa %a4,%a2
80014e2c:	6d 00 4b 00 	call 80014ec2 <ip4_route>
80014e30:	b5 e2 fc ff 	st.a [%a14]-4,%a2
#endif
  if (netif != NULL) {
80014e34:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80014e38:	df 02 3f 00 	jeq %d2,0,80014eb6 <icmp_send_response+0x194>
    /* calculate checksum */
    icmphdr->chksum = 0;
80014e3c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80014e40:	82 02       	mov %d2,0
80014e42:	e9 22 02 00 	st.b [%a2]2,%d2
80014e46:	82 02       	mov %d2,0
80014e48:	e9 22 03 00 	st.b [%a2]3,%d2
#if CHECKSUM_GEN_ICMP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
      icmphdr->chksum = inet_chksum(icmphdr, q->len);
80014e4c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80014e50:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80014e54:	02 24       	mov %d4,%d2
80014e56:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80014e5a:	6d 00 65 15 	call 80017924 <inet_chksum>
80014e5e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80014e62:	8f f2 0f 31 	and %d3,%d2,255
80014e66:	82 04       	mov %d4,0
80014e68:	a6 43       	or %d3,%d4
80014e6a:	e9 23 02 00 	st.b [%a2]2,%d3
80014e6e:	06 82       	sh %d2,-8
80014e70:	37 02 70 20 	extr.u %d2,%d2,0,16
80014e74:	82 03       	mov %d3,0
80014e76:	a6 32       	or %d2,%d3
80014e78:	e9 22 03 00 	st.b [%a2]3,%d2
    }
#endif
    ICMP_STATS_INC(icmp.xmit);
80014e7c:	91 10 00 27 	movh.a %a2,28673
80014e80:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014e84:	b9 22 20 10 	ld.hu %d2,[%a2]96 <70010060 <ram_heap+0x4fcc>>
80014e88:	c2 12       	add %d2,1
80014e8a:	37 02 70 20 	extr.u %d2,%d2,0,16
80014e8e:	91 10 00 27 	movh.a %a2,28673
80014e92:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014e96:	f9 22 20 10 	st.h [%a2]96 <70010060 <ram_heap+0x4fcc>>,%d2
    ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
80014e9a:	d9 e2 ec ff 	lea %a2,[%a14]-20 <70010060 <ram_heap+0x4fcc>>
80014e9e:	99 e7 fc ff 	ld.a %a7,[%a14]-4 <70010060 <ram_heap+0x4fcc>>
80014ea2:	82 16       	mov %d6,1
80014ea4:	82 05       	mov %d5,0
80014ea6:	3b f0 0f 40 	mov %d4,255
80014eaa:	40 26       	mov.aa %a6,%a2
80014eac:	a0 05       	mov.a %a5,0
80014eae:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80014eb2:	6d 00 d3 03 	call 80015658 <ip4_output_if>
  }
  pbuf_free(q);
80014eb6:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80014eba:	6d 00 6f 28 	call 80019f98 <pbuf_free>
80014ebe:	00 90       	ret 
}
80014ec0:	00 90       	ret 

80014ec2 <ip4_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip4_route(const ip4_addr_t *dest)
{
80014ec2:	40 ae       	mov.aa %a14,%sp
80014ec4:	20 10       	sub.a %sp,16
80014ec6:	b5 e4 f4 ff 	st.a [%a14]-12,%a4

  /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
  LWIP_UNUSED_ARG(dest);

  /* iterate through netifs */
  NETIF_FOREACH(netif) {
80014eca:	91 10 00 27 	movh.a %a2,28673
80014ece:	d9 22 48 34 	lea %a2,[%a2]17608 <700144c8 <netif_list>>
80014ed2:	54 22       	ld.w %d2,[%a2]
80014ed4:	59 e2 fc ff 	st.w [%a14]-4 <700144c8 <netif_list>>,%d2
80014ed8:	1d 00 50 00 	j 80014f78 <ip4_route+0xb6>
    /* is the netif up, does it have a link and a valid address? */
    if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
80014edc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80014ee0:	39 22 31 00 	ld.bu %d2,[%a2]49
80014ee4:	8f 12 00 21 	and %d2,%d2,1
80014ee8:	8f f2 0f 21 	and %d2,%d2,255
80014eec:	df 02 41 00 	jeq %d2,0,80014f6e <ip4_route+0xac>
80014ef0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80014ef4:	39 22 31 00 	ld.bu %d2,[%a2]49
80014ef8:	06 e2       	sh %d2,-2
80014efa:	8f 12 00 21 	and %d2,%d2,1
80014efe:	8f f2 0f 21 	and %d2,%d2,255
80014f02:	df 02 36 00 	jeq %d2,0,80014f6e <ip4_route+0xac>
80014f06:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80014f0a:	60 22       	mov.a %a2,%d2
80014f0c:	b0 42       	add.a %a2,4
80014f0e:	54 22       	ld.w %d2,[%a2]
80014f10:	df 02 2f 00 	jeq %d2,0,80014f6e <ip4_route+0xac>
      /* network mask matches? */
      if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
80014f14:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014f18:	54 23       	ld.w %d3,[%a2]
80014f1a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80014f1e:	60 22       	mov.a %a2,%d2
80014f20:	b0 42       	add.a %a2,4
80014f22:	54 22       	ld.w %d2,[%a2]
80014f24:	c6 32       	xor %d2,%d3
80014f26:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80014f2a:	60 32       	mov.a %a2,%d3
80014f2c:	d9 22 08 00 	lea %a2,[%a2]8
80014f30:	54 23       	ld.w %d3,[%a2]
80014f32:	26 32       	and %d2,%d3
80014f34:	df 02 06 80 	jne %d2,0,80014f40 <ip4_route+0x7e>
        /* return netif on which to forward IP packet */
        return netif;
80014f38:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80014f3c:	1d 00 69 00 	j 8001500e <ip4_route+0x14c>
      }
      /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
      if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
80014f40:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80014f44:	39 22 31 00 	ld.bu %d2,[%a2]49
80014f48:	8f 22 00 21 	and %d2,%d2,2
80014f4c:	df 02 11 80 	jne %d2,0,80014f6e <ip4_route+0xac>
80014f50:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014f54:	54 23       	ld.w %d3,[%a2]
80014f56:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80014f5a:	60 22       	mov.a %a2,%d2
80014f5c:	d9 22 0c 00 	lea %a2,[%a2]12
80014f60:	54 22       	ld.w %d2,[%a2]
80014f62:	5f 23 06 80 	jne %d3,%d2,80014f6e <ip4_route+0xac>
        /* return netif on which to forward IP packet */
        return netif;
80014f66:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80014f6a:	1d 00 52 00 	j 8001500e <ip4_route+0x14c>
  NETIF_FOREACH(netif) {
80014f6e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80014f72:	54 22       	ld.w %d2,[%a2]
80014f74:	59 e2 fc ff 	st.w [%a14]-4,%d2
80014f78:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80014f7c:	df 02 b0 ff 	jne %d2,0,80014edc <ip4_route+0x1a>
    return netif;
  }
#endif
#endif /* !LWIP_SINGLE_NETIF */

  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
80014f80:	91 10 00 27 	movh.a %a2,28673
80014f84:	d9 22 4c 34 	lea %a2,[%a2]17612 <700144cc <netif_default>>
80014f88:	54 22       	ld.w %d2,[%a2]
80014f8a:	df 02 2b 00 	jeq %d2,0,80014fe0 <ip4_route+0x11e>
80014f8e:	91 10 00 27 	movh.a %a2,28673
80014f92:	d9 22 4c 34 	lea %a2,[%a2]17612 <700144cc <netif_default>>
80014f96:	d4 22       	ld.a %a2,[%a2]
80014f98:	39 22 31 00 	ld.bu %d2,[%a2]49 <700144cc <netif_default>>
80014f9c:	8f 12 00 21 	and %d2,%d2,1
80014fa0:	df 02 20 00 	jeq %d2,0,80014fe0 <ip4_route+0x11e>
80014fa4:	91 10 00 27 	movh.a %a2,28673
80014fa8:	d9 22 4c 34 	lea %a2,[%a2]17612 <700144cc <netif_default>>
80014fac:	d4 22       	ld.a %a2,[%a2]
80014fae:	39 22 31 00 	ld.bu %d2,[%a2]49 <700144cc <netif_default>>
80014fb2:	8f 42 00 21 	and %d2,%d2,4
80014fb6:	df 02 15 00 	jeq %d2,0,80014fe0 <ip4_route+0x11e>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
80014fba:	91 10 00 27 	movh.a %a2,28673
80014fbe:	d9 22 4c 34 	lea %a2,[%a2]17612 <700144cc <netif_default>>
80014fc2:	54 22       	ld.w %d2,[%a2]
80014fc4:	60 22       	mov.a %a2,%d2
80014fc6:	b0 42       	add.a %a2,4
80014fc8:	54 22       	ld.w %d2,[%a2]
  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
80014fca:	df 02 0b 00 	jeq %d2,0,80014fe0 <ip4_route+0x11e>
      ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
80014fce:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80014fd2:	54 22       	ld.w %d2,[%a2]
80014fd4:	8f f2 0f 21 	and %d2,%d2,255
80014fd8:	8b f2 27 22 	ne %d2,%d2,127
80014fdc:	df 02 14 80 	jne %d2,0,80015004 <ip4_route+0x142>
    /* No matching netif found and default netif is not usable.
       If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
                ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
80014fe0:	91 10 00 27 	movh.a %a2,28673
80014fe4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014fe8:	b9 22 16 10 	ld.hu %d2,[%a2]86 <70010056 <ram_heap+0x4fc2>>
80014fec:	c2 12       	add %d2,1
80014fee:	37 02 70 20 	extr.u %d2,%d2,0,16
80014ff2:	91 10 00 27 	movh.a %a2,28673
80014ff6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80014ffa:	f9 22 16 10 	st.h [%a2]86 <70010056 <ram_heap+0x4fc2>>,%d2
    MIB2_STATS_INC(mib2.ipoutnoroutes);
    return NULL;
80014ffe:	82 02       	mov %d2,0
80015000:	1d 00 07 00 	j 8001500e <ip4_route+0x14c>
  }

  return netif_default;
80015004:	91 10 00 27 	movh.a %a2,28673
80015008:	d9 22 4c 34 	lea %a2,[%a2]17612 <700144cc <netif_default>>
8001500c:	54 22       	ld.w %d2,[%a2]
}
8001500e:	60 22       	mov.a %a2,%d2
80015010:	00 90       	ret 

80015012 <ip4_input_accept>:
#endif /* IP_FORWARD */

/** Return true if the current input packet should be accepted on this netif */
static int
ip4_input_accept(struct netif *netif)
{
80015012:	40 ae       	mov.aa %a14,%sp
80015014:	20 08       	sub.a %sp,8
80015016:	b5 e4 fc ff 	st.a [%a14]-4,%a4
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
                         ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));

  /* interface is up and configured? */
  if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
8001501a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001501e:	39 22 31 00 	ld.bu %d2,[%a2]49
80015022:	8f 12 00 21 	and %d2,%d2,1
80015026:	8f f2 0f 21 	and %d2,%d2,255
8001502a:	df 02 27 00 	jeq %d2,0,80015078 <ip4_input_accept+0x66>
8001502e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015032:	60 22       	mov.a %a2,%d2
80015034:	b0 42       	add.a %a2,4
80015036:	54 22       	ld.w %d2,[%a2]
80015038:	df 02 20 00 	jeq %d2,0,80015078 <ip4_input_accept+0x66>
    /* unicast to this interface address? */
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
8001503c:	91 10 00 27 	movh.a %a2,28673
80015040:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015044:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80015048:	54 23       	ld.w %d3,[%a2]
8001504a:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <70010014 <ram_heap+0x4f80>>
8001504e:	60 22       	mov.a %a2,%d2
80015050:	b0 42       	add.a %a2,4
80015052:	54 22       	ld.w %d2,[%a2]
80015054:	5f 23 10 00 	jeq %d3,%d2,80015074 <ip4_input_accept+0x62>
        /* or broadcast on this interface network address? */
        ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
80015058:	91 10 00 27 	movh.a %a2,28673
8001505c:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015060:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80015064:	54 22       	ld.w %d2,[%a2]
80015066:	99 e4 fc ff 	ld.a %a4,[%a14]-4 <70010014 <ram_heap+0x4f80>>
8001506a:	02 24       	mov %d4,%d2
8001506c:	6d 00 f0 05 	call 80015c4c <ip4_addr_isbroadcast_u32>
    if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
80015070:	df 02 04 00 	jeq %d2,0,80015078 <ip4_input_accept+0x66>
#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
       ) {
      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
                             netif->name[0], netif->name[1]));
      /* accept on this netif */
      return 1;
80015074:	82 12       	mov %d2,1
80015076:	00 90       	ret 
      /* accept on this netif */
      return 1;
    }
#endif /* LWIP_AUTOIP */
  }
  return 0;
80015078:	82 02       	mov %d2,0
}
8001507a:	00 90       	ret 

8001507c <ip4_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
{
8001507c:	40 ae       	mov.aa %a14,%sp
8001507e:	20 20       	sub.a %sp,32
80015080:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80015084:	b5 e5 e0 ff 	st.a [%a14]-32,%a5
  const struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP
  int check_ip_src = 1;
80015088:	82 12       	mov %d2,1
8001508a:	59 e2 fc ff 	st.w [%a14]-4,%d2
  raw_input_state_t raw_status;
#endif /* LWIP_RAW */

  LWIP_ASSERT_CORE_LOCKED();

  IP_STATS_INC(ip.recv);
8001508e:	91 10 00 27 	movh.a %a2,28673
80015092:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015096:	b9 22 0a 10 	ld.hu %d2,[%a2]74 <7001004a <ram_heap+0x4fb6>>
8001509a:	c2 12       	add %d2,1
8001509c:	37 02 70 20 	extr.u %d2,%d2,0,16
800150a0:	91 10 00 27 	movh.a %a2,28673
800150a4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800150a8:	f9 22 0a 10 	st.h [%a2]74 <7001004a <ram_heap+0x4fb6>>,%d2
  MIB2_STATS_INC(mib2.ipinreceives);

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
800150ac:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <7001004a <ram_heap+0x4fb6>>
800150b0:	b0 42       	add.a %a2,4
800150b2:	54 22       	ld.w %d2,[%a2]
800150b4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
  if (IPH_V(iphdr) != 4) {
800150b8:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800150bc:	14 22       	ld.bu %d2,[%a2]
800150be:	06 c2       	sh %d2,-4
800150c0:	8f f2 0f 21 	and %d2,%d2,255
800150c4:	df 42 26 00 	jeq %d2,4,80015110 <ip4_input+0x94>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
    ip4_debug_print(p);
    pbuf_free(p);
800150c8:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800150cc:	6d 00 66 27 	call 80019f98 <pbuf_free>
    IP_STATS_INC(ip.err);
800150d0:	91 10 00 27 	movh.a %a2,28673
800150d4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800150d8:	b9 22 1c 10 	ld.hu %d2,[%a2]92 <7001005c <ram_heap+0x4fc8>>
800150dc:	c2 12       	add %d2,1
800150de:	37 02 70 20 	extr.u %d2,%d2,0,16
800150e2:	91 10 00 27 	movh.a %a2,28673
800150e6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800150ea:	f9 22 1c 10 	st.h [%a2]92 <7001005c <ram_heap+0x4fc8>>,%d2
    IP_STATS_INC(ip.drop);
800150ee:	91 10 00 27 	movh.a %a2,28673
800150f2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800150f6:	b9 22 0e 10 	ld.hu %d2,[%a2]78 <7001004e <ram_heap+0x4fba>>
800150fa:	c2 12       	add %d2,1
800150fc:	37 02 70 20 	extr.u %d2,%d2,0,16
80015100:	91 10 00 27 	movh.a %a2,28673
80015104:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015108:	f9 22 0e 10 	st.h [%a2]78 <7001004e <ram_heap+0x4fba>>,%d2
    MIB2_STATS_INC(mib2.ipinhdrerrors);
    return ERR_OK;
8001510c:	82 02       	mov %d2,0
8001510e:	00 90       	ret 
    return ERR_OK;
  }
#endif

  /* obtain IP header length in bytes */
  iphdr_hlen = IPH_HL_BYTES(iphdr);
80015110:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80015114:	14 22       	ld.bu %d2,[%a2]
80015116:	8f f2 00 21 	and %d2,%d2,15
8001511a:	8f f2 0f 21 	and %d2,%d2,255
8001511e:	06 22       	sh %d2,2
80015120:	8f f2 0f 21 	and %d2,%d2,255
80015124:	f9 e2 ee ff 	st.h [%a14]-18,%d2
  /* obtain ip length in bytes */
  iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
80015128:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001512c:	39 23 02 00 	ld.bu %d3,[%a2]2
80015130:	39 22 03 00 	ld.bu %d2,[%a2]3
80015134:	8f 82 00 20 	sh %d2,%d2,8
80015138:	a6 32       	or %d2,%d3
8001513a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001513e:	02 24       	mov %d4,%d2
80015140:	6d 00 0a 12 	call 80017554 <lwip_htons>
80015144:	f9 e2 ec ff 	st.h [%a14]-20,%d2

  /* Trim pbuf. This is especially required for packets < 60 bytes. */
  if (iphdr_len < p->tot_len) {
80015148:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001514c:	b9 22 08 00 	ld.hu %d2,[%a2]8
80015150:	b9 e3 ec ff 	ld.hu %d3,[%a14]-20
80015154:	7f 23 09 80 	jge.u %d3,%d2,80015166 <ip4_input+0xea>
    pbuf_realloc(p, iphdr_len);
80015158:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
8001515c:	02 24       	mov %d4,%d2
8001515e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015162:	6d 00 cc 24 	call 80019afa <pbuf_realloc>
  }

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
80015166:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001516a:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8001516e:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80015172:	3f 23 10 80 	jlt.u %d3,%d2,80015192 <ip4_input+0x116>
80015176:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001517a:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001517e:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80015182:	3f 23 08 80 	jlt.u %d3,%d2,80015192 <ip4_input+0x116>
80015186:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
8001518a:	8b 42 a1 22 	ge.u %d2,%d2,20
8001518e:	df 02 26 80 	jne %d2,0,800151da <ip4_input+0x15e>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
                   iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
80015192:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015196:	6d 00 01 27 	call 80019f98 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
8001519a:	91 10 00 27 	movh.a %a2,28673
8001519e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800151a2:	b9 22 12 10 	ld.hu %d2,[%a2]82 <70010052 <ram_heap+0x4fbe>>
800151a6:	c2 12       	add %d2,1
800151a8:	37 02 70 20 	extr.u %d2,%d2,0,16
800151ac:	91 10 00 27 	movh.a %a2,28673
800151b0:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800151b4:	f9 22 12 10 	st.h [%a2]82 <70010052 <ram_heap+0x4fbe>>,%d2
    IP_STATS_INC(ip.drop);
800151b8:	91 10 00 27 	movh.a %a2,28673
800151bc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800151c0:	b9 22 0e 10 	ld.hu %d2,[%a2]78 <7001004e <ram_heap+0x4fba>>
800151c4:	c2 12       	add %d2,1
800151c6:	37 02 70 20 	extr.u %d2,%d2,0,16
800151ca:	91 10 00 27 	movh.a %a2,28673
800151ce:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800151d2:	f9 22 0e 10 	st.h [%a2]78 <7001004e <ram_heap+0x4fba>>,%d2
    MIB2_STATS_INC(mib2.ipindiscards);
    return ERR_OK;
800151d6:	82 02       	mov %d2,0
800151d8:	00 90       	ret 
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
    if (inet_chksum(iphdr, iphdr_hlen) != 0) {
800151da:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
800151de:	02 24       	mov %d4,%d2
800151e0:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
800151e4:	6d 00 a0 13 	call 80017924 <inet_chksum>
800151e8:	df 02 26 00 	jeq %d2,0,80015234 <ip4_input+0x1b8>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
      ip4_debug_print(p);
      pbuf_free(p);
800151ec:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800151f0:	6d 00 d4 26 	call 80019f98 <pbuf_free>
      IP_STATS_INC(ip.chkerr);
800151f4:	91 10 00 27 	movh.a %a2,28673
800151f8:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800151fc:	b9 22 10 10 	ld.hu %d2,[%a2]80 <70010050 <ram_heap+0x4fbc>>
80015200:	c2 12       	add %d2,1
80015202:	37 02 70 20 	extr.u %d2,%d2,0,16
80015206:	91 10 00 27 	movh.a %a2,28673
8001520a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001520e:	f9 22 10 10 	st.h [%a2]80 <70010050 <ram_heap+0x4fbc>>,%d2
      IP_STATS_INC(ip.drop);
80015212:	91 10 00 27 	movh.a %a2,28673
80015216:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001521a:	b9 22 0e 10 	ld.hu %d2,[%a2]78 <7001004e <ram_heap+0x4fba>>
8001521e:	c2 12       	add %d2,1
80015220:	37 02 70 20 	extr.u %d2,%d2,0,16
80015224:	91 10 00 27 	movh.a %a2,28673
80015228:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001522c:	f9 22 0e 10 	st.h [%a2]78 <7001004e <ram_heap+0x4fba>>,%d2
      MIB2_STATS_INC(mib2.ipinhdrerrors);
      return ERR_OK;
80015230:	82 02       	mov %d2,0
80015232:	00 90       	ret 
    }
  }
#endif

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
80015234:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80015238:	39 23 10 00 	ld.bu %d3,[%a2]16
8001523c:	39 22 11 00 	ld.bu %d2,[%a2]17
80015240:	8f 82 00 20 	sh %d2,%d2,8
80015244:	a6 32       	or %d2,%d3
80015246:	39 23 12 00 	ld.bu %d3,[%a2]18
8001524a:	8f 03 01 30 	sh %d3,%d3,16
8001524e:	a6 32       	or %d2,%d3
80015250:	39 23 13 00 	ld.bu %d3,[%a2]19
80015254:	8f 83 01 30 	sh %d3,%d3,24
80015258:	a6 32       	or %d2,%d3
8001525a:	91 10 00 27 	movh.a %a2,28673
8001525e:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015262:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80015266:	74 22       	st.w [%a2],%d2
  ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
80015268:	99 e2 f0 ff 	ld.a %a2,[%a14]-16 <70010014 <ram_heap+0x4f80>>
8001526c:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010014 <ram_heap+0x4f80>>
80015270:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010014 <ram_heap+0x4f80>>
80015274:	8f 82 00 20 	sh %d2,%d2,8
80015278:	a6 32       	or %d2,%d3
8001527a:	39 23 0e 00 	ld.bu %d3,[%a2]14
8001527e:	8f 03 01 30 	sh %d3,%d3,16
80015282:	a6 32       	or %d2,%d3
80015284:	39 23 0f 00 	ld.bu %d3,[%a2]15
80015288:	8f 83 01 30 	sh %d3,%d3,24
8001528c:	a6 32       	or %d2,%d3
8001528e:	91 10 00 27 	movh.a %a2,28673
80015292:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015296:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
8001529a:	74 22       	st.w [%a2],%d2

  /* match packet against an interface, i.e. is this packet for us? */
  if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
8001529c:	91 10 00 27 	movh.a %a2,28673
800152a0:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800152a4:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
800152a8:	54 22       	ld.w %d2,[%a2]
800152aa:	8f 02 0f 21 	and %d2,%d2,240
800152ae:	8b 02 2e 22 	ne %d2,%d2,224
800152b2:	df 02 1e 80 	jne %d2,0,800152ee <ip4_input+0x272>
      netif = inp;
    } else {
      netif = NULL;
    }
#else /* LWIP_IGMP */
    if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
800152b6:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
800152ba:	39 22 31 00 	ld.bu %d2,[%a2]49
800152be:	8f 12 00 21 	and %d2,%d2,1
800152c2:	8f f2 0f 21 	and %d2,%d2,255
800152c6:	df 02 0f 00 	jeq %d2,0,800152e4 <ip4_input+0x268>
800152ca:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800152ce:	60 22       	mov.a %a2,%d2
800152d0:	b0 42       	add.a %a2,4
800152d2:	54 22       	ld.w %d2,[%a2]
800152d4:	df 02 08 00 	jeq %d2,0,800152e4 <ip4_input+0x268>
      netif = inp;
800152d8:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800152dc:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800152e0:	1d 00 47 00 	j 8001536e <ip4_input+0x2f2>
    } else {
      netif = NULL;
800152e4:	82 02       	mov %d2,0
800152e6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800152ea:	1d 00 42 00 	j 8001536e <ip4_input+0x2f2>
    }
#endif /* LWIP_IGMP */
  } else {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs. */
    if (ip4_input_accept(inp)) {
800152ee:	99 e4 e0 ff 	ld.a %a4,[%a14]-32
800152f2:	6d ff 90 fe 	call 80015012 <ip4_input_accept>
800152f6:	df 02 08 00 	jeq %d2,0,80015306 <ip4_input+0x28a>
      netif = inp;
800152fa:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800152fe:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80015302:	1d 00 36 00 	j 8001536e <ip4_input+0x2f2>
    } else {
      netif = NULL;
80015306:	82 02       	mov %d2,0
80015308:	59 e2 f8 ff 	st.w [%a14]-8,%d2
#if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
      /* Packets sent to the loopback address must not be accepted on an
       * interface that does not have the loopback address assigned to it,
       * unless a non-loopback interface is used for loopback traffic. */
      if (!ip4_addr_isloopback(ip4_current_dest_addr()))
8001530c:	91 10 00 27 	movh.a %a2,28673
80015310:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015314:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80015318:	54 22       	ld.w %d2,[%a2]
8001531a:	8f f2 0f 21 	and %d2,%d2,255
8001531e:	8b f2 07 22 	eq %d2,%d2,127
80015322:	df 02 26 80 	jne %d2,0,8001536e <ip4_input+0x2f2>
#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
      {
#if !LWIP_SINGLE_NETIF
        NETIF_FOREACH(netif) {
80015326:	91 10 00 27 	movh.a %a2,28673
8001532a:	d9 22 48 34 	lea %a2,[%a2]17608 <700144c8 <netif_list>>
8001532e:	54 22       	ld.w %d2,[%a2]
80015330:	59 e2 f8 ff 	st.w [%a14]-8 <700144c8 <netif_list>>,%d2
80015334:	1d 00 16 00 	j 80015360 <ip4_input+0x2e4>
          if (netif == inp) {
80015338:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8001533c:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80015340:	5f 23 0a 00 	jeq %d3,%d2,80015354 <ip4_input+0x2d8>
            /* we checked that before already */
            continue;
          }
          if (ip4_input_accept(netif)) {
80015344:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80015348:	6d ff 65 fe 	call 80015012 <ip4_input_accept>
8001534c:	df 02 10 80 	jne %d2,0,8001536c <ip4_input+0x2f0>
80015350:	1d 00 03 00 	j 80015356 <ip4_input+0x2da>
            continue;
80015354:	00 00       	nop 
        NETIF_FOREACH(netif) {
80015356:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001535a:	54 22       	ld.w %d2,[%a2]
8001535c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80015360:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80015364:	df 02 ea ff 	jne %d2,0,80015338 <ip4_input+0x2bc>
80015368:	1d 00 03 00 	j 8001536e <ip4_input+0x2f2>
            break;
8001536c:	00 00       	nop 
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
8001536e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80015372:	df 02 27 80 	jne %d2,0,800153c0 <ip4_input+0x344>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
80015376:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001537a:	39 22 09 00 	ld.bu %d2,[%a2]9
8001537e:	8b 12 21 22 	ne %d2,%d2,17
80015382:	df 02 1f 80 	jne %d2,0,800153c0 <ip4_input+0x344>
      const struct udp_hdr *udphdr = (const struct udp_hdr *)((const u8_t *)iphdr + iphdr_hlen);
80015386:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
8001538a:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8001538e:	42 32       	add %d2,%d3
80015390:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: UDP packet to DHCP client port %"U16_F"\n",
                                              lwip_ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
80015394:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80015398:	39 23 02 00 	ld.bu %d3,[%a2]2
8001539c:	39 22 03 00 	ld.bu %d2,[%a2]3
800153a0:	8f 82 00 20 	sh %d2,%d2,8
800153a4:	a6 32       	or %d2,%d3
800153a6:	37 02 70 20 	extr.u %d2,%d2,0,16
800153aa:	3b 00 40 34 	mov %d3,17408
800153ae:	5f 32 09 80 	jne %d2,%d3,800153c0 <ip4_input+0x344>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: DHCP packet accepted.\n"));
        netif = inp;
800153b2:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800153b6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        check_ip_src = 0;
800153ba:	82 02       	mov %d2,0
800153bc:	59 e2 fc ff 	st.w [%a14]-4,%d2
  }
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING
  if (check_ip_src
800153c0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800153c4:	df 02 3b 00 	jeq %d2,0,8001543a <ip4_input+0x3be>
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
      /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
      && !ip4_addr_isany_val(*ip4_current_src_addr())
800153c8:	91 10 00 27 	movh.a %a2,28673
800153cc:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800153d0:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
800153d4:	54 22       	ld.w %d2,[%a2]
800153d6:	df 02 32 00 	jeq %d2,0,8001543a <ip4_input+0x3be>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
     )
#endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
800153da:	91 10 00 27 	movh.a %a2,28673
800153de:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800153e2:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
800153e6:	54 22       	ld.w %d2,[%a2]
800153e8:	99 e4 e0 ff 	ld.a %a4,[%a14]-32 <70010010 <ram_heap+0x4f7c>>
800153ec:	02 24       	mov %d4,%d2
800153ee:	6d 00 2f 04 	call 80015c4c <ip4_addr_isbroadcast_u32>
800153f2:	df 02 0f 80 	jne %d2,0,80015410 <ip4_input+0x394>
        (ip4_addr_ismulticast(ip4_current_src_addr()))) {
800153f6:	91 10 00 27 	movh.a %a2,28673
800153fa:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800153fe:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80015402:	54 22       	ld.w %d2,[%a2]
80015404:	8f 02 0f 21 	and %d2,%d2,240
    if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
80015408:	8b 02 2e 22 	ne %d2,%d2,224
8001540c:	df 02 17 80 	jne %d2,0,8001543a <ip4_input+0x3be>
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
80015410:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015414:	6d 00 c2 25 	call 80019f98 <pbuf_free>
      IP_STATS_INC(ip.drop);
80015418:	91 10 00 27 	movh.a %a2,28673
8001541c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015420:	b9 22 0e 10 	ld.hu %d2,[%a2]78 <7001004e <ram_heap+0x4fba>>
80015424:	c2 12       	add %d2,1
80015426:	37 02 70 20 	extr.u %d2,%d2,0,16
8001542a:	91 10 00 27 	movh.a %a2,28673
8001542e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015432:	f9 22 0e 10 	st.h [%a2]78 <7001004e <ram_heap+0x4fba>>,%d2
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
      return ERR_OK;
80015436:	82 02       	mov %d2,0
80015438:	00 90       	ret 
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
8001543a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001543e:	df 02 17 80 	jne %d2,0,8001546c <ip4_input+0x3f0>
      /* try to forward IP packet on (other) interfaces */
      ip4_forward(p, (struct ip_hdr *)p->payload, inp);
    } else
#endif /* IP_FORWARD */
    {
      IP_STATS_INC(ip.drop);
80015442:	91 10 00 27 	movh.a %a2,28673
80015446:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001544a:	b9 22 0e 10 	ld.hu %d2,[%a2]78 <7001004e <ram_heap+0x4fba>>
8001544e:	c2 12       	add %d2,1
80015450:	37 02 70 20 	extr.u %d2,%d2,0,16
80015454:	91 10 00 27 	movh.a %a2,28673
80015458:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001545c:	f9 22 0e 10 	st.h [%a2]78 <7001004e <ram_heap+0x4fba>>,%d2
      MIB2_STATS_INC(mib2.ipinaddrerrors);
      MIB2_STATS_INC(mib2.ipindiscards);
    }
    pbuf_free(p);
80015460:	99 e4 e4 ff 	ld.a %a4,[%a14]-28 <7001004e <ram_heap+0x4fba>>
80015464:	6d 00 9a 25 	call 80019f98 <pbuf_free>
    return ERR_OK;
80015468:	82 02       	mov %d2,0
8001546a:	00 90       	ret 
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
8001546c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80015470:	39 23 06 00 	ld.bu %d3,[%a2]6
80015474:	39 22 07 00 	ld.bu %d2,[%a2]7
80015478:	8f 82 00 20 	sh %d2,%d2,8
8001547c:	a6 32       	or %d2,%d3
8001547e:	37 02 70 20 	extr.u %d2,%d2,0,16
80015482:	02 23       	mov %d3,%d2
80015484:	bb f0 f3 2f 	mov.u %d2,65343
80015488:	26 32       	and %d2,%d3
8001548a:	df 02 14 00 	jeq %d2,0,800154b2 <ip4_input+0x436>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip4_reass()\n",
                           lwip_ntohs(IPH_ID(iphdr)), p->tot_len, lwip_ntohs(IPH_LEN(iphdr)), (u16_t)!!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (u16_t)((lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK) * 8)));
    /* reassemble the packet*/
    p = ip4_reass(p);
8001548e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015492:	6d 00 96 0a 	call 800169be <ip4_reass>
80015496:	b5 e2 e4 ff 	st.a [%a14]-28,%a2
    /* packet not fully reassembled yet? */
    if (p == NULL) {
8001549a:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8001549e:	df 02 04 80 	jne %d2,0,800154a6 <ip4_input+0x42a>
      return ERR_OK;
800154a2:	82 02       	mov %d2,0
800154a4:	00 90       	ret 
    }
    iphdr = (const struct ip_hdr *)p->payload;
800154a6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800154aa:	b0 42       	add.a %a2,4
800154ac:	54 22       	ld.w %d2,[%a2]
800154ae:	59 e2 f0 ff 	st.w [%a14]-16,%d2
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
  ip4_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  ip_data.current_netif = netif;
800154b2:	91 10 00 27 	movh.a %a2,28673
800154b6:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800154ba:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <7000b07c <ip_data>>
800154be:	74 22       	st.w [%a2],%d2
  ip_data.current_input_netif = inp;
800154c0:	91 10 00 27 	movh.a %a2,28673
800154c4:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800154c8:	19 e2 e0 ff 	ld.w %d2,[%a14]-32 <7000b07c <ip_data>>
800154cc:	b0 42       	add.a %a2,4
800154ce:	74 22       	st.w [%a2],%d2
  ip_data.current_ip4_header = iphdr;
800154d0:	91 10 00 27 	movh.a %a2,28673
800154d4:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800154d8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16 <7000b07c <ip_data>>
800154dc:	d9 22 08 00 	lea %a2,[%a2]8 <70010008 <ram_heap+0x4f74>>
800154e0:	74 22       	st.w [%a2],%d2
  ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
800154e2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16 <70010008 <ram_heap+0x4f74>>
800154e6:	14 22       	ld.bu %d2,[%a2]
800154e8:	8f f2 00 21 	and %d2,%d2,15
800154ec:	8f f2 0f 21 	and %d2,%d2,255
800154f0:	06 22       	sh %d2,2
800154f2:	8f f2 0f 21 	and %d2,%d2,255
800154f6:	37 02 70 20 	extr.u %d2,%d2,0,16
800154fa:	91 10 00 27 	movh.a %a2,28673
800154fe:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015502:	f9 22 0c 00 	st.h [%a2]12 <7001000c <ram_heap+0x4f78>>,%d2
  /* raw input did not eat the packet? */
  raw_status = raw_input(p, inp);
  if (raw_status != RAW_INPUT_EATEN)
#endif /* LWIP_RAW */
  {
    pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
80015506:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18 <7001000c <ram_heap+0x4f78>>
8001550a:	02 24       	mov %d4,%d2
8001550c:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015510:	6d 00 7e 24 	call 80019e0c <pbuf_remove_header>

    switch (IPH_PROTO(iphdr)) {
80015514:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80015518:	39 22 09 00 	ld.bu %d2,[%a2]9
8001551c:	8b 12 01 32 	eq %d3,%d2,17
80015520:	df 03 0c 80 	jne %d3,0,80015538 <ip4_input+0x4bc>
80015524:	8b 22 81 32 	ge %d3,%d2,18
80015528:	df 03 20 80 	jne %d3,0,80015568 <ip4_input+0x4ec>
8001552c:	df 12 16 00 	jeq %d2,1,80015558 <ip4_input+0x4dc>
80015530:	df 62 0c 00 	jeq %d2,6,80015548 <ip4_input+0x4cc>
80015534:	1d 00 1a 00 	j 80015568 <ip4_input+0x4ec>
      case IP_PROTO_UDP:
#if LWIP_UDPLITE
      case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
        MIB2_STATS_INC(mib2.ipindelivers);
        udp_input(p, inp);
80015538:	99 e5 e0 ff 	ld.a %a5,[%a14]-32
8001553c:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015540:	6d 00 b5 7e 	call 800252aa <udp_input>
        break;
80015544:	1d 00 5c 00 	j 800155fc <ip4_input+0x580>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case IP_PROTO_TCP:
        MIB2_STATS_INC(mib2.ipindelivers);
        tcp_input(p, inp);
80015548:	99 e5 e0 ff 	ld.a %a5,[%a14]-32
8001554c:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015550:	6d 00 10 3f 	call 8001d370 <tcp_input>
        break;
80015554:	1d 00 54 00 	j 800155fc <ip4_input+0x580>
#endif /* LWIP_TCP */
#if LWIP_ICMP
      case IP_PROTO_ICMP:
        MIB2_STATS_INC(mib2.ipindelivers);
        icmp_input(p, inp);
80015558:	99 e5 e0 ff 	ld.a %a5,[%a14]-32
8001555c:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015560:	6d ff 31 f9 	call 800147c2 <icmp_input>
        break;
80015564:	1d 00 4c 00 	j 800155fc <ip4_input+0x580>
        } else
#endif /* LWIP_RAW */
        {
#if LWIP_ICMP
          /* send ICMP destination protocol unreachable unless is was a broadcast */
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
80015568:	91 10 00 27 	movh.a %a2,28673
8001556c:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015570:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80015574:	54 22       	ld.w %d2,[%a2]
80015576:	99 e4 f8 ff 	ld.a %a4,[%a14]-8 <70010014 <ram_heap+0x4f80>>
8001557a:	02 24       	mov %d4,%d2
8001557c:	6d 00 68 03 	call 80015c4c <ip4_addr_isbroadcast_u32>
80015580:	df 02 1b 80 	jne %d2,0,800155b6 <ip4_input+0x53a>
              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
80015584:	91 10 00 27 	movh.a %a2,28673
80015588:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001558c:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80015590:	54 22       	ld.w %d2,[%a2]
80015592:	8f 02 0f 21 	and %d2,%d2,240
          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
80015596:	8b 02 0e 22 	eq %d2,%d2,224
8001559a:	df 02 0e 80 	jne %d2,0,800155b6 <ip4_input+0x53a>
            pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
8001559e:	c9 e2 ee ff 	ld.h %d2,[%a14]-18
800155a2:	02 24       	mov %d4,%d2
800155a4:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800155a8:	6d 00 e8 24 	call 80019f78 <pbuf_header_force>
            icmp_dest_unreach(p, ICMP_DUR_PROTO);
800155ac:	82 24       	mov %d4,2
800155ae:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800155b2:	6d ff 93 fb 	call 80014cd8 <icmp_dest_unreach>
          }
#endif /* LWIP_ICMP */

          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", (u16_t)IPH_PROTO(iphdr)));

          IP_STATS_INC(ip.proterr);
800155b6:	91 10 00 27 	movh.a %a2,28673
800155ba:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800155be:	b9 22 18 10 	ld.hu %d2,[%a2]88 <70010058 <ram_heap+0x4fc4>>
800155c2:	c2 12       	add %d2,1
800155c4:	37 02 70 20 	extr.u %d2,%d2,0,16
800155c8:	91 10 00 27 	movh.a %a2,28673
800155cc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800155d0:	f9 22 18 10 	st.h [%a2]88 <70010058 <ram_heap+0x4fc4>>,%d2
          IP_STATS_INC(ip.drop);
800155d4:	91 10 00 27 	movh.a %a2,28673
800155d8:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800155dc:	b9 22 0e 10 	ld.hu %d2,[%a2]78 <7001004e <ram_heap+0x4fba>>
800155e0:	c2 12       	add %d2,1
800155e2:	37 02 70 20 	extr.u %d2,%d2,0,16
800155e6:	91 10 00 27 	movh.a %a2,28673
800155ea:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800155ee:	f9 22 0e 10 	st.h [%a2]78 <7001004e <ram_heap+0x4fba>>,%d2
          MIB2_STATS_INC(mib2.ipinunknownprotos);
        }
        pbuf_free(p);
800155f2:	99 e4 e4 ff 	ld.a %a4,[%a14]-28 <7001004e <ram_heap+0x4fba>>
800155f6:	6d 00 d1 24 	call 80019f98 <pbuf_free>
        break;
800155fa:	00 00       	nop 
    }
  }

  /* @todo: this is not really necessary... */
  ip_data.current_netif = NULL;
800155fc:	91 10 00 27 	movh.a %a2,28673
80015600:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015604:	82 02       	mov %d2,0
80015606:	74 22       	st.w [%a2],%d2
  ip_data.current_input_netif = NULL;
80015608:	91 10 00 27 	movh.a %a2,28673
8001560c:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80015610:	82 02       	mov %d2,0
80015612:	b0 42       	add.a %a2,4
80015614:	74 22       	st.w [%a2],%d2
  ip_data.current_ip4_header = NULL;
80015616:	91 10 00 27 	movh.a %a2,28673
8001561a:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001561e:	82 02       	mov %d2,0
80015620:	d9 22 08 00 	lea %a2,[%a2]8 <70010008 <ram_heap+0x4f74>>
80015624:	74 22       	st.w [%a2],%d2
  ip_data.current_ip_header_tot_len = 0;
80015626:	91 10 00 27 	movh.a %a2,28673
8001562a:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001562e:	82 02       	mov %d2,0
80015630:	f9 22 0c 00 	st.h [%a2]12 <7001000c <ram_heap+0x4f78>>,%d2
  ip4_addr_set_any(ip4_current_src_addr());
80015634:	91 10 00 27 	movh.a %a2,28673
80015638:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001563c:	82 02       	mov %d2,0
8001563e:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80015642:	74 22       	st.w [%a2],%d2
  ip4_addr_set_any(ip4_current_dest_addr());
80015644:	91 10 00 27 	movh.a %a2,28673
80015648:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001564c:	82 02       	mov %d2,0
8001564e:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80015652:	74 22       	st.w [%a2],%d2

  return ERR_OK;
80015654:	82 02       	mov %d2,0
}
80015656:	00 90       	ret 

80015658 <ip4_output_if>:
 */
err_t
ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
              u8_t ttl, u8_t tos,
              u8_t proto, struct netif *netif)
{
80015658:	40 ae       	mov.aa %a14,%sp
8001565a:	20 28       	sub.a %sp,40
8001565c:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80015660:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
80015664:	b5 e6 ec ff 	st.a [%a14]-20,%a6
80015668:	02 42       	mov %d2,%d4
8001566a:	02 54       	mov %d4,%d5
8001566c:	02 63       	mov %d3,%d6
8001566e:	b5 e7 dc ff 	st.a [%a14]-36,%a7
80015672:	e9 e2 e8 ff 	st.b [%a14]-24,%d2
80015676:	02 42       	mov %d2,%d4
80015678:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
8001567c:	02 32       	mov %d2,%d3
8001567e:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
                  u16_t optlen)
{
#endif /* IP_OPTIONS_SEND */
  const ip4_addr_t *src_used = src;
80015682:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80015686:	59 e2 fc ff 	st.w [%a14]-4,%d2
  if (dest != LWIP_IP_HDRINCL) {
8001568a:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001568e:	df 02 10 00 	jeq %d2,0,800156ae <ip4_output_if+0x56>
    if (ip4_addr_isany(src)) {
80015692:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80015696:	df 02 07 00 	jeq %d2,0,800156a4 <ip4_output_if+0x4c>
8001569a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001569e:	54 22       	ld.w %d2,[%a2]
800156a0:	df 02 07 80 	jne %d2,0,800156ae <ip4_output_if+0x56>
      src_used = netif_ip4_addr(netif);
800156a4:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800156a8:	c2 42       	add %d2,4
800156aa:	59 e2 fc ff 	st.w [%a14]-4,%d2

#if IP_OPTIONS_SEND
  return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
                               ip_options, optlen);
#else /* IP_OPTIONS_SEND */
  return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
800156ae:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
800156b2:	39 e3 e4 ff 	ld.bu %d3,[%a14]-28
800156b6:	39 e4 e0 ff 	ld.bu %d4,[%a14]-32
800156ba:	99 e7 dc ff 	ld.a %a7,[%a14]-36
800156be:	02 46       	mov %d6,%d4
800156c0:	02 35       	mov %d5,%d3
800156c2:	02 24       	mov %d4,%d2
800156c4:	99 e6 ec ff 	ld.a %a6,[%a14]-20
800156c8:	99 e5 fc ff 	ld.a %a5,[%a14]-4
800156cc:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800156d0:	6d 00 03 00 	call 800156d6 <ip4_output_if_src>
#endif /* IP_OPTIONS_SEND */
}
800156d4:	00 90       	ret 

800156d6 <ip4_output_if_src>:
 */
err_t
ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
                  u8_t ttl, u8_t tos,
                  u8_t proto, struct netif *netif)
{
800156d6:	40 ae       	mov.aa %a14,%sp
800156d8:	20 40       	sub.a %sp,64
800156da:	b5 e4 ec ff 	st.a [%a14]-20,%a4
800156de:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
800156e2:	b5 e6 e4 ff 	st.a [%a14]-28,%a6
800156e6:	02 42       	mov %d2,%d4
800156e8:	02 54       	mov %d4,%d5
800156ea:	02 63       	mov %d3,%d6
800156ec:	b5 e7 d4 ff 	st.a [%a14]-44,%a7
800156f0:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
800156f4:	02 42       	mov %d2,%d4
800156f6:	e9 e2 dc ff 	st.b [%a14]-36,%d2
800156fa:	02 32       	mov %d2,%d3
800156fc:	e9 e2 d8 ff 	st.b [%a14]-40,%d2
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip4_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
80015700:	82 02       	mov %d2,0
80015702:	59 e2 fc ff 	st.w [%a14]-4,%d2
#endif /* CHECKSUM_GEN_IP_INLINE */

  LWIP_ASSERT_CORE_LOCKED();
  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
80015706:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001570a:	39 22 0e 00 	ld.bu %d2,[%a2]14
8001570e:	df 12 17 00 	jeq %d2,1,8001573c <ip4_output_if_src+0x66>
80015712:	91 00 00 28 	movh.a %a2,32768
80015716:	d9 22 15 31 	lea %a2,[%a2]4309 <800010d5 <IfxCpu_Trap_vectorTable0_end+0xee1>>
8001571a:	b5 a2 08 00 	st.a [%sp]8 <800010d5 <IfxCpu_Trap_vectorTable0_end+0xee1>>,%a2
8001571e:	3b 40 35 20 	mov %d2,852
80015722:	59 a2 04 00 	st.w [%sp]4,%d2
80015726:	91 00 00 28 	movh.a %a2,32768
8001572a:	d9 22 04 41 	lea %a2,[%a2]4356 <80001104 <IfxCpu_Trap_vectorTable0_end+0xf10>>
8001572e:	f4 a2       	st.a [%sp],%a2
80015730:	91 00 00 28 	movh.a %a2,32768
80015734:	d9 24 2d 21 	lea %a4,[%a2]4269 <800010ad <IfxCpu_Trap_vectorTable0_end+0xeb9>>
80015738:	6d ff ff 7d 	call 80005336 <Ifx_Lwip_printf>

  MIB2_STATS_INC(mib2.ipoutrequests);

  /* Should the IP header be generated or is it already included in p? */
  if (dest != LWIP_IP_HDRINCL) {
8001573c:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80015740:	df 02 18 02 	jeq %d2,0,80015b70 <ip4_output_if_src+0x49a>
    u16_t ip_hlen = IP_HLEN;
80015744:	3b 40 01 20 	mov %d2,20
80015748:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_add_header(p, IP_HLEN)) {
8001574c:	3b 40 01 40 	mov %d4,20
80015750:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80015754:	6d 00 4e 23 	call 80019df0 <pbuf_add_header>
80015758:	df 02 13 00 	jeq %d2,0,8001577e <ip4_output_if_src+0xa8>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
8001575c:	91 10 00 27 	movh.a %a2,28673
80015760:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015764:	b9 22 1c 10 	ld.hu %d2,[%a2]92 <7001005c <ram_heap+0x4fc8>>
80015768:	c2 12       	add %d2,1
8001576a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001576e:	91 10 00 27 	movh.a %a2,28673
80015772:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015776:	f9 22 1c 10 	st.h [%a2]92 <7001005c <ram_heap+0x4fc8>>,%d2
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
8001577a:	82 e2       	mov %d2,-2
8001577c:	00 90       	ret 
    }

    iphdr = (struct ip_hdr *)p->payload;
8001577e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80015782:	b0 42       	add.a %a2,4
80015784:	54 22       	ld.w %d2,[%a2]
80015786:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
8001578a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001578e:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80015792:	8b 42 a1 22 	ge.u %d2,%d2,20
80015796:	df 02 17 80 	jne %d2,0,800157c4 <ip4_output_if_src+0xee>
8001579a:	91 00 00 28 	movh.a %a2,32768
8001579e:	d9 22 15 31 	lea %a2,[%a2]4309 <800010d5 <IfxCpu_Trap_vectorTable0_end+0xee1>>
800157a2:	b5 a2 08 00 	st.a [%sp]8 <800010d5 <IfxCpu_Trap_vectorTable0_end+0xee1>>,%a2
800157a6:	3b 80 38 20 	mov %d2,904
800157aa:	59 a2 04 00 	st.w [%sp]4,%d2
800157ae:	91 00 00 28 	movh.a %a2,32768
800157b2:	d9 22 10 41 	lea %a2,[%a2]4368 <80001110 <IfxCpu_Trap_vectorTable0_end+0xf1c>>
800157b6:	f4 a2       	st.a [%sp],%a2
800157b8:	91 00 00 28 	movh.a %a2,32768
800157bc:	d9 24 2d 21 	lea %a4,[%a2]4269 <800010ad <IfxCpu_Trap_vectorTable0_end+0xeb9>>
800157c0:	6d ff bb 7d 	call 80005336 <Ifx_Lwip_printf>
                (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
800157c4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800157c8:	79 e2 e0 ff 	ld.b %d2,[%a14]-32
800157cc:	e9 22 08 00 	st.b [%a2]8,%d2
    IPH_PROTO_SET(iphdr, proto);
800157d0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800157d4:	79 e2 d8 ff 	ld.b %d2,[%a14]-40
800157d8:	e9 22 09 00 	st.b [%a2]9,%d2
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(proto | (ttl << 8));
800157dc:	39 e3 d8 ff 	ld.bu %d3,[%a14]-40
800157e0:	39 e2 e0 ff 	ld.bu %d2,[%a14]-32
800157e4:	8f 82 00 20 	sh %d2,%d2,8
800157e8:	a6 32       	or %d2,%d3
800157ea:	8f 82 00 20 	sh %d2,%d2,8
800157ee:	37 02 50 30 	extr %d3,%d2,0,16
800157f2:	39 e4 d8 ff 	ld.bu %d4,[%a14]-40
800157f6:	39 e2 e0 ff 	ld.bu %d2,[%a14]-32
800157fa:	8f 82 00 20 	sh %d2,%d2,8
800157fe:	a6 42       	or %d2,%d4
80015800:	86 82       	sha %d2,-8
80015802:	37 02 50 20 	extr %d2,%d2,0,16
80015806:	8f f2 0f 21 	and %d2,%d2,255
8001580a:	37 02 50 20 	extr %d2,%d2,0,16
8001580e:	a6 32       	or %d2,%d3
80015810:	37 02 50 20 	extr %d2,%d2,0,16
80015814:	37 02 70 20 	extr.u %d2,%d2,0,16
80015818:	02 23       	mov %d3,%d2
8001581a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001581e:	42 32       	add %d2,%d3
80015820:	59 e2 fc ff 	st.w [%a14]-4,%d2
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip4_addr_copy(iphdr->dest, *dest);
80015824:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80015828:	54 22       	ld.w %d2,[%a2]
8001582a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001582e:	8f f2 0f 31 	and %d3,%d2,255
80015832:	82 04       	mov %d4,0
80015834:	a6 43       	or %d3,%d4
80015836:	e9 23 10 00 	st.b [%a2]16,%d3
8001583a:	8f 82 1f 30 	sh %d3,%d2,-8
8001583e:	8f f3 0f 31 	and %d3,%d3,255
80015842:	82 04       	mov %d4,0
80015844:	a6 43       	or %d3,%d4
80015846:	e9 23 11 00 	st.b [%a2]17,%d3
8001584a:	8f 02 1f 30 	sh %d3,%d2,-16
8001584e:	8f f3 0f 31 	and %d3,%d3,255
80015852:	82 04       	mov %d4,0
80015854:	a6 43       	or %d3,%d4
80015856:	e9 23 12 00 	st.b [%a2]18,%d3
8001585a:	8f 82 1e 20 	sh %d2,%d2,-24
8001585e:	82 03       	mov %d3,0
80015860:	a6 32       	or %d2,%d3
80015862:	e9 22 13 00 	st.b [%a2]19,%d2
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
80015866:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001586a:	39 23 10 00 	ld.bu %d3,[%a2]16
8001586e:	39 22 11 00 	ld.bu %d2,[%a2]17
80015872:	8f 82 00 20 	sh %d2,%d2,8
80015876:	a6 32       	or %d2,%d3
80015878:	39 23 12 00 	ld.bu %d3,[%a2]18
8001587c:	8f 03 01 30 	sh %d3,%d3,16
80015880:	a6 32       	or %d2,%d3
80015882:	39 23 13 00 	ld.bu %d3,[%a2]19
80015886:	8f 83 01 30 	sh %d3,%d3,24
8001588a:	a6 32       	or %d2,%d3
8001588c:	02 23       	mov %d3,%d2
8001588e:	bb f0 ff 2f 	mov.u %d2,65535
80015892:	26 32       	and %d2,%d3
80015894:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80015898:	42 32       	add %d2,%d3
8001589a:	59 e2 fc ff 	st.w [%a14]-4,%d2
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
8001589e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800158a2:	39 23 10 00 	ld.bu %d3,[%a2]16
800158a6:	39 22 11 00 	ld.bu %d2,[%a2]17
800158aa:	8f 82 00 20 	sh %d2,%d2,8
800158ae:	a6 32       	or %d2,%d3
800158b0:	39 23 12 00 	ld.bu %d3,[%a2]18
800158b4:	8f 03 01 30 	sh %d3,%d3,16
800158b8:	a6 32       	or %d2,%d3
800158ba:	39 23 13 00 	ld.bu %d3,[%a2]19
800158be:	8f 83 01 30 	sh %d3,%d3,24
800158c2:	a6 32       	or %d2,%d3
800158c4:	8f 02 1f 20 	sh %d2,%d2,-16
800158c8:	19 e3 fc ff 	ld.w %d3,[%a14]-4
800158cc:	42 32       	add %d2,%d3
800158ce:	59 e2 fc ff 	st.w [%a14]-4,%d2
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
800158d2:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10
800158d6:	06 e2       	sh %d2,-2
800158d8:	37 02 70 20 	extr.u %d2,%d2,0,16
800158dc:	8f f2 0f 21 	and %d2,%d2,255
800158e0:	8f 02 44 21 	or %d2,%d2,64
800158e4:	8f f2 0f 21 	and %d2,%d2,255
800158e8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800158ec:	34 22       	st.b [%a2],%d2
    IPH_TOS_SET(iphdr, tos);
800158ee:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800158f2:	79 e2 dc ff 	ld.b %d2,[%a14]-36
800158f6:	e9 22 01 00 	st.b [%a2]1,%d2
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
800158fa:	39 e3 dc ff 	ld.bu %d3,[%a14]-36
800158fe:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015902:	14 22       	ld.bu %d2,[%a2]
80015904:	8f 82 00 20 	sh %d2,%d2,8
80015908:	a6 32       	or %d2,%d3
8001590a:	8f 82 00 20 	sh %d2,%d2,8
8001590e:	37 02 50 30 	extr %d3,%d2,0,16
80015912:	39 e4 dc ff 	ld.bu %d4,[%a14]-36
80015916:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001591a:	14 22       	ld.bu %d2,[%a2]
8001591c:	8f 82 00 20 	sh %d2,%d2,8
80015920:	a6 42       	or %d2,%d4
80015922:	86 82       	sha %d2,-8
80015924:	37 02 50 20 	extr %d2,%d2,0,16
80015928:	8f f2 0f 21 	and %d2,%d2,255
8001592c:	37 02 50 20 	extr %d2,%d2,0,16
80015930:	a6 32       	or %d2,%d3
80015932:	37 02 50 20 	extr %d2,%d2,0,16
80015936:	37 02 70 20 	extr.u %d2,%d2,0,16
8001593a:	02 23       	mov %d3,%d2
8001593c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015940:	42 32       	add %d2,%d3
80015942:	59 e2 fc ff 	st.w [%a14]-4,%d2
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
80015946:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001594a:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001594e:	02 24       	mov %d4,%d2
80015950:	6d 00 02 0e 	call 80017554 <lwip_htons>
80015954:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015958:	8f f2 0f 31 	and %d3,%d2,255
8001595c:	82 04       	mov %d4,0
8001595e:	a6 43       	or %d3,%d4
80015960:	e9 23 02 00 	st.b [%a2]2,%d3
80015964:	06 82       	sh %d2,-8
80015966:	37 02 70 20 	extr.u %d2,%d2,0,16
8001596a:	82 03       	mov %d3,0
8001596c:	a6 32       	or %d2,%d3
8001596e:	e9 22 03 00 	st.b [%a2]3,%d2
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
80015972:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015976:	39 23 02 00 	ld.bu %d3,[%a2]2
8001597a:	39 22 03 00 	ld.bu %d2,[%a2]3
8001597e:	8f 82 00 20 	sh %d2,%d2,8
80015982:	a6 32       	or %d2,%d3
80015984:	37 02 70 20 	extr.u %d2,%d2,0,16
80015988:	02 23       	mov %d3,%d2
8001598a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001598e:	42 32       	add %d2,%d3
80015990:	59 e2 fc ff 	st.w [%a14]-4,%d2
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
80015994:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015998:	82 02       	mov %d2,0
8001599a:	e9 22 06 00 	st.b [%a2]6,%d2
8001599e:	82 02       	mov %d2,0
800159a0:	e9 22 07 00 	st.b [%a2]7,%d2
    IPH_ID_SET(iphdr, lwip_htons(ip_id));
800159a4:	91 10 00 27 	movh.a %a2,28673
800159a8:	d9 22 32 1b 	lea %a2,[%a2]-20366 <7000b072 <ip_id>>
800159ac:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
800159b0:	02 24       	mov %d4,%d2
800159b2:	6d 00 d1 0d 	call 80017554 <lwip_htons>
800159b6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800159ba:	8f f2 0f 31 	and %d3,%d2,255
800159be:	82 04       	mov %d4,0
800159c0:	a6 43       	or %d3,%d4
800159c2:	e9 23 04 00 	st.b [%a2]4,%d3
800159c6:	06 82       	sh %d2,-8
800159c8:	37 02 70 20 	extr.u %d2,%d2,0,16
800159cc:	82 03       	mov %d3,0
800159ce:	a6 32       	or %d2,%d3
800159d0:	e9 22 05 00 	st.b [%a2]5,%d2
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
800159d4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800159d8:	39 23 04 00 	ld.bu %d3,[%a2]4
800159dc:	39 22 05 00 	ld.bu %d2,[%a2]5
800159e0:	8f 82 00 20 	sh %d2,%d2,8
800159e4:	a6 32       	or %d2,%d3
800159e6:	37 02 70 20 	extr.u %d2,%d2,0,16
800159ea:	02 23       	mov %d3,%d2
800159ec:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800159f0:	42 32       	add %d2,%d3
800159f2:	59 e2 fc ff 	st.w [%a14]-4,%d2
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
800159f6:	91 10 00 27 	movh.a %a2,28673
800159fa:	d9 22 32 1b 	lea %a2,[%a2]-20366 <7000b072 <ip_id>>
800159fe:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80015a02:	c2 12       	add %d2,1
80015a04:	37 02 70 20 	extr.u %d2,%d2,0,16
80015a08:	91 10 00 27 	movh.a %a2,28673
80015a0c:	d9 22 32 1b 	lea %a2,[%a2]-20366 <7000b072 <ip_id>>
80015a10:	b4 22       	st.h [%a2],%d2

    if (src == NULL) {
80015a12:	19 e2 e8 ff 	ld.w %d2,[%a14]-24 <7000b072 <ip_id>>
80015a16:	df 02 27 80 	jne %d2,0,80015a64 <ip4_output_if_src+0x38e>
      ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
80015a1a:	91 00 00 28 	movh.a %a2,32768
80015a1e:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80015a22:	54 22       	ld.w %d2,[%a2]
80015a24:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <8000451c <ip_addr_any>>
80015a28:	8f f2 0f 31 	and %d3,%d2,255
80015a2c:	82 04       	mov %d4,0
80015a2e:	a6 43       	or %d3,%d4
80015a30:	e9 23 0c 00 	st.b [%a2]12,%d3
80015a34:	8f 82 1f 30 	sh %d3,%d2,-8
80015a38:	8f f3 0f 31 	and %d3,%d3,255
80015a3c:	82 04       	mov %d4,0
80015a3e:	a6 43       	or %d3,%d4
80015a40:	e9 23 0d 00 	st.b [%a2]13,%d3
80015a44:	8f 02 1f 30 	sh %d3,%d2,-16
80015a48:	8f f3 0f 31 	and %d3,%d3,255
80015a4c:	82 04       	mov %d4,0
80015a4e:	a6 43       	or %d3,%d4
80015a50:	e9 23 0e 00 	st.b [%a2]14,%d3
80015a54:	8f 82 1e 20 	sh %d2,%d2,-24
80015a58:	82 03       	mov %d3,0
80015a5a:	a6 32       	or %d2,%d3
80015a5c:	e9 22 0f 00 	st.b [%a2]15,%d2
80015a60:	1d 00 23 00 	j 80015aa6 <ip4_output_if_src+0x3d0>
    } else {
      /* src cannot be NULL here */
      ip4_addr_copy(iphdr->src, *src);
80015a64:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80015a68:	54 22       	ld.w %d2,[%a2]
80015a6a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015a6e:	8f f2 0f 31 	and %d3,%d2,255
80015a72:	82 04       	mov %d4,0
80015a74:	a6 43       	or %d3,%d4
80015a76:	e9 23 0c 00 	st.b [%a2]12,%d3
80015a7a:	8f 82 1f 30 	sh %d3,%d2,-8
80015a7e:	8f f3 0f 31 	and %d3,%d3,255
80015a82:	82 04       	mov %d4,0
80015a84:	a6 43       	or %d3,%d4
80015a86:	e9 23 0d 00 	st.b [%a2]13,%d3
80015a8a:	8f 02 1f 30 	sh %d3,%d2,-16
80015a8e:	8f f3 0f 31 	and %d3,%d3,255
80015a92:	82 04       	mov %d4,0
80015a94:	a6 43       	or %d3,%d4
80015a96:	e9 23 0e 00 	st.b [%a2]14,%d3
80015a9a:	8f 82 1e 20 	sh %d2,%d2,-24
80015a9e:	82 03       	mov %d3,0
80015aa0:	a6 32       	or %d2,%d3
80015aa2:	e9 22 0f 00 	st.b [%a2]15,%d2
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
80015aa6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015aaa:	39 23 0c 00 	ld.bu %d3,[%a2]12
80015aae:	39 22 0d 00 	ld.bu %d2,[%a2]13
80015ab2:	8f 82 00 20 	sh %d2,%d2,8
80015ab6:	a6 32       	or %d2,%d3
80015ab8:	39 23 0e 00 	ld.bu %d3,[%a2]14
80015abc:	8f 03 01 30 	sh %d3,%d3,16
80015ac0:	a6 32       	or %d2,%d3
80015ac2:	39 23 0f 00 	ld.bu %d3,[%a2]15
80015ac6:	8f 83 01 30 	sh %d3,%d3,24
80015aca:	a6 32       	or %d2,%d3
80015acc:	02 23       	mov %d3,%d2
80015ace:	bb f0 ff 2f 	mov.u %d2,65535
80015ad2:	26 32       	and %d2,%d3
80015ad4:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80015ad8:	42 32       	add %d2,%d3
80015ada:	59 e2 fc ff 	st.w [%a14]-4,%d2
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
80015ade:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015ae2:	39 23 0c 00 	ld.bu %d3,[%a2]12
80015ae6:	39 22 0d 00 	ld.bu %d2,[%a2]13
80015aea:	8f 82 00 20 	sh %d2,%d2,8
80015aee:	a6 32       	or %d2,%d3
80015af0:	39 23 0e 00 	ld.bu %d3,[%a2]14
80015af4:	8f 03 01 30 	sh %d3,%d3,16
80015af8:	a6 32       	or %d2,%d3
80015afa:	39 23 0f 00 	ld.bu %d3,[%a2]15
80015afe:	8f 83 01 30 	sh %d3,%d3,24
80015b02:	a6 32       	or %d2,%d3
80015b04:	8f 02 1f 20 	sh %d2,%d2,-16
80015b08:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80015b0c:	42 32       	add %d2,%d3
80015b0e:	59 e2 fc ff 	st.w [%a14]-4,%d2
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
80015b12:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015b16:	8f 02 1f 30 	sh %d3,%d2,-16
80015b1a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015b1e:	bb f0 ff 4f 	mov.u %d4,65535
80015b22:	26 42       	and %d2,%d4
80015b24:	42 32       	add %d2,%d3
80015b26:	59 e2 fc ff 	st.w [%a14]-4,%d2
    chk_sum = (chk_sum >> 16) + chk_sum;
80015b2a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015b2e:	8f 02 1f 20 	sh %d2,%d2,-16
80015b32:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80015b36:	42 32       	add %d2,%d3
80015b38:	59 e2 fc ff 	st.w [%a14]-4,%d2
    chk_sum = ~chk_sum;
80015b3c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015b40:	46 02       	not %d2
80015b42:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      iphdr->_chksum = (u16_t)chk_sum; /* network order */
80015b46:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015b4a:	37 02 70 20 	extr.u %d2,%d2,0,16
80015b4e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015b52:	8f f2 0f 31 	and %d3,%d2,255
80015b56:	82 04       	mov %d4,0
80015b58:	a6 43       	or %d3,%d4
80015b5a:	e9 23 0a 00 	st.b [%a2]10,%d3
80015b5e:	06 82       	sh %d2,-8
80015b60:	37 02 70 20 	extr.u %d2,%d2,0,16
80015b64:	82 03       	mov %d3,0
80015b66:	a6 32       	or %d2,%d3
80015b68:	e9 22 0b 00 	st.b [%a2]11,%d2
80015b6c:	1d 00 3a 00 	j 80015be0 <ip4_output_if_src+0x50a>
    }
#endif /* CHECKSUM_GEN_IP */
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    if (p->len < IP_HLEN) {
80015b70:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80015b74:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80015b78:	8b 42 a1 22 	ge.u %d2,%d2,20
80015b7c:	df 02 13 80 	jne %d2,0,80015ba2 <ip4_output_if_src+0x4cc>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
      IP_STATS_INC(ip.err);
80015b80:	91 10 00 27 	movh.a %a2,28673
80015b84:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015b88:	b9 22 1c 10 	ld.hu %d2,[%a2]92 <7001005c <ram_heap+0x4fc8>>
80015b8c:	c2 12       	add %d2,1
80015b8e:	37 02 70 20 	extr.u %d2,%d2,0,16
80015b92:	91 10 00 27 	movh.a %a2,28673
80015b96:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015b9a:	f9 22 1c 10 	st.h [%a2]92 <7001005c <ram_heap+0x4fc8>>,%d2
      MIB2_STATS_INC(mib2.ipoutdiscards);
      return ERR_BUF;
80015b9e:	82 e2       	mov %d2,-2
80015ba0:	00 90       	ret 
    }
    iphdr = (struct ip_hdr *)p->payload;
80015ba2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80015ba6:	b0 42       	add.a %a2,4
80015ba8:	54 22       	ld.w %d2,[%a2]
80015baa:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    ip4_addr_copy(dest_addr, iphdr->dest);
80015bae:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015bb2:	39 23 10 00 	ld.bu %d3,[%a2]16
80015bb6:	39 22 11 00 	ld.bu %d2,[%a2]17
80015bba:	8f 82 00 20 	sh %d2,%d2,8
80015bbe:	a6 32       	or %d2,%d3
80015bc0:	39 23 12 00 	ld.bu %d3,[%a2]18
80015bc4:	8f 03 01 30 	sh %d3,%d3,16
80015bc8:	a6 32       	or %d2,%d3
80015bca:	39 23 13 00 	ld.bu %d3,[%a2]19
80015bce:	8f 83 01 30 	sh %d3,%d3,24
80015bd2:	a6 32       	or %d2,%d3
80015bd4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    dest = &dest_addr;
80015bd8:	d9 e2 f0 ff 	lea %a2,[%a14]-16
80015bdc:	b5 e2 e4 ff 	st.a [%a14]-28,%a2
  }

  IP_STATS_INC(ip.xmit);
80015be0:	91 10 00 27 	movh.a %a2,28673
80015be4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015be8:	b9 22 08 10 	ld.hu %d2,[%a2]72 <70010048 <ram_heap+0x4fb4>>
80015bec:	c2 12       	add %d2,1
80015bee:	37 02 70 20 	extr.u %d2,%d2,0,16
80015bf2:	91 10 00 27 	movh.a %a2,28673
80015bf6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80015bfa:	f9 22 08 10 	st.h [%a2]72 <70010048 <ram_heap+0x4fb4>>,%d2
  }
#endif /* LWIP_MULTICAST_TX_OPTIONS */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
80015bfe:	99 e2 d4 ff 	ld.a %a2,[%a14]-44 <70010048 <ram_heap+0x4fb4>>
80015c02:	b9 22 28 00 	ld.hu %d2,[%a2]40 <70010048 <ram_heap+0x4fb4>>
80015c06:	df 02 15 00 	jeq %d2,0,80015c30 <ip4_output_if_src+0x55a>
80015c0a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80015c0e:	b9 22 08 00 	ld.hu %d2,[%a2]8
80015c12:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80015c16:	b9 23 28 00 	ld.hu %d3,[%a2]40
80015c1a:	7f 23 0b 80 	jge.u %d3,%d2,80015c30 <ip4_output_if_src+0x55a>
    return ip4_frag(p, netif, dest);
80015c1e:	99 e6 e4 ff 	ld.a %a6,[%a14]-28
80015c22:	99 e5 d4 ff 	ld.a %a5,[%a14]-44
80015c26:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80015c2a:	6d 00 7a 0a 	call 8001711e <ip4_frag>
80015c2e:	00 90       	ret 
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
  return netif->output(netif, p, dest);
80015c30:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80015c34:	d9 22 14 00 	lea %a2,[%a2]20
80015c38:	d4 22       	ld.a %a2,[%a2]
80015c3a:	99 e6 e4 ff 	ld.a %a6,[%a14]-28
80015c3e:	99 e5 ec ff 	ld.a %a5,[%a14]-20
80015c42:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
80015c46:	2d 02 00 00 	calli %a2
}
80015c4a:	00 90       	ret 

80015c4c <ip4_addr_isbroadcast_u32>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
{
80015c4c:	40 ae       	mov.aa %a14,%sp
80015c4e:	20 10       	sub.a %sp,16
80015c50:	59 e4 f4 ff 	st.w [%a14]-12,%d4
80015c54:	b5 e4 f0 ff 	st.a [%a14]-16,%a4
  ip4_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
80015c58:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80015c5c:	59 e2 fc ff 	st.w [%a14]-4,%d2

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
80015c60:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80015c64:	df f2 06 00 	jeq %d2,-1,80015c70 <ip4_addr_isbroadcast_u32+0x24>
80015c68:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80015c6c:	df 02 04 80 	jne %d2,0,80015c74 <ip4_addr_isbroadcast_u32+0x28>
      (addr == IPADDR_ANY)) {
    return 1;
80015c70:	82 12       	mov %d2,1
80015c72:	00 90       	ret 
    /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
80015c74:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80015c78:	39 22 31 00 	ld.bu %d2,[%a2]49
80015c7c:	8f 22 00 21 	and %d2,%d2,2
80015c80:	df 02 04 80 	jne %d2,0,80015c88 <ip4_addr_isbroadcast_u32+0x3c>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
80015c84:	82 02       	mov %d2,0
80015c86:	00 90       	ret 
    /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
80015c88:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80015c8c:	60 22       	mov.a %a2,%d2
80015c8e:	b0 42       	add.a %a2,4
80015c90:	54 22       	ld.w %d2,[%a2]
80015c92:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80015c96:	5f 23 04 80 	jne %d3,%d2,80015c9e <ip4_addr_isbroadcast_u32+0x52>
    return 0;
80015c9a:	82 02       	mov %d2,0
80015c9c:	00 90       	ret 
    /*  on the same (sub) network... */
  } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
80015c9e:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80015ca2:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80015ca6:	60 22       	mov.a %a2,%d2
80015ca8:	b0 42       	add.a %a2,4
80015caa:	54 22       	ld.w %d2,[%a2]
80015cac:	c6 32       	xor %d2,%d3
80015cae:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
80015cb2:	60 32       	mov.a %a2,%d3
80015cb4:	d9 22 08 00 	lea %a2,[%a2]8
80015cb8:	54 23       	ld.w %d3,[%a2]
80015cba:	26 32       	and %d2,%d3
80015cbc:	df 02 17 80 	jne %d2,0,80015cea <ip4_addr_isbroadcast_u32+0x9e>
             /* ...and host identifier bits are all ones? =>... */
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
80015cc0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80015cc4:	60 22       	mov.a %a2,%d2
80015cc6:	d9 22 08 00 	lea %a2,[%a2]8
80015cca:	54 22       	ld.w %d2,[%a2]
80015ccc:	46 02       	not %d2
80015cce:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80015cd2:	26 23       	and %d3,%d2
                 (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
80015cd4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80015cd8:	60 22       	mov.a %a2,%d2
80015cda:	d9 22 08 00 	lea %a2,[%a2]8
80015cde:	54 22       	ld.w %d2,[%a2]
80015ce0:	46 02       	not %d2
             && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
80015ce2:	5f 23 04 80 	jne %d3,%d2,80015cea <ip4_addr_isbroadcast_u32+0x9e>
    /* => network broadcast address */
    return 1;
80015ce6:	82 12       	mov %d2,1
80015ce8:	00 90       	ret 
  } else {
    return 0;
80015cea:	82 02       	mov %d2,0
  }
}
80015cec:	00 90       	ret 

80015cee <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
80015cee:	40 ae       	mov.aa %a14,%sp
80015cf0:	20 10       	sub.a %sp,16
  struct ip_reassdata *r, *prev = NULL;
80015cf2:	82 02       	mov %d2,0
80015cf4:	59 e2 f8 ff 	st.w [%a14]-8,%d2

  r = reassdatagrams;
80015cf8:	91 10 00 27 	movh.a %a2,28673
80015cfc:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
80015d00:	54 22       	ld.w %d2,[%a2]
80015d02:	59 e2 fc ff 	st.w [%a14]-4 <7000b074 <reassdatagrams>>,%d2
  while (r != NULL) {
80015d06:	1d 00 2d 00 	j 80015d60 <ip_reass_tmr+0x72>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
80015d0a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80015d0e:	39 22 1f 00 	ld.bu %d2,[%a2]31
80015d12:	df 02 18 00 	jeq %d2,0,80015d42 <ip_reass_tmr+0x54>
      r->timer--;
80015d16:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80015d1a:	39 22 1f 00 	ld.bu %d2,[%a2]31
80015d1e:	c2 f2       	add %d2,-1
80015d20:	8f f2 0f 21 	and %d2,%d2,255
80015d24:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80015d28:	e9 22 1f 00 	st.b [%a2]31,%d2
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n", (u16_t)r->timer));
      prev = r;
80015d2c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015d30:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      r = r->next;
80015d34:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80015d38:	54 22       	ld.w %d2,[%a2]
80015d3a:	59 e2 fc ff 	st.w [%a14]-4,%d2
80015d3e:	1d 00 11 00 	j 80015d60 <ip_reass_tmr+0x72>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
80015d42:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015d46:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      /* get the next pointer before freeing */
      r = r->next;
80015d4a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80015d4e:	54 22       	ld.w %d2,[%a2]
80015d50:	59 e2 fc ff 	st.w [%a14]-4,%d2
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
80015d54:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80015d58:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80015d5c:	6d 00 09 00 	call 80015d6e <ip_reass_free_complete_datagram>
  while (r != NULL) {
80015d60:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80015d64:	df 02 d3 ff 	jne %d2,0,80015d0a <ip_reass_tmr+0x1c>
    }
  }
}
80015d68:	00 00       	nop 
80015d6a:	00 00       	nop 
80015d6c:	00 90       	ret 

80015d6e <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
80015d6e:	40 ae       	mov.aa %a14,%sp
80015d70:	20 30       	sub.a %sp,48
80015d72:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80015d76:	b5 e5 e0 ff 	st.a [%a14]-32,%a5
  u16_t pbufs_freed = 0;
80015d7a:	82 02       	mov %d2,0
80015d7c:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  u16_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
80015d80:	19 e3 e0 ff 	ld.w %d3,[%a14]-32
80015d84:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80015d88:	5f 23 17 80 	jne %d3,%d2,80015db6 <ip_reass_free_complete_datagram+0x48>
80015d8c:	91 00 00 28 	movh.a %a2,32768
80015d90:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80015d94:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80015d98:	3b b0 0a 20 	mov %d2,171
80015d9c:	59 a2 04 00 	st.w [%sp]4,%d2
80015da0:	91 00 00 28 	movh.a %a2,32768
80015da4:	d9 22 19 61 	lea %a2,[%a2]4505 <80001199 <IfxCpu_Trap_vectorTable0_end+0xfa5>>
80015da8:	f4 a2       	st.a [%sp],%a2
80015daa:	91 00 00 28 	movh.a %a2,32768
80015dae:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80015db2:	6d ff c2 7a 	call 80005336 <Ifx_Lwip_printf>
  if (prev != NULL) {
80015db6:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80015dba:	df 02 1e 00 	jeq %d2,0,80015df6 <ip_reass_free_complete_datagram+0x88>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
80015dbe:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80015dc2:	54 22       	ld.w %d2,[%a2]
80015dc4:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
80015dc8:	5f 23 17 00 	jeq %d3,%d2,80015df6 <ip_reass_free_complete_datagram+0x88>
80015dcc:	91 00 00 28 	movh.a %a2,32768
80015dd0:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80015dd4:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80015dd8:	3b d0 0a 20 	mov %d2,173
80015ddc:	59 a2 04 00 	st.w [%sp]4,%d2
80015de0:	91 00 00 28 	movh.a %a2,32768
80015de4:	d9 22 25 61 	lea %a2,[%a2]4517 <800011a5 <IfxCpu_Trap_vectorTable0_end+0xfb1>>
80015de8:	f4 a2       	st.a [%sp],%a2
80015dea:	91 00 00 28 	movh.a %a2,32768
80015dee:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80015df2:	6d ff a2 7a 	call 80005336 <Ifx_Lwip_printf>
  }

  MIB2_STATS_INC(mib2.ipreasmfails);
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
80015df6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80015dfa:	b0 42       	add.a %a2,4
80015dfc:	d4 22       	ld.a %a2,[%a2]
80015dfe:	b0 42       	add.a %a2,4
80015e00:	54 22       	ld.w %d2,[%a2]
80015e02:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  if (iprh->start == 0) {
80015e06:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80015e0a:	39 23 04 00 	ld.bu %d3,[%a2]4
80015e0e:	39 22 05 00 	ld.bu %d2,[%a2]5
80015e12:	8f 82 00 20 	sh %d2,%d2,8
80015e16:	a6 32       	or %d2,%d3
80015e18:	37 02 70 20 	extr.u %d2,%d2,0,16
80015e1c:	df 02 60 80 	jne %d2,0,80015edc <ip_reass_free_complete_datagram+0x16e>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
80015e20:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80015e24:	b0 42       	add.a %a2,4
80015e26:	54 22       	ld.w %d2,[%a2]
80015e28:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    ipr->p = iprh->next_pbuf;
80015e2c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80015e30:	14 23       	ld.bu %d3,[%a2]
80015e32:	39 22 01 00 	ld.bu %d2,[%a2]1
80015e36:	8f 82 00 20 	sh %d2,%d2,8
80015e3a:	a6 32       	or %d2,%d3
80015e3c:	39 23 02 00 	ld.bu %d3,[%a2]2
80015e40:	8f 03 01 30 	sh %d3,%d3,16
80015e44:	a6 32       	or %d2,%d3
80015e46:	39 23 03 00 	ld.bu %d3,[%a2]3
80015e4a:	8f 83 01 30 	sh %d3,%d3,24
80015e4e:	a6 32       	or %d2,%d3
80015e50:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80015e54:	b0 42       	add.a %a2,4
80015e56:	74 22       	st.w [%a2],%d2
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
80015e58:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015e5c:	b0 42       	add.a %a2,4
80015e5e:	54 23       	ld.w %d3,[%a2]
80015e60:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80015e64:	1b 82 00 20 	addi %d2,%d2,8
80015e68:	3b 40 01 40 	mov %d4,20
80015e6c:	60 25       	mov.a %a5,%d2
80015e6e:	60 34       	mov.a %a4,%d3
80015e70:	6d 00 d6 89 	call 8002721c <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
80015e74:	82 14       	mov %d4,1
80015e76:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80015e7a:	6d ff 41 f7 	call 80014cfc <icmp_time_exceeded>
    clen = pbuf_clen(p);
80015e7e:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80015e82:	6d 00 6e 21 	call 8001a15e <pbuf_clen>
80015e86:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
80015e8a:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80015e8e:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
80015e92:	42 32       	add %d2,%d3
80015e94:	7b 10 00 30 	movh %d3,1
80015e98:	3f 32 17 00 	jlt %d2,%d3,80015ec6 <ip_reass_free_complete_datagram+0x158>
80015e9c:	91 00 00 28 	movh.a %a2,32768
80015ea0:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80015ea4:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80015ea8:	3b c0 0b 20 	mov %d2,188
80015eac:	59 a2 04 00 	st.w [%sp]4,%d2
80015eb0:	91 00 00 28 	movh.a %a2,32768
80015eb4:	d9 22 37 61 	lea %a2,[%a2]4535 <800011b7 <IfxCpu_Trap_vectorTable0_end+0xfc3>>
80015eb8:	f4 a2       	st.a [%sp],%a2
80015eba:	91 00 00 28 	movh.a %a2,32768
80015ebe:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80015ec2:	6d ff 3a 7a 	call 80005336 <Ifx_Lwip_printf>
    pbufs_freed = (u16_t)(pbufs_freed + clen);
80015ec6:	c9 e3 fe ff 	ld.h %d3,[%a14]-2
80015eca:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80015ece:	42 32       	add %d2,%d3
80015ed0:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    pbuf_free(p);
80015ed4:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80015ed8:	6d 00 60 20 	call 80019f98 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released
     separately as they have not yet been chained */
  p = ipr->p;
80015edc:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80015ee0:	b0 42       	add.a %a2,4
80015ee2:	54 22       	ld.w %d2,[%a2]
80015ee4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  while (p != NULL) {
80015ee8:	1d 00 4f 00 	j 80015f86 <ip_reass_free_complete_datagram+0x218>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
80015eec:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80015ef0:	b0 42       	add.a %a2,4
80015ef2:	54 22       	ld.w %d2,[%a2]
80015ef4:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    pcur = p;
80015ef8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80015efc:	59 e2 ec ff 	st.w [%a14]-20,%d2
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
80015f00:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80015f04:	14 23       	ld.bu %d3,[%a2]
80015f06:	39 22 01 00 	ld.bu %d2,[%a2]1
80015f0a:	8f 82 00 20 	sh %d2,%d2,8
80015f0e:	a6 32       	or %d2,%d3
80015f10:	39 23 02 00 	ld.bu %d3,[%a2]2
80015f14:	8f 03 01 30 	sh %d3,%d3,16
80015f18:	a6 32       	or %d2,%d3
80015f1a:	39 23 03 00 	ld.bu %d3,[%a2]3
80015f1e:	8f 83 01 30 	sh %d3,%d3,24
80015f22:	a6 32       	or %d2,%d3
80015f24:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    clen = pbuf_clen(pcur);
80015f28:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80015f2c:	6d 00 19 21 	call 8001a15e <pbuf_clen>
80015f30:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
80015f34:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80015f38:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
80015f3c:	42 32       	add %d2,%d3
80015f3e:	7b 10 00 30 	movh %d3,1
80015f42:	3f 32 17 00 	jlt %d2,%d3,80015f70 <ip_reass_free_complete_datagram+0x202>
80015f46:	91 00 00 28 	movh.a %a2,32768
80015f4a:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80015f4e:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80015f52:	3b c0 0c 20 	mov %d2,204
80015f56:	59 a2 04 00 	st.w [%sp]4,%d2
80015f5a:	91 00 00 28 	movh.a %a2,32768
80015f5e:	d9 22 37 61 	lea %a2,[%a2]4535 <800011b7 <IfxCpu_Trap_vectorTable0_end+0xfc3>>
80015f62:	f4 a2       	st.a [%sp],%a2
80015f64:	91 00 00 28 	movh.a %a2,32768
80015f68:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80015f6c:	6d ff e5 79 	call 80005336 <Ifx_Lwip_printf>
    pbufs_freed = (u16_t)(pbufs_freed + clen);
80015f70:	c9 e3 fe ff 	ld.h %d3,[%a14]-2
80015f74:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80015f78:	42 32       	add %d2,%d3
80015f7a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    pbuf_free(pcur);
80015f7e:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80015f82:	6d 00 0b 20 	call 80019f98 <pbuf_free>
  while (p != NULL) {
80015f86:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80015f8a:	df 02 b1 ff 	jne %d2,0,80015eec <ip_reass_free_complete_datagram+0x17e>
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
80015f8e:	99 e5 e0 ff 	ld.a %a5,[%a14]-32
80015f92:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80015f96:	6d 00 4e 01 	call 80016232 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= pbufs_freed", ip_reass_pbufcount >= pbufs_freed);
80015f9a:	91 10 00 27 	movh.a %a2,28673
80015f9e:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80015fa2:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80015fa6:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2 <70010000 <ram_heap+0x4f6c>>
80015faa:	7f 23 17 80 	jge.u %d3,%d2,80015fd8 <ip_reass_free_complete_datagram+0x26a>
80015fae:	91 00 00 28 	movh.a %a2,32768
80015fb2:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80015fb6:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80015fba:	3b 20 0d 20 	mov %d2,210
80015fbe:	59 a2 04 00 	st.w [%sp]4,%d2
80015fc2:	91 00 00 28 	movh.a %a2,32768
80015fc6:	d9 22 14 71 	lea %a2,[%a2]4564 <800011d4 <IfxCpu_Trap_vectorTable0_end+0xfe0>>
80015fca:	f4 a2       	st.a [%sp],%a2
80015fcc:	91 00 00 28 	movh.a %a2,32768
80015fd0:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80015fd4:	6d ff b1 79 	call 80005336 <Ifx_Lwip_printf>
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - pbufs_freed);
80015fd8:	91 10 00 27 	movh.a %a2,28673
80015fdc:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80015fe0:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80015fe4:	c9 e2 fe ff 	ld.h %d2,[%a14]-2 <70010000 <ram_heap+0x4f6c>>
80015fe8:	0b 23 80 20 	sub %d2,%d3,%d2
80015fec:	37 02 70 20 	extr.u %d2,%d2,0,16
80015ff0:	91 10 00 27 	movh.a %a2,28673
80015ff4:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80015ff8:	b4 22       	st.h [%a2],%d2

  return pbufs_freed;
80015ffa:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2 <7000b078 <ip_reass_pbufcount>>
}
80015ffe:	00 90       	ret 

80016000 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
80016000:	40 ae       	mov.aa %a14,%sp
80016002:	20 28       	sub.a %sp,40
80016004:	b5 e4 dc ff 	st.a [%a14]-36,%a4
80016008:	59 e4 d8 ff 	st.w [%a14]-40,%d4
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev, *oldest_prev;
  int pbufs_freed = 0, pbufs_freed_current;
8001600c:	82 02       	mov %d2,0
8001600e:	59 e2 ec ff 	st.w [%a14]-20,%d2
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
80016012:	82 02       	mov %d2,0
80016014:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    prev = NULL;
80016018:	82 02       	mov %d2,0
8001601a:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    oldest_prev = NULL;
8001601e:	82 02       	mov %d2,0
80016020:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    other_datagrams = 0;
80016024:	82 02       	mov %d2,0
80016026:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    r = reassdatagrams;
8001602a:	91 10 00 27 	movh.a %a2,28673
8001602e:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
80016032:	54 22       	ld.w %d2,[%a2]
80016034:	59 e2 fc ff 	st.w [%a14]-4 <7000b074 <reassdatagrams>>,%d2
    while (r != NULL) {
80016038:	1d 00 7a 00 	j 8001612c <ip_reass_remove_oldest_datagram+0x12c>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
8001603c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016040:	d9 22 14 00 	lea %a2,[%a2]20
80016044:	54 24       	ld.w %d4,[%a2]
80016046:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001604a:	39 23 0c 00 	ld.bu %d3,[%a2]12
8001604e:	39 22 0d 00 	ld.bu %d2,[%a2]13
80016052:	8f 82 00 20 	sh %d2,%d2,8
80016056:	a6 32       	or %d2,%d3
80016058:	39 23 0e 00 	ld.bu %d3,[%a2]14
8001605c:	8f 03 01 30 	sh %d3,%d3,16
80016060:	a6 32       	or %d2,%d3
80016062:	39 23 0f 00 	ld.bu %d3,[%a2]15
80016066:	8f 83 01 30 	sh %d3,%d3,24
8001606a:	a6 32       	or %d2,%d3
8001606c:	5f 24 2d 80 	jne %d4,%d2,800160c6 <ip_reass_remove_oldest_datagram+0xc6>
80016070:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016074:	d9 22 18 00 	lea %a2,[%a2]24
80016078:	54 24       	ld.w %d4,[%a2]
8001607a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001607e:	39 23 10 00 	ld.bu %d3,[%a2]16
80016082:	39 22 11 00 	ld.bu %d2,[%a2]17
80016086:	8f 82 00 20 	sh %d2,%d2,8
8001608a:	a6 32       	or %d2,%d3
8001608c:	39 23 12 00 	ld.bu %d3,[%a2]18
80016090:	8f 03 01 30 	sh %d3,%d3,16
80016094:	a6 32       	or %d2,%d3
80016096:	39 23 13 00 	ld.bu %d3,[%a2]19
8001609a:	8f 83 01 30 	sh %d3,%d3,24
8001609e:	a6 32       	or %d2,%d3
800160a0:	5f 24 13 80 	jne %d4,%d2,800160c6 <ip_reass_remove_oldest_datagram+0xc6>
800160a4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800160a8:	b9 23 0c 00 	ld.hu %d3,[%a2]12
800160ac:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800160b0:	39 24 04 00 	ld.bu %d4,[%a2]4
800160b4:	39 22 05 00 	ld.bu %d2,[%a2]5
800160b8:	8f 82 00 20 	sh %d2,%d2,8
800160bc:	a6 42       	or %d2,%d4
800160be:	37 02 70 20 	extr.u %d2,%d2,0,16
800160c2:	5f 23 27 00 	jeq %d3,%d2,80016110 <ip_reass_remove_oldest_datagram+0x110>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
800160c6:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800160ca:	c2 12       	add %d2,1
800160cc:	59 e2 e8 ff 	st.w [%a14]-24,%d2
        if (oldest == NULL) {
800160d0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800160d4:	df 02 0c 80 	jne %d2,0,800160ec <ip_reass_remove_oldest_datagram+0xec>
          oldest = r;
800160d8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800160dc:	59 e2 f8 ff 	st.w [%a14]-8,%d2
          oldest_prev = prev;
800160e0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800160e4:	59 e2 f0 ff 	st.w [%a14]-16,%d2
800160e8:	1d 00 14 00 	j 80016110 <ip_reass_remove_oldest_datagram+0x110>
        } else if (r->timer <= oldest->timer) {
800160ec:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800160f0:	39 22 1f 00 	ld.bu %d2,[%a2]31
800160f4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800160f8:	39 23 1f 00 	ld.bu %d3,[%a2]31
800160fc:	3f 23 0a 80 	jlt.u %d3,%d2,80016110 <ip_reass_remove_oldest_datagram+0x110>
          /* older than the previous oldest */
          oldest = r;
80016100:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80016104:	59 e2 f8 ff 	st.w [%a14]-8,%d2
          oldest_prev = prev;
80016108:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001610c:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        }
      }
      if (r->next != NULL) {
80016110:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016114:	54 22       	ld.w %d2,[%a2]
80016116:	df 02 06 00 	jeq %d2,0,80016122 <ip_reass_remove_oldest_datagram+0x122>
        prev = r;
8001611a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001611e:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      }
      r = r->next;
80016122:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016126:	54 22       	ld.w %d2,[%a2]
80016128:	59 e2 fc ff 	st.w [%a14]-4,%d2
    while (r != NULL) {
8001612c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80016130:	df 02 86 ff 	jne %d2,0,8001603c <ip_reass_remove_oldest_datagram+0x3c>
    }
    if (oldest != NULL) {
80016134:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016138:	df 02 11 00 	jeq %d2,0,8001615a <ip_reass_remove_oldest_datagram+0x15a>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
8001613c:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
80016140:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80016144:	6d ff 15 fe 	call 80015d6e <ip_reass_free_complete_datagram>
80016148:	59 e2 e4 ff 	st.w [%a14]-28,%d2
      pbufs_freed += pbufs_freed_current;
8001614c:	19 e3 ec ff 	ld.w %d3,[%a14]-20
80016150:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80016154:	42 32       	add %d2,%d3
80016156:	59 e2 ec ff 	st.w [%a14]-20,%d2
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
8001615a:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8001615e:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80016162:	7f 23 06 00 	jge %d3,%d2,8001616e <ip_reass_remove_oldest_datagram+0x16e>
80016166:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001616a:	ff 22 54 7f 	jge %d2,2,80016012 <ip_reass_remove_oldest_datagram+0x12>
  return pbufs_freed;
8001616e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
}
80016172:	00 90       	ret 

80016174 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata *
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
80016174:	40 ae       	mov.aa %a14,%sp
80016176:	20 10       	sub.a %sp,16
80016178:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001617c:	59 e4 f0 ff 	st.w [%a14]-16,%d4
#if ! IP_REASS_FREE_OLDEST
  LWIP_UNUSED_ARG(clen);
#endif

  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
80016180:	82 44       	mov %d4,4
80016182:	6d 00 24 14 	call 800189ca <memp_malloc>
80016186:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (ipr == NULL) {
8001618a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001618e:	df 02 27 80 	jne %d2,0,800161dc <ip_reass_enqueue_new_datagram+0x68>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
80016192:	19 e4 f0 ff 	ld.w %d4,[%a14]-16
80016196:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001619a:	6d ff 33 ff 	call 80016000 <ip_reass_remove_oldest_datagram>
8001619e:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
800161a2:	3f 32 07 00 	jlt %d2,%d3,800161b0 <ip_reass_enqueue_new_datagram+0x3c>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
800161a6:	82 44       	mov %d4,4
800161a8:	6d 00 11 14 	call 800189ca <memp_malloc>
800161ac:	b5 e2 fc ff 	st.a [%a14]-4,%a2
    }
    if (ipr == NULL)
800161b0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800161b4:	df 02 14 80 	jne %d2,0,800161dc <ip_reass_enqueue_new_datagram+0x68>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
800161b8:	91 10 00 27 	movh.a %a2,28673
800161bc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800161c0:	b9 22 3c 00 	ld.hu %d2,[%a2]60 <7001003c <ram_heap+0x4fa8>>
800161c4:	c2 12       	add %d2,1
800161c6:	37 02 70 20 	extr.u %d2,%d2,0,16
800161ca:	91 10 00 27 	movh.a %a2,28673
800161ce:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800161d2:	f9 22 3c 00 	st.h [%a2]60 <7001003c <ram_heap+0x4fa8>>,%d2
      LWIP_DEBUGF(IP_REASS_DEBUG, ("Failed to alloc reassdata struct\n"));
      return NULL;
800161d6:	82 02       	mov %d2,0
800161d8:	1d 00 2b 00 	j 8001622e <ip_reass_enqueue_new_datagram+0xba>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
800161dc:	3b 00 02 50 	mov %d5,32
800161e0:	82 04       	mov %d4,0
800161e2:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800161e6:	6d 00 25 88 	call 80027230 <memset>
  ipr->timer = IP_REASS_MAXAGE;
800161ea:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800161ee:	3b f0 00 20 	mov %d2,15
800161f2:	e9 22 1f 00 	st.b [%a2]31,%d2

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
800161f6:	91 10 00 27 	movh.a %a2,28673
800161fa:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
800161fe:	54 22       	ld.w %d2,[%a2]
80016200:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <7000b074 <reassdatagrams>>
80016204:	74 22       	st.w [%a2],%d2
  reassdatagrams = ipr;
80016206:	91 10 00 27 	movh.a %a2,28673
8001620a:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
8001620e:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000b074 <reassdatagrams>>
80016212:	74 22       	st.w [%a2],%d2
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
80016214:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <7000b074 <reassdatagrams>>
80016218:	1b 82 00 20 	addi %d2,%d2,8
8001621c:	3b 40 01 40 	mov %d4,20
80016220:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80016224:	60 24       	mov.a %a4,%d2
80016226:	6d 00 fb 87 	call 8002721c <memcpy>
  return ipr;
8001622a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8001622e:	60 22       	mov.a %a2,%d2
80016230:	00 90       	ret 

80016232 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
80016232:	40 ae       	mov.aa %a14,%sp
80016234:	20 18       	sub.a %sp,24
80016236:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001623a:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
8001623e:	91 10 00 27 	movh.a %a2,28673
80016242:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
80016246:	54 22       	ld.w %d2,[%a2]
80016248:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <7000b074 <reassdatagrams>>
8001624c:	5f 23 0c 80 	jne %d3,%d2,80016264 <ip_reass_dequeue_datagram+0x32>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
80016250:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016254:	54 22       	ld.w %d2,[%a2]
80016256:	91 10 00 27 	movh.a %a2,28673
8001625a:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
8001625e:	74 22       	st.w [%a2],%d2
80016260:	1d 00 21 00 	j 800162a2 <ip_reass_dequeue_datagram+0x70>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
80016264:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016268:	df 02 17 80 	jne %d2,0,80016296 <ip_reass_dequeue_datagram+0x64>
8001626c:	91 00 00 28 	movh.a %a2,32768
80016270:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80016274:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80016278:	3b 50 14 20 	mov %d2,325
8001627c:	59 a2 04 00 	st.w [%sp]4,%d2
80016280:	91 00 00 28 	movh.a %a2,32768
80016284:	d9 22 36 71 	lea %a2,[%a2]4598 <800011f6 <IfxCpu_Trap_vectorTable0_end+0x1002>>
80016288:	f4 a2       	st.a [%sp],%a2
8001628a:	91 00 00 28 	movh.a %a2,32768
8001628e:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80016292:	6d ff 52 78 	call 80005336 <Ifx_Lwip_printf>
    prev->next = ipr->next;
80016296:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001629a:	54 22       	ld.w %d2,[%a2]
8001629c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800162a0:	74 22       	st.w [%a2],%d2
  }

  /* now we can free the ip_reassdata struct */
  memp_free(MEMP_REASSDATA, ipr);
800162a2:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800162a6:	82 44       	mov %d4,4
800162a8:	6d 00 07 14 	call 80018ab6 <memp_free>
}
800162ac:	00 00       	nop 
800162ae:	00 90       	ret 

800162b0 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param is_last is 1 if this pbuf has MF==0 (ipr->flags not updated yet)
 * @return see IP_REASS_VALIDATE_* defines
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p, int is_last)
{
800162b0:	40 ae       	mov.aa %a14,%sp
800162b2:	20 40       	sub.a %sp,64
800162b4:	b5 e4 dc ff 	st.a [%a14]-36,%a4
800162b8:	b5 e5 d8 ff 	st.a [%a14]-40,%a5
800162bc:	59 e4 d4 ff 	st.w [%a14]-44,%d4
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev = NULL;
800162c0:	82 02       	mov %d2,0
800162c2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  struct pbuf *q;
  u16_t offset, len;
  u8_t hlen;
  struct ip_hdr *fraghdr;
  int valid = 1;
800162c6:	82 12       	mov %d2,1
800162c8:	59 e2 f0 ff 	st.w [%a14]-16,%d2

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr *)new_p->payload;
800162cc:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
800162d0:	b0 42       	add.a %a2,4
800162d2:	54 22       	ld.w %d2,[%a2]
800162d4:	59 e2 ec ff 	st.w [%a14]-20,%d2
  len = lwip_ntohs(IPH_LEN(fraghdr));
800162d8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800162dc:	39 23 02 00 	ld.bu %d3,[%a2]2
800162e0:	39 22 03 00 	ld.bu %d2,[%a2]3
800162e4:	8f 82 00 20 	sh %d2,%d2,8
800162e8:	a6 32       	or %d2,%d3
800162ea:	37 02 70 20 	extr.u %d2,%d2,0,16
800162ee:	02 24       	mov %d4,%d2
800162f0:	6d 00 32 09 	call 80017554 <lwip_htons>
800162f4:	f9 e2 ea ff 	st.h [%a14]-22,%d2
  hlen = IPH_HL_BYTES(fraghdr);
800162f8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800162fc:	14 22       	ld.bu %d2,[%a2]
800162fe:	8f f2 00 21 	and %d2,%d2,15
80016302:	8f f2 0f 21 	and %d2,%d2,255
80016306:	06 22       	sh %d2,2
80016308:	e9 e2 e9 ff 	st.b [%a14]-23,%d2
  if (hlen > len) {
8001630c:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
80016310:	37 02 70 20 	extr.u %d2,%d2,0,16
80016314:	b9 e3 ea ff 	ld.hu %d3,[%a14]-22
80016318:	7f 23 04 80 	jge.u %d3,%d2,80016320 <ip_reass_chain_frag_into_datagram_and_validate+0x70>
    /* invalid datagram */
    return IP_REASS_VALIDATE_PBUF_DROPPED;
8001631c:	82 f2       	mov %d2,-1
8001631e:	00 90       	ret 
  }
  len = (u16_t)(len - hlen);
80016320:	39 e2 e9 ff 	ld.bu %d2,[%a14]-23
80016324:	37 02 70 20 	extr.u %d2,%d2,0,16
80016328:	c9 e3 ea ff 	ld.h %d3,[%a14]-22
8001632c:	0b 23 80 20 	sub %d2,%d3,%d2
80016330:	f9 e2 ea ff 	st.h [%a14]-22,%d2
  offset = IPH_OFFSET_BYTES(fraghdr);
80016334:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80016338:	39 23 06 00 	ld.bu %d3,[%a2]6
8001633c:	39 22 07 00 	ld.bu %d2,[%a2]7
80016340:	8f 82 00 20 	sh %d2,%d2,8
80016344:	a6 32       	or %d2,%d3
80016346:	37 02 70 20 	extr.u %d2,%d2,0,16
8001634a:	02 24       	mov %d4,%d2
8001634c:	6d 00 04 09 	call 80017554 <lwip_htons>
80016350:	02 23       	mov %d3,%d2
80016352:	3b f0 ff 21 	mov %d2,8191
80016356:	26 32       	and %d2,%d3
80016358:	37 02 70 20 	extr.u %d2,%d2,0,16
8001635c:	06 32       	sh %d2,3
8001635e:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper *)new_p->payload;
80016362:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80016366:	b0 42       	add.a %a2,4
80016368:	54 22       	ld.w %d2,[%a2]
8001636a:	59 e2 fc ff 	st.w [%a14]-4,%d2
  iprh->next_pbuf = NULL;
8001636e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016372:	82 02       	mov %d2,0
80016374:	34 22       	st.b [%a2],%d2
80016376:	82 02       	mov %d2,0
80016378:	e9 22 01 00 	st.b [%a2]1,%d2
8001637c:	82 02       	mov %d2,0
8001637e:	e9 22 02 00 	st.b [%a2]2,%d2
80016382:	82 02       	mov %d2,0
80016384:	e9 22 03 00 	st.b [%a2]3,%d2
  iprh->start = offset;
80016388:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001638c:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
80016390:	8f f2 0f 21 	and %d2,%d2,255
80016394:	82 03       	mov %d3,0
80016396:	a6 32       	or %d2,%d3
80016398:	e9 22 04 00 	st.b [%a2]4,%d2
8001639c:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
800163a0:	06 82       	sh %d2,-8
800163a2:	37 02 70 20 	extr.u %d2,%d2,0,16
800163a6:	82 03       	mov %d3,0
800163a8:	a6 32       	or %d2,%d3
800163aa:	e9 22 05 00 	st.b [%a2]5,%d2
  iprh->end = (u16_t)(offset + len);
800163ae:	c9 e3 e6 ff 	ld.h %d3,[%a14]-26
800163b2:	c9 e2 ea ff 	ld.h %d2,[%a14]-22
800163b6:	42 32       	add %d2,%d3
800163b8:	37 02 70 20 	extr.u %d2,%d2,0,16
800163bc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800163c0:	8f f2 0f 31 	and %d3,%d2,255
800163c4:	82 04       	mov %d4,0
800163c6:	a6 43       	or %d3,%d4
800163c8:	e9 23 06 00 	st.b [%a2]6,%d3
800163cc:	06 82       	sh %d2,-8
800163ce:	37 02 70 20 	extr.u %d2,%d2,0,16
800163d2:	82 03       	mov %d3,0
800163d4:	a6 32       	or %d2,%d3
800163d6:	e9 22 07 00 	st.b [%a2]7,%d2
  if (iprh->end < offset) {
800163da:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800163de:	39 23 06 00 	ld.bu %d3,[%a2]6
800163e2:	39 22 07 00 	ld.bu %d2,[%a2]7
800163e6:	8f 82 00 20 	sh %d2,%d2,8
800163ea:	a6 32       	or %d2,%d3
800163ec:	37 02 70 30 	extr.u %d3,%d2,0,16
800163f0:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
800163f4:	7f 23 04 80 	jge.u %d3,%d2,800163fc <ip_reass_chain_frag_into_datagram_and_validate+0x14c>
    /* u16_t overflow, cannot handle this */
    return IP_REASS_VALIDATE_PBUF_DROPPED;
800163f8:	82 f2       	mov %d2,-1
800163fa:	00 90       	ret 
  }

  /* Iterate through until we either get to the end of the list (append),
   * or we find one with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
800163fc:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80016400:	b0 42       	add.a %a2,4
80016402:	54 22       	ld.w %d2,[%a2]
80016404:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80016408:	1d 00 48 01 	j 80016698 <ip_reass_chain_frag_into_datagram_and_validate+0x3e8>
    iprh_tmp = (struct ip_reass_helper *)q->payload;
8001640c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80016410:	b0 42       	add.a %a2,4
80016412:	54 22       	ld.w %d2,[%a2]
80016414:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    if (iprh->start < iprh_tmp->start) {
80016418:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001641c:	39 23 04 00 	ld.bu %d3,[%a2]4
80016420:	39 22 05 00 	ld.bu %d2,[%a2]5
80016424:	8f 82 00 20 	sh %d2,%d2,8
80016428:	a6 32       	or %d2,%d3
8001642a:	37 02 70 30 	extr.u %d3,%d2,0,16
8001642e:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80016432:	39 24 04 00 	ld.bu %d4,[%a2]4
80016436:	39 22 05 00 	ld.bu %d2,[%a2]5
8001643a:	8f 82 00 20 	sh %d2,%d2,8
8001643e:	a6 42       	or %d2,%d4
80016440:	37 02 70 20 	extr.u %d2,%d2,0,16
80016444:	7f 23 bf 80 	jge.u %d3,%d2,800165c2 <ip_reass_chain_frag_into_datagram_and_validate+0x312>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
80016448:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001644c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80016450:	8f f2 0f 21 	and %d2,%d2,255
80016454:	82 03       	mov %d3,0
80016456:	a6 32       	or %d2,%d3
80016458:	34 22       	st.b [%a2],%d2
8001645a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001645e:	06 82       	sh %d2,-8
80016460:	8f f2 0f 21 	and %d2,%d2,255
80016464:	82 03       	mov %d3,0
80016466:	a6 32       	or %d2,%d3
80016468:	e9 22 01 00 	st.b [%a2]1,%d2
8001646c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80016470:	8f 02 1f 20 	sh %d2,%d2,-16
80016474:	8f f2 0f 21 	and %d2,%d2,255
80016478:	82 03       	mov %d3,0
8001647a:	a6 32       	or %d2,%d3
8001647c:	e9 22 02 00 	st.b [%a2]2,%d2
80016480:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80016484:	8f 82 1e 20 	sh %d2,%d2,-24
80016488:	82 03       	mov %d3,0
8001648a:	a6 32       	or %d2,%d3
8001648c:	e9 22 03 00 	st.b [%a2]3,%d2
      if (iprh_prev != NULL) {
80016490:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016494:	df 02 75 00 	jeq %d2,0,8001657e <ip_reass_chain_frag_into_datagram_and_validate+0x2ce>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
80016498:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001649c:	39 23 04 00 	ld.bu %d3,[%a2]4
800164a0:	39 22 05 00 	ld.bu %d2,[%a2]5
800164a4:	8f 82 00 20 	sh %d2,%d2,8
800164a8:	a6 32       	or %d2,%d3
800164aa:	37 02 70 30 	extr.u %d3,%d2,0,16
800164ae:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800164b2:	39 24 06 00 	ld.bu %d4,[%a2]6
800164b6:	39 22 07 00 	ld.bu %d2,[%a2]7
800164ba:	8f 82 00 20 	sh %d2,%d2,8
800164be:	a6 42       	or %d2,%d4
800164c0:	37 02 70 20 	extr.u %d2,%d2,0,16
800164c4:	3f 23 1a 80 	jlt.u %d3,%d2,800164f8 <ip_reass_chain_frag_into_datagram_and_validate+0x248>
800164c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800164cc:	39 23 06 00 	ld.bu %d3,[%a2]6
800164d0:	39 22 07 00 	ld.bu %d2,[%a2]7
800164d4:	8f 82 00 20 	sh %d2,%d2,8
800164d8:	a6 32       	or %d2,%d3
800164da:	37 02 70 20 	extr.u %d2,%d2,0,16
800164de:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
800164e2:	39 24 04 00 	ld.bu %d4,[%a2]4
800164e6:	39 23 05 00 	ld.bu %d3,[%a2]5
800164ea:	8f 83 00 30 	sh %d3,%d3,8
800164ee:	a6 43       	or %d3,%d4
800164f0:	37 03 70 30 	extr.u %d3,%d3,0,16
800164f4:	7f 23 04 80 	jge.u %d3,%d2,800164fc <ip_reass_chain_frag_into_datagram_and_validate+0x24c>
          /* fragment overlaps with previous or following, throw away */
          return IP_REASS_VALIDATE_PBUF_DROPPED;
800164f8:	82 f2       	mov %d2,-1
800164fa:	00 90       	ret 
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
800164fc:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016500:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80016504:	8f f2 0f 21 	and %d2,%d2,255
80016508:	82 03       	mov %d3,0
8001650a:	a6 32       	or %d2,%d3
8001650c:	34 22       	st.b [%a2],%d2
8001650e:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80016512:	06 82       	sh %d2,-8
80016514:	8f f2 0f 21 	and %d2,%d2,255
80016518:	82 03       	mov %d3,0
8001651a:	a6 32       	or %d2,%d3
8001651c:	e9 22 01 00 	st.b [%a2]1,%d2
80016520:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80016524:	8f 02 1f 20 	sh %d2,%d2,-16
80016528:	8f f2 0f 21 	and %d2,%d2,255
8001652c:	82 03       	mov %d3,0
8001652e:	a6 32       	or %d2,%d3
80016530:	e9 22 02 00 	st.b [%a2]2,%d2
80016534:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80016538:	8f 82 1e 20 	sh %d2,%d2,-24
8001653c:	82 03       	mov %d3,0
8001653e:	a6 32       	or %d2,%d3
80016540:	e9 22 03 00 	st.b [%a2]3,%d2
        if (iprh_prev->end != iprh->start) {
80016544:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016548:	39 23 06 00 	ld.bu %d3,[%a2]6
8001654c:	39 22 07 00 	ld.bu %d2,[%a2]7
80016550:	8f 82 00 20 	sh %d2,%d2,8
80016554:	a6 32       	or %d2,%d3
80016556:	37 02 70 30 	extr.u %d3,%d2,0,16
8001655a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001655e:	39 24 04 00 	ld.bu %d4,[%a2]4
80016562:	39 22 05 00 	ld.bu %d2,[%a2]5
80016566:	8f 82 00 20 	sh %d2,%d2,8
8001656a:	a6 42       	or %d2,%d4
8001656c:	37 02 70 20 	extr.u %d2,%d2,0,16
80016570:	5f 23 9a 00 	jeq %d3,%d2,800166a4 <ip_reass_chain_frag_into_datagram_and_validate+0x3f4>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
80016574:	82 02       	mov %d2,0
80016576:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
8001657a:	1d 00 95 00 	j 800166a4 <ip_reass_chain_frag_into_datagram_and_validate+0x3f4>
        if (iprh->end > iprh_tmp->start) {
8001657e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016582:	39 23 06 00 	ld.bu %d3,[%a2]6
80016586:	39 22 07 00 	ld.bu %d2,[%a2]7
8001658a:	8f 82 00 20 	sh %d2,%d2,8
8001658e:	a6 32       	or %d2,%d3
80016590:	37 02 70 20 	extr.u %d2,%d2,0,16
80016594:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80016598:	39 24 04 00 	ld.bu %d4,[%a2]4
8001659c:	39 23 05 00 	ld.bu %d3,[%a2]5
800165a0:	8f 83 00 30 	sh %d3,%d3,8
800165a4:	a6 43       	or %d3,%d4
800165a6:	37 03 70 30 	extr.u %d3,%d3,0,16
800165aa:	7f 23 04 80 	jge.u %d3,%d2,800165b2 <ip_reass_chain_frag_into_datagram_and_validate+0x302>
          return IP_REASS_VALIDATE_PBUF_DROPPED;
800165ae:	82 f2       	mov %d2,-1
800165b0:	00 90       	ret 
        ipr->p = new_p;
800165b2:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800165b6:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
800165ba:	b0 42       	add.a %a2,4
800165bc:	74 22       	st.w [%a2],%d2
      break;
800165be:	1d 00 73 00 	j 800166a4 <ip_reass_chain_frag_into_datagram_and_validate+0x3f4>
    } else if (iprh->start == iprh_tmp->start) {
800165c2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800165c6:	39 23 04 00 	ld.bu %d3,[%a2]4
800165ca:	39 22 05 00 	ld.bu %d2,[%a2]5
800165ce:	8f 82 00 20 	sh %d2,%d2,8
800165d2:	a6 32       	or %d2,%d3
800165d4:	37 02 70 30 	extr.u %d3,%d2,0,16
800165d8:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
800165dc:	39 24 04 00 	ld.bu %d4,[%a2]4
800165e0:	39 22 05 00 	ld.bu %d2,[%a2]5
800165e4:	8f 82 00 20 	sh %d2,%d2,8
800165e8:	a6 42       	or %d2,%d4
800165ea:	37 02 70 20 	extr.u %d2,%d2,0,16
800165ee:	5f 23 04 80 	jne %d3,%d2,800165f6 <ip_reass_chain_frag_into_datagram_and_validate+0x346>
      /* received the same datagram twice: no need to keep the datagram */
      return IP_REASS_VALIDATE_PBUF_DROPPED;
800165f2:	82 f2       	mov %d2,-1
800165f4:	00 90       	ret 
#if IP_REASS_CHECK_OVERLAP
    } else if (iprh->start < iprh_tmp->end) {
800165f6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800165fa:	39 23 04 00 	ld.bu %d3,[%a2]4
800165fe:	39 22 05 00 	ld.bu %d2,[%a2]5
80016602:	8f 82 00 20 	sh %d2,%d2,8
80016606:	a6 32       	or %d2,%d3
80016608:	37 02 70 30 	extr.u %d3,%d2,0,16
8001660c:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80016610:	39 24 06 00 	ld.bu %d4,[%a2]6
80016614:	39 22 07 00 	ld.bu %d2,[%a2]7
80016618:	8f 82 00 20 	sh %d2,%d2,8
8001661c:	a6 42       	or %d2,%d4
8001661e:	37 02 70 20 	extr.u %d2,%d2,0,16
80016622:	7f 23 04 80 	jge.u %d3,%d2,8001662a <ip_reass_chain_frag_into_datagram_and_validate+0x37a>
      /* overlap: no need to keep the new datagram */
      return IP_REASS_VALIDATE_PBUF_DROPPED;
80016626:	82 f2       	mov %d2,-1
80016628:	00 90       	ret 
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no holes. */
      if (iprh_prev != NULL) {
8001662a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001662e:	df 02 1d 00 	jeq %d2,0,80016668 <ip_reass_chain_frag_into_datagram_and_validate+0x3b8>
        if (iprh_prev->end != iprh_tmp->start) {
80016632:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016636:	39 23 06 00 	ld.bu %d3,[%a2]6
8001663a:	39 22 07 00 	ld.bu %d2,[%a2]7
8001663e:	8f 82 00 20 	sh %d2,%d2,8
80016642:	a6 32       	or %d2,%d3
80016644:	37 02 70 30 	extr.u %d3,%d2,0,16
80016648:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8001664c:	39 24 04 00 	ld.bu %d4,[%a2]4
80016650:	39 22 05 00 	ld.bu %d2,[%a2]5
80016654:	8f 82 00 20 	sh %d2,%d2,8
80016658:	a6 42       	or %d2,%d4
8001665a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001665e:	5f 23 05 00 	jeq %d3,%d2,80016668 <ip_reass_chain_frag_into_datagram_and_validate+0x3b8>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
80016662:	82 02       	mov %d2,0
80016664:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        }
      }
    }
    q = iprh_tmp->next_pbuf;
80016668:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
8001666c:	14 23       	ld.bu %d3,[%a2]
8001666e:	39 22 01 00 	ld.bu %d2,[%a2]1
80016672:	8f 82 00 20 	sh %d2,%d2,8
80016676:	a6 32       	or %d2,%d3
80016678:	39 23 02 00 	ld.bu %d3,[%a2]2
8001667c:	8f 03 01 30 	sh %d3,%d3,16
80016680:	a6 32       	or %d2,%d3
80016682:	39 23 03 00 	ld.bu %d3,[%a2]3
80016686:	8f 83 01 30 	sh %d3,%d3,24
8001668a:	a6 32       	or %d2,%d3
8001668c:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    iprh_prev = iprh_tmp;
80016690:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80016694:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  for (q = ipr->p; q != NULL;) {
80016698:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001669c:	df 02 b8 fe 	jne %d2,0,8001640c <ip_reass_chain_frag_into_datagram_and_validate+0x15c>
800166a0:	1d 00 03 00 	j 800166a6 <ip_reass_chain_frag_into_datagram_and_validate+0x3f6>
      break;
800166a4:	00 00       	nop 
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
800166a6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800166aa:	df 02 95 80 	jne %d2,0,800167d4 <ip_reass_chain_frag_into_datagram_and_validate+0x524>
    if (iprh_prev != NULL) {
800166ae:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800166b2:	df 02 70 00 	jeq %d2,0,80016792 <ip_reass_chain_frag_into_datagram_and_validate+0x4e2>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
800166b6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800166ba:	39 23 06 00 	ld.bu %d3,[%a2]6
800166be:	39 22 07 00 	ld.bu %d2,[%a2]7
800166c2:	8f 82 00 20 	sh %d2,%d2,8
800166c6:	a6 32       	or %d2,%d3
800166c8:	37 02 70 20 	extr.u %d2,%d2,0,16
800166cc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800166d0:	39 24 04 00 	ld.bu %d4,[%a2]4
800166d4:	39 23 05 00 	ld.bu %d3,[%a2]5
800166d8:	8f 83 00 30 	sh %d3,%d3,8
800166dc:	a6 43       	or %d3,%d4
800166de:	37 03 70 30 	extr.u %d3,%d3,0,16
800166e2:	7f 23 17 80 	jge.u %d3,%d2,80016710 <ip_reass_chain_frag_into_datagram_and_validate+0x460>
800166e6:	91 00 00 28 	movh.a %a2,32768
800166ea:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
800166ee:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
800166f2:	3b 60 1b 20 	mov %d2,438
800166f6:	59 a2 04 00 	st.w [%sp]4,%d2
800166fa:	91 00 00 28 	movh.a %a2,32768
800166fe:	d9 22 0f 81 	lea %a2,[%a2]4623 <8000120f <IfxCpu_Trap_vectorTable0_end+0x101b>>
80016702:	f4 a2       	st.a [%sp],%a2
80016704:	91 00 00 28 	movh.a %a2,32768
80016708:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
8001670c:	6d ff 15 76 	call 80005336 <Ifx_Lwip_printf>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
80016710:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016714:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80016718:	8f f2 0f 21 	and %d2,%d2,255
8001671c:	82 03       	mov %d3,0
8001671e:	a6 32       	or %d2,%d3
80016720:	34 22       	st.b [%a2],%d2
80016722:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80016726:	06 82       	sh %d2,-8
80016728:	8f f2 0f 21 	and %d2,%d2,255
8001672c:	82 03       	mov %d3,0
8001672e:	a6 32       	or %d2,%d3
80016730:	e9 22 01 00 	st.b [%a2]1,%d2
80016734:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80016738:	8f 02 1f 20 	sh %d2,%d2,-16
8001673c:	8f f2 0f 21 	and %d2,%d2,255
80016740:	82 03       	mov %d3,0
80016742:	a6 32       	or %d2,%d3
80016744:	e9 22 02 00 	st.b [%a2]2,%d2
80016748:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8001674c:	8f 82 1e 20 	sh %d2,%d2,-24
80016750:	82 03       	mov %d3,0
80016752:	a6 32       	or %d2,%d3
80016754:	e9 22 03 00 	st.b [%a2]3,%d2
      if (iprh_prev->end != iprh->start) {
80016758:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001675c:	39 23 06 00 	ld.bu %d3,[%a2]6
80016760:	39 22 07 00 	ld.bu %d2,[%a2]7
80016764:	8f 82 00 20 	sh %d2,%d2,8
80016768:	a6 32       	or %d2,%d3
8001676a:	37 02 70 30 	extr.u %d3,%d2,0,16
8001676e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016772:	39 24 04 00 	ld.bu %d4,[%a2]4
80016776:	39 22 05 00 	ld.bu %d2,[%a2]5
8001677a:	8f 82 00 20 	sh %d2,%d2,8
8001677e:	a6 42       	or %d2,%d4
80016780:	37 02 70 20 	extr.u %d2,%d2,0,16
80016784:	5f 23 28 00 	jeq %d3,%d2,800167d4 <ip_reass_chain_frag_into_datagram_and_validate+0x524>
        valid = 0;
80016788:	82 02       	mov %d2,0
8001678a:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8001678e:	1d 00 23 00 	j 800167d4 <ip_reass_chain_frag_into_datagram_and_validate+0x524>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
80016792:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80016796:	b0 42       	add.a %a2,4
80016798:	54 22       	ld.w %d2,[%a2]
8001679a:	df 02 17 00 	jeq %d2,0,800167c8 <ip_reass_chain_frag_into_datagram_and_validate+0x518>
8001679e:	91 00 00 28 	movh.a %a2,32768
800167a2:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
800167a6:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
800167aa:	3b e0 1b 20 	mov %d2,446
800167ae:	59 a2 04 00 	st.w [%sp]4,%d2
800167b2:	91 00 00 28 	movh.a %a2,32768
800167b6:	d9 22 2d 81 	lea %a2,[%a2]4653 <8000122d <IfxCpu_Trap_vectorTable0_end+0x1039>>
800167ba:	f4 a2       	st.a [%sp],%a2
800167bc:	91 00 00 28 	movh.a %a2,32768
800167c0:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
800167c4:	6d ff b9 75 	call 80005336 <Ifx_Lwip_printf>
                  ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
800167c8:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800167cc:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
800167d0:	b0 42       	add.a %a2,4
800167d2:	74 22       	st.w [%a2],%d2
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
800167d4:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800167d8:	df 02 0a 80 	jne %d2,0,800167ec <ip_reass_chain_frag_into_datagram_and_validate+0x53c>
800167dc:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800167e0:	39 22 1e 00 	ld.bu %d2,[%a2]30
800167e4:	8f 12 00 21 	and %d2,%d2,1
800167e8:	df 02 e9 00 	jeq %d2,0,800169ba <ip_reass_chain_frag_into_datagram_and_validate+0x70a>
    /* and had no holes so far */
    if (valid) {
800167ec:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800167f0:	df 02 de 00 	jeq %d2,0,800169ac <ip_reass_chain_frag_into_datagram_and_validate+0x6fc>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if ((ipr->p == NULL) || (((struct ip_reass_helper *)ipr->p->payload)->start != 0)) {
800167f4:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800167f8:	b0 42       	add.a %a2,4
800167fa:	54 22       	ld.w %d2,[%a2]
800167fc:	df 02 13 00 	jeq %d2,0,80016822 <ip_reass_chain_frag_into_datagram_and_validate+0x572>
80016800:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80016804:	b0 42       	add.a %a2,4
80016806:	d4 22       	ld.a %a2,[%a2]
80016808:	b0 42       	add.a %a2,4
8001680a:	d4 22       	ld.a %a2,[%a2]
8001680c:	39 23 04 00 	ld.bu %d3,[%a2]4
80016810:	39 22 05 00 	ld.bu %d2,[%a2]5
80016814:	8f 82 00 20 	sh %d2,%d2,8
80016818:	a6 32       	or %d2,%d3
8001681a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001681e:	df 02 07 00 	jeq %d2,0,8001682c <ip_reass_chain_frag_into_datagram_and_validate+0x57c>
        valid = 0;
80016822:	82 02       	mov %d2,0
80016824:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80016828:	1d 00 c2 00 	j 800169ac <ip_reass_chain_frag_into_datagram_and_validate+0x6fc>
      } else {
        /* and check that there are no holes after this datagram */
        iprh_prev = iprh;
8001682c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80016830:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        q = iprh->next_pbuf;
80016834:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016838:	14 23       	ld.bu %d3,[%a2]
8001683a:	39 22 01 00 	ld.bu %d2,[%a2]1
8001683e:	8f 82 00 20 	sh %d2,%d2,8
80016842:	a6 32       	or %d2,%d3
80016844:	39 23 02 00 	ld.bu %d3,[%a2]2
80016848:	8f 03 01 30 	sh %d3,%d3,16
8001684c:	a6 32       	or %d2,%d3
8001684e:	39 23 03 00 	ld.bu %d3,[%a2]3
80016852:	8f 83 01 30 	sh %d3,%d3,24
80016856:	a6 32       	or %d2,%d3
80016858:	59 e2 f4 ff 	st.w [%a14]-12,%d2
        while (q != NULL) {
8001685c:	1d 00 3d 00 	j 800168d6 <ip_reass_chain_frag_into_datagram_and_validate+0x626>
          iprh = (struct ip_reass_helper *)q->payload;
80016860:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80016864:	b0 42       	add.a %a2,4
80016866:	54 22       	ld.w %d2,[%a2]
80016868:	59 e2 fc ff 	st.w [%a14]-4,%d2
          if (iprh_prev->end != iprh->start) {
8001686c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016870:	39 23 06 00 	ld.bu %d3,[%a2]6
80016874:	39 22 07 00 	ld.bu %d2,[%a2]7
80016878:	8f 82 00 20 	sh %d2,%d2,8
8001687c:	a6 32       	or %d2,%d3
8001687e:	37 02 70 30 	extr.u %d3,%d2,0,16
80016882:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016886:	39 24 04 00 	ld.bu %d4,[%a2]4
8001688a:	39 22 05 00 	ld.bu %d2,[%a2]5
8001688e:	8f 82 00 20 	sh %d2,%d2,8
80016892:	a6 42       	or %d2,%d4
80016894:	37 02 70 20 	extr.u %d2,%d2,0,16
80016898:	5f 23 07 00 	jeq %d3,%d2,800168a6 <ip_reass_chain_frag_into_datagram_and_validate+0x5f6>
            valid = 0;
8001689c:	82 02       	mov %d2,0
8001689e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
            break;
800168a2:	1d 00 1e 00 	j 800168de <ip_reass_chain_frag_into_datagram_and_validate+0x62e>
          }
          iprh_prev = iprh;
800168a6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800168aa:	59 e2 f8 ff 	st.w [%a14]-8,%d2
          q = iprh->next_pbuf;
800168ae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800168b2:	14 23       	ld.bu %d3,[%a2]
800168b4:	39 22 01 00 	ld.bu %d2,[%a2]1
800168b8:	8f 82 00 20 	sh %d2,%d2,8
800168bc:	a6 32       	or %d2,%d3
800168be:	39 23 02 00 	ld.bu %d3,[%a2]2
800168c2:	8f 03 01 30 	sh %d3,%d3,16
800168c6:	a6 32       	or %d2,%d3
800168c8:	39 23 03 00 	ld.bu %d3,[%a2]3
800168cc:	8f 83 01 30 	sh %d3,%d3,24
800168d0:	a6 32       	or %d2,%d3
800168d2:	59 e2 f4 ff 	st.w [%a14]-12,%d2
        while (q != NULL) {
800168d6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800168da:	df 02 c3 ff 	jne %d2,0,80016860 <ip_reass_chain_frag_into_datagram_and_validate+0x5b0>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
800168de:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800168e2:	df 02 65 00 	jeq %d2,0,800169ac <ip_reass_chain_frag_into_datagram_and_validate+0x6fc>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
800168e6:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800168ea:	b0 42       	add.a %a2,4
800168ec:	54 22       	ld.w %d2,[%a2]
800168ee:	df 02 17 80 	jne %d2,0,8001691c <ip_reass_chain_frag_into_datagram_and_validate+0x66c>
800168f2:	91 00 00 28 	movh.a %a2,32768
800168f6:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
800168fa:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
800168fe:	3b f0 1d 20 	mov %d2,479
80016902:	59 a2 04 00 	st.w [%sp]4,%d2
80016906:	91 00 00 28 	movh.a %a2,32768
8001690a:	d9 22 24 91 	lea %a2,[%a2]4708 <80001264 <IfxCpu_Trap_vectorTable0_end+0x1070>>
8001690e:	f4 a2       	st.a [%sp],%a2
80016910:	91 00 00 28 	movh.a %a2,32768
80016914:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80016918:	6d ff 0f 75 	call 80005336 <Ifx_Lwip_printf>
          LWIP_ASSERT("sanity check",
8001691c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80016920:	b0 42       	add.a %a2,4
80016922:	d4 22       	ld.a %a2,[%a2]
80016924:	b0 42       	add.a %a2,4
80016926:	54 22       	ld.w %d2,[%a2]
80016928:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8001692c:	5f 23 17 80 	jne %d3,%d2,8001695a <ip_reass_chain_frag_into_datagram_and_validate+0x6aa>
80016930:	91 00 00 28 	movh.a %a2,32768
80016934:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80016938:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
8001693c:	3b 00 1e 20 	mov %d2,480
80016940:	59 a2 04 00 	st.w [%sp]4,%d2
80016944:	91 00 00 28 	movh.a %a2,32768
80016948:	d9 22 24 91 	lea %a2,[%a2]4708 <80001264 <IfxCpu_Trap_vectorTable0_end+0x1070>>
8001694c:	f4 a2       	st.a [%sp],%a2
8001694e:	91 00 00 28 	movh.a %a2,32768
80016952:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80016956:	6d ff f0 74 	call 80005336 <Ifx_Lwip_printf>
                      ((struct ip_reass_helper *)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
8001695a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001695e:	14 23       	ld.bu %d3,[%a2]
80016960:	39 22 01 00 	ld.bu %d2,[%a2]1
80016964:	8f 82 00 20 	sh %d2,%d2,8
80016968:	a6 32       	or %d2,%d3
8001696a:	39 23 02 00 	ld.bu %d3,[%a2]2
8001696e:	8f 03 01 30 	sh %d3,%d3,16
80016972:	a6 32       	or %d2,%d3
80016974:	39 23 03 00 	ld.bu %d3,[%a2]3
80016978:	8f 83 01 30 	sh %d3,%d3,24
8001697c:	a6 32       	or %d2,%d3
8001697e:	df 02 17 00 	jeq %d2,0,800169ac <ip_reass_chain_frag_into_datagram_and_validate+0x6fc>
80016982:	91 00 00 28 	movh.a %a2,32768
80016986:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
8001698a:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
8001698e:	3b 20 1e 20 	mov %d2,482
80016992:	59 a2 04 00 	st.w [%sp]4,%d2
80016996:	91 00 00 28 	movh.a %a2,32768
8001699a:	d9 22 31 91 	lea %a2,[%a2]4721 <80001271 <IfxCpu_Trap_vectorTable0_end+0x107d>>
8001699e:	f4 a2       	st.a [%sp],%a2
800169a0:	91 00 00 28 	movh.a %a2,32768
800169a4:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
800169a8:	6d ff c7 74 	call 80005336 <Ifx_Lwip_printf>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
800169ac:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800169b0:	8b 02 20 22 	ne %d2,%d2,0
800169b4:	8f f2 0f 21 	and %d2,%d2,255
800169b8:	00 90       	ret 
  }
  /* If we come here, not all fragments were received, yet! */
  return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
800169ba:	82 02       	mov %d2,0
}
800169bc:	00 90       	ret 

800169be <ip4_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip4_reass(struct pbuf *p)
{
800169be:	40 ae       	mov.aa %a14,%sp
800169c0:	20 48       	sub.a %sp,72
800169c2:	b5 e4 cc ff 	st.a [%a14]-52,%a4
  u16_t offset, len, clen;
  u8_t hlen;
  int valid;
  int is_last;

  IPFRAG_STATS_INC(ip_frag.recv);
800169c6:	91 10 00 27 	movh.a %a2,28673
800169ca:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800169ce:	b9 22 32 00 	ld.hu %d2,[%a2]50 <70010032 <ram_heap+0x4f9e>>
800169d2:	c2 12       	add %d2,1
800169d4:	37 02 70 20 	extr.u %d2,%d2,0,16
800169d8:	91 10 00 27 	movh.a %a2,28673
800169dc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800169e0:	f9 22 32 00 	st.h [%a2]50 <70010032 <ram_heap+0x4f9e>>,%d2
  MIB2_STATS_INC(mib2.ipreasmreqds);

  fraghdr = (struct ip_hdr *)p->payload;
800169e4:	99 e2 cc ff 	ld.a %a2,[%a14]-52 <70010032 <ram_heap+0x4f9e>>
800169e8:	b0 42       	add.a %a2,4
800169ea:	54 22       	ld.w %d2,[%a2]
800169ec:	59 e2 f0 ff 	st.w [%a14]-16,%d2

  if (IPH_HL_BYTES(fraghdr) != IP_HLEN) {
800169f0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800169f4:	14 22       	ld.bu %d2,[%a2]
800169f6:	8f f2 00 21 	and %d2,%d2,15
800169fa:	8f f2 0f 21 	and %d2,%d2,255
800169fe:	06 22       	sh %d2,2
80016a00:	8f f2 0f 21 	and %d2,%d2,255
80016a04:	8b 42 01 22 	eq %d2,%d2,20
80016a08:	df 02 13 80 	jne %d2,0,80016a2e <ip4_reass+0x70>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
80016a0c:	91 10 00 27 	movh.a %a2,28673
80016a10:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80016a14:	b9 22 04 10 	ld.hu %d2,[%a2]68 <70010044 <ram_heap+0x4fb0>>
80016a18:	c2 12       	add %d2,1
80016a1a:	37 02 70 20 	extr.u %d2,%d2,0,16
80016a1e:	91 10 00 27 	movh.a %a2,28673
80016a22:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80016a26:	f9 22 04 10 	st.h [%a2]68 <70010044 <ram_heap+0x4fb0>>,%d2
    goto nullreturn;
80016a2a:	1d 00 e8 02 	j 80016ffa <ip4_reass+0x63c>
  }

  offset = IPH_OFFSET_BYTES(fraghdr);
80016a2e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016a32:	39 23 06 00 	ld.bu %d3,[%a2]6
80016a36:	39 22 07 00 	ld.bu %d2,[%a2]7
80016a3a:	8f 82 00 20 	sh %d2,%d2,8
80016a3e:	a6 32       	or %d2,%d3
80016a40:	37 02 70 20 	extr.u %d2,%d2,0,16
80016a44:	02 24       	mov %d4,%d2
80016a46:	6d 00 87 05 	call 80017554 <lwip_htons>
80016a4a:	02 23       	mov %d3,%d2
80016a4c:	3b f0 ff 21 	mov %d2,8191
80016a50:	26 32       	and %d2,%d3
80016a52:	37 02 70 20 	extr.u %d2,%d2,0,16
80016a56:	06 32       	sh %d2,3
80016a58:	f9 e2 ee ff 	st.h [%a14]-18,%d2
  len = lwip_ntohs(IPH_LEN(fraghdr));
80016a5c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016a60:	39 23 02 00 	ld.bu %d3,[%a2]2
80016a64:	39 22 03 00 	ld.bu %d2,[%a2]3
80016a68:	8f 82 00 20 	sh %d2,%d2,8
80016a6c:	a6 32       	or %d2,%d3
80016a6e:	37 02 70 20 	extr.u %d2,%d2,0,16
80016a72:	02 24       	mov %d4,%d2
80016a74:	6d 00 70 05 	call 80017554 <lwip_htons>
80016a78:	f9 e2 ec ff 	st.h [%a14]-20,%d2
  hlen = IPH_HL_BYTES(fraghdr);
80016a7c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016a80:	14 22       	ld.bu %d2,[%a2]
80016a82:	8f f2 00 21 	and %d2,%d2,15
80016a86:	8f f2 0f 21 	and %d2,%d2,255
80016a8a:	06 22       	sh %d2,2
80016a8c:	e9 e2 eb ff 	st.b [%a14]-21,%d2
  if (hlen > len) {
80016a90:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80016a94:	37 02 70 20 	extr.u %d2,%d2,0,16
80016a98:	b9 e3 ec ff 	ld.hu %d3,[%a14]-20
80016a9c:	3f 23 ab 82 	jlt.u %d3,%d2,80016ff2 <ip4_reass+0x634>
    /* invalid datagram */
    goto nullreturn;
  }
  len = (u16_t)(len - hlen);
80016aa0:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80016aa4:	37 02 70 20 	extr.u %d2,%d2,0,16
80016aa8:	c9 e3 ec ff 	ld.h %d3,[%a14]-20
80016aac:	0b 23 80 20 	sub %d2,%d3,%d2
80016ab0:	f9 e2 ec ff 	st.h [%a14]-20,%d2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
80016ab4:	99 e4 cc ff 	ld.a %a4,[%a14]-52
80016ab8:	6d 00 53 1b 	call 8001a15e <pbuf_clen>
80016abc:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
80016ac0:	91 10 00 27 	movh.a %a2,28673
80016ac4:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80016ac8:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80016acc:	02 23       	mov %d3,%d2
80016ace:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
80016ad2:	42 32       	add %d2,%d3
80016ad4:	8b b2 40 22 	lt %d2,%d2,11
80016ad8:	df 02 2a 80 	jne %d2,0,80016b2c <ip4_reass+0x16e>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
80016adc:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
80016ae0:	02 24       	mov %d4,%d2
80016ae2:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80016ae6:	6d ff 8d fa 	call 80016000 <ip_reass_remove_oldest_datagram>
80016aea:	df 02 10 00 	jeq %d2,0,80016b0a <ip4_reass+0x14c>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
80016aee:	91 10 00 27 	movh.a %a2,28673
80016af2:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80016af6:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80016afa:	02 23       	mov %d3,%d2
80016afc:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
80016b00:	42 32       	add %d2,%d3
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
80016b02:	8b b2 40 22 	lt %d2,%d2,11
80016b06:	df 02 13 80 	jne %d2,0,80016b2c <ip4_reass+0x16e>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
                                   ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
80016b0a:	91 10 00 27 	movh.a %a2,28673
80016b0e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80016b12:	b9 22 3c 00 	ld.hu %d2,[%a2]60 <7001003c <ram_heap+0x4fa8>>
80016b16:	c2 12       	add %d2,1
80016b18:	37 02 70 20 	extr.u %d2,%d2,0,16
80016b1c:	91 10 00 27 	movh.a %a2,28673
80016b20:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80016b24:	f9 22 3c 00 	st.h [%a2]60 <7001003c <ram_heap+0x4fa8>>,%d2
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
80016b28:	1d 00 69 02 	j 80016ffa <ip4_reass+0x63c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
80016b2c:	91 10 00 27 	movh.a %a2,28673
80016b30:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
80016b34:	54 22       	ld.w %d2,[%a2]
80016b36:	59 e2 f8 ff 	st.w [%a14]-8 <7000b074 <reassdatagrams>>,%d2
80016b3a:	1d 00 5d 00 	j 80016bf4 <ip4_reass+0x236>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
80016b3e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016b42:	d9 22 14 00 	lea %a2,[%a2]20
80016b46:	54 24       	ld.w %d4,[%a2]
80016b48:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016b4c:	39 23 0c 00 	ld.bu %d3,[%a2]12
80016b50:	39 22 0d 00 	ld.bu %d2,[%a2]13
80016b54:	8f 82 00 20 	sh %d2,%d2,8
80016b58:	a6 32       	or %d2,%d3
80016b5a:	39 23 0e 00 	ld.bu %d3,[%a2]14
80016b5e:	8f 03 01 30 	sh %d3,%d3,16
80016b62:	a6 32       	or %d2,%d3
80016b64:	39 23 0f 00 	ld.bu %d3,[%a2]15
80016b68:	8f 83 01 30 	sh %d3,%d3,24
80016b6c:	a6 32       	or %d2,%d3
80016b6e:	5f 24 3e 80 	jne %d4,%d2,80016bea <ip4_reass+0x22c>
80016b72:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016b76:	d9 22 18 00 	lea %a2,[%a2]24
80016b7a:	54 24       	ld.w %d4,[%a2]
80016b7c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016b80:	39 23 10 00 	ld.bu %d3,[%a2]16
80016b84:	39 22 11 00 	ld.bu %d2,[%a2]17
80016b88:	8f 82 00 20 	sh %d2,%d2,8
80016b8c:	a6 32       	or %d2,%d3
80016b8e:	39 23 12 00 	ld.bu %d3,[%a2]18
80016b92:	8f 03 01 30 	sh %d3,%d3,16
80016b96:	a6 32       	or %d2,%d3
80016b98:	39 23 13 00 	ld.bu %d3,[%a2]19
80016b9c:	8f 83 01 30 	sh %d3,%d3,24
80016ba0:	a6 32       	or %d2,%d3
80016ba2:	5f 24 24 80 	jne %d4,%d2,80016bea <ip4_reass+0x22c>
80016ba6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016baa:	b9 23 0c 00 	ld.hu %d3,[%a2]12
80016bae:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016bb2:	39 24 04 00 	ld.bu %d4,[%a2]4
80016bb6:	39 22 05 00 	ld.bu %d2,[%a2]5
80016bba:	8f 82 00 20 	sh %d2,%d2,8
80016bbe:	a6 42       	or %d2,%d4
80016bc0:	37 02 70 20 	extr.u %d2,%d2,0,16
80016bc4:	5f 23 13 80 	jne %d3,%d2,80016bea <ip4_reass+0x22c>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
                                   lwip_ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
80016bc8:	91 10 00 27 	movh.a %a2,28673
80016bcc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80016bd0:	b9 22 06 10 	ld.hu %d2,[%a2]70 <70010046 <ram_heap+0x4fb2>>
80016bd4:	c2 12       	add %d2,1
80016bd6:	37 02 70 20 	extr.u %d2,%d2,0,16
80016bda:	91 10 00 27 	movh.a %a2,28673
80016bde:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80016be2:	f9 22 06 10 	st.h [%a2]70 <70010046 <ram_heap+0x4fb2>>,%d2
      break;
80016be6:	1d 00 0b 00 	j 80016bfc <ip4_reass+0x23e>
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
80016bea:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016bee:	54 22       	ld.w %d2,[%a2]
80016bf0:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80016bf4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016bf8:	df 02 a3 ff 	jne %d2,0,80016b3e <ip4_reass+0x180>
    }
  }

  if (ipr == NULL) {
80016bfc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016c00:	df 02 11 80 	jne %d2,0,80016c22 <ip4_reass+0x264>
    /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
80016c04:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
80016c08:	02 24       	mov %d4,%d2
80016c0a:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80016c0e:	6d ff b3 fa 	call 80016174 <ip_reass_enqueue_new_datagram>
80016c12:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
    /* Bail if unable to enqueue */
    if (ipr == NULL) {
80016c16:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016c1a:	df 02 30 80 	jne %d2,0,80016c7a <ip4_reass+0x2bc>
      goto nullreturn;
80016c1e:	1d 00 ee 01 	j 80016ffa <ip4_reass+0x63c>
    }
  } else {
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
80016c22:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016c26:	39 23 06 00 	ld.bu %d3,[%a2]6
80016c2a:	39 22 07 00 	ld.bu %d2,[%a2]7
80016c2e:	8f 82 00 20 	sh %d2,%d2,8
80016c32:	a6 32       	or %d2,%d3
80016c34:	37 02 70 20 	extr.u %d2,%d2,0,16
80016c38:	02 24       	mov %d4,%d2
80016c3a:	6d 00 8d 04 	call 80017554 <lwip_htons>
80016c3e:	02 23       	mov %d3,%d2
80016c40:	3b f0 ff 21 	mov %d2,8191
80016c44:	26 32       	and %d2,%d3
80016c46:	df 02 1a 80 	jne %d2,0,80016c7a <ip4_reass+0x2bc>
        ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
80016c4a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016c4e:	b9 22 0e 00 	ld.hu %d2,[%a2]14
80016c52:	02 24       	mov %d4,%d2
80016c54:	6d 00 80 04 	call 80017554 <lwip_htons>
80016c58:	02 23       	mov %d3,%d2
80016c5a:	3b f0 ff 21 	mov %d2,8191
80016c5e:	26 32       	and %d2,%d3
    if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
80016c60:	df 02 0d 00 	jeq %d2,0,80016c7a <ip4_reass+0x2bc>
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
80016c64:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016c68:	1b 82 00 20 	addi %d2,%d2,8
80016c6c:	3b 40 01 40 	mov %d4,20
80016c70:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
80016c74:	60 24       	mov.a %a4,%d2
80016c76:	6d 00 d3 82 	call 8002721c <memcpy>

  /* At this point, we have either created a new entry or pointing
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
80016c7a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016c7e:	39 23 06 00 	ld.bu %d3,[%a2]6
80016c82:	39 22 07 00 	ld.bu %d2,[%a2]7
80016c86:	8f 82 00 20 	sh %d2,%d2,8
80016c8a:	a6 32       	or %d2,%d3
80016c8c:	37 02 70 20 	extr.u %d2,%d2,0,16
80016c90:	8f 02 02 21 	and %d2,%d2,32
80016c94:	8b 02 00 22 	eq %d2,%d2,0
80016c98:	8f f2 0f 21 	and %d2,%d2,255
80016c9c:	59 e2 e4 ff 	st.w [%a14]-28,%d2
  if (is_last) {
80016ca0:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80016ca4:	df 02 15 00 	jeq %d2,0,80016cce <ip4_reass+0x310>
    u16_t datagram_len = (u16_t)(offset + len);
80016ca8:	c9 e3 ee ff 	ld.h %d3,[%a14]-18
80016cac:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
80016cb0:	42 32       	add %d2,%d3
80016cb2:	f9 e2 e2 ff 	st.h [%a14]-30,%d2
    if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
80016cb6:	b9 e3 e2 ff 	ld.hu %d3,[%a14]-30
80016cba:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80016cbe:	3f 23 52 81 	jlt.u %d3,%d2,80016f62 <ip4_reass+0x5a4>
80016cc2:	b9 e2 e2 ff 	ld.hu %d2,[%a14]-30
80016cc6:	bb c0 fe 3f 	mov.u %d3,65516
80016cca:	7f 32 4c 81 	jge.u %d2,%d3,80016f62 <ip4_reass+0x5a4>
      goto nullreturn_ipr;
    }
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
80016cce:	19 e4 e4 ff 	ld.w %d4,[%a14]-28
80016cd2:	99 e5 cc ff 	ld.a %a5,[%a14]-52
80016cd6:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80016cda:	6d ff eb fa 	call 800162b0 <ip_reass_chain_frag_into_datagram_and_validate>
80016cde:	59 e2 dc ff 	st.w [%a14]-36,%d2
  if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
80016ce2:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80016ce6:	df f2 41 01 	jeq %d2,-1,80016f68 <ip4_reass+0x5aa>
  /* if we come here, the pbuf has been enqueued */

  /* Track the current number of pbufs current 'in-flight', in order to limit
     the number of fragments that may be enqueued at any one time
     (overflow checked by testing against IP_REASS_MAX_PBUFS) */
  ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
80016cea:	91 10 00 27 	movh.a %a2,28673
80016cee:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80016cf2:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80016cf6:	c9 e2 e8 ff 	ld.h %d2,[%a14]-24 <70010000 <ram_heap+0x4f6c>>
80016cfa:	42 32       	add %d2,%d3
80016cfc:	37 02 70 20 	extr.u %d2,%d2,0,16
80016d00:	91 10 00 27 	movh.a %a2,28673
80016d04:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80016d08:	b4 22       	st.h [%a2],%d2
  if (is_last) {
80016d0a:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <7000b078 <ip_reass_pbufcount>>
80016d0e:	df 02 1b 00 	jeq %d2,0,80016d44 <ip4_reass+0x386>
    u16_t datagram_len = (u16_t)(offset + len);
80016d12:	c9 e3 ee ff 	ld.h %d3,[%a14]-18
80016d16:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
80016d1a:	42 32       	add %d2,%d3
80016d1c:	f9 e2 da ff 	st.h [%a14]-38,%d2
    ipr->datagram_len = datagram_len;
80016d20:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016d24:	c9 e2 da ff 	ld.h %d2,[%a14]-38
80016d28:	f9 22 1c 00 	st.h [%a2]28,%d2
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
80016d2c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016d30:	39 22 1e 00 	ld.bu %d2,[%a2]30
80016d34:	8f 12 40 21 	or %d2,%d2,1
80016d38:	8f f2 0f 21 	and %d2,%d2,255
80016d3c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016d40:	e9 22 1e 00 	st.b [%a2]30,%d2
    LWIP_DEBUGF(IP_REASS_DEBUG,
                ("ip4_reass: last fragment seen, total len %"S16_F"\n",
                 ipr->datagram_len));
  }

  if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
80016d44:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80016d48:	df 12 0a 81 	jne %d2,1,80016f5c <ip4_reass+0x59e>
    struct ip_reassdata *ipr_prev;
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    u16_t datagram_len = (u16_t)(ipr->datagram_len + IP_HLEN);
80016d4c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016d50:	b9 22 1c 00 	ld.hu %d2,[%a2]28
80016d54:	1b 42 01 20 	addi %d2,%d2,20
80016d58:	f9 e2 d8 ff 	st.h [%a14]-40,%d2

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper *)ipr->p->payload)->next_pbuf;
80016d5c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016d60:	b0 42       	add.a %a2,4
80016d62:	d4 22       	ld.a %a2,[%a2]
80016d64:	b0 42       	add.a %a2,4
80016d66:	d4 22       	ld.a %a2,[%a2]
80016d68:	14 23       	ld.bu %d3,[%a2]
80016d6a:	39 22 01 00 	ld.bu %d2,[%a2]1
80016d6e:	8f 82 00 20 	sh %d2,%d2,8
80016d72:	a6 32       	or %d2,%d3
80016d74:	39 23 02 00 	ld.bu %d3,[%a2]2
80016d78:	8f 03 01 30 	sh %d3,%d3,16
80016d7c:	a6 32       	or %d2,%d3
80016d7e:	39 23 03 00 	ld.bu %d3,[%a2]3
80016d82:	8f 83 01 30 	sh %d3,%d3,24
80016d86:	a6 32       	or %d2,%d3
80016d88:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr *)(ipr->p->payload);
80016d8c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016d90:	b0 42       	add.a %a2,4
80016d92:	d4 22       	ld.a %a2,[%a2]
80016d94:	b0 42       	add.a %a2,4
80016d96:	54 22       	ld.w %d2,[%a2]
80016d98:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
80016d9c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016da0:	1b 82 00 20 	addi %d2,%d2,8
80016da4:	3b 40 01 40 	mov %d4,20
80016da8:	60 25       	mov.a %a5,%d2
80016daa:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80016dae:	6d 00 37 82 	call 8002721c <memcpy>
    IPH_LEN_SET(fraghdr, lwip_htons(datagram_len));
80016db2:	b9 e2 d8 ff 	ld.hu %d2,[%a14]-40
80016db6:	02 24       	mov %d4,%d2
80016db8:	6d 00 ce 03 	call 80017554 <lwip_htons>
80016dbc:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016dc0:	8f f2 0f 31 	and %d3,%d2,255
80016dc4:	82 04       	mov %d4,0
80016dc6:	a6 43       	or %d3,%d4
80016dc8:	e9 23 02 00 	st.b [%a2]2,%d3
80016dcc:	06 82       	sh %d2,-8
80016dce:	37 02 70 20 	extr.u %d2,%d2,0,16
80016dd2:	82 03       	mov %d3,0
80016dd4:	a6 32       	or %d2,%d3
80016dd6:	e9 22 03 00 	st.b [%a2]3,%d2
    IPH_OFFSET_SET(fraghdr, 0);
80016dda:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016dde:	82 02       	mov %d2,0
80016de0:	e9 22 06 00 	st.b [%a2]6,%d2
80016de4:	82 02       	mov %d2,0
80016de6:	e9 22 07 00 	st.b [%a2]7,%d2
    IPH_CHKSUM_SET(fraghdr, 0);
80016dea:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016dee:	82 02       	mov %d2,0
80016df0:	e9 22 0a 00 	st.b [%a2]10,%d2
80016df4:	82 02       	mov %d2,0
80016df6:	e9 22 0b 00 	st.b [%a2]11,%d2
    /* @todo: do we need to set/calculate the correct checksum? */
#if CHECKSUM_GEN_IP
    IF__NETIF_CHECKSUM_ENABLED(ip_current_input_netif(), NETIF_CHECKSUM_GEN_IP) {
      IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
80016dfa:	3b 40 01 40 	mov %d4,20
80016dfe:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80016e02:	6d 00 91 05 	call 80017924 <inet_chksum>
80016e06:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80016e0a:	8f f2 0f 31 	and %d3,%d2,255
80016e0e:	82 04       	mov %d4,0
80016e10:	a6 43       	or %d3,%d4
80016e12:	e9 23 0a 00 	st.b [%a2]10,%d3
80016e16:	06 82       	sh %d2,-8
80016e18:	37 02 70 20 	extr.u %d2,%d2,0,16
80016e1c:	82 03       	mov %d3,0
80016e1e:	a6 32       	or %d2,%d3
80016e20:	e9 22 0b 00 	st.b [%a2]11,%d2
    }
#endif /* CHECKSUM_GEN_IP */

    p = ipr->p;
80016e24:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016e28:	b0 42       	add.a %a2,4
80016e2a:	54 22       	ld.w %d2,[%a2]
80016e2c:	59 e2 cc ff 	st.w [%a14]-52,%d2

    /* chain together the pbufs contained within the reass_data list. */
    while (r != NULL) {
80016e30:	1d 00 28 00 	j 80016e80 <ip4_reass+0x4c2>
      iprh = (struct ip_reass_helper *)r->payload;
80016e34:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80016e38:	b0 42       	add.a %a2,4
80016e3a:	54 22       	ld.w %d2,[%a2]
80016e3c:	59 e2 d4 ff 	st.w [%a14]-44,%d2

      /* hide the ip header for every succeeding fragment */
      pbuf_remove_header(r, IP_HLEN);
80016e40:	3b 40 01 40 	mov %d4,20
80016e44:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80016e48:	6d 00 e2 17 	call 80019e0c <pbuf_remove_header>
      pbuf_cat(p, r);
80016e4c:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80016e50:	99 e4 cc ff 	ld.a %a4,[%a14]-52
80016e54:	6d 00 cf 19 	call 8001a1f2 <pbuf_cat>
      r = iprh->next_pbuf;
80016e58:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80016e5c:	14 23       	ld.bu %d3,[%a2]
80016e5e:	39 22 01 00 	ld.bu %d2,[%a2]1
80016e62:	8f 82 00 20 	sh %d2,%d2,8
80016e66:	a6 32       	or %d2,%d3
80016e68:	39 23 02 00 	ld.bu %d3,[%a2]2
80016e6c:	8f 03 01 30 	sh %d3,%d3,16
80016e70:	a6 32       	or %d2,%d3
80016e72:	39 23 03 00 	ld.bu %d3,[%a2]3
80016e76:	8f 83 01 30 	sh %d3,%d3,24
80016e7a:	a6 32       	or %d2,%d3
80016e7c:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    while (r != NULL) {
80016e80:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80016e84:	df 02 d8 ff 	jne %d2,0,80016e34 <ip4_reass+0x476>
    }

    /* find the previous entry in the linked list */
    if (ipr == reassdatagrams) {
80016e88:	91 10 00 27 	movh.a %a2,28673
80016e8c:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
80016e90:	54 22       	ld.w %d2,[%a2]
80016e92:	19 e3 f8 ff 	ld.w %d3,[%a14]-8 <7000b074 <reassdatagrams>>
80016e96:	5f 23 07 80 	jne %d3,%d2,80016ea4 <ip4_reass+0x4e6>
      ipr_prev = NULL;
80016e9a:	82 02       	mov %d2,0
80016e9c:	59 e2 fc ff 	st.w [%a14]-4,%d2
80016ea0:	1d 00 1e 00 	j 80016edc <ip4_reass+0x51e>
    } else {
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
80016ea4:	91 10 00 27 	movh.a %a2,28673
80016ea8:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
80016eac:	54 22       	ld.w %d2,[%a2]
80016eae:	59 e2 fc ff 	st.w [%a14]-4 <7000b074 <reassdatagrams>>,%d2
80016eb2:	1d 00 0e 00 	j 80016ece <ip4_reass+0x510>
        if (ipr_prev->next == ipr) {
80016eb6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016eba:	54 22       	ld.w %d2,[%a2]
80016ebc:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80016ec0:	5f 23 0d 00 	jeq %d3,%d2,80016eda <ip4_reass+0x51c>
      for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
80016ec4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80016ec8:	54 22       	ld.w %d2,[%a2]
80016eca:	59 e2 fc ff 	st.w [%a14]-4,%d2
80016ece:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80016ed2:	df 02 f2 ff 	jne %d2,0,80016eb6 <ip4_reass+0x4f8>
80016ed6:	1d 00 03 00 	j 80016edc <ip4_reass+0x51e>
          break;
80016eda:	00 00       	nop 
        }
      }
    }

    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
80016edc:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80016ee0:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80016ee4:	6d ff a7 f9 	call 80016232 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    clen = pbuf_clen(p);
80016ee8:	99 e4 cc ff 	ld.a %a4,[%a14]-52
80016eec:	6d 00 39 19 	call 8001a15e <pbuf_clen>
80016ef0:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
    LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= clen);
80016ef4:	91 10 00 27 	movh.a %a2,28673
80016ef8:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80016efc:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80016f00:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24 <70010000 <ram_heap+0x4f6c>>
80016f04:	7f 23 17 80 	jge.u %d3,%d2,80016f32 <ip4_reass+0x574>
80016f08:	91 00 00 28 	movh.a %a2,32768
80016f0c:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80016f10:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80016f14:	3b b0 29 20 	mov %d2,667
80016f18:	59 a2 04 00 	st.w [%sp]4,%d2
80016f1c:	91 00 00 28 	movh.a %a2,32768
80016f20:	d9 22 13 a1 	lea %a2,[%a2]4755 <80001293 <IfxCpu_Trap_vectorTable0_end+0x109f>>
80016f24:	f4 a2       	st.a [%sp],%a2
80016f26:	91 00 00 28 	movh.a %a2,32768
80016f2a:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80016f2e:	6d ff 04 72 	call 80005336 <Ifx_Lwip_printf>
    ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount - clen);
80016f32:	91 10 00 27 	movh.a %a2,28673
80016f36:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80016f3a:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80016f3e:	c9 e2 e8 ff 	ld.h %d2,[%a14]-24 <70010000 <ram_heap+0x4f6c>>
80016f42:	0b 23 80 20 	sub %d2,%d3,%d2
80016f46:	37 02 70 20 	extr.u %d2,%d2,0,16
80016f4a:	91 10 00 27 	movh.a %a2,28673
80016f4e:	d9 22 38 1b 	lea %a2,[%a2]-20360 <7000b078 <ip_reass_pbufcount>>
80016f52:	b4 22       	st.h [%a2],%d2

    MIB2_STATS_INC(mib2.ipreasmoks);

    /* Return the pbuf chain */
    return p;
80016f54:	19 e2 cc ff 	ld.w %d2,[%a14]-52 <7000b078 <ip_reass_pbufcount>>
80016f58:	1d 00 65 00 	j 80017022 <ip4_reass+0x664>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
80016f5c:	82 02       	mov %d2,0
80016f5e:	1d 00 62 00 	j 80017022 <ip4_reass+0x664>
      goto nullreturn_ipr;
80016f62:	00 00       	nop 
80016f64:	1d 00 03 00 	j 80016f6a <ip4_reass+0x5ac>
    goto nullreturn_ipr;
80016f68:	00 00       	nop 

nullreturn_ipr:
  LWIP_ASSERT("ipr != NULL", ipr != NULL);
80016f6a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80016f6e:	df 02 17 80 	jne %d2,0,80016f9c <ip4_reass+0x5de>
80016f72:	91 00 00 28 	movh.a %a2,32768
80016f76:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80016f7a:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80016f7e:	3b 80 2a 20 	mov %d2,680
80016f82:	59 a2 04 00 	st.w [%sp]4,%d2
80016f86:	91 00 00 28 	movh.a %a2,32768
80016f8a:	d9 22 2e a1 	lea %a2,[%a2]4782 <800012ae <IfxCpu_Trap_vectorTable0_end+0x10ba>>
80016f8e:	f4 a2       	st.a [%sp],%a2
80016f90:	91 00 00 28 	movh.a %a2,32768
80016f94:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80016f98:	6d ff cf 71 	call 80005336 <Ifx_Lwip_printf>
  if (ipr->p == NULL) {
80016f9c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80016fa0:	b0 42       	add.a %a2,4
80016fa2:	54 22       	ld.w %d2,[%a2]
80016fa4:	df 02 2a 80 	jne %d2,0,80016ff8 <ip4_reass+0x63a>
    /* dropped pbuf after creating a new datagram entry: remove the entry, too */
    LWIP_ASSERT("not firstalthough just enqueued", ipr == reassdatagrams);
80016fa8:	91 10 00 27 	movh.a %a2,28673
80016fac:	d9 22 34 1b 	lea %a2,[%a2]-20364 <7000b074 <reassdatagrams>>
80016fb0:	54 22       	ld.w %d2,[%a2]
80016fb2:	19 e3 f8 ff 	ld.w %d3,[%a14]-8 <7000b074 <reassdatagrams>>
80016fb6:	5f 23 17 00 	jeq %d3,%d2,80016fe4 <ip4_reass+0x626>
80016fba:	91 00 00 28 	movh.a %a2,32768
80016fbe:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80016fc2:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80016fc6:	3b b0 2a 20 	mov %d2,683
80016fca:	59 a2 04 00 	st.w [%sp]4,%d2
80016fce:	91 00 00 28 	movh.a %a2,32768
80016fd2:	d9 22 3a a1 	lea %a2,[%a2]4794 <800012ba <IfxCpu_Trap_vectorTable0_end+0x10c6>>
80016fd6:	f4 a2       	st.a [%sp],%a2
80016fd8:	91 00 00 28 	movh.a %a2,32768
80016fdc:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80016fe0:	6d ff ab 71 	call 80005336 <Ifx_Lwip_printf>
    ip_reass_dequeue_datagram(ipr, NULL);
80016fe4:	a0 05       	mov.a %a5,0
80016fe6:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80016fea:	6d ff 24 f9 	call 80016232 <ip_reass_dequeue_datagram>
80016fee:	1d 00 06 00 	j 80016ffa <ip4_reass+0x63c>
    goto nullreturn;
80016ff2:	00 00       	nop 
80016ff4:	1d 00 03 00 	j 80016ffa <ip4_reass+0x63c>
  }

nullreturn:
80016ff8:	00 00       	nop 
  LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
80016ffa:	91 10 00 27 	movh.a %a2,28673
80016ffe:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017002:	b9 22 36 00 	ld.hu %d2,[%a2]54 <70010036 <ram_heap+0x4fa2>>
80017006:	c2 12       	add %d2,1
80017008:	37 02 70 20 	extr.u %d2,%d2,0,16
8001700c:	91 10 00 27 	movh.a %a2,28673
80017010:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017014:	f9 22 36 00 	st.h [%a2]54 <70010036 <ram_heap+0x4fa2>>,%d2
  pbuf_free(p);
80017018:	99 e4 cc ff 	ld.a %a4,[%a14]-52 <70010036 <ram_heap+0x4fa2>>
8001701c:	6d 00 be 17 	call 80019f98 <pbuf_free>
  return NULL;
80017020:	82 02       	mov %d2,0
}
80017022:	60 22       	mov.a %a2,%d2
80017024:	00 90       	ret 

80017026 <ip_frag_alloc_pbuf_custom_ref>:
#if IP_FRAG
#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref *
ip_frag_alloc_pbuf_custom_ref(void)
{
80017026:	40 ae       	mov.aa %a14,%sp
  return (struct pbuf_custom_ref *)memp_malloc(MEMP_FRAG_PBUF);
80017028:	82 54       	mov %d4,5
8001702a:	6d 00 d0 0c 	call 800189ca <memp_malloc>
8001702e:	80 22       	mov.d %d2,%a2
}
80017030:	60 22       	mov.a %a2,%d2
80017032:	00 90       	ret 

80017034 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref *p)
{
80017034:	40 ae       	mov.aa %a14,%sp
80017036:	20 18       	sub.a %sp,24
80017038:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("p != NULL", p != NULL);
8001703c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017040:	df 02 17 80 	jne %d2,0,8001706e <ip_frag_free_pbuf_custom_ref+0x3a>
80017044:	91 00 00 28 	movh.a %a2,32768
80017048:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
8001704c:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
80017050:	3b 40 2c 20 	mov %d2,708
80017054:	59 a2 04 00 	st.w [%sp]4,%d2
80017058:	91 00 00 28 	movh.a %a2,32768
8001705c:	d9 22 1a b1 	lea %a2,[%a2]4826 <800012da <IfxCpu_Trap_vectorTable0_end+0x10e6>>
80017060:	f4 a2       	st.a [%sp],%a2
80017062:	91 00 00 28 	movh.a %a2,32768
80017066:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
8001706a:	6d ff 66 71 	call 80005336 <Ifx_Lwip_printf>
  memp_free(MEMP_FRAG_PBUF, p);
8001706e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80017072:	82 54       	mov %d4,5
80017074:	6d 00 21 0d 	call 80018ab6 <memp_free>
}
80017078:	00 00       	nop 
8001707a:	00 90       	ret 

8001707c <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
8001707c:	40 ae       	mov.aa %a14,%sp
8001707e:	20 20       	sub.a %sp,32
80017080:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref *)p;
80017084:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017088:	59 e2 fc ff 	st.w [%a14]-4,%d2
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
8001708c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017090:	df 02 17 80 	jne %d2,0,800170be <ipfrag_free_pbuf_custom+0x42>
80017094:	91 00 00 28 	movh.a %a2,32768
80017098:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
8001709c:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
800170a0:	3b e0 2c 20 	mov %d2,718
800170a4:	59 a2 04 00 	st.w [%sp]4,%d2
800170a8:	91 00 00 28 	movh.a %a2,32768
800170ac:	d9 22 24 b1 	lea %a2,[%a2]4836 <800012e4 <IfxCpu_Trap_vectorTable0_end+0x10f0>>
800170b0:	f4 a2       	st.a [%sp],%a2
800170b2:	91 00 00 28 	movh.a %a2,32768
800170b6:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
800170ba:	6d ff 3e 71 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("pcr == p", (void *)pcr == (void *)p);
800170be:	19 e3 fc ff 	ld.w %d3,[%a14]-4
800170c2:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800170c6:	5f 23 17 00 	jeq %d3,%d2,800170f4 <ipfrag_free_pbuf_custom+0x78>
800170ca:	91 00 00 28 	movh.a %a2,32768
800170ce:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
800170d2:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
800170d6:	3b f0 2c 20 	mov %d2,719
800170da:	59 a2 04 00 	st.w [%sp]4,%d2
800170de:	91 00 00 28 	movh.a %a2,32768
800170e2:	d9 22 30 b1 	lea %a2,[%a2]4848 <800012f0 <IfxCpu_Trap_vectorTable0_end+0x10fc>>
800170e6:	f4 a2       	st.a [%sp],%a2
800170e8:	91 00 00 28 	movh.a %a2,32768
800170ec:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
800170f0:	6d ff 23 71 	call 80005336 <Ifx_Lwip_printf>
  if (pcr->original != NULL) {
800170f4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800170f8:	d9 22 14 00 	lea %a2,[%a2]20
800170fc:	54 22       	ld.w %d2,[%a2]
800170fe:	df 02 0a 00 	jeq %d2,0,80017112 <ipfrag_free_pbuf_custom+0x96>
    pbuf_free(pcr->original);
80017102:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017106:	d9 22 14 00 	lea %a2,[%a2]20
8001710a:	54 22       	ld.w %d2,[%a2]
8001710c:	60 24       	mov.a %a4,%d2
8001710e:	6d 00 45 17 	call 80019f98 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
80017112:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80017116:	6d ff 8f ff 	call 80017034 <ip_frag_free_pbuf_custom_ref>
}
8001711a:	00 00       	nop 
8001711c:	00 90       	ret 

8001711e <ip4_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t
ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
{
8001711e:	40 ae       	mov.aa %a14,%sp
80017120:	20 58       	sub.a %sp,88
80017122:	b5 e4 c4 ff 	st.a [%a14]-60,%a4
80017126:	b5 e5 c0 ff 	st.a [%a14]-64,%a5
8001712a:	b5 e6 fc ef 	st.a [%a14]-68,%a6
  struct pbuf *rambuf;
#if !LWIP_NETIF_TX_SINGLE_PBUF
  struct pbuf *newpbuf;
  u16_t newpbuflen = 0;
8001712e:	82 02       	mov %d2,0
80017130:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  u16_t left_to_copy;
#endif
  struct ip_hdr *original_iphdr;
  struct ip_hdr *iphdr;
  const u16_t nfb = (u16_t)((netif->mtu - IP_HLEN) / 8);
80017134:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
80017138:	b9 22 28 00 	ld.hu %d2,[%a2]40
8001713c:	1b c2 fe 2f 	addi %d2,%d2,-20
80017140:	1b 72 00 30 	addi %d3,%d2,7
80017144:	8b 02 40 42 	lt %d4,%d2,0
80017148:	2b 23 40 24 	sel %d2,%d4,%d3,%d2
8001714c:	86 d2       	sha %d2,-3
8001714e:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
  u16_t left, fragsize;
  u16_t ofo;
  int last;
  u16_t poff = IP_HLEN;
80017152:	3b 40 01 20 	mov %d2,20
80017156:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
  u16_t tmp;
  int mf_set;

  original_iphdr = (struct ip_hdr *)p->payload;
8001715a:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8001715e:	b0 42       	add.a %a2,4
80017160:	54 22       	ld.w %d2,[%a2]
80017162:	59 e2 ec ff 	st.w [%a14]-20,%d2
  iphdr = original_iphdr;
80017166:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001716a:	59 e2 e8 ff 	st.w [%a14]-24,%d2
  if (IPH_HL_BYTES(iphdr) != IP_HLEN) {
8001716e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80017172:	14 22       	ld.bu %d2,[%a2]
80017174:	8f f2 00 21 	and %d2,%d2,15
80017178:	8f f2 0f 21 	and %d2,%d2,255
8001717c:	06 22       	sh %d2,2
8001717e:	8f f2 0f 21 	and %d2,%d2,255
80017182:	8b 42 01 22 	eq %d2,%d2,20
80017186:	df 02 04 80 	jne %d2,0,8001718e <ip4_frag+0x70>
    /* ip4_frag() does not support IP options */
    return ERR_VAL;
8001718a:	82 a2       	mov %d2,-6
8001718c:	00 90       	ret 
  }
  LWIP_ERROR("ip4_frag(): pbuf too short", p->len >= IP_HLEN, return ERR_VAL);
8001718e:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
80017192:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80017196:	8b 42 a1 22 	ge.u %d2,%d2,20
8001719a:	df 02 19 80 	jne %d2,0,800171cc <ip4_frag+0xae>
8001719e:	91 00 00 28 	movh.a %a2,32768
800171a2:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
800171a6:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
800171aa:	3b c0 2f 20 	mov %d2,764
800171ae:	59 a2 04 00 	st.w [%sp]4,%d2
800171b2:	91 00 00 28 	movh.a %a2,32768
800171b6:	d9 22 39 b1 	lea %a2,[%a2]4857 <800012f9 <IfxCpu_Trap_vectorTable0_end+0x1105>>
800171ba:	f4 a2       	st.a [%sp],%a2
800171bc:	91 00 00 28 	movh.a %a2,32768
800171c0:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
800171c4:	6d ff b9 70 	call 80005336 <Ifx_Lwip_printf>
800171c8:	82 a2       	mov %d2,-6
800171ca:	00 90       	ret 

  /* Save original offset */
  tmp = lwip_ntohs(IPH_OFFSET(iphdr));
800171cc:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800171d0:	39 23 06 00 	ld.bu %d3,[%a2]6
800171d4:	39 22 07 00 	ld.bu %d2,[%a2]7
800171d8:	8f 82 00 20 	sh %d2,%d2,8
800171dc:	a6 32       	or %d2,%d3
800171de:	37 02 70 20 	extr.u %d2,%d2,0,16
800171e2:	02 24       	mov %d4,%d2
800171e4:	6d 00 b8 01 	call 80017554 <lwip_htons>
800171e8:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
  ofo = tmp & IP_OFFMASK;
800171ec:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12
800171f0:	3b f0 ff 31 	mov %d3,8191
800171f4:	26 32       	and %d2,%d3
800171f6:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
  /* already fragmented? if so, the last fragment we create must have MF, too */
  mf_set = tmp & IP_MF;
800171fa:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
800171fe:	3b 00 00 32 	mov %d3,8192
80017202:	26 32       	and %d2,%d3
80017204:	59 e2 e4 ff 	st.w [%a14]-28,%d2

  left = (u16_t)(p->tot_len - IP_HLEN);
80017208:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
8001720c:	b9 22 08 00 	ld.hu %d2,[%a2]8
80017210:	1b c2 fe 2f 	addi %d2,%d2,-20
80017214:	f9 e2 fa ff 	st.h [%a14]-6,%d2

  while (left) {
80017218:	1d 00 95 01 	j 80017542 <ip4_frag+0x424>
    /* Fill this fragment */
    fragsize = LWIP_MIN(left, (u16_t)(nfb * 8));
8001721c:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80017220:	06 32       	sh %d2,3
80017222:	37 02 70 20 	extr.u %d2,%d2,0,16
80017226:	b9 e3 fa ff 	ld.hu %d3,[%a14]-6
8001722a:	0b 23 90 21 	min.u %d2,%d3,%d2
8001722e:	f9 e2 e2 ff 	st.h [%a14]-30,%d2
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
80017232:	3b 00 28 60 	mov %d6,640
80017236:	3b 40 01 50 	mov %d5,20
8001723a:	3b 00 01 40 	mov %d4,16
8001723e:	6d 00 51 12 	call 800196e0 <pbuf_alloc>
80017242:	b5 e2 dc ff 	st.a [%a14]-36,%a2
    if (rambuf == NULL) {
80017246:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8001724a:	df 02 82 01 	jeq %d2,0,8001754e <ip4_frag+0x430>
      goto memerr;
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
8001724e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80017252:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80017256:	8b 42 a1 22 	ge.u %d2,%d2,20
8001725a:	df 02 17 80 	jne %d2,0,80017288 <ip4_frag+0x16a>
8001725e:	91 00 00 28 	movh.a %a2,32768
80017262:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
80017266:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
8001726a:	3b 40 32 20 	mov %d2,804
8001726e:	59 a2 04 00 	st.w [%sp]4,%d2
80017272:	91 00 00 28 	movh.a %a2,32768
80017276:	d9 22 14 c1 	lea %a2,[%a2]4884 <80001314 <IfxCpu_Trap_vectorTable0_end+0x1120>>
8001727a:	f4 a2       	st.a [%sp],%a2
8001727c:	91 00 00 28 	movh.a %a2,32768
80017280:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80017284:	6d ff 59 70 	call 80005336 <Ifx_Lwip_printf>
                (rambuf->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
80017288:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001728c:	b0 42       	add.a %a2,4
8001728e:	54 22       	ld.w %d2,[%a2]
80017290:	3b 40 01 40 	mov %d4,20
80017294:	99 e5 ec ff 	ld.a %a5,[%a14]-20
80017298:	60 24       	mov.a %a4,%d2
8001729a:	6d 00 c1 7f 	call 8002721c <memcpy>
    iphdr = (struct ip_hdr *)rambuf->payload;
8001729e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800172a2:	b0 42       	add.a %a2,4
800172a4:	54 22       	ld.w %d2,[%a2]
800172a6:	59 e2 e8 ff 	st.w [%a14]-24,%d2

    left_to_copy = fragsize;
800172aa:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
800172ae:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    while (left_to_copy) {
800172b2:	1d 00 a1 00 	j 800173f4 <ip4_frag+0x2d6>
      struct pbuf_custom_ref *pcr;
      u16_t plen = (u16_t)(p->len - poff);
800172b6:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
800172ba:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800172be:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
800172c2:	0b 23 80 20 	sub %d2,%d3,%d2
800172c6:	f9 e2 d6 ff 	st.h [%a14]-42,%d2
      LWIP_ASSERT("p->len >= poff", p->len >= poff);
800172ca:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
800172ce:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800172d2:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10
800172d6:	7f 23 17 80 	jge.u %d3,%d2,80017304 <ip4_frag+0x1e6>
800172da:	91 00 00 28 	movh.a %a2,32768
800172de:	d9 22 25 51 	lea %a2,[%a2]4453 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>
800172e2:	b5 a2 08 00 	st.a [%sp]8 <80001165 <IfxCpu_Trap_vectorTable0_end+0xf71>>,%a2
800172e6:	3b d0 32 20 	mov %d2,813
800172ea:	59 a2 04 00 	st.w [%sp]4,%d2
800172ee:	91 00 00 28 	movh.a %a2,32768
800172f2:	d9 22 34 c1 	lea %a2,[%a2]4916 <80001334 <IfxCpu_Trap_vectorTable0_end+0x1140>>
800172f6:	f4 a2       	st.a [%sp],%a2
800172f8:	91 00 00 28 	movh.a %a2,32768
800172fc:	d9 24 3d 41 	lea %a4,[%a2]4413 <8000113d <IfxCpu_Trap_vectorTable0_end+0xf49>>
80017300:	6d ff 1b 70 	call 80005336 <Ifx_Lwip_printf>
      newpbuflen = LWIP_MIN(left_to_copy, plen);
80017304:	b9 e3 d6 ff 	ld.hu %d3,[%a14]-42
80017308:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8001730c:	0b 23 90 21 	min.u %d2,%d3,%d2
80017310:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
80017314:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80017318:	df 02 0c 80 	jne %d2,0,80017330 <ip4_frag+0x212>
        poff = 0;
8001731c:	82 02       	mov %d2,0
8001731e:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
        p = p->next;
80017322:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
80017326:	54 22       	ld.w %d2,[%a2]
80017328:	59 e2 c4 ff 	st.w [%a14]-60,%d2
        continue;
8001732c:	1d 00 64 00 	j 800173f4 <ip4_frag+0x2d6>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
80017330:	6d ff 7b fe 	call 80017026 <ip_frag_alloc_pbuf_custom_ref>
80017334:	b5 e2 d0 ff 	st.a [%a14]-48,%a2
      if (pcr == NULL) {
80017338:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8001733c:	df 02 08 80 	jne %d2,0,8001734c <ip4_frag+0x22e>
        pbuf_free(rambuf);
80017340:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80017344:	6d 00 2a 16 	call 80019f98 <pbuf_free>
        goto memerr;
80017348:	1d 00 04 01 	j 80017550 <ip4_frag+0x432>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
8001734c:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80017350:	19 e4 d0 ff 	ld.w %d4,[%a14]-48
                                    (u8_t *)p->payload + poff, newpbuflen);
80017354:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
80017358:	b0 42       	add.a %a2,4
8001735a:	54 25       	ld.w %d5,[%a2]
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
8001735c:	b9 e3 f6 ff 	ld.hu %d3,[%a14]-10
80017360:	42 35       	add %d5,%d3
80017362:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80017366:	02 37       	mov %d7,%d3
80017368:	60 55       	mov.a %a5,%d5
8001736a:	60 44       	mov.a %a4,%d4
8001736c:	3b 10 04 60 	mov %d6,65
80017370:	02 25       	mov %d5,%d2
80017372:	82 04       	mov %d4,0
80017374:	6d 00 78 13 	call 80019a64 <pbuf_alloced_custom>
80017378:	b5 e2 cc ff 	st.a [%a14]-52,%a2
      if (newpbuf == NULL) {
8001737c:	19 e2 cc ff 	ld.w %d2,[%a14]-52
80017380:	df 02 0c 80 	jne %d2,0,80017398 <ip4_frag+0x27a>
        ip_frag_free_pbuf_custom_ref(pcr);
80017384:	99 e4 d0 ff 	ld.a %a4,[%a14]-48
80017388:	6d ff 56 fe 	call 80017034 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
8001738c:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80017390:	6d 00 04 16 	call 80019f98 <pbuf_free>
        goto memerr;
80017394:	1d 00 de 00 	j 80017550 <ip4_frag+0x432>
      }
      pbuf_ref(p);
80017398:	99 e4 c4 ff 	ld.a %a4,[%a14]-60
8001739c:	6d 00 fb 16 	call 8001a192 <pbuf_ref>
      pcr->original = p;
800173a0:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
800173a4:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
800173a8:	d9 22 14 00 	lea %a2,[%a2]20
800173ac:	74 22       	st.w [%a2],%d2
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
800173ae:	99 e3 d0 ff 	ld.a %a3,[%a14]-48
800173b2:	91 10 00 28 	movh.a %a2,32769
800173b6:	d9 22 3c 17 	lea %a2,[%a2]28796 <8001707c <ipfrag_free_pbuf_custom>>
800173ba:	d9 33 10 00 	lea %a3,[%a3]16 <8001707c <ipfrag_free_pbuf_custom>>
800173be:	f4 32       	st.a [%a3],%a2

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
800173c0:	99 e5 cc ff 	ld.a %a5,[%a14]-52 <8001707c <ipfrag_free_pbuf_custom>>
800173c4:	99 e4 dc ff 	ld.a %a4,[%a14]-36 <8001707c <ipfrag_free_pbuf_custom>>
800173c8:	6d 00 15 17 	call 8001a1f2 <pbuf_cat>
      left_to_copy = (u16_t)(left_to_copy - newpbuflen);
800173cc:	c9 e3 fc ff 	ld.h %d3,[%a14]-4
800173d0:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800173d4:	0b 23 80 20 	sub %d2,%d3,%d2
800173d8:	f9 e2 fc ff 	st.h [%a14]-4,%d2
      if (left_to_copy) {
800173dc:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800173e0:	df 02 0a 00 	jeq %d2,0,800173f4 <ip4_frag+0x2d6>
        poff = 0;
800173e4:	82 02       	mov %d2,0
800173e6:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
        p = p->next;
800173ea:	99 e2 c4 ff 	ld.a %a2,[%a14]-60
800173ee:	54 22       	ld.w %d2,[%a2]
800173f0:	59 e2 c4 ff 	st.w [%a14]-60,%d2
    while (left_to_copy) {
800173f4:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800173f8:	df 02 5f ff 	jne %d2,0,800172b6 <ip4_frag+0x198>
      }
    }
    poff = (u16_t)(poff + newpbuflen);
800173fc:	c9 e3 f6 ff 	ld.h %d3,[%a14]-10
80017400:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80017404:	42 32       	add %d2,%d3
80017406:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

    /* Correct header */
    last = (left <= netif->mtu - IP_HLEN);
8001740a:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
8001740e:	b9 22 28 00 	ld.hu %d2,[%a2]40
80017412:	1b d2 fe 3f 	addi %d3,%d2,-19
80017416:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8001741a:	0b 32 20 21 	lt %d2,%d2,%d3
8001741e:	8f f2 0f 21 	and %d2,%d2,255
80017422:	59 e2 d8 ff 	st.w [%a14]-40,%d2

    /* Set new offset and MF flag */
    tmp = (IP_OFFMASK & (ofo));
80017426:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
8001742a:	3b f0 ff 31 	mov %d3,8191
8001742e:	26 32       	and %d2,%d3
80017430:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    if (!last || mf_set) {
80017434:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80017438:	df 02 06 00 	jeq %d2,0,80017444 <ip4_frag+0x326>
8001743c:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80017440:	df 02 09 00 	jeq %d2,0,80017452 <ip4_frag+0x334>
      /* the last fragment has MF set if the input frame had it */
      tmp = tmp | IP_MF;
80017444:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12
80017448:	3b 00 00 32 	mov %d3,8192
8001744c:	a6 32       	or %d2,%d3
8001744e:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
    }
    IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
80017452:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
80017456:	02 24       	mov %d4,%d2
80017458:	6d 00 7e 00 	call 80017554 <lwip_htons>
8001745c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80017460:	8f f2 0f 31 	and %d3,%d2,255
80017464:	82 04       	mov %d4,0
80017466:	a6 43       	or %d3,%d4
80017468:	e9 23 06 00 	st.b [%a2]6,%d3
8001746c:	06 82       	sh %d2,-8
8001746e:	37 02 70 20 	extr.u %d2,%d2,0,16
80017472:	82 03       	mov %d3,0
80017474:	a6 32       	or %d2,%d3
80017476:	e9 22 07 00 	st.b [%a2]7,%d2
    IPH_LEN_SET(iphdr, lwip_htons((u16_t)(fragsize + IP_HLEN)));
8001747a:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
8001747e:	1b 42 01 20 	addi %d2,%d2,20
80017482:	37 02 70 20 	extr.u %d2,%d2,0,16
80017486:	02 24       	mov %d4,%d2
80017488:	6d 00 66 00 	call 80017554 <lwip_htons>
8001748c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80017490:	8f f2 0f 31 	and %d3,%d2,255
80017494:	82 04       	mov %d4,0
80017496:	a6 43       	or %d3,%d4
80017498:	e9 23 02 00 	st.b [%a2]2,%d3
8001749c:	06 82       	sh %d2,-8
8001749e:	37 02 70 20 	extr.u %d2,%d2,0,16
800174a2:	82 03       	mov %d3,0
800174a4:	a6 32       	or %d2,%d3
800174a6:	e9 22 03 00 	st.b [%a2]3,%d2
    IPH_CHKSUM_SET(iphdr, 0);
800174aa:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800174ae:	82 02       	mov %d2,0
800174b0:	e9 22 0a 00 	st.b [%a2]10,%d2
800174b4:	82 02       	mov %d2,0
800174b6:	e9 22 0b 00 	st.b [%a2]11,%d2
#if CHECKSUM_GEN_IP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
      IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
800174ba:	3b 40 01 40 	mov %d4,20
800174be:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
800174c2:	6d 00 31 02 	call 80017924 <inet_chksum>
800174c6:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800174ca:	8f f2 0f 31 	and %d3,%d2,255
800174ce:	82 04       	mov %d4,0
800174d0:	a6 43       	or %d3,%d4
800174d2:	e9 23 0a 00 	st.b [%a2]10,%d3
800174d6:	06 82       	sh %d2,-8
800174d8:	37 02 70 20 	extr.u %d2,%d2,0,16
800174dc:	82 03       	mov %d3,0
800174de:	a6 32       	or %d2,%d3
800174e0:	e9 22 0b 00 	st.b [%a2]11,%d2
#endif /* CHECKSUM_GEN_IP */

    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
800174e4:	99 e2 c0 ff 	ld.a %a2,[%a14]-64
800174e8:	d9 22 14 00 	lea %a2,[%a2]20
800174ec:	d4 22       	ld.a %a2,[%a2]
800174ee:	99 e6 fc ef 	ld.a %a6,[%a14]-68
800174f2:	99 e5 dc ff 	ld.a %a5,[%a14]-36
800174f6:	99 e4 c0 ff 	ld.a %a4,[%a14]-64
800174fa:	2d 02 00 00 	calli %a2
    IPFRAG_STATS_INC(ip_frag.xmit);
800174fe:	91 10 00 27 	movh.a %a2,28673
80017502:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017506:	b9 22 30 00 	ld.hu %d2,[%a2]48 <70010030 <ram_heap+0x4f9c>>
8001750a:	c2 12       	add %d2,1
8001750c:	37 02 70 20 	extr.u %d2,%d2,0,16
80017510:	91 10 00 27 	movh.a %a2,28673
80017514:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017518:	f9 22 30 00 	st.h [%a2]48 <70010030 <ram_heap+0x4f9c>>,%d2
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */

    pbuf_free(rambuf);
8001751c:	99 e4 dc ff 	ld.a %a4,[%a14]-36 <70010030 <ram_heap+0x4f9c>>
80017520:	6d 00 3c 15 	call 80019f98 <pbuf_free>
    left = (u16_t)(left - fragsize);
80017524:	c9 e3 fa ff 	ld.h %d3,[%a14]-6
80017528:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
8001752c:	0b 23 80 20 	sub %d2,%d3,%d2
80017530:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    ofo = (u16_t)(ofo + nfb);
80017534:	c9 e3 f8 ff 	ld.h %d3,[%a14]-8
80017538:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
8001753c:	42 32       	add %d2,%d3
8001753e:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
  while (left) {
80017542:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80017546:	df 02 6b fe 	jne %d2,0,8001721c <ip4_frag+0xfe>
  }
  MIB2_STATS_INC(mib2.ipfragoks);
  return ERR_OK;
8001754a:	82 02       	mov %d2,0
8001754c:	00 90       	ret 
      goto memerr;
8001754e:	00 00       	nop 
memerr:
  MIB2_STATS_INC(mib2.ipfragfails);
  return ERR_MEM;
80017550:	82 f2       	mov %d2,-1
}
80017552:	00 90       	ret 

80017554 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
80017554:	40 ae       	mov.aa %a14,%sp
80017556:	20 08       	sub.a %sp,8
80017558:	02 42       	mov %d2,%d4
8001755a:	f9 e2 fc ff 	st.h [%a14]-4,%d2
  return PP_HTONS(n);
8001755e:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80017562:	8f 82 00 20 	sh %d2,%d2,8
80017566:	37 02 50 30 	extr %d3,%d2,0,16
8001756a:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8001756e:	06 82       	sh %d2,-8
80017570:	37 02 70 20 	extr.u %d2,%d2,0,16
80017574:	37 02 50 20 	extr %d2,%d2,0,16
80017578:	a6 32       	or %d2,%d3
8001757a:	37 02 50 20 	extr %d2,%d2,0,16
8001757e:	37 02 70 20 	extr.u %d2,%d2,0,16
}
80017582:	00 90       	ret 

80017584 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
80017584:	40 ae       	mov.aa %a14,%sp
80017586:	20 08       	sub.a %sp,8
80017588:	59 e4 fc ff 	st.w [%a14]-4,%d4
  return PP_HTONL(n);
8001758c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017590:	8f 82 01 30 	sh %d3,%d2,24
80017594:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017598:	8f 82 00 20 	sh %d2,%d2,8
8001759c:	7b f0 0f 40 	movh %d4,255
800175a0:	26 42       	and %d2,%d4
800175a2:	a6 23       	or %d3,%d2
800175a4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800175a8:	06 82       	sh %d2,-8
800175aa:	bb 00 f0 4f 	mov.u %d4,65280
800175ae:	26 42       	and %d2,%d4
800175b0:	a6 23       	or %d3,%d2
800175b2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800175b6:	8f 82 1e 20 	sh %d2,%d2,-24
800175ba:	a6 32       	or %d2,%d3
}
800175bc:	00 90       	ret 

800175be <lwip_standard_chksum>:
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum)
 */
u16_t
lwip_standard_chksum(const void *dataptr, int len)
{
800175be:	40 ae       	mov.aa %a14,%sp
800175c0:	20 20       	sub.a %sp,32
800175c2:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
800175c6:	59 e4 e0 ff 	st.w [%a14]-32,%d4
  const u8_t *pb = (const u8_t *)dataptr;
800175ca:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800175ce:	59 e2 fc ff 	st.w [%a14]-4,%d2
  const u16_t *ps;
  u16_t t = 0;
800175d2:	82 02       	mov %d2,0
800175d4:	f9 e2 ee ff 	st.h [%a14]-18,%d2
  u32_t sum = 0;
800175d8:	82 02       	mov %d2,0
800175da:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  int odd = ((mem_ptr_t)pb & 1);
800175de:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800175e2:	8f 12 00 21 	and %d2,%d2,1
800175e6:	59 e2 f0 ff 	st.w [%a14]-16,%d2

  /* Get aligned to u16_t */
  if (odd && len > 0) {
800175ea:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800175ee:	df 02 16 00 	jeq %d2,0,8001761a <lwip_standard_chksum+0x5c>
800175f2:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
800175f6:	bf 12 12 00 	jlt %d2,1,8001761a <lwip_standard_chksum+0x5c>
    ((u8_t *)&t)[1] = *pb++;
800175fa:	99 e3 fc ff 	ld.a %a3,[%a14]-4
800175fe:	80 32       	mov.d %d2,%a3
80017600:	c2 12       	add %d2,1
80017602:	59 e2 fc ff 	st.w [%a14]-4,%d2
80017606:	d9 e2 ee ff 	lea %a2,[%a14]-18
8001760a:	b0 12       	add.a %a2,1
8001760c:	14 32       	ld.bu %d2,[%a3]
8001760e:	34 22       	st.b [%a2],%d2
    len--;
80017610:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80017614:	c2 f2       	add %d2,-1
80017616:	59 e2 e0 ff 	st.w [%a14]-32,%d2
  }

  /* Add the bulk of the data */
  ps = (const u16_t *)(const void *)pb;
8001761a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001761e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  while (len > 1) {
80017622:	1d 00 15 00 	j 8001764c <lwip_standard_chksum+0x8e>
    sum += *ps++;
80017626:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001762a:	80 22       	mov.d %d2,%a2
8001762c:	c2 22       	add %d2,2
8001762e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80017632:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017636:	02 23       	mov %d3,%d2
80017638:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001763c:	42 32       	add %d2,%d3
8001763e:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    len -= 2;
80017642:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80017646:	c2 e2       	add %d2,-2
80017648:	59 e2 e0 ff 	st.w [%a14]-32,%d2
  while (len > 1) {
8001764c:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80017650:	ff 22 eb 7f 	jge %d2,2,80017626 <lwip_standard_chksum+0x68>
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
80017654:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80017658:	bf 12 08 00 	jlt %d2,1,80017668 <lwip_standard_chksum+0xaa>
    ((u8_t *)&t)[0] = *(const u8_t *)ps;
8001765c:	d9 e2 ee ff 	lea %a2,[%a14]-18
80017660:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80017664:	14 32       	ld.bu %d2,[%a3]
80017666:	34 22       	st.b [%a2],%d2
  }

  /* Add end bytes */
  sum += t;
80017668:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
8001766c:	02 23       	mov %d3,%d2
8001766e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017672:	42 32       	add %d2,%d3
80017674:	59 e2 f4 ff 	st.w [%a14]-12,%d2

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  sum = FOLD_U32T(sum);
80017678:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001767c:	8f 02 1f 30 	sh %d3,%d2,-16
80017680:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017684:	bb f0 ff 4f 	mov.u %d4,65535
80017688:	26 42       	and %d2,%d4
8001768a:	42 32       	add %d2,%d3
8001768c:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  sum = FOLD_U32T(sum);
80017690:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017694:	8f 02 1f 30 	sh %d3,%d2,-16
80017698:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001769c:	bb f0 ff 4f 	mov.u %d4,65535
800176a0:	26 42       	and %d2,%d4
800176a2:	42 32       	add %d2,%d3
800176a4:	59 e2 f4 ff 	st.w [%a14]-12,%d2

  /* Swap if alignment was odd */
  if (odd) {
800176a8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800176ac:	df 02 11 00 	jeq %d2,0,800176ce <lwip_standard_chksum+0x110>
    sum = SWAP_BYTES_IN_WORD(sum);
800176b0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800176b4:	8f 82 00 20 	sh %d2,%d2,8
800176b8:	bb f0 ff 3f 	mov.u %d3,65535
800176bc:	26 23       	and %d3,%d2
800176be:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800176c2:	06 82       	sh %d2,-8
800176c4:	8f f2 0f 21 	and %d2,%d2,255
800176c8:	a6 32       	or %d2,%d3
800176ca:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  }

  return (u16_t)sum;
800176ce:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800176d2:	37 02 70 20 	extr.u %d2,%d2,0,16
}
800176d6:	00 90       	ret 

800176d8 <inet_cksum_pseudo_base>:
#endif

/** Parts of the pseudo checksum which are common to IPv4 and IPv6 */
static u16_t
inet_cksum_pseudo_base(struct pbuf *p, u8_t proto, u16_t proto_len, u32_t acc)
{
800176d8:	40 ae       	mov.aa %a14,%sp
800176da:	20 18       	sub.a %sp,24
800176dc:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
800176e0:	02 42       	mov %d2,%d4
800176e2:	02 53       	mov %d3,%d5
800176e4:	59 e6 e8 ff 	st.w [%a14]-24,%d6
800176e8:	e9 e2 f0 ff 	st.b [%a14]-16,%d2
800176ec:	02 32       	mov %d2,%d3
800176ee:	f9 e2 ec ff 	st.h [%a14]-20,%d2
  struct pbuf *q;
  int swapped = 0;
800176f2:	82 02       	mov %d2,0
800176f4:	59 e2 f8 ff 	st.w [%a14]-8,%d2

  /* iterate through all pbuf in chain */
  for (q = p; q != NULL; q = q->next) {
800176f8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800176fc:	59 e2 fc ff 	st.w [%a14]-4,%d2
80017700:	1d 00 46 00 	j 8001778c <inet_cksum_pseudo_base+0xb4>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
                             (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
80017704:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017708:	b0 42       	add.a %a2,4
8001770a:	54 22       	ld.w %d2,[%a2]
8001770c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017710:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80017714:	02 34       	mov %d4,%d3
80017716:	60 24       	mov.a %a4,%d2
80017718:	6d ff 53 ff 	call 800175be <lwip_standard_chksum>
8001771c:	02 23       	mov %d3,%d2
8001771e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80017722:	42 32       	add %d2,%d3
80017724:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
80017728:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001772c:	8f 02 1f 30 	sh %d3,%d2,-16
80017730:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80017734:	bb f0 ff 4f 	mov.u %d4,65535
80017738:	26 42       	and %d2,%d4
8001773a:	42 32       	add %d2,%d3
8001773c:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    if (q->len % 2 != 0) {
80017740:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017744:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80017748:	8f 12 00 21 	and %d2,%d2,1
8001774c:	37 02 70 20 	extr.u %d2,%d2,0,16
80017750:	df 02 19 00 	jeq %d2,0,80017782 <inet_cksum_pseudo_base+0xaa>
      swapped = !swapped;
80017754:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80017758:	8b 02 00 22 	eq %d2,%d2,0
8001775c:	8f f2 0f 21 	and %d2,%d2,255
80017760:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      acc = SWAP_BYTES_IN_WORD(acc);
80017764:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80017768:	8f 82 00 20 	sh %d2,%d2,8
8001776c:	bb f0 ff 3f 	mov.u %d3,65535
80017770:	26 23       	and %d3,%d2
80017772:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80017776:	06 82       	sh %d2,-8
80017778:	8f f2 0f 21 	and %d2,%d2,255
8001777c:	a6 32       	or %d2,%d3
8001777e:	59 e2 e8 ff 	st.w [%a14]-24,%d2
  for (q = p; q != NULL; q = q->next) {
80017782:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017786:	54 22       	ld.w %d2,[%a2]
80017788:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001778c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017790:	df 02 ba ff 	jne %d2,0,80017704 <inet_cksum_pseudo_base+0x2c>
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
80017794:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80017798:	df 02 11 00 	jeq %d2,0,800177ba <inet_cksum_pseudo_base+0xe2>
    acc = SWAP_BYTES_IN_WORD(acc);
8001779c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800177a0:	8f 82 00 20 	sh %d2,%d2,8
800177a4:	bb f0 ff 3f 	mov.u %d3,65535
800177a8:	26 23       	and %d3,%d2
800177aa:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800177ae:	06 82       	sh %d2,-8
800177b0:	8f f2 0f 21 	and %d2,%d2,255
800177b4:	a6 32       	or %d2,%d3
800177b6:	59 e2 e8 ff 	st.w [%a14]-24,%d2
  }

  acc += (u32_t)lwip_htons((u16_t)proto);
800177ba:	39 e2 f0 ff 	ld.bu %d2,[%a14]-16
800177be:	02 24       	mov %d4,%d2
800177c0:	6d ff ca fe 	call 80017554 <lwip_htons>
800177c4:	02 23       	mov %d3,%d2
800177c6:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800177ca:	42 32       	add %d2,%d3
800177cc:	59 e2 e8 ff 	st.w [%a14]-24,%d2
  acc += (u32_t)lwip_htons(proto_len);
800177d0:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800177d4:	02 24       	mov %d4,%d2
800177d6:	6d ff bf fe 	call 80017554 <lwip_htons>
800177da:	02 23       	mov %d3,%d2
800177dc:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800177e0:	42 32       	add %d2,%d3
800177e2:	59 e2 e8 ff 	st.w [%a14]-24,%d2

  /* Fold 32-bit sum to 16 bits
     calling this twice is probably faster than if statements... */
  acc = FOLD_U32T(acc);
800177e6:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800177ea:	8f 02 1f 30 	sh %d3,%d2,-16
800177ee:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800177f2:	bb f0 ff 4f 	mov.u %d4,65535
800177f6:	26 42       	and %d2,%d4
800177f8:	42 32       	add %d2,%d3
800177fa:	59 e2 e8 ff 	st.w [%a14]-24,%d2
  acc = FOLD_U32T(acc);
800177fe:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80017802:	8f 02 1f 30 	sh %d3,%d2,-16
80017806:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001780a:	bb f0 ff 4f 	mov.u %d4,65535
8001780e:	26 42       	and %d2,%d4
80017810:	42 32       	add %d2,%d3
80017812:	59 e2 e8 ff 	st.w [%a14]-24,%d2
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
80017816:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001781a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001781e:	46 02       	not %d2
80017820:	37 02 70 20 	extr.u %d2,%d2,0,16
}
80017824:	00 90       	ret 

80017826 <inet_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                   const ip4_addr_t *src, const ip4_addr_t *dest)
{
80017826:	40 ae       	mov.aa %a14,%sp
80017828:	20 20       	sub.a %sp,32
8001782a:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001782e:	02 42       	mov %d2,%d4
80017830:	02 53       	mov %d3,%d5
80017832:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80017836:	b5 e6 e4 ff 	st.a [%a14]-28,%a6
8001783a:	e9 e2 f0 ff 	st.b [%a14]-16,%d2
8001783e:	02 32       	mov %d2,%d3
80017840:	f9 e2 ec ff 	st.h [%a14]-20,%d2
  u32_t acc;
  u32_t addr;

  addr = ip4_addr_get_u32(src);
80017844:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80017848:	54 22       	ld.w %d2,[%a2]
8001784a:	59 e2 fc ff 	st.w [%a14]-4,%d2
  acc = (addr & 0xffffUL);
8001784e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017852:	bb f0 ff 3f 	mov.u %d3,65535
80017856:	26 32       	and %d2,%d3
80017858:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
8001785c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017860:	8f 02 1f 20 	sh %d2,%d2,-16
80017864:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80017868:	42 32       	add %d2,%d3
8001786a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  addr = ip4_addr_get_u32(dest);
8001786e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80017872:	54 22       	ld.w %d2,[%a2]
80017874:	59 e2 fc ff 	st.w [%a14]-4,%d2
  acc = (u32_t)(acc + (addr & 0xffffUL));
80017878:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001787c:	bb f0 ff 3f 	mov.u %d3,65535
80017880:	26 32       	and %d2,%d3
80017882:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80017886:	42 32       	add %d2,%d3
80017888:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  acc = (u32_t)(acc + ((addr >> 16) & 0xffffUL));
8001788c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017890:	8f 02 1f 20 	sh %d2,%d2,-16
80017894:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80017898:	42 32       	add %d2,%d3
8001789a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  /* fold down to 16 bits */
  acc = FOLD_U32T(acc);
8001789e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800178a2:	8f 02 1f 30 	sh %d3,%d2,-16
800178a6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800178aa:	bb f0 ff 4f 	mov.u %d4,65535
800178ae:	26 42       	and %d2,%d4
800178b0:	42 32       	add %d2,%d3
800178b2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  acc = FOLD_U32T(acc);
800178b6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800178ba:	8f 02 1f 30 	sh %d3,%d2,-16
800178be:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800178c2:	bb f0 ff 4f 	mov.u %d4,65535
800178c6:	26 42       	and %d2,%d4
800178c8:	42 32       	add %d2,%d3
800178ca:	59 e2 f8 ff 	st.w [%a14]-8,%d2

  return inet_cksum_pseudo_base(p, proto, proto_len, acc);
800178ce:	39 e3 f0 ff 	ld.bu %d3,[%a14]-16
800178d2:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
800178d6:	19 e6 f8 ff 	ld.w %d6,[%a14]-8
800178da:	02 25       	mov %d5,%d2
800178dc:	02 34       	mov %d4,%d3
800178de:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800178e2:	6d ff fb fe 	call 800176d8 <inet_cksum_pseudo_base>
}
800178e6:	00 90       	ret 

800178e8 <ip_chksum_pseudo>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
                 const ip_addr_t *src, const ip_addr_t *dest)
{
800178e8:	40 ae       	mov.aa %a14,%sp
800178ea:	20 18       	sub.a %sp,24
800178ec:	b5 e4 fc ff 	st.a [%a14]-4,%a4
800178f0:	02 42       	mov %d2,%d4
800178f2:	02 53       	mov %d3,%d5
800178f4:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
800178f8:	b5 e6 ec ff 	st.a [%a14]-20,%a6
800178fc:	e9 e2 f8 ff 	st.b [%a14]-8,%d2
80017900:	02 32       	mov %d2,%d3
80017902:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
  {
    return inet_chksum_pseudo(p, proto, proto_len, ip_2_ip4(src), ip_2_ip4(dest));
80017906:	39 e3 f8 ff 	ld.bu %d3,[%a14]-8
8001790a:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8001790e:	99 e6 ec ff 	ld.a %a6,[%a14]-20
80017912:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
80017916:	02 25       	mov %d5,%d2
80017918:	02 34       	mov %d4,%d3
8001791a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001791e:	6d ff 84 ff 	call 80017826 <inet_chksum_pseudo>
  }
#endif /* LWIP_IPV4 */
}
80017922:	00 90       	ret 

80017924 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(const void *dataptr, u16_t len)
{
80017924:	40 ae       	mov.aa %a14,%sp
80017926:	20 08       	sub.a %sp,8
80017928:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001792c:	02 42       	mov %d2,%d4
8001792e:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
  return (u16_t)~(unsigned int)LWIP_CHKSUM(dataptr, len);
80017932:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80017936:	02 24       	mov %d4,%d2
80017938:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001793c:	6d ff 41 fe 	call 800175be <lwip_standard_chksum>
80017940:	46 02       	not %d2
80017942:	37 02 70 20 	extr.u %d2,%d2,0,16
}
80017946:	00 90       	ret 

80017948 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
80017948:	40 ae       	mov.aa %a14,%sp
8001794a:	20 18       	sub.a %sp,24
8001794c:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  u32_t acc;
  struct pbuf *q;
  int swapped = 0;
80017950:	82 02       	mov %d2,0
80017952:	59 e2 f4 ff 	st.w [%a14]-12,%d2

  acc = 0;
80017956:	82 02       	mov %d2,0
80017958:	59 e2 fc ff 	st.w [%a14]-4,%d2
  for (q = p; q != NULL; q = q->next) {
8001795c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80017960:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80017964:	1d 00 46 00 	j 800179f0 <inet_chksum_pbuf+0xa8>
    acc += LWIP_CHKSUM(q->payload, q->len);
80017968:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001796c:	b0 42       	add.a %a2,4
8001796e:	54 22       	ld.w %d2,[%a2]
80017970:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80017974:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80017978:	02 34       	mov %d4,%d3
8001797a:	60 24       	mov.a %a4,%d2
8001797c:	6d ff 21 fe 	call 800175be <lwip_standard_chksum>
80017980:	02 23       	mov %d3,%d2
80017982:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017986:	42 32       	add %d2,%d3
80017988:	59 e2 fc ff 	st.w [%a14]-4,%d2
    acc = FOLD_U32T(acc);
8001798c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017990:	8f 02 1f 30 	sh %d3,%d2,-16
80017994:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017998:	bb f0 ff 4f 	mov.u %d4,65535
8001799c:	26 42       	and %d2,%d4
8001799e:	42 32       	add %d2,%d3
800179a0:	59 e2 fc ff 	st.w [%a14]-4,%d2
    if (q->len % 2 != 0) {
800179a4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800179a8:	b9 22 0a 00 	ld.hu %d2,[%a2]10
800179ac:	8f 12 00 21 	and %d2,%d2,1
800179b0:	37 02 70 20 	extr.u %d2,%d2,0,16
800179b4:	df 02 19 00 	jeq %d2,0,800179e6 <inet_chksum_pbuf+0x9e>
      swapped = !swapped;
800179b8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800179bc:	8b 02 00 22 	eq %d2,%d2,0
800179c0:	8f f2 0f 21 	and %d2,%d2,255
800179c4:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      acc = SWAP_BYTES_IN_WORD(acc);
800179c8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800179cc:	8f 82 00 20 	sh %d2,%d2,8
800179d0:	bb f0 ff 3f 	mov.u %d3,65535
800179d4:	26 23       	and %d3,%d2
800179d6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800179da:	06 82       	sh %d2,-8
800179dc:	8f f2 0f 21 	and %d2,%d2,255
800179e0:	a6 32       	or %d2,%d3
800179e2:	59 e2 fc ff 	st.w [%a14]-4,%d2
  for (q = p; q != NULL; q = q->next) {
800179e6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800179ea:	54 22       	ld.w %d2,[%a2]
800179ec:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800179f0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800179f4:	df 02 ba ff 	jne %d2,0,80017968 <inet_chksum_pbuf+0x20>
    }
  }

  if (swapped) {
800179f8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800179fc:	df 02 11 00 	jeq %d2,0,80017a1e <inet_chksum_pbuf+0xd6>
    acc = SWAP_BYTES_IN_WORD(acc);
80017a00:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017a04:	8f 82 00 20 	sh %d2,%d2,8
80017a08:	bb f0 ff 3f 	mov.u %d3,65535
80017a0c:	26 23       	and %d3,%d2
80017a0e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017a12:	06 82       	sh %d2,-8
80017a14:	8f f2 0f 21 	and %d2,%d2,255
80017a18:	a6 32       	or %d2,%d3
80017a1a:	59 e2 fc ff 	st.w [%a14]-4,%d2
  }
  return (u16_t)~(acc & 0xffffUL);
80017a1e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017a22:	37 02 70 20 	extr.u %d2,%d2,0,16
80017a26:	46 02       	not %d2
80017a28:	37 02 70 20 	extr.u %d2,%d2,0,16
}
80017a2c:	00 90       	ret 

80017a2e <lwip_init>:
 * Initialize all modules.
 * Use this in NO_SYS mode. Use tcpip_init() otherwise.
 */
void
lwip_init(void)
{
80017a2e:	40 ae       	mov.aa %a14,%sp
80017a30:	20 08       	sub.a %sp,8
#ifndef LWIP_SKIP_CONST_CHECK
  int a = 0;
80017a32:	82 02       	mov %d2,0
80017a34:	59 e2 fc ff 	st.w [%a14]-4,%d2
#ifndef LWIP_SKIP_PACKING_CHECK
  LWIP_ASSERT("Struct packing not implemented correctly. Check your lwIP port.", sizeof(struct packed_struct_test) == PACKED_STRUCT_TEST_EXPECTED_SIZE);
#endif

  /* Modules initialization */
  stats_init();
80017a38:	6d 00 d4 16 	call 8001a7e0 <stats_init>
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
80017a3c:	6d 00 34 01 	call 80017ca4 <mem_init>
  memp_init();
80017a40:	6d 00 22 07 	call 80018884 <memp_init>
  pbuf_init();
  netif_init();
80017a44:	6d 00 6f 08 	call 80018b22 <netif_init>
#endif /* LWIP_IPV4 */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
80017a48:	6d 00 42 6b 	call 800250cc <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
80017a4c:	6d 00 d8 16 	call 8001a7fc <tcp_init>
#if PPP_SUPPORT
  ppp_init();
#endif

#if LWIP_TIMERS
  sys_timeouts_init();
80017a50:	6d 00 dc 6a 	call 80025008 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
80017a54:	00 00       	nop 
80017a56:	00 90       	ret 

80017a58 <ptr_to_mem>:
#define mem_overflow_check_element(mem)
#endif /* MEM_OVERFLOW_CHECK */

static struct mem *
ptr_to_mem(mem_size_t ptr)
{
80017a58:	40 ae       	mov.aa %a14,%sp
80017a5a:	20 08       	sub.a %sp,8
80017a5c:	02 42       	mov %d2,%d4
80017a5e:	f9 e2 fc ff 	st.h [%a14]-4,%d2
  return (struct mem *)(void *)&ram[ptr];
80017a62:	91 10 00 27 	movh.a %a2,28673
80017a66:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
80017a6a:	54 23       	ld.w %d3,[%a2]
80017a6c:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4 <700114a8 <ram>>
80017a70:	42 32       	add %d2,%d3
}
80017a72:	60 22       	mov.a %a2,%d2
80017a74:	00 90       	ret 

80017a76 <mem_to_ptr>:

static mem_size_t
mem_to_ptr(void *mem)
{
80017a76:	40 ae       	mov.aa %a14,%sp
80017a78:	20 08       	sub.a %sp,8
80017a7a:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  return (mem_size_t)((u8_t *)mem - ram);
80017a7e:	91 10 00 27 	movh.a %a2,28673
80017a82:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
80017a86:	54 22       	ld.w %d2,[%a2]
80017a88:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700114a8 <ram>>
80017a8c:	0b 23 80 20 	sub %d2,%d3,%d2
80017a90:	37 02 70 20 	extr.u %d2,%d2,0,16
}
80017a94:	00 90       	ret 

80017a96 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
80017a96:	40 ae       	mov.aa %a14,%sp
80017a98:	20 20       	sub.a %sp,32
80017a9a:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
80017a9e:	91 10 00 27 	movh.a %a2,28673
80017aa2:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
80017aa6:	54 22       	ld.w %d2,[%a2]
80017aa8:	19 e3 f4 ff 	ld.w %d3,[%a14]-12 <700114a8 <ram>>
80017aac:	7f 23 17 80 	jge.u %d3,%d2,80017ada <plug_holes+0x44>
80017ab0:	91 00 00 28 	movh.a %a2,32768
80017ab4:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80017ab8:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80017abc:	3b f0 1d 20 	mov %d2,479
80017ac0:	59 a2 04 00 	st.w [%sp]4,%d2
80017ac4:	91 00 00 28 	movh.a %a2,32768
80017ac8:	d9 22 15 e1 	lea %a2,[%a2]5013 <80001395 <IfxCpu_Trap_vectorTable0_end+0x11a1>>
80017acc:	f4 a2       	st.a [%sp],%a2
80017ace:	91 00 00 28 	movh.a %a2,32768
80017ad2:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80017ad6:	6d ff 30 6c 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
80017ada:	91 10 00 27 	movh.a %a2,28673
80017ade:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80017ae2:	54 22       	ld.w %d2,[%a2]
80017ae4:	19 e3 f4 ff 	ld.w %d3,[%a14]-12 <700114ac <ram_end>>
80017ae8:	3f 23 17 80 	jlt.u %d3,%d2,80017b16 <plug_holes+0x80>
80017aec:	91 00 00 28 	movh.a %a2,32768
80017af0:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80017af4:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80017af8:	3b 00 1e 20 	mov %d2,480
80017afc:	59 a2 04 00 	st.w [%sp]4,%d2
80017b00:	91 00 00 28 	movh.a %a2,32768
80017b04:	d9 22 2c e1 	lea %a2,[%a2]5036 <800013ac <IfxCpu_Trap_vectorTable0_end+0x11b8>>
80017b08:	f4 a2       	st.a [%sp],%a2
80017b0a:	91 00 00 28 	movh.a %a2,32768
80017b0e:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80017b12:	6d ff 12 6c 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
80017b16:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80017b1a:	39 22 04 00 	ld.bu %d2,[%a2]4
80017b1e:	df 02 17 00 	jeq %d2,0,80017b4c <plug_holes+0xb6>
80017b22:	91 00 00 28 	movh.a %a2,32768
80017b26:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80017b2a:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80017b2e:	3b 10 1e 20 	mov %d2,481
80017b32:	59 a2 04 00 	st.w [%sp]4,%d2
80017b36:	91 00 00 28 	movh.a %a2,32768
80017b3a:	d9 22 06 f1 	lea %a2,[%a2]5062 <800013c6 <IfxCpu_Trap_vectorTable0_end+0x11d2>>
80017b3e:	f4 a2       	st.a [%sp],%a2
80017b40:	91 00 00 28 	movh.a %a2,32768
80017b44:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80017b48:	6d ff f7 6b 	call 80005336 <Ifx_Lwip_printf>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
80017b4c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80017b50:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017b54:	3b 10 40 36 	mov %d3,25601
80017b58:	3f 32 17 80 	jlt.u %d2,%d3,80017b86 <plug_holes+0xf0>
80017b5c:	91 00 00 28 	movh.a %a2,32768
80017b60:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80017b64:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80017b68:	3b 40 1e 20 	mov %d2,484
80017b6c:	59 a2 04 00 	st.w [%sp]4,%d2
80017b70:	91 00 00 28 	movh.a %a2,32768
80017b74:	d9 22 21 f1 	lea %a2,[%a2]5089 <800013e1 <IfxCpu_Trap_vectorTable0_end+0x11ed>>
80017b78:	f4 a2       	st.a [%sp],%a2
80017b7a:	91 00 00 28 	movh.a %a2,32768
80017b7e:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80017b82:	6d ff da 6b 	call 80005336 <Ifx_Lwip_printf>

  nmem = ptr_to_mem(mem->next);
80017b86:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80017b8a:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017b8e:	02 24       	mov %d4,%d2
80017b90:	6d ff 64 ff 	call 80017a58 <ptr_to_mem>
80017b94:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
80017b98:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80017b9c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80017ba0:	5f 23 3e 00 	jeq %d3,%d2,80017c1c <plug_holes+0x186>
80017ba4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017ba8:	39 22 04 00 	ld.bu %d2,[%a2]4
80017bac:	df 02 38 80 	jne %d2,0,80017c1c <plug_holes+0x186>
80017bb0:	91 10 00 27 	movh.a %a2,28673
80017bb4:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80017bb8:	54 22       	ld.w %d2,[%a2]
80017bba:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700114ac <ram_end>>
80017bbe:	5f 23 2f 00 	jeq %d3,%d2,80017c1c <plug_holes+0x186>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
80017bc2:	91 10 00 27 	movh.a %a2,28673
80017bc6:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80017bca:	54 22       	ld.w %d2,[%a2]
80017bcc:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700114b0 <lfree>>
80017bd0:	5f 23 09 80 	jne %d3,%d2,80017be2 <plug_holes+0x14c>
      lfree = mem;
80017bd4:	91 10 00 27 	movh.a %a2,28673
80017bd8:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80017bdc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <700114b0 <lfree>>
80017be0:	74 22       	st.w [%a2],%d2
    }
    mem->next = nmem->next;
80017be2:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700114b0 <lfree>>
80017be6:	b9 22 00 00 	ld.hu %d2,[%a2]0 <700114b0 <lfree>>
80017bea:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <700114b0 <lfree>>
80017bee:	b4 22       	st.h [%a2],%d2
    if (nmem->next != MEM_SIZE_ALIGNED) {
80017bf0:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700114b0 <lfree>>
80017bf4:	b9 22 00 00 	ld.hu %d2,[%a2]0 <700114b0 <lfree>>
80017bf8:	3b 00 40 36 	mov %d3,25600
80017bfc:	5f 32 10 00 	jeq %d2,%d3,80017c1c <plug_holes+0x186>
      ptr_to_mem(nmem->next)->prev = mem_to_ptr(mem);
80017c00:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017c04:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017c08:	02 24       	mov %d4,%d2
80017c0a:	6d ff 27 ff 	call 80017a58 <ptr_to_mem>
80017c0e:	40 2c       	mov.aa %a12,%a2
80017c10:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80017c14:	6d ff 31 ff 	call 80017a76 <mem_to_ptr>
80017c18:	f9 c2 02 00 	st.h [%a12]2,%d2
    }
  }

  /* plug hole backward */
  pmem = ptr_to_mem(mem->prev);
80017c1c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80017c20:	b9 22 02 00 	ld.hu %d2,[%a2]2
80017c24:	02 24       	mov %d4,%d2
80017c26:	6d ff 19 ff 	call 80017a58 <ptr_to_mem>
80017c2a:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  if (pmem != mem && pmem->used == 0) {
80017c2e:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80017c32:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017c36:	5f 23 35 00 	jeq %d3,%d2,80017ca0 <plug_holes+0x20a>
80017c3a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80017c3e:	39 22 04 00 	ld.bu %d2,[%a2]4
80017c42:	df 02 2f 80 	jne %d2,0,80017ca0 <plug_holes+0x20a>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
80017c46:	91 10 00 27 	movh.a %a2,28673
80017c4a:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80017c4e:	54 22       	ld.w %d2,[%a2]
80017c50:	19 e3 f4 ff 	ld.w %d3,[%a14]-12 <700114b0 <lfree>>
80017c54:	5f 23 09 80 	jne %d3,%d2,80017c66 <plug_holes+0x1d0>
      lfree = pmem;
80017c58:	91 10 00 27 	movh.a %a2,28673
80017c5c:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80017c60:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <700114b0 <lfree>>
80017c64:	74 22       	st.w [%a2],%d2
    }
    pmem->next = mem->next;
80017c66:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <700114b0 <lfree>>
80017c6a:	b9 22 00 00 	ld.hu %d2,[%a2]0 <700114b0 <lfree>>
80017c6e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <700114b0 <lfree>>
80017c72:	b4 22       	st.h [%a2],%d2
    if (mem->next != MEM_SIZE_ALIGNED) {
80017c74:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <700114b0 <lfree>>
80017c78:	b9 22 00 00 	ld.hu %d2,[%a2]0 <700114b0 <lfree>>
80017c7c:	3b 00 40 36 	mov %d3,25600
80017c80:	5f 32 10 00 	jeq %d2,%d3,80017ca0 <plug_holes+0x20a>
      ptr_to_mem(mem->next)->prev = mem_to_ptr(pmem);
80017c84:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80017c88:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017c8c:	02 24       	mov %d4,%d2
80017c8e:	6d ff e5 fe 	call 80017a58 <ptr_to_mem>
80017c92:	40 2c       	mov.aa %a12,%a2
80017c94:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80017c98:	6d ff ef fe 	call 80017a76 <mem_to_ptr>
80017c9c:	f9 c2 02 00 	st.h [%a12]2,%d2
    }
  }
}
80017ca0:	00 00       	nop 
80017ca2:	00 90       	ret 

80017ca4 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
80017ca4:	40 ae       	mov.aa %a14,%sp
80017ca6:	20 08       	sub.a %sp,8

  LWIP_ASSERT("Sanity check alignment",
              (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT - 1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
80017ca8:	91 10 00 27 	movh.a %a2,28673
80017cac:	d9 22 14 2b 	lea %a2,[%a2]-20332 <7000b094 <ram_heap>>
80017cb0:	80 22       	mov.d %d2,%a2
80017cb2:	c2 32       	add %d2,3
80017cb4:	8f 32 c0 21 	andn %d2,%d2,3
80017cb8:	91 10 00 27 	movh.a %a2,28673
80017cbc:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
80017cc0:	74 22       	st.w [%a2],%d2
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
80017cc2:	91 10 00 27 	movh.a %a2,28673
80017cc6:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
80017cca:	54 22       	ld.w %d2,[%a2]
80017ccc:	59 e2 fc ff 	st.w [%a14]-4 <700114a8 <ram>>,%d2
  mem->next = MEM_SIZE_ALIGNED;
80017cd0:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700114a8 <ram>>
80017cd4:	3b 00 40 26 	mov %d2,25600
80017cd8:	b4 22       	st.h [%a2],%d2
  mem->prev = 0;
80017cda:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017cde:	82 02       	mov %d2,0
80017ce0:	f9 22 02 00 	st.h [%a2]2,%d2
  mem->used = 0;
80017ce4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017ce8:	82 02       	mov %d2,0
80017cea:	e9 22 04 00 	st.b [%a2]4,%d2
  /* initialize the end of the heap */
  ram_end = ptr_to_mem(MEM_SIZE_ALIGNED);
80017cee:	3b 00 40 46 	mov %d4,25600
80017cf2:	6d ff b3 fe 	call 80017a58 <ptr_to_mem>
80017cf6:	80 22       	mov.d %d2,%a2
80017cf8:	91 10 00 27 	movh.a %a2,28673
80017cfc:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80017d00:	74 22       	st.w [%a2],%d2
  ram_end->used = 1;
80017d02:	91 10 00 27 	movh.a %a2,28673
80017d06:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80017d0a:	d4 22       	ld.a %a2,[%a2]
80017d0c:	82 12       	mov %d2,1
80017d0e:	e9 22 04 00 	st.b [%a2]4,%d2
  ram_end->next = MEM_SIZE_ALIGNED;
80017d12:	91 10 00 27 	movh.a %a2,28673
80017d16:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80017d1a:	d4 22       	ld.a %a2,[%a2]
80017d1c:	3b 00 40 26 	mov %d2,25600
80017d20:	b4 22       	st.h [%a2],%d2
  ram_end->prev = MEM_SIZE_ALIGNED;
80017d22:	91 10 00 27 	movh.a %a2,28673
80017d26:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80017d2a:	d4 22       	ld.a %a2,[%a2]
80017d2c:	3b 00 40 26 	mov %d2,25600
80017d30:	f9 22 02 00 	st.h [%a2]2,%d2
  MEM_SANITY();

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
80017d34:	91 10 00 27 	movh.a %a2,28673
80017d38:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
80017d3c:	54 22       	ld.w %d2,[%a2]
80017d3e:	91 10 00 27 	movh.a %a2,28673
80017d42:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80017d46:	74 22       	st.w [%a2],%d2

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
80017d48:	91 10 00 27 	movh.a %a2,28673
80017d4c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017d50:	3b 00 40 26 	mov %d2,25600
80017d54:	f9 22 2e 20 	st.h [%a2]174 <700100ae <ram_heap+0x501a>>,%d2

  if (sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
80017d58:	00 00       	nop 
80017d5a:	00 90       	ret 

80017d5c <mem_link_valid>:
/* Check if a struct mem is correctly linked.
 * If not, double-free is a possible reason.
 */
static int
mem_link_valid(struct mem *mem)
{
80017d5c:	40 ae       	mov.aa %a14,%sp
80017d5e:	20 18       	sub.a %sp,24
80017d60:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  struct mem *nmem, *pmem;
  mem_size_t rmem_idx;
  rmem_idx = mem_to_ptr(mem);
80017d64:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80017d68:	6d ff 87 fe 	call 80017a76 <mem_to_ptr>
80017d6c:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  nmem = ptr_to_mem(mem->next);
80017d70:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80017d74:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017d78:	02 24       	mov %d4,%d2
80017d7a:	6d ff 6f fe 	call 80017a58 <ptr_to_mem>
80017d7e:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  pmem = ptr_to_mem(mem->prev);
80017d82:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80017d86:	b9 22 02 00 	ld.hu %d2,[%a2]2
80017d8a:	02 24       	mov %d4,%d2
80017d8c:	6d ff 66 fe 	call 80017a58 <ptr_to_mem>
80017d90:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
80017d94:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80017d98:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017d9c:	3b 10 40 36 	mov %d3,25601
80017da0:	7f 32 2b 80 	jge.u %d2,%d3,80017df6 <mem_link_valid+0x9a>
80017da4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80017da8:	b9 22 02 00 	ld.hu %d2,[%a2]2
80017dac:	3b 10 40 36 	mov %d3,25601
80017db0:	7f 32 23 80 	jge.u %d2,%d3,80017df6 <mem_link_valid+0x9a>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
80017db4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80017db8:	b9 22 02 00 	ld.hu %d2,[%a2]2
  if ((mem->next > MEM_SIZE_ALIGNED) || (mem->prev > MEM_SIZE_ALIGNED) ||
80017dbc:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80017dc0:	5f 23 0a 00 	jeq %d3,%d2,80017dd4 <mem_link_valid+0x78>
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
80017dc4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80017dc8:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017dcc:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80017dd0:	5f 23 13 80 	jne %d3,%d2,80017df6 <mem_link_valid+0x9a>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
80017dd4:	91 10 00 27 	movh.a %a2,28673
80017dd8:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80017ddc:	54 22       	ld.w %d2,[%a2]
      ((mem->prev != rmem_idx) && (pmem->next != rmem_idx)) ||
80017dde:	19 e3 f8 ff 	ld.w %d3,[%a14]-8 <700114ac <ram_end>>
80017de2:	5f 23 0c 00 	jeq %d3,%d2,80017dfa <mem_link_valid+0x9e>
      ((nmem != ram_end) && (nmem->prev != rmem_idx))) {
80017de6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80017dea:	b9 22 02 00 	ld.hu %d2,[%a2]2
80017dee:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80017df2:	5f 23 04 00 	jeq %d3,%d2,80017dfa <mem_link_valid+0x9e>
    return 0;
80017df6:	82 02       	mov %d2,0
80017df8:	00 90       	ret 
  }
  return 1;
80017dfa:	82 12       	mov %d2,1
}
80017dfc:	00 90       	ret 

80017dfe <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
80017dfe:	40 ae       	mov.aa %a14,%sp
80017e00:	20 20       	sub.a %sp,32
80017e02:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
80017e06:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017e0a:	df 02 fd 00 	jeq %d2,0,80018004 <mem_free+0x206>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  if ((((mem_ptr_t)rmem) & (MEM_ALIGNMENT - 1)) != 0) {
80017e0e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017e12:	8f 32 00 21 	and %d2,%d2,3
80017e16:	df 02 27 00 	jeq %d2,0,80017e64 <mem_free+0x66>
    LWIP_MEM_ILLEGAL_FREE("mem_free: sanity check alignment");
80017e1a:	91 00 00 28 	movh.a %a2,32768
80017e1e:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80017e22:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80017e26:	3b 30 27 20 	mov %d2,627
80017e2a:	59 a2 04 00 	st.w [%sp]4,%d2
80017e2e:	91 00 00 28 	movh.a %a2,32768
80017e32:	d9 22 4b 01 	lea %a2,[%a2]5131 <8000140b <IfxCpu_Trap_vectorTable0_end+0x1217>>
80017e36:	f4 a2       	st.a [%sp],%a2
80017e38:	91 00 00 28 	movh.a %a2,32768
80017e3c:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80017e40:	6d ff 7b 6a 	call 80005336 <Ifx_Lwip_printf>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: sanity check alignment\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
80017e44:	91 10 00 27 	movh.a %a2,28673
80017e48:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017e4c:	b9 22 34 20 	ld.hu %d2,[%a2]180 <700100b4 <ram_heap+0x5020>>
80017e50:	c2 12       	add %d2,1
80017e52:	37 02 70 20 	extr.u %d2,%d2,0,16
80017e56:	91 10 00 27 	movh.a %a2,28673
80017e5a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017e5e:	f9 22 34 20 	st.h [%a2]180 <700100b4 <ram_heap+0x5020>>,%d2
    return;
80017e62:	00 90       	ret 
  }

  /* Get the corresponding struct mem: */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
80017e64:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017e68:	c2 82       	add %d2,-8
80017e6a:	59 e2 fc ff 	st.w [%a14]-4,%d2

  if ((u8_t *)mem < ram || (u8_t *)rmem + MIN_SIZE_ALIGNED > (u8_t *)ram_end) {
80017e6e:	91 10 00 27 	movh.a %a2,28673
80017e72:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
80017e76:	54 22       	ld.w %d2,[%a2]
80017e78:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700114a8 <ram>>
80017e7c:	3f 23 0d 80 	jlt.u %d3,%d2,80017e96 <mem_free+0x98>
80017e80:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80017e84:	1b c2 00 20 	addi %d2,%d2,12
80017e88:	91 10 00 27 	movh.a %a2,28673
80017e8c:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80017e90:	54 23       	ld.w %d3,[%a2]
80017e92:	7f 23 27 80 	jge.u %d3,%d2,80017ee0 <mem_free+0xe2>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory");
80017e96:	91 00 00 28 	movh.a %a2,32768
80017e9a:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80017e9e:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80017ea2:	3b f0 27 20 	mov %d2,639
80017ea6:	59 a2 04 00 	st.w [%sp]4,%d2
80017eaa:	91 00 00 28 	movh.a %a2,32768
80017eae:	d9 22 6c 01 	lea %a2,[%a2]5164 <8000142c <IfxCpu_Trap_vectorTable0_end+0x1238>>
80017eb2:	f4 a2       	st.a [%sp],%a2
80017eb4:	91 00 00 28 	movh.a %a2,32768
80017eb8:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80017ebc:	6d ff 3d 6a 	call 80005336 <Ifx_Lwip_printf>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
80017ec0:	91 10 00 27 	movh.a %a2,28673
80017ec4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017ec8:	b9 22 34 20 	ld.hu %d2,[%a2]180 <700100b4 <ram_heap+0x5020>>
80017ecc:	c2 12       	add %d2,1
80017ece:	37 02 70 20 	extr.u %d2,%d2,0,16
80017ed2:	91 10 00 27 	movh.a %a2,28673
80017ed6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017eda:	f9 22 34 20 	st.h [%a2]180 <700100b4 <ram_heap+0x5020>>,%d2
    return;
80017ede:	00 90       	ret 
  mem_overflow_check_element(mem);
#endif
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* mem has to be in a used state */
  if (!mem->used) {
80017ee0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017ee4:	39 22 04 00 	ld.bu %d2,[%a2]4
80017ee8:	df 02 27 80 	jne %d2,0,80017f36 <mem_free+0x138>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: double free");
80017eec:	91 00 00 28 	movh.a %a2,32768
80017ef0:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80017ef4:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80017ef8:	3b c0 28 20 	mov %d2,652
80017efc:	59 a2 04 00 	st.w [%sp]4,%d2
80017f00:	91 00 00 28 	movh.a %a2,32768
80017f04:	d9 22 45 11 	lea %a2,[%a2]5189 <80001445 <IfxCpu_Trap_vectorTable0_end+0x1251>>
80017f08:	f4 a2       	st.a [%sp],%a2
80017f0a:	91 00 00 28 	movh.a %a2,32768
80017f0e:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80017f12:	6d ff 12 6a 	call 80005336 <Ifx_Lwip_printf>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
80017f16:	91 10 00 27 	movh.a %a2,28673
80017f1a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017f1e:	b9 22 34 20 	ld.hu %d2,[%a2]180 <700100b4 <ram_heap+0x5020>>
80017f22:	c2 12       	add %d2,1
80017f24:	37 02 70 20 	extr.u %d2,%d2,0,16
80017f28:	91 10 00 27 	movh.a %a2,28673
80017f2c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017f30:	f9 22 34 20 	st.h [%a2]180 <700100b4 <ram_heap+0x5020>>,%d2
    return;
80017f34:	00 90       	ret 
  }

  if (!mem_link_valid(mem)) {
80017f36:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80017f3a:	6d ff 11 ff 	call 80017d5c <mem_link_valid>
80017f3e:	df 02 27 80 	jne %d2,0,80017f8c <mem_free+0x18e>
    LWIP_MEM_ILLEGAL_FREE("mem_free: illegal memory: non-linked: double free");
80017f42:	91 00 00 28 	movh.a %a2,32768
80017f46:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80017f4a:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80017f4e:	3b 50 29 20 	mov %d2,661
80017f52:	59 a2 04 00 	st.w [%sp]4,%d2
80017f56:	91 00 00 28 	movh.a %a2,32768
80017f5a:	d9 22 6b 11 	lea %a2,[%a2]5227 <8000146b <IfxCpu_Trap_vectorTable0_end+0x1277>>
80017f5e:	f4 a2       	st.a [%sp],%a2
80017f60:	91 00 00 28 	movh.a %a2,32768
80017f64:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80017f68:	6d ff e7 69 	call 80005336 <Ifx_Lwip_printf>
    LWIP_MEM_FREE_UNPROTECT();
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory: non-linked: double free?\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
80017f6c:	91 10 00 27 	movh.a %a2,28673
80017f70:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017f74:	b9 22 34 20 	ld.hu %d2,[%a2]180 <700100b4 <ram_heap+0x5020>>
80017f78:	c2 12       	add %d2,1
80017f7a:	37 02 70 20 	extr.u %d2,%d2,0,16
80017f7e:	91 10 00 27 	movh.a %a2,28673
80017f82:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017f86:	f9 22 34 20 	st.h [%a2]180 <700100b4 <ram_heap+0x5020>>,%d2
    return;
80017f8a:	00 90       	ret 
  }

  /* mem is now unused. */
  mem->used = 0;
80017f8c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017f90:	82 02       	mov %d2,0
80017f92:	e9 22 04 00 	st.b [%a2]4,%d2

  if (mem < lfree) {
80017f96:	91 10 00 27 	movh.a %a2,28673
80017f9a:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80017f9e:	54 22       	ld.w %d2,[%a2]
80017fa0:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700114b0 <lfree>>
80017fa4:	7f 23 09 80 	jge.u %d3,%d2,80017fb6 <mem_free+0x1b8>
    /* the newly freed struct is now the lowest */
    lfree = mem;
80017fa8:	91 10 00 27 	movh.a %a2,28673
80017fac:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80017fb0:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <700114b0 <lfree>>
80017fb4:	74 22       	st.w [%a2],%d2
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
80017fb6:	91 10 00 27 	movh.a %a2,28673
80017fba:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017fbe:	b9 23 30 20 	ld.hu %d3,[%a2]176 <700100b0 <ram_heap+0x501c>>
80017fc2:	91 10 00 27 	movh.a %a2,28673
80017fc6:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
80017fca:	54 22       	ld.w %d2,[%a2]
80017fcc:	19 e4 fc ff 	ld.w %d4,[%a14]-4 <700114a8 <ram>>
80017fd0:	0b 24 80 20 	sub %d2,%d4,%d2
80017fd4:	37 02 70 40 	extr.u %d4,%d2,0,16
80017fd8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80017fdc:	b9 22 00 00 	ld.hu %d2,[%a2]0
80017fe0:	0b 24 80 20 	sub %d2,%d4,%d2
80017fe4:	37 02 70 20 	extr.u %d2,%d2,0,16
80017fe8:	42 32       	add %d2,%d3
80017fea:	37 02 70 20 	extr.u %d2,%d2,0,16
80017fee:	91 10 00 27 	movh.a %a2,28673
80017ff2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80017ff6:	f9 22 30 20 	st.h [%a2]176 <700100b0 <ram_heap+0x501c>>,%d2

  /* finally, see if prev or next are free also */
  plug_holes(mem);
80017ffa:	99 e4 fc ff 	ld.a %a4,[%a14]-4 <700100b0 <ram_heap+0x501c>>
80017ffe:	6d ff 4c fd 	call 80017a96 <plug_holes>
80018002:	00 90       	ret 
    return;
80018004:	00 00       	nop 
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
80018006:	00 90       	ret 

80018008 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t new_size)
{
80018008:	40 ae       	mov.aa %a14,%sp
8001800a:	20 30       	sub.a %sp,48
8001800c:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80018010:	02 42       	mov %d2,%d4
80018012:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = (mem_size_t)LWIP_MEM_ALIGN_SIZE(new_size);
80018016:	c9 e2 e0 ff 	ld.h %d2,[%a14]-32
8001801a:	c2 32       	add %d2,3
8001801c:	37 02 70 20 	extr.u %d2,%d2,0,16
80018020:	8f 32 c0 21 	andn %d2,%d2,3
80018024:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  if (newsize < MIN_SIZE_ALIGNED) {
80018028:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8001802c:	ff c2 06 80 	jge.u %d2,12,80018038 <mem_trim+0x30>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
80018030:	3b c0 00 20 	mov %d2,12
80018034:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  }
#if MEM_OVERFLOW_CHECK
  newsize += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((newsize > MEM_SIZE_ALIGNED) || (newsize < new_size)) {
80018038:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8001803c:	3b 10 40 36 	mov %d3,25601
80018040:	7f 32 08 80 	jge.u %d2,%d3,80018050 <mem_trim+0x48>
80018044:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80018048:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
8001804c:	7f 23 05 80 	jge.u %d3,%d2,80018056 <mem_trim+0x4e>
    return NULL;
80018050:	82 02       	mov %d2,0
80018052:	1d 00 b6 01 	j 800183be <mem_trim+0x3b6>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
80018056:	91 10 00 27 	movh.a %a2,28673
8001805a:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
8001805e:	54 22       	ld.w %d2,[%a2]
80018060:	19 e3 e4 ff 	ld.w %d3,[%a14]-28 <700114a8 <ram>>
80018064:	3f 23 0b 80 	jlt.u %d3,%d2,8001807a <mem_trim+0x72>
80018068:	91 10 00 27 	movh.a %a2,28673
8001806c:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80018070:	54 22       	ld.w %d2,[%a2]
80018072:	19 e3 e4 ff 	ld.w %d3,[%a14]-28 <700114ac <ram_end>>
80018076:	3f 23 17 80 	jlt.u %d3,%d2,800180a4 <mem_trim+0x9c>
8001807a:	91 00 00 28 	movh.a %a2,32768
8001807e:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80018082:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80018086:	3b 10 2d 20 	mov %d2,721
8001808a:	59 a2 04 00 	st.w [%sp]4,%d2
8001808e:	91 00 00 28 	movh.a %a2,32768
80018092:	d9 22 5d 21 	lea %a2,[%a2]5277 <8000149d <IfxCpu_Trap_vectorTable0_end+0x12a9>>
80018096:	f4 a2       	st.a [%sp],%a2
80018098:	91 00 00 28 	movh.a %a2,32768
8001809c:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
800180a0:	6d ff 4b 69 	call 80005336 <Ifx_Lwip_printf>
              (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
800180a4:	91 10 00 27 	movh.a %a2,28673
800180a8:	d9 22 68 21 	lea %a2,[%a2]5288 <700114a8 <ram>>
800180ac:	54 22       	ld.w %d2,[%a2]
800180ae:	19 e3 e4 ff 	ld.w %d3,[%a14]-28 <700114a8 <ram>>
800180b2:	3f 23 0b 80 	jlt.u %d3,%d2,800180c8 <mem_trim+0xc0>
800180b6:	91 10 00 27 	movh.a %a2,28673
800180ba:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
800180be:	54 22       	ld.w %d2,[%a2]
800180c0:	19 e3 e4 ff 	ld.w %d3,[%a14]-28 <700114ac <ram_end>>
800180c4:	3f 23 15 80 	jlt.u %d3,%d2,800180ee <mem_trim+0xe6>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    MEM_STATS_INC_LOCKED(illegal);
800180c8:	91 10 00 27 	movh.a %a2,28673
800180cc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800180d0:	b9 22 34 20 	ld.hu %d2,[%a2]180 <700100b4 <ram_heap+0x5020>>
800180d4:	c2 12       	add %d2,1
800180d6:	37 02 70 20 	extr.u %d2,%d2,0,16
800180da:	91 10 00 27 	movh.a %a2,28673
800180de:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800180e2:	f9 22 34 20 	st.h [%a2]180 <700100b4 <ram_heap+0x5020>>,%d2
    return rmem;
800180e6:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <700100b4 <ram_heap+0x5020>>
800180ea:	1d 00 6a 01 	j 800183be <mem_trim+0x3b6>
  }
  /* Get the corresponding struct mem ... */
  /* cast through void* to get rid of alignment warnings */
  mem = (struct mem *)(void *)((u8_t *)rmem - (SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET));
800180ee:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800180f2:	c2 82       	add %d2,-8
800180f4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
#if MEM_OVERFLOW_CHECK
  mem_overflow_check_element(mem);
#endif
  /* ... and its offset pointer */
  ptr = mem_to_ptr(mem);
800180f8:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
800180fc:	6d ff bd fc 	call 80017a76 <mem_to_ptr>
80018100:	f9 e2 f6 ff 	st.h [%a14]-10,%d2

  size = (mem_size_t)((mem_size_t)(mem->next - ptr) - (SIZEOF_STRUCT_MEM + MEM_SANITY_OVERHEAD));
80018104:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80018108:	b9 23 00 00 	ld.hu %d3,[%a2]0
8001810c:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
80018110:	0b 23 80 20 	sub %d2,%d3,%d2
80018114:	37 02 70 20 	extr.u %d2,%d2,0,16
80018118:	c2 82       	add %d2,-8
8001811a:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
8001811e:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80018122:	b9 e3 f4 ff 	ld.hu %d3,[%a14]-12
80018126:	7f 23 17 80 	jge.u %d3,%d2,80018154 <mem_trim+0x14c>
8001812a:	91 00 00 28 	movh.a %a2,32768
8001812e:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80018132:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80018136:	3b 40 2e 20 	mov %d2,740
8001813a:	59 a2 04 00 	st.w [%sp]4,%d2
8001813e:	91 00 00 28 	movh.a %a2,32768
80018142:	d9 22 74 21 	lea %a2,[%a2]5300 <800014b4 <IfxCpu_Trap_vectorTable0_end+0x12c0>>
80018146:	f4 a2       	st.a [%sp],%a2
80018148:	91 00 00 28 	movh.a %a2,32768
8001814c:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80018150:	6d ff f3 68 	call 80005336 <Ifx_Lwip_printf>
  if (newsize > size) {
80018154:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80018158:	b9 e3 f4 ff 	ld.hu %d3,[%a14]-12
8001815c:	7f 23 05 80 	jge.u %d3,%d2,80018166 <mem_trim+0x15e>
    /* not supported */
    return NULL;
80018160:	82 02       	mov %d2,0
80018162:	1d 00 2e 01 	j 800183be <mem_trim+0x3b6>
  }
  if (newsize == size) {
80018166:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
8001816a:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8001816e:	5f 23 06 80 	jne %d3,%d2,8001817a <mem_trim+0x172>
    /* No change in size, simply return */
    return rmem;
80018172:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80018176:	1d 00 24 01 	j 800183be <mem_trim+0x3b6>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = ptr_to_mem(mem->next);
8001817a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001817e:	b9 22 00 00 	ld.hu %d2,[%a2]0
80018182:	02 24       	mov %d4,%d2
80018184:	6d ff 6a fc 	call 80017a58 <ptr_to_mem>
80018188:	b5 e2 f0 ff 	st.a [%a14]-16,%a2
  if (mem2->used == 0) {
8001818c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018190:	39 22 04 00 	ld.bu %d2,[%a2]4
80018194:	df 02 8b 80 	jne %d2,0,800182aa <mem_trim+0x2a2>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
80018198:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001819c:	b9 22 00 00 	ld.hu %d2,[%a2]0
800181a0:	3b 00 40 36 	mov %d3,25600
800181a4:	5f 32 17 80 	jne %d2,%d3,800181d2 <mem_trim+0x1ca>
800181a8:	91 00 00 28 	movh.a %a2,32768
800181ac:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
800181b0:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
800181b4:	3b 50 2f 20 	mov %d2,757
800181b8:	59 a2 04 00 	st.w [%sp]4,%d2
800181bc:	91 00 00 28 	movh.a %a2,32768
800181c0:	d9 22 54 31 	lea %a2,[%a2]5332 <800014d4 <IfxCpu_Trap_vectorTable0_end+0x12e0>>
800181c4:	f4 a2       	st.a [%sp],%a2
800181c6:	91 00 00 28 	movh.a %a2,32768
800181ca:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
800181ce:	6d ff b4 68 	call 80005336 <Ifx_Lwip_printf>
    /* remember the old next pointer */
    next = mem2->next;
800181d2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800181d6:	94 22       	ld.h %d2,[%a2]
800181d8:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
800181dc:	c9 e3 f6 ff 	ld.h %d3,[%a14]-10
800181e0:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800181e4:	42 32       	add %d2,%d3
800181e6:	37 02 70 20 	extr.u %d2,%d2,0,16
800181ea:	1b 82 00 20 	addi %d2,%d2,8
800181ee:	f9 e2 ee ff 	st.h [%a14]-18,%d2
    if (lfree == mem2) {
800181f2:	91 10 00 27 	movh.a %a2,28673
800181f6:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
800181fa:	54 22       	ld.w %d2,[%a2]
800181fc:	19 e3 f0 ff 	ld.w %d3,[%a14]-16 <700114b0 <lfree>>
80018200:	5f 23 0d 80 	jne %d3,%d2,8001821a <mem_trim+0x212>
      lfree = ptr_to_mem(ptr2);
80018204:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80018208:	02 24       	mov %d4,%d2
8001820a:	6d ff 27 fc 	call 80017a58 <ptr_to_mem>
8001820e:	80 22       	mov.d %d2,%a2
80018210:	91 10 00 27 	movh.a %a2,28673
80018214:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80018218:	74 22       	st.w [%a2],%d2
    }
    mem2 = ptr_to_mem(ptr2);
8001821a:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18 <700114b0 <lfree>>
8001821e:	02 24       	mov %d4,%d2
80018220:	6d ff 1c fc 	call 80017a58 <ptr_to_mem>
80018224:	b5 e2 f0 ff 	st.a [%a14]-16,%a2
    mem2->used = 0;
80018228:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001822c:	82 02       	mov %d2,0
8001822e:	e9 22 04 00 	st.b [%a2]4,%d2
    /* restore the next pointer */
    mem2->next = next;
80018232:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018236:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
8001823a:	b4 22       	st.h [%a2],%d2
    /* link it back to mem */
    mem2->prev = ptr;
8001823c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018240:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
80018244:	f9 22 02 00 	st.h [%a2]2,%d2
    /* link mem to it */
    mem->next = ptr2;
80018248:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001824c:	c9 e2 ee ff 	ld.h %d2,[%a14]-18
80018250:	b4 22       	st.h [%a2],%d2
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
80018252:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018256:	b9 22 00 00 	ld.hu %d2,[%a2]0
8001825a:	3b 00 40 36 	mov %d3,25600
8001825e:	5f 32 0d 00 	jeq %d2,%d3,80018278 <mem_trim+0x270>
      ptr_to_mem(mem2->next)->prev = ptr2;
80018262:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018266:	b9 22 00 00 	ld.hu %d2,[%a2]0
8001826a:	02 24       	mov %d4,%d2
8001826c:	6d ff f6 fb 	call 80017a58 <ptr_to_mem>
80018270:	c9 e2 ee ff 	ld.h %d2,[%a14]-18
80018274:	f9 22 02 00 	st.h [%a2]2,%d2
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
80018278:	91 10 00 27 	movh.a %a2,28673
8001827c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80018280:	b9 23 30 20 	ld.hu %d3,[%a2]176 <700100b0 <ram_heap+0x501c>>
80018284:	c9 e4 fe ff 	ld.h %d4,[%a14]-2 <700100b0 <ram_heap+0x501c>>
80018288:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12 <700100b0 <ram_heap+0x501c>>
8001828c:	0b 24 80 20 	sub %d2,%d4,%d2
80018290:	37 02 70 20 	extr.u %d2,%d2,0,16
80018294:	42 32       	add %d2,%d3
80018296:	37 02 70 20 	extr.u %d2,%d2,0,16
8001829a:	91 10 00 27 	movh.a %a2,28673
8001829e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800182a2:	f9 22 30 20 	st.h [%a2]176 <700100b0 <ram_heap+0x501c>>,%d2
800182a6:	1d 00 8a 00 	j 800183ba <mem_trim+0x3b2>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
800182aa:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800182ae:	1b 42 01 30 	addi %d3,%d2,20
800182b2:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
800182b6:	3f 32 82 80 	jlt.u %d2,%d3,800183ba <mem_trim+0x3b2>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + newsize);
800182ba:	c9 e3 f6 ff 	ld.h %d3,[%a14]-10
800182be:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800182c2:	42 32       	add %d2,%d3
800182c4:	37 02 70 20 	extr.u %d2,%d2,0,16
800182c8:	1b 82 00 20 	addi %d2,%d2,8
800182cc:	f9 e2 ee ff 	st.h [%a14]-18,%d2
    LWIP_ASSERT("invalid next ptr", mem->next != MEM_SIZE_ALIGNED);
800182d0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800182d4:	b9 22 00 00 	ld.hu %d2,[%a2]0
800182d8:	3b 00 40 36 	mov %d3,25600
800182dc:	5f 32 17 80 	jne %d2,%d3,8001830a <mem_trim+0x302>
800182e0:	91 00 00 28 	movh.a %a2,32768
800182e4:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
800182e8:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
800182ec:	3b 60 31 20 	mov %d2,790
800182f0:	59 a2 04 00 	st.w [%sp]4,%d2
800182f4:	91 00 00 28 	movh.a %a2,32768
800182f8:	d9 22 54 31 	lea %a2,[%a2]5332 <800014d4 <IfxCpu_Trap_vectorTable0_end+0x12e0>>
800182fc:	f4 a2       	st.a [%sp],%a2
800182fe:	91 00 00 28 	movh.a %a2,32768
80018302:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80018306:	6d ff 18 68 	call 80005336 <Ifx_Lwip_printf>
    mem2 = ptr_to_mem(ptr2);
8001830a:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
8001830e:	02 24       	mov %d4,%d2
80018310:	6d ff a4 fb 	call 80017a58 <ptr_to_mem>
80018314:	b5 e2 f0 ff 	st.a [%a14]-16,%a2
    if (mem2 < lfree) {
80018318:	91 10 00 27 	movh.a %a2,28673
8001831c:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80018320:	54 22       	ld.w %d2,[%a2]
80018322:	19 e3 f0 ff 	ld.w %d3,[%a14]-16 <700114b0 <lfree>>
80018326:	7f 23 09 80 	jge.u %d3,%d2,80018338 <mem_trim+0x330>
      lfree = mem2;
8001832a:	91 10 00 27 	movh.a %a2,28673
8001832e:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80018332:	19 e2 f0 ff 	ld.w %d2,[%a14]-16 <700114b0 <lfree>>
80018336:	74 22       	st.w [%a2],%d2
    }
    mem2->used = 0;
80018338:	99 e2 f0 ff 	ld.a %a2,[%a14]-16 <700114b0 <lfree>>
8001833c:	82 02       	mov %d2,0
8001833e:	e9 22 04 00 	st.b [%a2]4,%d2
    mem2->next = mem->next;
80018342:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80018346:	b9 22 00 00 	ld.hu %d2,[%a2]0
8001834a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001834e:	b4 22       	st.h [%a2],%d2
    mem2->prev = ptr;
80018350:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018354:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
80018358:	f9 22 02 00 	st.h [%a2]2,%d2
    mem->next = ptr2;
8001835c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80018360:	c9 e2 ee ff 	ld.h %d2,[%a14]-18
80018364:	b4 22       	st.h [%a2],%d2
    if (mem2->next != MEM_SIZE_ALIGNED) {
80018366:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001836a:	b9 22 00 00 	ld.hu %d2,[%a2]0
8001836e:	3b 00 40 36 	mov %d3,25600
80018372:	5f 32 0d 00 	jeq %d2,%d3,8001838c <mem_trim+0x384>
      ptr_to_mem(mem2->next)->prev = ptr2;
80018376:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001837a:	b9 22 00 00 	ld.hu %d2,[%a2]0
8001837e:	02 24       	mov %d4,%d2
80018380:	6d ff 6c fb 	call 80017a58 <ptr_to_mem>
80018384:	c9 e2 ee ff 	ld.h %d2,[%a14]-18
80018388:	f9 22 02 00 	st.h [%a2]2,%d2
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
8001838c:	91 10 00 27 	movh.a %a2,28673
80018390:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80018394:	b9 23 30 20 	ld.hu %d3,[%a2]176 <700100b0 <ram_heap+0x501c>>
80018398:	c9 e4 fe ff 	ld.h %d4,[%a14]-2 <700100b0 <ram_heap+0x501c>>
8001839c:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12 <700100b0 <ram_heap+0x501c>>
800183a0:	0b 24 80 20 	sub %d2,%d4,%d2
800183a4:	37 02 70 20 	extr.u %d2,%d2,0,16
800183a8:	42 32       	add %d2,%d3
800183aa:	37 02 70 20 	extr.u %d2,%d2,0,16
800183ae:	91 10 00 27 	movh.a %a2,28673
800183b2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800183b6:	f9 22 30 20 	st.h [%a2]176 <700100b0 <ram_heap+0x501c>>,%d2
  MEM_SANITY();
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
800183ba:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <700100b0 <ram_heap+0x501c>>
}
800183be:	60 22       	mov.a %a2,%d2
800183c0:	00 90       	ret 

800183c2 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size_in)
{
800183c2:	40 ae       	mov.aa %a14,%sp
800183c4:	20 30       	sub.a %sp,48
800183c6:	02 42       	mov %d2,%d4
800183c8:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size_in == 0) {
800183cc:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
800183d0:	df 02 05 80 	jne %d2,0,800183da <mem_malloc+0x18>
    return NULL;
800183d4:	82 02       	mov %d2,0
800183d6:	1d 00 fe 01 	j 800187d2 <mem_malloc+0x410>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = (mem_size_t)LWIP_MEM_ALIGN_SIZE(size_in);
800183da:	c9 e2 e4 ff 	ld.h %d2,[%a14]-28
800183de:	c2 32       	add %d2,3
800183e0:	37 02 70 20 	extr.u %d2,%d2,0,16
800183e4:	8f 32 c0 21 	andn %d2,%d2,3
800183e8:	f9 e2 fc ff 	st.h [%a14]-4,%d2
  if (size < MIN_SIZE_ALIGNED) {
800183ec:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800183f0:	ff c2 06 80 	jge.u %d2,12,800183fc <mem_malloc+0x3a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
800183f4:	3b c0 00 20 	mov %d2,12
800183f8:	f9 e2 fc ff 	st.h [%a14]-4,%d2
  }
#if MEM_OVERFLOW_CHECK
  size += MEM_SANITY_REGION_BEFORE_ALIGNED + MEM_SANITY_REGION_AFTER_ALIGNED;
#endif
  if ((size > MEM_SIZE_ALIGNED) || (size < size_in)) {
800183fc:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80018400:	3b 10 40 36 	mov %d3,25601
80018404:	7f 32 08 80 	jge.u %d2,%d3,80018414 <mem_malloc+0x52>
80018408:	b9 e3 fc ff 	ld.hu %d3,[%a14]-4
8001840c:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
80018410:	7f 23 05 80 	jge.u %d3,%d2,8001841a <mem_malloc+0x58>
    return NULL;
80018414:	82 02       	mov %d2,0
80018416:	1d 00 de 01 	j 800187d2 <mem_malloc+0x410>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
8001841a:	91 10 00 27 	movh.a %a2,28673
8001841e:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80018422:	54 22       	ld.w %d2,[%a2]
80018424:	60 24       	mov.a %a4,%d2
80018426:	6d ff 28 fb 	call 80017a76 <mem_to_ptr>
8001842a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
8001842e:	1d 00 b8 01 	j 8001879e <mem_malloc+0x3dc>
         ptr = ptr_to_mem(ptr)->next) {
      mem = ptr_to_mem(ptr);
80018432:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80018436:	02 24       	mov %d4,%d2
80018438:	6d ff 10 fb 	call 80017a58 <ptr_to_mem>
8001843c:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
80018440:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018444:	39 22 04 00 	ld.bu %d2,[%a2]4
80018448:	df 02 a3 81 	jne %d2,0,8001878e <mem_malloc+0x3cc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
8001844c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018450:	b9 22 00 00 	ld.hu %d2,[%a2]0
80018454:	02 23       	mov %d3,%d2
80018456:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8001845a:	0b 23 80 20 	sub %d2,%d3,%d2
8001845e:	1b 82 ff 3f 	addi %d3,%d2,-8
80018462:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
      if ((!mem->used) &&
80018466:	3f 23 94 81 	jlt.u %d3,%d2,8001878e <mem_malloc+0x3cc>
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
8001846a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001846e:	b9 22 00 00 	ld.hu %d2,[%a2]0
80018472:	02 23       	mov %d3,%d2
80018474:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80018478:	0b 23 80 20 	sub %d2,%d3,%d2
8001847c:	1b 82 ff 3f 	addi %d3,%d2,-8
80018480:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
80018484:	1b 42 01 20 	addi %d2,%d2,20
80018488:	3f 23 8f 80 	jlt.u %d3,%d2,800185a6 <mem_malloc+0x1e4>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = (mem_size_t)(ptr + SIZEOF_STRUCT_MEM + size);
8001848c:	c9 e3 fe ff 	ld.h %d3,[%a14]-2
80018490:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80018494:	42 32       	add %d2,%d3
80018496:	37 02 70 20 	extr.u %d2,%d2,0,16
8001849a:	1b 82 00 20 	addi %d2,%d2,8
8001849e:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
          LWIP_ASSERT("invalid next ptr",ptr2 != MEM_SIZE_ALIGNED);
800184a2:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
800184a6:	3b 00 40 36 	mov %d3,25600
800184aa:	5f 32 17 80 	jne %d2,%d3,800184d8 <mem_malloc+0x116>
800184ae:	91 00 00 28 	movh.a %a2,32768
800184b2:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
800184b6:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
800184ba:	3b 70 38 20 	mov %d2,903
800184be:	59 a2 04 00 	st.w [%sp]4,%d2
800184c2:	91 00 00 28 	movh.a %a2,32768
800184c6:	d9 22 54 31 	lea %a2,[%a2]5332 <800014d4 <IfxCpu_Trap_vectorTable0_end+0x12e0>>
800184ca:	f4 a2       	st.a [%sp],%a2
800184cc:	91 00 00 28 	movh.a %a2,32768
800184d0:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
800184d4:	6d ff 31 67 	call 80005336 <Ifx_Lwip_printf>
          /* create mem2 struct */
          mem2 = ptr_to_mem(ptr2);
800184d8:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
800184dc:	02 24       	mov %d4,%d2
800184de:	6d ff bd fa 	call 80017a58 <ptr_to_mem>
800184e2:	b5 e2 ec ff 	st.a [%a14]-20,%a2
          mem2->used = 0;
800184e6:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800184ea:	82 02       	mov %d2,0
800184ec:	e9 22 04 00 	st.b [%a2]4,%d2
          mem2->next = mem->next;
800184f0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800184f4:	b9 22 00 00 	ld.hu %d2,[%a2]0
800184f8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800184fc:	b4 22       	st.h [%a2],%d2
          mem2->prev = ptr;
800184fe:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80018502:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80018506:	f9 22 02 00 	st.h [%a2]2,%d2
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
8001850a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001850e:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80018512:	b4 22       	st.h [%a2],%d2
          mem->used = 1;
80018514:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018518:	82 12       	mov %d2,1
8001851a:	e9 22 04 00 	st.b [%a2]4,%d2

          if (mem2->next != MEM_SIZE_ALIGNED) {
8001851e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80018522:	b9 22 00 00 	ld.hu %d2,[%a2]0
80018526:	3b 00 40 36 	mov %d3,25600
8001852a:	5f 32 0d 00 	jeq %d2,%d3,80018544 <mem_malloc+0x182>
            ptr_to_mem(mem2->next)->prev = ptr2;
8001852e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80018532:	b9 22 00 00 	ld.hu %d2,[%a2]0
80018536:	02 24       	mov %d4,%d2
80018538:	6d ff 90 fa 	call 80017a58 <ptr_to_mem>
8001853c:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80018540:	f9 22 02 00 	st.h [%a2]2,%d2
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
80018544:	91 10 00 27 	movh.a %a2,28673
80018548:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001854c:	b9 23 30 20 	ld.hu %d3,[%a2]176 <700100b0 <ram_heap+0x501c>>
80018550:	c9 e2 fc ff 	ld.h %d2,[%a14]-4 <700100b0 <ram_heap+0x501c>>
80018554:	42 32       	add %d2,%d3
80018556:	37 02 70 20 	extr.u %d2,%d2,0,16
8001855a:	1b 82 00 20 	addi %d2,%d2,8
8001855e:	37 02 70 20 	extr.u %d2,%d2,0,16
80018562:	91 10 00 27 	movh.a %a2,28673
80018566:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001856a:	f9 22 30 20 	st.h [%a2]176 <700100b0 <ram_heap+0x501c>>,%d2
8001856e:	91 10 00 27 	movh.a %a2,28673
80018572:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80018576:	b9 23 32 20 	ld.hu %d3,[%a2]178 <700100b2 <ram_heap+0x501e>>
8001857a:	91 10 00 27 	movh.a %a2,28673
8001857e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80018582:	b9 22 30 20 	ld.hu %d2,[%a2]176 <700100b0 <ram_heap+0x501c>>
80018586:	7f 23 4a 80 	jge.u %d3,%d2,8001861a <mem_malloc+0x258>
8001858a:	91 10 00 27 	movh.a %a2,28673
8001858e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80018592:	b9 22 30 20 	ld.hu %d2,[%a2]176 <700100b0 <ram_heap+0x501c>>
80018596:	91 10 00 27 	movh.a %a2,28673
8001859a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001859e:	f9 22 32 20 	st.h [%a2]178 <700100b2 <ram_heap+0x501e>>,%d2
800185a2:	1d 00 3c 00 	j 8001861a <mem_malloc+0x258>
           * take care of this).
           * -> near fit or exact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
800185a6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800185aa:	82 12       	mov %d2,1
800185ac:	e9 22 04 00 	st.b [%a2]4,%d2
          MEM_STATS_INC_USED(used, mem->next - mem_to_ptr(mem));
800185b0:	91 10 00 27 	movh.a %a2,28673
800185b4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800185b8:	b9 23 30 20 	ld.hu %d3,[%a2]176 <700100b0 <ram_heap+0x501c>>
800185bc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <700100b0 <ram_heap+0x501c>>
800185c0:	b9 22 00 00 	ld.hu %d2,[%a2]0 <700100b0 <ram_heap+0x501c>>
800185c4:	42 32       	add %d2,%d3
800185c6:	37 02 70 80 	extr.u %d8,%d2,0,16
800185ca:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800185ce:	6d ff 54 fa 	call 80017a76 <mem_to_ptr>
800185d2:	0b 28 80 20 	sub %d2,%d8,%d2
800185d6:	37 02 70 20 	extr.u %d2,%d2,0,16
800185da:	91 10 00 27 	movh.a %a2,28673
800185de:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800185e2:	f9 22 30 20 	st.h [%a2]176 <700100b0 <ram_heap+0x501c>>,%d2
800185e6:	91 10 00 27 	movh.a %a2,28673
800185ea:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800185ee:	b9 23 32 20 	ld.hu %d3,[%a2]178 <700100b2 <ram_heap+0x501e>>
800185f2:	91 10 00 27 	movh.a %a2,28673
800185f6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800185fa:	b9 22 30 20 	ld.hu %d2,[%a2]176 <700100b0 <ram_heap+0x501c>>
800185fe:	7f 23 0e 80 	jge.u %d3,%d2,8001861a <mem_malloc+0x258>
80018602:	91 10 00 27 	movh.a %a2,28673
80018606:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001860a:	b9 22 30 20 	ld.hu %d2,[%a2]176 <700100b0 <ram_heap+0x501c>>
8001860e:	91 10 00 27 	movh.a %a2,28673
80018612:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80018616:	f9 22 32 20 	st.h [%a2]178 <700100b2 <ram_heap+0x501e>>,%d2
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
8001861a:	91 10 00 27 	movh.a %a2,28673
8001861e:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80018622:	54 22       	ld.w %d2,[%a2]
80018624:	19 e3 f4 ff 	ld.w %d3,[%a14]-12 <700114b0 <lfree>>
80018628:	5f 23 54 80 	jne %d3,%d2,800186d0 <mem_malloc+0x30e>
          struct mem *cur = lfree;
8001862c:	91 10 00 27 	movh.a %a2,28673
80018630:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80018634:	54 22       	ld.w %d2,[%a2]
80018636:	59 e2 f8 ff 	st.w [%a14]-8 <700114b0 <lfree>>,%d2
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
8001863a:	1d 00 0b 00 	j 80018650 <mem_malloc+0x28e>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = ptr_to_mem(cur->next);
8001863e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80018642:	b9 22 00 00 	ld.hu %d2,[%a2]0
80018646:	02 24       	mov %d4,%d2
80018648:	6d ff 08 fa 	call 80017a58 <ptr_to_mem>
8001864c:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
          while (cur->used && cur != ram_end) {
80018650:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80018654:	39 22 04 00 	ld.bu %d2,[%a2]4
80018658:	df 02 0b 00 	jeq %d2,0,8001866e <mem_malloc+0x2ac>
8001865c:	91 10 00 27 	movh.a %a2,28673
80018660:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
80018664:	54 22       	ld.w %d2,[%a2]
80018666:	19 e3 f8 ff 	ld.w %d3,[%a14]-8 <700114ac <ram_end>>
8001866a:	5f 23 ea ff 	jne %d3,%d2,8001863e <mem_malloc+0x27c>
          }
          lfree = cur;
8001866e:	91 10 00 27 	movh.a %a2,28673
80018672:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80018676:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <700114b0 <lfree>>
8001867a:	74 22       	st.w [%a2],%d2
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
8001867c:	91 10 00 27 	movh.a %a2,28673
80018680:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
80018684:	54 23       	ld.w %d3,[%a2]
80018686:	91 10 00 27 	movh.a %a2,28673
8001868a:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
8001868e:	54 22       	ld.w %d2,[%a2]
80018690:	5f 23 20 00 	jeq %d3,%d2,800186d0 <mem_malloc+0x30e>
80018694:	91 10 00 27 	movh.a %a2,28673
80018698:	d9 22 70 21 	lea %a2,[%a2]5296 <700114b0 <lfree>>
8001869c:	d4 22       	ld.a %a2,[%a2]
8001869e:	39 22 04 00 	ld.bu %d2,[%a2]4 <700114b0 <lfree>>
800186a2:	df 02 17 00 	jeq %d2,0,800186d0 <mem_malloc+0x30e>
800186a6:	91 00 00 28 	movh.a %a2,32768
800186aa:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
800186ae:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
800186b2:	3b 50 3b 20 	mov %d2,949
800186b6:	59 a2 04 00 	st.w [%sp]4,%d2
800186ba:	91 00 00 28 	movh.a %a2,32768
800186be:	d9 22 65 31 	lea %a2,[%a2]5349 <800014e5 <IfxCpu_Trap_vectorTable0_end+0x12f1>>
800186c2:	f4 a2       	st.a [%sp],%a2
800186c4:	91 00 00 28 	movh.a %a2,32768
800186c8:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
800186cc:	6d ff 35 66 	call 80005336 <Ifx_Lwip_printf>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
800186d0:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800186d4:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
800186d8:	42 32       	add %d2,%d3
800186da:	1b 82 00 20 	addi %d2,%d2,8
800186de:	91 10 00 27 	movh.a %a2,28673
800186e2:	d9 22 6c 21 	lea %a2,[%a2]5292 <700114ac <ram_end>>
800186e6:	54 23       	ld.w %d3,[%a2]
800186e8:	7f 23 17 80 	jge.u %d3,%d2,80018716 <mem_malloc+0x354>
800186ec:	91 00 00 28 	movh.a %a2,32768
800186f0:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
800186f4:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
800186f8:	3b 90 3b 20 	mov %d2,953
800186fc:	59 a2 04 00 	st.w [%sp]4,%d2
80018700:	91 00 00 28 	movh.a %a2,32768
80018704:	d9 22 7e 31 	lea %a2,[%a2]5374 <800014fe <IfxCpu_Trap_vectorTable0_end+0x130a>>
80018708:	f4 a2       	st.a [%sp],%a2
8001870a:	91 00 00 28 	movh.a %a2,32768
8001870e:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80018712:	6d ff 12 66 	call 80005336 <Ifx_Lwip_printf>
                    (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
80018716:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001871a:	8f 32 00 21 	and %d2,%d2,3
8001871e:	df 02 17 00 	jeq %d2,0,8001874c <mem_malloc+0x38a>
80018722:	91 00 00 28 	movh.a %a2,32768
80018726:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
8001872a:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
8001872e:	3b b0 3b 20 	mov %d2,955
80018732:	59 a2 04 00 	st.w [%sp]4,%d2
80018736:	91 00 00 28 	movh.a %a2,32768
8001873a:	d9 22 6e 41 	lea %a2,[%a2]5422 <8000152e <IfxCpu_Trap_vectorTable0_end+0x133a>>
8001873e:	f4 a2       	st.a [%sp],%a2
80018740:	91 00 00 28 	movh.a %a2,32768
80018744:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
80018748:	6d ff f7 65 	call 80005336 <Ifx_Lwip_printf>
                    ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
8001874c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80018750:	8f 32 00 21 	and %d2,%d2,3
80018754:	df 02 17 00 	jeq %d2,0,80018782 <mem_malloc+0x3c0>
80018758:	91 00 00 28 	movh.a %a2,32768
8001875c:	d9 22 2b d1 	lea %a2,[%a2]4971 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>
80018760:	b5 a2 08 00 	st.a [%sp]8 <8000136b <IfxCpu_Trap_vectorTable0_end+0x1177>>,%a2
80018764:	3b d0 3b 20 	mov %d2,957
80018768:	59 a2 04 00 	st.w [%sp]4,%d2
8001876c:	91 00 00 28 	movh.a %a2,32768
80018770:	d9 22 5d 51 	lea %a2,[%a2]5469 <8000155d <IfxCpu_Trap_vectorTable0_end+0x1369>>
80018774:	f4 a2       	st.a [%sp],%a2
80018776:	91 00 00 28 	movh.a %a2,32768
8001877a:	d9 24 03 d1 	lea %a4,[%a2]4931 <80001343 <IfxCpu_Trap_vectorTable0_end+0x114f>>
8001877e:	6d ff dc 65 	call 80005336 <Ifx_Lwip_printf>

#if MEM_OVERFLOW_CHECK
        mem_overflow_init_element(mem, size_in);
#endif
        MEM_SANITY();
        return (u8_t *)mem + SIZEOF_STRUCT_MEM + MEM_SANITY_OFFSET;
80018782:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80018786:	1b 82 00 20 	addi %d2,%d2,8
8001878a:	1d 00 24 00 	j 800187d2 <mem_malloc+0x410>
         ptr = ptr_to_mem(ptr)->next) {
8001878e:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80018792:	02 24       	mov %d4,%d2
80018794:	6d ff 62 f9 	call 80017a58 <ptr_to_mem>
80018798:	94 22       	ld.h %d2,[%a2]
8001879a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    for (ptr = mem_to_ptr(lfree); ptr < MEM_SIZE_ALIGNED - size;
8001879e:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800187a2:	b9 e3 fc ff 	ld.hu %d3,[%a14]-4
800187a6:	3b 00 40 46 	mov %d4,25600
800187aa:	0b 34 80 30 	sub %d3,%d4,%d3
800187ae:	3f 32 42 fe 	jlt.u %d2,%d3,80018432 <mem_malloc+0x70>
    }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while (local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  MEM_STATS_INC(err);
800187b2:	91 10 00 27 	movh.a %a2,28673
800187b6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800187ba:	b9 22 2c 20 	ld.hu %d2,[%a2]172 <700100ac <ram_heap+0x5018>>
800187be:	c2 12       	add %d2,1
800187c0:	37 02 70 20 	extr.u %d2,%d2,0,16
800187c4:	91 10 00 27 	movh.a %a2,28673
800187c8:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800187cc:	f9 22 2c 20 	st.h [%a2]172 <700100ac <ram_heap+0x5018>>,%d2
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  return NULL;
800187d0:	82 02       	mov %d2,0
}
800187d2:	60 22       	mov.a %a2,%d2
800187d4:	00 90       	ret 

800187d6 <memp_init_pool>:
 *
 * @param desc pool to initialize
 */
void
memp_init_pool(const struct memp_desc *desc)
{
800187d6:	40 ae       	mov.aa %a14,%sp
800187d8:	20 10       	sub.a %sp,16
800187da:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  LWIP_UNUSED_ARG(desc);
#else
  int i;
  struct memp *memp;

  *desc->tab = NULL;
800187de:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800187e2:	d9 22 10 00 	lea %a2,[%a2]16
800187e6:	d4 22       	ld.a %a2,[%a2]
800187e8:	82 02       	mov %d2,0
800187ea:	74 22       	st.w [%a2],%d2
  memp = (struct memp *)LWIP_MEM_ALIGN(desc->base);
800187ec:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800187f0:	d9 22 0c 00 	lea %a2,[%a2]12
800187f4:	54 22       	ld.w %d2,[%a2]
800187f6:	c2 32       	add %d2,3
800187f8:	8f 32 c0 21 	andn %d2,%d2,3
800187fc:	59 e2 f8 ff 	st.w [%a14]-8,%d2
                                       + MEM_SANITY_REGION_AFTER_ALIGNED
#endif
                                      ));
#endif
  /* create a linked list of memp elements */
  for (i = 0; i < desc->num; ++i) {
80018800:	82 02       	mov %d2,0
80018802:	59 e2 fc ff 	st.w [%a14]-4,%d2
80018806:	1d 00 22 00 	j 8001884a <memp_init_pool+0x74>
    memp->next = *desc->tab;
8001880a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001880e:	d9 22 10 00 	lea %a2,[%a2]16
80018812:	d4 22       	ld.a %a2,[%a2]
80018814:	54 22       	ld.w %d2,[%a2]
80018816:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001881a:	74 22       	st.w [%a2],%d2
    *desc->tab = memp;
8001881c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018820:	d9 22 10 00 	lea %a2,[%a2]16
80018824:	d4 22       	ld.a %a2,[%a2]
80018826:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001882a:	74 22       	st.w [%a2],%d2
#if MEMP_OVERFLOW_CHECK
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */
    /* cast through void* to get rid of alignment warnings */
    memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc->size
8001882c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018830:	b9 22 08 00 	ld.hu %d2,[%a2]8
80018834:	02 23       	mov %d3,%d2
80018836:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001883a:	42 32       	add %d2,%d3
8001883c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  for (i = 0; i < desc->num; ++i) {
80018840:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018844:	c2 12       	add %d2,1
80018846:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001884a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001884e:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80018852:	02 23       	mov %d3,%d2
80018854:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018858:	3f 32 d9 7f 	jlt %d2,%d3,8001880a <memp_init_pool+0x34>
                                   + MEM_SANITY_REGION_AFTER_ALIGNED
#endif
                                  );
  }
#if MEMP_STATS
  desc->stats->avail = desc->num;
8001885c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018860:	b0 42       	add.a %a2,4
80018862:	d4 22       	ld.a %a2,[%a2]
80018864:	99 e3 f4 ff 	ld.a %a3,[%a14]-12
80018868:	b9 32 0a 00 	ld.hu %d2,[%a3]10
8001886c:	f9 22 06 00 	st.h [%a2]6,%d2
#endif /* MEMP_STATS */
#endif /* !MEMP_MEM_MALLOC */

#if MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY)
  desc->stats->name  = desc->desc;
80018870:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018874:	b0 42       	add.a %a2,4
80018876:	d4 22       	ld.a %a2,[%a2]
80018878:	99 e3 f4 ff 	ld.a %a3,[%a14]-12
8001887c:	54 32       	ld.w %d2,[%a3]
8001887e:	74 22       	st.w [%a2],%d2
#endif /* MEMP_STATS && (defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY) */
}
80018880:	00 00       	nop 
80018882:	00 90       	ret 

80018884 <memp_init>:
 *
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
80018884:	40 ae       	mov.aa %a14,%sp
80018886:	20 08       	sub.a %sp,8
  u16_t i;

  /* for every pool: */
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
80018888:	82 02       	mov %d2,0
8001888a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
8001888e:	1d 00 2c 00 	j 800188e6 <memp_init+0x62>
    memp_init_pool(memp_pools[i]);
80018892:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80018896:	91 00 00 28 	movh.a %a2,32768
8001889a:	d9 22 58 74 	lea %a2,[%a2]17880 <800045d8 <memp_pools>>
8001889e:	06 22       	sh %d2,2
800188a0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800188a4:	54 22       	ld.w %d2,[%a2]
800188a6:	60 24       	mov.a %a4,%d2
800188a8:	6d ff 97 ff 	call 800187d6 <memp_init_pool>

#if LWIP_STATS && MEMP_STATS
    lwip_stats.memp[i] = memp_pools[i]->stats;
800188ac:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800188b0:	91 00 00 28 	movh.a %a2,32768
800188b4:	d9 22 58 74 	lea %a2,[%a2]17880 <800045d8 <memp_pools>>
800188b8:	06 22       	sh %d2,2
800188ba:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800188be:	d4 22       	ld.a %a2,[%a2]
800188c0:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800188c4:	b0 42       	add.a %a2,4
800188c6:	54 23       	ld.w %d3,[%a2]
800188c8:	91 10 00 27 	movh.a %a2,28673
800188cc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800188d0:	1b e2 02 20 	addi %d2,%d2,46
800188d4:	06 22       	sh %d2,2
800188d6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800188da:	74 23       	st.w [%a2],%d3
  for (i = 0; i < LWIP_ARRAYSIZE(memp_pools); i++) {
800188dc:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800188e0:	c2 12       	add %d2,1
800188e2:	f9 e2 fe ff 	st.h [%a14]-2,%d2
800188e6:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800188ea:	bf 92 d4 ff 	jlt.u %d2,9,80018892 <memp_init+0xe>

#if MEMP_OVERFLOW_CHECK >= 2
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
}
800188ee:	00 00       	nop 
800188f0:	00 00       	nop 
800188f2:	00 90       	ret 

800188f4 <do_memp_malloc_pool>:
#if !MEMP_OVERFLOW_CHECK
do_memp_malloc_pool(const struct memp_desc *desc)
#else
do_memp_malloc_pool_fn(const struct memp_desc *desc, const char *file, const int line)
#endif
{
800188f4:	40 ae       	mov.aa %a14,%sp
800188f6:	20 20       	sub.a %sp,32
800188f8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  memp = (struct memp *)mem_malloc(MEMP_SIZE + MEMP_ALIGN_SIZE(desc->size));
  SYS_ARCH_PROTECT(old_level);
#else /* MEMP_MEM_MALLOC */
  SYS_ARCH_PROTECT(old_level);

  memp = *desc->tab;
800188fc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018900:	d9 22 10 00 	lea %a2,[%a2]16
80018904:	d4 22       	ld.a %a2,[%a2]
80018906:	54 22       	ld.w %d2,[%a2]
80018908:	59 e2 fc ff 	st.w [%a14]-4,%d2
#endif /* MEMP_MEM_MALLOC */

  if (memp != NULL) {
8001890c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018910:	df 02 4f 00 	jeq %d2,0,800189ae <do_memp_malloc_pool+0xba>
#if !MEMP_MEM_MALLOC
#if MEMP_OVERFLOW_CHECK == 1
    memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

    *desc->tab = memp->next;
80018914:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018918:	d9 22 10 00 	lea %a2,[%a2]16
8001891c:	d4 22       	ld.a %a2,[%a2]
8001891e:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80018922:	54 32       	ld.w %d2,[%a3]
80018924:	74 22       	st.w [%a2],%d2
    memp->line = line;
#if MEMP_MEM_MALLOC
    memp_overflow_init_element(memp, desc);
#endif /* MEMP_MEM_MALLOC */
#endif /* MEMP_OVERFLOW_CHECK */
    LWIP_ASSERT("memp_malloc: memp properly aligned",
80018926:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001892a:	8f 32 00 21 	and %d2,%d2,3
8001892e:	df 02 17 00 	jeq %d2,0,8001895c <do_memp_malloc_pool+0x68>
80018932:	91 00 00 28 	movh.a %a2,32768
80018936:	d9 22 46 81 	lea %a2,[%a2]5638 <80001606 <IfxCpu_Trap_vectorTable0_end+0x1412>>
8001893a:	b5 a2 08 00 	st.a [%sp]8 <80001606 <IfxCpu_Trap_vectorTable0_end+0x1412>>,%a2
8001893e:	3b 80 11 20 	mov %d2,280
80018942:	59 a2 04 00 	st.w [%sp]4,%d2
80018946:	91 00 00 28 	movh.a %a2,32768
8001894a:	d9 22 71 81 	lea %a2,[%a2]5681 <80001631 <IfxCpu_Trap_vectorTable0_end+0x143d>>
8001894e:	f4 a2       	st.a [%sp],%a2
80018950:	91 00 00 28 	movh.a %a2,32768
80018954:	d9 24 5e 71 	lea %a4,[%a2]5598 <800015de <IfxCpu_Trap_vectorTable0_end+0x13ea>>
80018958:	6d ff ef 64 	call 80005336 <Ifx_Lwip_printf>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
#if MEMP_STATS
    desc->stats->used++;
8001895c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018960:	b0 42       	add.a %a2,4
80018962:	d4 22       	ld.a %a2,[%a2]
80018964:	b9 22 08 00 	ld.hu %d2,[%a2]8
80018968:	c2 12       	add %d2,1
8001896a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001896e:	f9 22 08 00 	st.h [%a2]8,%d2
    if (desc->stats->used > desc->stats->max) {
80018972:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018976:	b0 42       	add.a %a2,4
80018978:	d4 22       	ld.a %a2,[%a2]
8001897a:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001897e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018982:	b0 42       	add.a %a2,4
80018984:	d4 22       	ld.a %a2,[%a2]
80018986:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8001898a:	7f 23 0e 80 	jge.u %d3,%d2,800189a6 <do_memp_malloc_pool+0xb2>
      desc->stats->max = desc->stats->used;
8001898e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018992:	b0 42       	add.a %a2,4
80018994:	d4 23       	ld.a %a3,[%a2]
80018996:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001899a:	b0 42       	add.a %a2,4
8001899c:	d4 22       	ld.a %a2,[%a2]
8001899e:	b9 32 08 00 	ld.hu %d2,[%a3]8
800189a2:	f9 22 0a 00 	st.h [%a2]10,%d2
    }
#endif
    SYS_ARCH_UNPROTECT(old_level);
    /* cast through u8_t* to get rid of alignment warnings */
    return ((u8_t *)memp + MEMP_SIZE);
800189a6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800189aa:	1d 00 0e 00 	j 800189c6 <do_memp_malloc_pool+0xd2>
  } else {
#if MEMP_STATS
    desc->stats->err++;
800189ae:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800189b2:	b0 42       	add.a %a2,4
800189b4:	d4 22       	ld.a %a2,[%a2]
800189b6:	b9 22 04 00 	ld.hu %d2,[%a2]4
800189ba:	c2 12       	add %d2,1
800189bc:	37 02 70 20 	extr.u %d2,%d2,0,16
800189c0:	f9 22 04 00 	st.h [%a2]4,%d2
#endif
    SYS_ARCH_UNPROTECT(old_level);
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", desc->desc));
  }

  return NULL;
800189c4:	82 02       	mov %d2,0
}
800189c6:	60 22       	mov.a %a2,%d2
800189c8:	00 90       	ret 

800189ca <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char *file, const int line)
#endif
{
800189ca:	40 ae       	mov.aa %a14,%sp
800189cc:	20 20       	sub.a %sp,32
800189ce:	59 e4 f4 ff 	st.w [%a14]-12,%d4
  void *memp;
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
800189d2:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800189d6:	bf 92 1a 80 	jlt.u %d2,9,80018a0a <memp_malloc+0x40>
800189da:	91 00 00 28 	movh.a %a2,32768
800189de:	d9 22 46 81 	lea %a2,[%a2]5638 <80001606 <IfxCpu_Trap_vectorTable0_end+0x1412>>
800189e2:	b5 a2 08 00 	st.a [%sp]8 <80001606 <IfxCpu_Trap_vectorTable0_end+0x1412>>,%a2
800189e6:	3b 70 15 20 	mov %d2,343
800189ea:	59 a2 04 00 	st.w [%sp]4,%d2
800189ee:	91 00 00 28 	movh.a %a2,32768
800189f2:	d9 22 66 91 	lea %a2,[%a2]5734 <80001666 <IfxCpu_Trap_vectorTable0_end+0x1472>>
800189f6:	f4 a2       	st.a [%sp],%a2
800189f8:	91 00 00 28 	movh.a %a2,32768
800189fc:	d9 24 5e 71 	lea %a4,[%a2]5598 <800015de <IfxCpu_Trap_vectorTable0_end+0x13ea>>
80018a00:	6d ff 9b 64 	call 80005336 <Ifx_Lwip_printf>
80018a04:	82 02       	mov %d2,0
80018a06:	1d 00 13 00 	j 80018a2c <memp_malloc+0x62>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

#if !MEMP_OVERFLOW_CHECK
  memp = do_memp_malloc_pool(memp_pools[type]);
80018a0a:	91 00 00 28 	movh.a %a2,32768
80018a0e:	d9 22 58 74 	lea %a2,[%a2]17880 <800045d8 <memp_pools>>
80018a12:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <800045d8 <memp_pools>>
80018a16:	06 22       	sh %d2,2
80018a18:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80018a1c:	54 22       	ld.w %d2,[%a2]
80018a1e:	60 24       	mov.a %a4,%d2
80018a20:	6d ff 6a ff 	call 800188f4 <do_memp_malloc_pool>
80018a24:	b5 e2 fc ff 	st.a [%a14]-4,%a2
#else
  memp = do_memp_malloc_pool_fn(memp_pools[type], file, line);
#endif

  return memp;
80018a28:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
80018a2c:	60 22       	mov.a %a2,%d2
80018a2e:	00 90       	ret 

80018a30 <do_memp_free_pool>:

static void
do_memp_free_pool(const struct memp_desc *desc, void *mem)
{
80018a30:	40 ae       	mov.aa %a14,%sp
80018a32:	20 20       	sub.a %sp,32
80018a34:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80018a38:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  LWIP_ASSERT("memp_free: mem properly aligned",
80018a3c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80018a40:	8f 32 00 21 	and %d2,%d2,3
80018a44:	df 02 17 00 	jeq %d2,0,80018a72 <do_memp_free_pool+0x42>
80018a48:	91 00 00 28 	movh.a %a2,32768
80018a4c:	d9 22 46 81 	lea %a2,[%a2]5638 <80001606 <IfxCpu_Trap_vectorTable0_end+0x1412>>
80018a50:	b5 a2 08 00 	st.a [%sp]8 <80001606 <IfxCpu_Trap_vectorTable0_end+0x1412>>,%a2
80018a54:	3b c0 16 20 	mov %d2,364
80018a58:	59 a2 04 00 	st.w [%sp]4,%d2
80018a5c:	91 00 00 28 	movh.a %a2,32768
80018a60:	d9 22 43 a1 	lea %a2,[%a2]5763 <80001683 <IfxCpu_Trap_vectorTable0_end+0x148f>>
80018a64:	f4 a2       	st.a [%sp],%a2
80018a66:	91 00 00 28 	movh.a %a2,32768
80018a6a:	d9 24 5e 71 	lea %a4,[%a2]5598 <800015de <IfxCpu_Trap_vectorTable0_end+0x13ea>>
80018a6e:	6d ff 64 64 	call 80005336 <Ifx_Lwip_printf>
              ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  /* cast through void* to get rid of alignment warnings */
  memp = (struct memp *)(void *)((u8_t *)mem - MEMP_SIZE);
80018a72:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80018a76:	59 e2 fc ff 	st.w [%a14]-4,%d2
#if MEMP_OVERFLOW_CHECK == 1
  memp_overflow_check_element(memp, desc);
#endif /* MEMP_OVERFLOW_CHECK */

#if MEMP_STATS
  desc->stats->used--;
80018a7a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018a7e:	b0 42       	add.a %a2,4
80018a80:	d4 22       	ld.a %a2,[%a2]
80018a82:	b9 22 08 00 	ld.hu %d2,[%a2]8
80018a86:	c2 f2       	add %d2,-1
80018a88:	37 02 70 20 	extr.u %d2,%d2,0,16
80018a8c:	f9 22 08 00 	st.h [%a2]8,%d2
#if MEMP_MEM_MALLOC
  LWIP_UNUSED_ARG(desc);
  SYS_ARCH_UNPROTECT(old_level);
  mem_free(memp);
#else /* MEMP_MEM_MALLOC */
  memp->next = *desc->tab;
80018a90:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018a94:	d9 22 10 00 	lea %a2,[%a2]16
80018a98:	d4 22       	ld.a %a2,[%a2]
80018a9a:	54 22       	ld.w %d2,[%a2]
80018a9c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80018aa0:	74 22       	st.w [%a2],%d2
  *desc->tab = memp;
80018aa2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018aa6:	d9 22 10 00 	lea %a2,[%a2]16
80018aaa:	d4 22       	ld.a %a2,[%a2]
80018aac:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018ab0:	74 22       	st.w [%a2],%d2
  LWIP_ASSERT("memp sanity", memp_sanity(desc));
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
#endif /* !MEMP_MEM_MALLOC */
}
80018ab2:	00 00       	nop 
80018ab4:	00 90       	ret 

80018ab6 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
80018ab6:	40 ae       	mov.aa %a14,%sp
80018ab8:	20 18       	sub.a %sp,24
80018aba:	59 e4 fc ff 	st.w [%a14]-4,%d4
80018abe:	b5 e4 f8 ff 	st.a [%a14]-8,%a4
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  struct memp *old_first;
#endif

  LWIP_ERROR("memp_free: type < MEMP_MAX", (type < MEMP_MAX), return;);
80018ac2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018ac6:	bf 92 18 80 	jlt.u %d2,9,80018af6 <memp_free+0x40>
80018aca:	91 00 00 28 	movh.a %a2,32768
80018ace:	d9 22 46 81 	lea %a2,[%a2]5638 <80001606 <IfxCpu_Trap_vectorTable0_end+0x1412>>
80018ad2:	b5 a2 08 00 	st.a [%sp]8 <80001606 <IfxCpu_Trap_vectorTable0_end+0x1412>>,%a2
80018ad6:	3b a0 1a 20 	mov %d2,426
80018ada:	59 a2 04 00 	st.w [%sp]4,%d2
80018ade:	91 00 00 28 	movh.a %a2,32768
80018ae2:	d9 22 63 a1 	lea %a2,[%a2]5795 <800016a3 <IfxCpu_Trap_vectorTable0_end+0x14af>>
80018ae6:	f4 a2       	st.a [%sp],%a2
80018ae8:	91 00 00 28 	movh.a %a2,32768
80018aec:	d9 24 5e 71 	lea %a4,[%a2]5598 <800015de <IfxCpu_Trap_vectorTable0_end+0x13ea>>
80018af0:	6d ff 23 64 	call 80005336 <Ifx_Lwip_printf>
80018af4:	00 90       	ret 

  if (mem == NULL) {
80018af6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80018afa:	df 02 12 00 	jeq %d2,0,80018b1e <memp_free+0x68>

#ifdef LWIP_HOOK_MEMP_AVAILABLE
  old_first = *memp_pools[type]->tab;
#endif

  do_memp_free_pool(memp_pools[type], mem);
80018afe:	91 00 00 28 	movh.a %a2,32768
80018b02:	d9 22 58 74 	lea %a2,[%a2]17880 <800045d8 <memp_pools>>
80018b06:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <800045d8 <memp_pools>>
80018b0a:	06 22       	sh %d2,2
80018b0c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80018b10:	54 22       	ld.w %d2,[%a2]
80018b12:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80018b16:	60 24       	mov.a %a4,%d2
80018b18:	6d ff 8c ff 	call 80018a30 <do_memp_free_pool>
80018b1c:	00 90       	ret 
    return;
80018b1e:	00 00       	nop 
#ifdef LWIP_HOOK_MEMP_AVAILABLE
  if (old_first == NULL) {
    LWIP_HOOK_MEMP_AVAILABLE(type);
  }
#endif
}
80018b20:	00 90       	ret 

80018b22 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
80018b22:	40 ae       	mov.aa %a14,%sp

  netif_set_link_up(&loop_netif);
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
80018b24:	00 00       	nop 
80018b26:	00 90       	ret 

80018b28 <netif_add>:
netif_add(struct netif *netif,
#if LWIP_IPV4
          const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
#endif /* LWIP_IPV4 */
          void *state, netif_init_fn init, netif_input_fn input)
{
80018b28:	40 ae       	mov.aa %a14,%sp
80018b2a:	20 28       	sub.a %sp,40
80018b2c:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80018b30:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
80018b34:	b5 e6 ec ff 	st.a [%a14]-20,%a6
80018b38:	b5 e7 e8 ff 	st.a [%a14]-24,%a7
    LWIP_ASSERT("single netif already set", 0);
    return NULL;
  }
#endif

  LWIP_ERROR("netif_add: invalid netif", netif != NULL, return NULL);
80018b3c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80018b40:	df 02 1a 80 	jne %d2,0,80018b74 <netif_add+0x4c>
80018b44:	91 00 00 28 	movh.a %a2,32768
80018b48:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80018b4c:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80018b50:	3b 70 12 20 	mov %d2,295
80018b54:	59 a2 04 00 	st.w [%sp]4,%d2
80018b58:	91 00 00 28 	movh.a %a2,32768
80018b5c:	d9 22 47 d1 	lea %a2,[%a2]5959 <80001747 <IfxCpu_Trap_vectorTable0_end+0x1553>>
80018b60:	f4 a2       	st.a [%sp],%a2
80018b62:	91 00 00 28 	movh.a %a2,32768
80018b66:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80018b6a:	6d ff e6 63 	call 80005336 <Ifx_Lwip_printf>
80018b6e:	82 02       	mov %d2,0
80018b70:	1d 00 3f 01 	j 80018dee <netif_add+0x2c6>
  LWIP_ERROR("netif_add: No init function given", init != NULL, return NULL);
80018b74:	19 e2 04 00 	ld.w %d2,[%a14]4
80018b78:	df 02 1a 80 	jne %d2,0,80018bac <netif_add+0x84>
80018b7c:	91 00 00 28 	movh.a %a2,32768
80018b80:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80018b84:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80018b88:	3b 80 12 20 	mov %d2,296
80018b8c:	59 a2 04 00 	st.w [%sp]4,%d2
80018b90:	91 00 00 28 	movh.a %a2,32768
80018b94:	d9 22 60 d1 	lea %a2,[%a2]5984 <80001760 <IfxCpu_Trap_vectorTable0_end+0x156c>>
80018b98:	f4 a2       	st.a [%sp],%a2
80018b9a:	91 00 00 28 	movh.a %a2,32768
80018b9e:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80018ba2:	6d ff ca 63 	call 80005336 <Ifx_Lwip_printf>
80018ba6:	82 02       	mov %d2,0
80018ba8:	1d 00 23 01 	j 80018dee <netif_add+0x2c6>

#if LWIP_IPV4
  if (ipaddr == NULL) {
80018bac:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80018bb0:	df 02 08 80 	jne %d2,0,80018bc0 <netif_add+0x98>
    ipaddr = ip_2_ip4(IP4_ADDR_ANY);
80018bb4:	91 00 00 28 	movh.a %a2,32768
80018bb8:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80018bbc:	b5 e2 f0 ff 	st.a [%a14]-16 <8000451c <ip_addr_any>>,%a2
  }
  if (netmask == NULL) {
80018bc0:	19 e2 ec ff 	ld.w %d2,[%a14]-20 <8000451c <ip_addr_any>>
80018bc4:	df 02 08 80 	jne %d2,0,80018bd4 <netif_add+0xac>
    netmask = ip_2_ip4(IP4_ADDR_ANY);
80018bc8:	91 00 00 28 	movh.a %a2,32768
80018bcc:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80018bd0:	b5 e2 ec ff 	st.a [%a14]-20 <8000451c <ip_addr_any>>,%a2
  }
  if (gw == NULL) {
80018bd4:	19 e2 e8 ff 	ld.w %d2,[%a14]-24 <8000451c <ip_addr_any>>
80018bd8:	df 02 08 80 	jne %d2,0,80018be8 <netif_add+0xc0>
    gw = ip_2_ip4(IP4_ADDR_ANY);
80018bdc:	91 00 00 28 	movh.a %a2,32768
80018be0:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80018be4:	b5 e2 e8 ff 	st.a [%a14]-24 <8000451c <ip_addr_any>>,%a2
  }

  /* reset new interface configuration state */
  ip_addr_set_zero_ip4(&netif->ip_addr);
80018be8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <8000451c <ip_addr_any>>
80018bec:	82 02       	mov %d2,0
80018bee:	b0 42       	add.a %a2,4
80018bf0:	74 22       	st.w [%a2],%d2
  ip_addr_set_zero_ip4(&netif->netmask);
80018bf2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018bf6:	82 02       	mov %d2,0
80018bf8:	d9 22 08 00 	lea %a2,[%a2]8
80018bfc:	74 22       	st.w [%a2],%d2
  ip_addr_set_zero_ip4(&netif->gw);
80018bfe:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018c02:	82 02       	mov %d2,0
80018c04:	d9 22 0c 00 	lea %a2,[%a2]12
80018c08:	74 22       	st.w [%a2],%d2
  netif->output = netif_null_output_ip4;
80018c0a:	99 e3 f4 ff 	ld.a %a3,[%a14]-12
80018c0e:	91 20 00 28 	movh.a %a2,32770
80018c12:	d9 22 76 29 	lea %a2,[%a2]-27466 <800194b6 <netif_null_output_ip4>>
80018c16:	d9 33 14 00 	lea %a3,[%a3]20 <800194b6 <netif_null_output_ip4>>
80018c1a:	f4 32       	st.a [%a3],%a2
#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
  }
  netif->output_ip6 = netif_null_output_ip6;
#endif /* LWIP_IPV6 */
  NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
  netif->mtu = 0;
80018c1c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <800194b6 <netif_null_output_ip4>>
80018c20:	82 02       	mov %d2,0
80018c22:	f9 22 28 00 	st.h [%a2]40,%d2
  netif->flags = 0;
80018c26:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018c2a:	82 02       	mov %d2,0
80018c2c:	e9 22 31 00 	st.b [%a2]49,%d2
#ifdef netif_get_client_data
  memset(netif->client_data, 0, sizeof(netif->client_data));
80018c30:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80018c34:	1b 02 02 20 	addi %d2,%d2,32
80018c38:	82 45       	mov %d5,4
80018c3a:	82 04       	mov %d4,0
80018c3c:	60 24       	mov.a %a4,%d2
80018c3e:	6d 00 f9 72 	call 80027230 <memset>
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
80018c42:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018c46:	54 e2       	ld.w %d2,[%a14]
80018c48:	d9 22 1c 00 	lea %a2,[%a2]28
80018c4c:	74 22       	st.w [%a2],%d2
  netif->num = netif_num;
80018c4e:	91 10 00 27 	movh.a %a2,28673
80018c52:	d9 22 50 34 	lea %a2,[%a2]17616 <700144d0 <netif_num>>
80018c56:	14 22       	ld.bu %d2,[%a2]
80018c58:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <700144d0 <netif_num>>
80018c5c:	e9 22 34 00 	st.b [%a2]52 <700144d0 <netif_num>>,%d2
  netif->input = input;
80018c60:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <700144d0 <netif_num>>
80018c64:	19 e2 08 00 	ld.w %d2,[%a14]8 <700144d0 <netif_num>>
80018c68:	d9 22 10 00 	lea %a2,[%a2]16 <700144d0 <netif_num>>
80018c6c:	74 22       	st.w [%a2],%d2
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

#if LWIP_IPV4
  netif_set_addr(netif, ipaddr, netmask, gw);
80018c6e:	99 e7 e8 ff 	ld.a %a7,[%a14]-24 <700144d0 <netif_num>>
80018c72:	99 e6 ec ff 	ld.a %a6,[%a14]-20 <700144d0 <netif_num>>
80018c76:	99 e5 f0 ff 	ld.a %a5,[%a14]-16 <700144d0 <netif_num>>
80018c7a:	99 e4 f4 ff 	ld.a %a4,[%a14]-12 <700144d0 <netif_num>>
80018c7e:	6d 00 45 02 	call 80019108 <netif_set_addr>
#endif /* LWIP_IPV4 */

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
80018c82:	99 e2 04 00 	ld.a %a2,[%a14]4
80018c86:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80018c8a:	2d 02 00 00 	calli %a2
80018c8e:	df 02 05 00 	jeq %d2,0,80018c98 <netif_add+0x170>
    return NULL;
80018c92:	82 02       	mov %d2,0
80018c94:	1d 00 ad 00 	j 80018dee <netif_add+0x2c6>
     */
  {
    struct netif *netif2;
    int num_netifs;
    do {
      if (netif->num == 255) {
80018c98:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018c9c:	39 22 34 00 	ld.bu %d2,[%a2]52
80018ca0:	8b f2 2f 22 	ne %d2,%d2,255
80018ca4:	df 02 07 80 	jne %d2,0,80018cb2 <netif_add+0x18a>
        netif->num = 0;
80018ca8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018cac:	82 02       	mov %d2,0
80018cae:	e9 22 34 00 	st.b [%a2]52,%d2
      }
      num_netifs = 0;
80018cb2:	82 02       	mov %d2,0
80018cb4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
80018cb8:	91 10 00 27 	movh.a %a2,28673
80018cbc:	d9 22 48 34 	lea %a2,[%a2]17608 <700144c8 <netif_list>>
80018cc0:	54 22       	ld.w %d2,[%a2]
80018cc2:	59 e2 fc ff 	st.w [%a14]-4 <700144c8 <netif_list>>,%d2
80018cc6:	1d 00 59 00 	j 80018d78 <netif_add+0x250>
        LWIP_ASSERT("netif already added", netif2 != netif);
80018cca:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80018cce:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80018cd2:	5f 23 17 80 	jne %d3,%d2,80018d00 <netif_add+0x1d8>
80018cd6:	91 00 00 28 	movh.a %a2,32768
80018cda:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80018cde:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80018ce2:	3b b0 18 20 	mov %d2,395
80018ce6:	59 a2 04 00 	st.w [%sp]4,%d2
80018cea:	91 00 00 28 	movh.a %a2,32768
80018cee:	d9 22 42 e1 	lea %a2,[%a2]6018 <80001782 <IfxCpu_Trap_vectorTable0_end+0x158e>>
80018cf2:	f4 a2       	st.a [%sp],%a2
80018cf4:	91 00 00 28 	movh.a %a2,32768
80018cf8:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80018cfc:	6d ff 1d 63 	call 80005336 <Ifx_Lwip_printf>
        num_netifs++;
80018d00:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80018d04:	c2 12       	add %d2,1
80018d06:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        LWIP_ASSERT("too many netifs, max. supported number is 255", num_netifs <= 255);
80018d0a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80018d0e:	3b 00 10 30 	mov %d3,256
80018d12:	3f 32 17 00 	jlt %d2,%d3,80018d40 <netif_add+0x218>
80018d16:	91 00 00 28 	movh.a %a2,32768
80018d1a:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80018d1e:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80018d22:	3b d0 18 20 	mov %d2,397
80018d26:	59 a2 04 00 	st.w [%sp]4,%d2
80018d2a:	91 00 00 28 	movh.a %a2,32768
80018d2e:	d9 22 56 e1 	lea %a2,[%a2]6038 <80001796 <IfxCpu_Trap_vectorTable0_end+0x15a2>>
80018d32:	f4 a2       	st.a [%sp],%a2
80018d34:	91 00 00 28 	movh.a %a2,32768
80018d38:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80018d3c:	6d ff fd 62 	call 80005336 <Ifx_Lwip_printf>
        if (netif2->num == netif->num) {
80018d40:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80018d44:	39 23 34 00 	ld.bu %d3,[%a2]52
80018d48:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018d4c:	39 22 34 00 	ld.bu %d2,[%a2]52
80018d50:	5f 23 0f 80 	jne %d3,%d2,80018d6e <netif_add+0x246>
          netif->num++;
80018d54:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018d58:	39 22 34 00 	ld.bu %d2,[%a2]52
80018d5c:	c2 12       	add %d2,1
80018d5e:	8f f2 0f 21 	and %d2,%d2,255
80018d62:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018d66:	e9 22 34 00 	st.b [%a2]52,%d2
          break;
80018d6a:	1d 00 0b 00 	j 80018d80 <netif_add+0x258>
      for (netif2 = netif_list; netif2 != NULL; netif2 = netif2->next) {
80018d6e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80018d72:	54 22       	ld.w %d2,[%a2]
80018d74:	59 e2 fc ff 	st.w [%a14]-4,%d2
80018d78:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018d7c:	df 02 a7 ff 	jne %d2,0,80018cca <netif_add+0x1a2>
        }
      }
    } while (netif2 != NULL);
80018d80:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018d84:	df 02 8a ff 	jne %d2,0,80018c98 <netif_add+0x170>
  }
  if (netif->num == 254) {
80018d88:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018d8c:	39 22 34 00 	ld.bu %d2,[%a2]52
80018d90:	8b e2 2f 22 	ne %d2,%d2,254
80018d94:	df 02 0a 80 	jne %d2,0,80018da8 <netif_add+0x280>
    netif_num = 0;
80018d98:	91 10 00 27 	movh.a %a2,28673
80018d9c:	d9 22 50 34 	lea %a2,[%a2]17616 <700144d0 <netif_num>>
80018da0:	82 02       	mov %d2,0
80018da2:	34 22       	st.b [%a2],%d2
80018da4:	1d 00 0e 00 	j 80018dc0 <netif_add+0x298>
  } else {
    netif_num = (u8_t)(netif->num + 1);
80018da8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018dac:	39 22 34 00 	ld.bu %d2,[%a2]52
80018db0:	c2 12       	add %d2,1
80018db2:	8f f2 0f 21 	and %d2,%d2,255
80018db6:	91 10 00 27 	movh.a %a2,28673
80018dba:	d9 22 50 34 	lea %a2,[%a2]17616 <700144d0 <netif_num>>
80018dbe:	34 22       	st.b [%a2],%d2
  }

  /* add this netif to the list */
  netif->next = netif_list;
80018dc0:	91 10 00 27 	movh.a %a2,28673
80018dc4:	d9 22 48 34 	lea %a2,[%a2]17608 <700144c8 <netif_list>>
80018dc8:	54 22       	ld.w %d2,[%a2]
80018dca:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <700144c8 <netif_list>>
80018dce:	74 22       	st.w [%a2],%d2
  netif_list = netif;
80018dd0:	91 10 00 27 	movh.a %a2,28673
80018dd4:	d9 22 48 34 	lea %a2,[%a2]17608 <700144c8 <netif_list>>
80018dd8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <700144c8 <netif_list>>
80018ddc:	74 22       	st.w [%a2],%d2
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip4_addr_debug_print(NETIF_DEBUG, gw);
#endif /* LWIP_IPV4 */
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));

  netif_invoke_ext_callback(netif, LWIP_NSC_NETIF_ADDED, NULL);
80018dde:	a0 05       	mov.a %a5,0
80018de0:	82 14       	mov %d4,1
80018de2:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80018de6:	6d 00 ef 03 	call 800195c4 <netif_invoke_ext_callback>

  return netif;
80018dea:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
}
80018dee:	60 22       	mov.a %a2,%d2
80018df0:	00 90       	ret 

80018df2 <netif_do_ip_addr_changed>:

static void
netif_do_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
80018df2:	40 ae       	mov.aa %a14,%sp
80018df4:	20 08       	sub.a %sp,8
80018df6:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80018dfa:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
#if LWIP_TCP
  tcp_netif_ip_addr_changed(old_addr, new_addr);
80018dfe:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80018e02:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80018e06:	6d 00 4a 22 	call 8001d29a <tcp_netif_ip_addr_changed>
#endif /* LWIP_TCP */
#if LWIP_UDP
  udp_netif_ip_addr_changed(old_addr, new_addr);
80018e0a:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80018e0e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80018e12:	6d 00 66 69 	call 800260de <udp_netif_ip_addr_changed>
#endif /* LWIP_UDP */
#if LWIP_RAW
  raw_netif_ip_addr_changed(old_addr, new_addr);
#endif /* LWIP_RAW */
}
80018e16:	00 00       	nop 
80018e18:	00 90       	ret 

80018e1a <netif_do_set_ipaddr>:

#if LWIP_IPV4
static int
netif_do_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr, ip_addr_t *old_addr)
{
80018e1a:	40 ae       	mov.aa %a14,%sp
80018e1c:	20 28       	sub.a %sp,40
80018e1e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80018e22:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
80018e26:	b5 e6 ec ff 	st.a [%a14]-20,%a6
  LWIP_ASSERT("invalid pointer", ipaddr != NULL);
80018e2a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80018e2e:	df 02 17 80 	jne %d2,0,80018e5c <netif_do_set_ipaddr+0x42>
80018e32:	91 00 00 28 	movh.a %a2,32768
80018e36:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80018e3a:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80018e3e:	3b b0 1c 20 	mov %d2,459
80018e42:	59 a2 04 00 	st.w [%sp]4,%d2
80018e46:	91 00 00 28 	movh.a %a2,32768
80018e4a:	d9 22 44 f1 	lea %a2,[%a2]6084 <800017c4 <IfxCpu_Trap_vectorTable0_end+0x15d0>>
80018e4e:	f4 a2       	st.a [%sp],%a2
80018e50:	91 00 00 28 	movh.a %a2,32768
80018e54:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80018e58:	6d ff 6f 62 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("invalid pointer", old_addr != NULL);
80018e5c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80018e60:	df 02 17 80 	jne %d2,0,80018e8e <netif_do_set_ipaddr+0x74>
80018e64:	91 00 00 28 	movh.a %a2,32768
80018e68:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80018e6c:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80018e70:	3b c0 1c 20 	mov %d2,460
80018e74:	59 a2 04 00 	st.w [%sp]4,%d2
80018e78:	91 00 00 28 	movh.a %a2,32768
80018e7c:	d9 22 44 f1 	lea %a2,[%a2]6084 <800017c4 <IfxCpu_Trap_vectorTable0_end+0x15d0>>
80018e80:	f4 a2       	st.a [%sp],%a2
80018e82:	91 00 00 28 	movh.a %a2,32768
80018e86:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80018e8a:	6d ff 56 62 	call 80005336 <Ifx_Lwip_printf>

  /* address is actually being changed? */
  if (ip4_addr_cmp(ipaddr, netif_ip4_addr(netif)) == 0) {
80018e8e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018e92:	54 23       	ld.w %d3,[%a2]
80018e94:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80018e98:	60 22       	mov.a %a2,%d2
80018e9a:	b0 42       	add.a %a2,4
80018e9c:	54 22       	ld.w %d2,[%a2]
80018e9e:	5f 23 31 00 	jeq %d3,%d2,80018f00 <netif_do_set_ipaddr+0xe6>
    ip_addr_t new_addr;
    *ip_2_ip4(&new_addr) = *ipaddr;
80018ea2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018ea6:	54 22       	ld.w %d2,[%a2]
80018ea8:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);

    ip_addr_copy(*old_addr, *netif_ip_addr4(netif));
80018eac:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80018eb0:	60 22       	mov.a %a2,%d2
80018eb2:	b0 42       	add.a %a2,4
80018eb4:	54 22       	ld.w %d2,[%a2]
80018eb6:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80018eba:	74 22       	st.w [%a2],%d2

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
80018ebc:	91 00 00 28 	movh.a %a2,32768
80018ec0:	d9 24 54 f1 	lea %a4,[%a2]6100 <800017d4 <IfxCpu_Trap_vectorTable0_end+0x15e0>>
80018ec4:	6d ff 39 62 	call 80005336 <Ifx_Lwip_printf>
    netif_do_ip_addr_changed(old_addr, &new_addr);
80018ec8:	d9 e2 fc ff 	lea %a2,[%a14]-4
80018ecc:	40 25       	mov.aa %a5,%a2
80018ece:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80018ed2:	6d ff 90 ff 	call 80018df2 <netif_do_ip_addr_changed>

    mib2_remove_ip4(netif);
    mib2_remove_route_ip4(0, netif);
    /* set new IP address to netif */
    ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
80018ed6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80018eda:	df 02 07 00 	jeq %d2,0,80018ee8 <netif_do_set_ipaddr+0xce>
80018ede:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80018ee2:	54 22       	ld.w %d2,[%a2]
80018ee4:	1d 00 03 00 	j 80018eea <netif_do_set_ipaddr+0xd0>
80018ee8:	82 02       	mov %d2,0
80018eea:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018eee:	b0 42       	add.a %a2,4
80018ef0:	74 22       	st.w [%a2],%d2
    IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
    mib2_add_ip4(netif);
    mib2_add_route_ip4(0, netif);

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
80018ef2:	82 14       	mov %d4,1
80018ef4:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80018ef8:	6d 00 0b 02 	call 8001930e <netif_issue_reports>

    NETIF_STATUS_CALLBACK(netif);
    return 1; /* address changed */
80018efc:	82 12       	mov %d2,1
80018efe:	00 90       	ret 
  }
  return 0; /* address unchanged */
80018f00:	82 02       	mov %d2,0
}
80018f02:	00 90       	ret 

80018f04 <netif_do_set_netmask>:
  }
}

static int
netif_do_set_netmask(struct netif *netif, const ip4_addr_t *netmask, ip_addr_t *old_nm)
{
80018f04:	40 ae       	mov.aa %a14,%sp
80018f06:	20 28       	sub.a %sp,40
80018f08:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80018f0c:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
80018f10:	b5 e6 f4 ff 	st.a [%a14]-12,%a6
  /* address is actually being changed? */
  if (ip4_addr_cmp(netmask, netif_ip4_netmask(netif)) == 0) {
80018f14:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80018f18:	54 23       	ld.w %d3,[%a2]
80018f1a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018f1e:	60 22       	mov.a %a2,%d2
80018f20:	d9 22 08 00 	lea %a2,[%a2]8
80018f24:	54 22       	ld.w %d2,[%a2]
80018f26:	5f 23 6e 00 	jeq %d3,%d2,80019002 <netif_do_set_netmask+0xfe>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    LWIP_ASSERT("invalid pointer", old_nm != NULL);
80018f2a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80018f2e:	df 02 17 80 	jne %d2,0,80018f5c <netif_do_set_netmask+0x58>
80018f32:	91 00 00 28 	movh.a %a2,32768
80018f36:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80018f3a:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80018f3e:	3b 00 21 20 	mov %d2,528
80018f42:	59 a2 04 00 	st.w [%sp]4,%d2
80018f46:	91 00 00 28 	movh.a %a2,32768
80018f4a:	d9 22 44 f1 	lea %a2,[%a2]6084 <800017c4 <IfxCpu_Trap_vectorTable0_end+0x15d0>>
80018f4e:	f4 a2       	st.a [%sp],%a2
80018f50:	91 00 00 28 	movh.a %a2,32768
80018f54:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80018f58:	6d ff ef 61 	call 80005336 <Ifx_Lwip_printf>
    ip_addr_copy(*old_nm, *netif_ip_netmask4(netif));
80018f5c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018f60:	60 22       	mov.a %a2,%d2
80018f62:	d9 22 08 00 	lea %a2,[%a2]8
80018f66:	54 22       	ld.w %d2,[%a2]
80018f68:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80018f6c:	74 22       	st.w [%a2],%d2
#else
    LWIP_UNUSED_ARG(old_nm);
#endif
    mib2_remove_route_ip4(0, netif);
    /* set new netmask to netif */
    ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
80018f6e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80018f72:	df 02 07 00 	jeq %d2,0,80018f80 <netif_do_set_netmask+0x7c>
80018f76:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80018f7a:	54 22       	ld.w %d2,[%a2]
80018f7c:	1d 00 03 00 	j 80018f82 <netif_do_set_netmask+0x7e>
80018f80:	82 02       	mov %d2,0
80018f82:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80018f86:	d9 22 08 00 	lea %a2,[%a2]8
80018f8a:	74 22       	st.w [%a2],%d2
    IP_SET_TYPE_VAL(netif->netmask, IPADDR_TYPE_V4);
    mib2_add_route_ip4(0, netif);
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: netmask of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
80018f8c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80018f90:	79 22 32 00 	ld.b %d2,[%a2]50
80018f94:	02 23       	mov %d3,%d2
80018f96:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80018f9a:	79 22 33 00 	ld.b %d2,[%a2]51
80018f9e:	02 24       	mov %d4,%d2
80018fa0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018fa4:	1b 82 00 20 	addi %d2,%d2,8
80018fa8:	60 22       	mov.a %a2,%d2
80018faa:	14 22       	ld.bu %d2,[%a2]
80018fac:	02 25       	mov %d5,%d2
80018fae:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018fb2:	1b 82 00 20 	addi %d2,%d2,8
80018fb6:	60 22       	mov.a %a2,%d2
80018fb8:	b0 12       	add.a %a2,1
80018fba:	14 22       	ld.bu %d2,[%a2]
80018fbc:	02 26       	mov %d6,%d2
80018fbe:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018fc2:	1b 82 00 20 	addi %d2,%d2,8
80018fc6:	60 22       	mov.a %a2,%d2
80018fc8:	b0 22       	add.a %a2,2
80018fca:	14 22       	ld.bu %d2,[%a2]
80018fcc:	02 27       	mov %d7,%d2
80018fce:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80018fd2:	1b 82 00 20 	addi %d2,%d2,8
80018fd6:	60 22       	mov.a %a2,%d2
80018fd8:	b0 32       	add.a %a2,3
80018fda:	14 22       	ld.bu %d2,[%a2]
80018fdc:	59 a2 14 00 	st.w [%sp]20,%d2
80018fe0:	59 a7 10 00 	st.w [%sp]16,%d7
80018fe4:	59 a6 0c 00 	st.w [%sp]12,%d6
80018fe8:	59 a5 08 00 	st.w [%sp]8,%d5
80018fec:	59 a4 04 00 	st.w [%sp]4,%d4
80018ff0:	74 a3       	st.w [%sp],%d3
80018ff2:	91 00 00 28 	movh.a %a2,32768
80018ff6:	d9 24 a3 01 	lea %a4,[%a2]6179 <80001823 <IfxCpu_Trap_vectorTable0_end+0x162f>>
80018ffa:	6d ff 9e 61 	call 80005336 <Ifx_Lwip_printf>
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_netmask(netif)),
                ip4_addr2_16(netif_ip4_netmask(netif)),
                ip4_addr3_16(netif_ip4_netmask(netif)),
                ip4_addr4_16(netif_ip4_netmask(netif))));
    return 1; /* netmask changed */
80018ffe:	82 12       	mov %d2,1
80019000:	00 90       	ret 
  }
  return 0; /* netmask unchanged */
80019002:	82 02       	mov %d2,0
}
80019004:	00 90       	ret 

80019006 <netif_do_set_gw>:
  }
}

static int
netif_do_set_gw(struct netif *netif, const ip4_addr_t *gw, ip_addr_t *old_gw)
{
80019006:	40 ae       	mov.aa %a14,%sp
80019008:	20 28       	sub.a %sp,40
8001900a:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001900e:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
80019012:	b5 e6 f4 ff 	st.a [%a14]-12,%a6
  /* address is actually being changed? */
  if (ip4_addr_cmp(gw, netif_ip4_gw(netif)) == 0) {
80019016:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001901a:	54 23       	ld.w %d3,[%a2]
8001901c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019020:	60 22       	mov.a %a2,%d2
80019022:	d9 22 0c 00 	lea %a2,[%a2]12
80019026:	54 22       	ld.w %d2,[%a2]
80019028:	5f 23 6e 00 	jeq %d3,%d2,80019104 <netif_do_set_gw+0xfe>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    LWIP_ASSERT("invalid pointer", old_gw != NULL);
8001902c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019030:	df 02 17 80 	jne %d2,0,8001905e <netif_do_set_gw+0x58>
80019034:	91 00 00 28 	movh.a %a2,32768
80019038:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
8001903c:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80019040:	3b 00 25 20 	mov %d2,592
80019044:	59 a2 04 00 	st.w [%sp]4,%d2
80019048:	91 00 00 28 	movh.a %a2,32768
8001904c:	d9 22 44 f1 	lea %a2,[%a2]6084 <800017c4 <IfxCpu_Trap_vectorTable0_end+0x15d0>>
80019050:	f4 a2       	st.a [%sp],%a2
80019052:	91 00 00 28 	movh.a %a2,32768
80019056:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
8001905a:	6d ff 6e 61 	call 80005336 <Ifx_Lwip_printf>
    ip_addr_copy(*old_gw, *netif_ip_gw4(netif));
8001905e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019062:	60 22       	mov.a %a2,%d2
80019064:	d9 22 0c 00 	lea %a2,[%a2]12
80019068:	54 22       	ld.w %d2,[%a2]
8001906a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001906e:	74 22       	st.w [%a2],%d2
#else
    LWIP_UNUSED_ARG(old_gw);
#endif

    ip4_addr_set(ip_2_ip4(&netif->gw), gw);
80019070:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80019074:	df 02 07 00 	jeq %d2,0,80019082 <netif_do_set_gw+0x7c>
80019078:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001907c:	54 22       	ld.w %d2,[%a2]
8001907e:	1d 00 03 00 	j 80019084 <netif_do_set_gw+0x7e>
80019082:	82 02       	mov %d2,0
80019084:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019088:	d9 22 0c 00 	lea %a2,[%a2]12
8001908c:	74 22       	st.w [%a2],%d2
    IP_SET_TYPE_VAL(netif->gw, IPADDR_TYPE_V4);
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: GW address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
8001908e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019092:	79 22 32 00 	ld.b %d2,[%a2]50
80019096:	02 23       	mov %d3,%d2
80019098:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001909c:	79 22 33 00 	ld.b %d2,[%a2]51
800190a0:	02 24       	mov %d4,%d2
800190a2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800190a6:	1b c2 00 20 	addi %d2,%d2,12
800190aa:	60 22       	mov.a %a2,%d2
800190ac:	14 22       	ld.bu %d2,[%a2]
800190ae:	02 25       	mov %d5,%d2
800190b0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800190b4:	1b c2 00 20 	addi %d2,%d2,12
800190b8:	60 22       	mov.a %a2,%d2
800190ba:	b0 12       	add.a %a2,1
800190bc:	14 22       	ld.bu %d2,[%a2]
800190be:	02 26       	mov %d6,%d2
800190c0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800190c4:	1b c2 00 20 	addi %d2,%d2,12
800190c8:	60 22       	mov.a %a2,%d2
800190ca:	b0 22       	add.a %a2,2
800190cc:	14 22       	ld.bu %d2,[%a2]
800190ce:	02 27       	mov %d7,%d2
800190d0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800190d4:	1b c2 00 20 	addi %d2,%d2,12
800190d8:	60 22       	mov.a %a2,%d2
800190da:	b0 32       	add.a %a2,3
800190dc:	14 22       	ld.bu %d2,[%a2]
800190de:	59 a2 14 00 	st.w [%sp]20,%d2
800190e2:	59 a7 10 00 	st.w [%sp]16,%d7
800190e6:	59 a6 0c 00 	st.w [%sp]12,%d6
800190ea:	59 a5 08 00 	st.w [%sp]8,%d5
800190ee:	59 a4 04 00 	st.w [%sp]4,%d4
800190f2:	74 a3       	st.w [%sp],%d3
800190f4:	91 00 00 28 	movh.a %a2,32768
800190f8:	d9 24 b9 11 	lea %a4,[%a2]6265 <80001879 <IfxCpu_Trap_vectorTable0_end+0x1685>>
800190fc:	6d ff 1d 61 	call 80005336 <Ifx_Lwip_printf>
                netif->name[0], netif->name[1],
                ip4_addr1_16(netif_ip4_gw(netif)),
                ip4_addr2_16(netif_ip4_gw(netif)),
                ip4_addr3_16(netif_ip4_gw(netif)),
                ip4_addr4_16(netif_ip4_gw(netif))));
    return 1; /* gateway changed */
80019100:	82 12       	mov %d2,1
80019102:	00 90       	ret 
  }
  return 0; /* gateway unchanged */
80019104:	82 02       	mov %d2,0
}
80019106:	00 90       	ret 

80019108 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
               const ip4_addr_t *gw)
{
80019108:	40 ae       	mov.aa %a14,%sp
8001910a:	20 38       	sub.a %sp,56
8001910c:	b5 e4 d4 ff 	st.a [%a14]-44,%a4
80019110:	b5 e5 d0 ff 	st.a [%a14]-48,%a5
80019114:	b5 e6 cc ff 	st.a [%a14]-52,%a6
80019118:	b5 e7 c8 ff 	st.a [%a14]-56,%a7
#if LWIP_NETIF_EXT_STATUS_CALLBACK
  netif_nsc_reason_t change_reason = LWIP_NSC_NONE;
8001911c:	82 02       	mov %d2,0
8001911e:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  netif_ext_callback_args_t cb_args;
  ip_addr_t old_nm_val;
  ip_addr_t old_gw_val;
  ip_addr_t *old_nm = &old_nm_val;
80019122:	d9 e2 e0 ff 	lea %a2,[%a14]-32
80019126:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  ip_addr_t *old_gw = &old_gw_val;
8001912a:	d9 e2 dc ff 	lea %a2,[%a14]-36
8001912e:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
  int remove;

  LWIP_ASSERT_CORE_LOCKED();

  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
80019132:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
80019136:	df 02 08 80 	jne %d2,0,80019146 <netif_set_addr+0x3e>
    ipaddr = IP4_ADDR_ANY4;
8001913a:	91 00 00 28 	movh.a %a2,32768
8001913e:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80019142:	b5 e2 d0 ff 	st.a [%a14]-48 <8000451c <ip_addr_any>>,%a2
  }
  if (netmask == NULL) {
80019146:	19 e2 cc ff 	ld.w %d2,[%a14]-52 <8000451c <ip_addr_any>>
8001914a:	df 02 08 80 	jne %d2,0,8001915a <netif_set_addr+0x52>
    netmask = IP4_ADDR_ANY4;
8001914e:	91 00 00 28 	movh.a %a2,32768
80019152:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80019156:	b5 e2 cc ff 	st.a [%a14]-52 <8000451c <ip_addr_any>>,%a2
  }
  if (gw == NULL) {
8001915a:	19 e2 c8 ff 	ld.w %d2,[%a14]-56 <8000451c <ip_addr_any>>
8001915e:	df 02 08 80 	jne %d2,0,8001916e <netif_set_addr+0x66>
    gw = IP4_ADDR_ANY4;
80019162:	91 00 00 28 	movh.a %a2,32768
80019166:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
8001916a:	b5 e2 c8 ff 	st.a [%a14]-56 <8000451c <ip_addr_any>>,%a2
  }

  remove = ip4_addr_isany(ipaddr);
8001916e:	19 e2 d0 ff 	ld.w %d2,[%a14]-48 <8000451c <ip_addr_any>>
80019172:	df 02 07 00 	jeq %d2,0,80019180 <netif_set_addr+0x78>
80019176:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8001917a:	54 22       	ld.w %d2,[%a2]
8001917c:	df 02 05 80 	jne %d2,0,80019186 <netif_set_addr+0x7e>
80019180:	82 12       	mov %d2,1
80019182:	1d 00 03 00 	j 80019188 <netif_set_addr+0x80>
80019186:	82 02       	mov %d2,0
80019188:	59 e2 f0 ff 	st.w [%a14]-16,%d2
  if (remove) {
8001918c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019190:	df 02 17 00 	jeq %d2,0,800191be <netif_set_addr+0xb6>
    /* when removing an address, we have to remove it *before* changing netmask/gw
       to ensure that tcp RST segment can be sent correctly */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
80019194:	d9 e2 d8 ff 	lea %a2,[%a14]-40
80019198:	40 26       	mov.aa %a6,%a2
8001919a:	99 e5 d0 ff 	ld.a %a5,[%a14]-48
8001919e:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
800191a2:	6d ff 3c fe 	call 80018e1a <netif_do_set_ipaddr>
800191a6:	df 02 0c 00 	jeq %d2,0,800191be <netif_set_addr+0xb6>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
800191aa:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800191ae:	8f 02 41 21 	or %d2,%d2,16
800191b2:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      cb_args.ipv4_changed.old_address = &old_addr;
800191b6:	d9 e2 d8 ff 	lea %a2,[%a14]-40
800191ba:	b5 e2 e4 ff 	st.a [%a14]-28,%a2
#endif
    }
  }
  if (netif_do_set_netmask(netif, netmask, old_nm)) {
800191be:	99 e6 f8 ff 	ld.a %a6,[%a14]-8
800191c2:	99 e5 cc ff 	ld.a %a5,[%a14]-52
800191c6:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
800191ca:	6d ff 9d fe 	call 80018f04 <netif_do_set_netmask>
800191ce:	df 02 0c 00 	jeq %d2,0,800191e6 <netif_set_addr+0xde>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_NETMASK_CHANGED;
800191d2:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800191d6:	8f 02 44 21 	or %d2,%d2,64
800191da:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    cb_args.ipv4_changed.old_netmask = old_nm;
800191de:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800191e2:	59 e2 e8 ff 	st.w [%a14]-24,%d2
#endif
  }
  if (netif_do_set_gw(netif, gw, old_gw)) {
800191e6:	99 e6 f4 ff 	ld.a %a6,[%a14]-12
800191ea:	99 e5 c8 ff 	ld.a %a5,[%a14]-56
800191ee:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
800191f2:	6d ff 0a ff 	call 80019006 <netif_do_set_gw>
800191f6:	df 02 0c 00 	jeq %d2,0,8001920e <netif_set_addr+0x106>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    change_reason |= LWIP_NSC_IPV4_GATEWAY_CHANGED;
800191fa:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800191fe:	8f 02 42 21 	or %d2,%d2,32
80019202:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    cb_args.ipv4_changed.old_gw = old_gw;
80019206:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001920a:	59 e2 ec ff 	st.w [%a14]-20,%d2
#endif
  }
  if (!remove) {
8001920e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019212:	df 02 17 80 	jne %d2,0,80019240 <netif_set_addr+0x138>
    /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
    if (netif_do_set_ipaddr(netif, ipaddr, &old_addr)) {
80019216:	d9 e2 d8 ff 	lea %a2,[%a14]-40
8001921a:	40 26       	mov.aa %a6,%a2
8001921c:	99 e5 d0 ff 	ld.a %a5,[%a14]-48
80019220:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
80019224:	6d ff fb fd 	call 80018e1a <netif_do_set_ipaddr>
80019228:	df 02 0c 00 	jeq %d2,0,80019240 <netif_set_addr+0x138>
#if LWIP_NETIF_EXT_STATUS_CALLBACK
      change_reason |= LWIP_NSC_IPV4_ADDRESS_CHANGED;
8001922c:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80019230:	8f 02 41 21 	or %d2,%d2,16
80019234:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      cb_args.ipv4_changed.old_address = &old_addr;
80019238:	d9 e2 d8 ff 	lea %a2,[%a14]-40
8001923c:	b5 e2 e4 ff 	st.a [%a14]-28,%a2
#endif
    }
  }

#if LWIP_NETIF_EXT_STATUS_CALLBACK
  if (change_reason != LWIP_NSC_NONE) {
80019240:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80019244:	df 02 12 00 	jeq %d2,0,80019268 <netif_set_addr+0x160>
    change_reason |= LWIP_NSC_IPV4_SETTINGS_CHANGED;
80019248:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001924c:	8f 02 48 21 	or %d2,%d2,128
80019250:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    netif_invoke_ext_callback(netif, change_reason, &cb_args);
80019254:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80019258:	d9 e2 e4 ff 	lea %a2,[%a14]-28
8001925c:	40 25       	mov.aa %a5,%a2
8001925e:	02 24       	mov %d4,%d2
80019260:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
80019264:	6d 00 b0 01 	call 800195c4 <netif_invoke_ext_callback>
  }
#endif
}
80019268:	00 00       	nop 
8001926a:	00 90       	ret 

8001926c <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
8001926c:	40 ae       	mov.aa %a14,%sp
8001926e:	20 08       	sub.a %sp,8
80019270:	b5 e4 fc ff 	st.a [%a14]-4,%a4
    mib2_remove_route_ip4(1, netif);
  } else {
    /* install default route */
    mib2_add_route_ip4(1, netif);
  }
  netif_default = netif;
80019274:	91 10 00 27 	movh.a %a2,28673
80019278:	d9 22 4c 34 	lea %a2,[%a2]17612 <700144cc <netif_default>>
8001927c:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <700144cc <netif_default>>
80019280:	74 22       	st.w [%a2],%d2
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
                            netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
80019282:	00 00       	nop 
80019284:	00 90       	ret 

80019286 <netif_set_up>:
 * Bring an interface up, available for processing
 * traffic.
 */
void
netif_set_up(struct netif *netif)
{
80019286:	40 ae       	mov.aa %a14,%sp
80019288:	20 28       	sub.a %sp,40
8001928a:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_up: invalid netif", netif != NULL, return);
8001928e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80019292:	df 02 18 80 	jne %d2,0,800192c2 <netif_set_up+0x3c>
80019296:	91 00 00 28 	movh.a %a2,32768
8001929a:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
8001929e:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
800192a2:	3b 00 35 20 	mov %d2,848
800192a6:	59 a2 04 00 	st.w [%sp]4,%d2
800192aa:	91 00 00 28 	movh.a %a2,32768
800192ae:	d9 22 8d 31 	lea %a2,[%a2]6349 <800018cd <IfxCpu_Trap_vectorTable0_end+0x16d9>>
800192b2:	f4 a2       	st.a [%sp],%a2
800192b4:	91 00 00 28 	movh.a %a2,32768
800192b8:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
800192bc:	6d ff 3d 60 	call 80005336 <Ifx_Lwip_printf>
800192c0:	00 90       	ret 

  if (!(netif->flags & NETIF_FLAG_UP)) {
800192c2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800192c6:	39 22 31 00 	ld.bu %d2,[%a2]49
800192ca:	8f 12 00 21 	and %d2,%d2,1
800192ce:	df 02 1f 80 	jne %d2,0,8001930c <netif_set_up+0x86>
    netif_set_flags(netif, NETIF_FLAG_UP);
800192d2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800192d6:	39 22 31 00 	ld.bu %d2,[%a2]49
800192da:	8f 12 40 21 	or %d2,%d2,1
800192de:	8f f2 0f 21 	and %d2,%d2,255
800192e2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800192e6:	e9 22 31 00 	st.b [%a2]49,%d2
    NETIF_STATUS_CALLBACK(netif);

#if LWIP_NETIF_EXT_STATUS_CALLBACK
    {
      netif_ext_callback_args_t args;
      args.status_changed.state = 1;
800192ea:	82 12       	mov %d2,1
800192ec:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
      netif_invoke_ext_callback(netif, LWIP_NSC_STATUS_CHANGED, &args);
800192f0:	d9 e2 f4 ff 	lea %a2,[%a14]-12
800192f4:	40 25       	mov.aa %a5,%a2
800192f6:	3b 80 00 40 	mov %d4,8
800192fa:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800192fe:	6d 00 63 01 	call 800195c4 <netif_invoke_ext_callback>
    }
#endif

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
80019302:	82 34       	mov %d4,3
80019304:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80019308:	6d 00 03 00 	call 8001930e <netif_issue_reports>
#if LWIP_IPV6
    nd6_restart_netif(netif);
#endif /* LWIP_IPV6 */
  }
}
8001930c:	00 90       	ret 

8001930e <netif_issue_reports>:

/** Send ARP/IGMP/MLD/RS events, e.g. on link-up/netif-up or addr-change
 */
static void
netif_issue_reports(struct netif *netif, u8_t report_type)
{
8001930e:	40 ae       	mov.aa %a14,%sp
80019310:	20 18       	sub.a %sp,24
80019312:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80019316:	02 42       	mov %d2,%d4
80019318:	e9 e2 f8 ff 	st.b [%a14]-8,%d2
  LWIP_ASSERT("netif_issue_reports: invalid netif", netif != NULL);
8001931c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019320:	df 02 17 80 	jne %d2,0,8001934e <netif_issue_reports+0x40>
80019324:	91 00 00 28 	movh.a %a2,32768
80019328:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
8001932c:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80019330:	3b d0 36 20 	mov %d2,877
80019334:	59 a2 04 00 	st.w [%sp]4,%d2
80019338:	91 00 00 28 	movh.a %a2,32768
8001933c:	d9 22 a9 31 	lea %a2,[%a2]6377 <800018e9 <IfxCpu_Trap_vectorTable0_end+0x16f5>>
80019340:	f4 a2       	st.a [%sp],%a2
80019342:	91 00 00 28 	movh.a %a2,32768
80019346:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
8001934a:	6d ff f6 5f 	call 80005336 <Ifx_Lwip_printf>

  /* Only send reports when both link and admin states are up */
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
8001934e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019352:	39 22 31 00 	ld.bu %d2,[%a2]49
80019356:	8f 42 00 21 	and %d2,%d2,4
8001935a:	df 02 28 00 	jeq %d2,0,800193aa <netif_issue_reports+0x9c>
      !(netif->flags & NETIF_FLAG_UP)) {
8001935e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019362:	39 22 31 00 	ld.bu %d2,[%a2]49
80019366:	8f 12 00 21 	and %d2,%d2,1
  if (!(netif->flags & NETIF_FLAG_LINK_UP) ||
8001936a:	df 02 20 00 	jeq %d2,0,800193aa <netif_issue_reports+0x9c>
    return;
  }

#if LWIP_IPV4
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
8001936e:	39 e2 f8 ff 	ld.bu %d2,[%a14]-8
80019372:	8f 12 00 21 	and %d2,%d2,1
80019376:	df 02 1a 00 	jeq %d2,0,800193aa <netif_issue_reports+0x9c>
      !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
8001937a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001937e:	60 22       	mov.a %a2,%d2
80019380:	b0 42       	add.a %a2,4
80019382:	54 22       	ld.w %d2,[%a2]
  if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
80019384:	df 02 13 00 	jeq %d2,0,800193aa <netif_issue_reports+0x9c>
#if LWIP_ARP
    /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
    if (netif->flags & (NETIF_FLAG_ETHARP)) {
80019388:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001938c:	39 22 31 00 	ld.bu %d2,[%a2]49
80019390:	8f 82 00 21 	and %d2,%d2,8
80019394:	df 02 0b 00 	jeq %d2,0,800193aa <netif_issue_reports+0x9c>
      etharp_gratuitous(netif);
80019398:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001939c:	c2 42       	add %d2,4
8001939e:	60 25       	mov.a %a5,%d2
800193a0:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800193a4:	6d ff fe d9 	call 800147a0 <etharp_request>
800193a8:	00 90       	ret 
    /* send mld memberships */
    mld6_report_groups(netif);
#endif /* LWIP_IPV6_MLD */
  }
#endif /* LWIP_IPV6 */
}
800193aa:	00 90       	ret 

800193ac <netif_set_link_up>:
 * @ingroup netif
 * Called by a driver when its link goes up
 */
void
netif_set_link_up(struct netif *netif)
{
800193ac:	40 ae       	mov.aa %a14,%sp
800193ae:	20 28       	sub.a %sp,40
800193b0:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_up: invalid netif", netif != NULL, return);
800193b4:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800193b8:	df 02 18 80 	jne %d2,0,800193e8 <netif_set_link_up+0x3c>
800193bc:	91 00 00 28 	movh.a %a2,32768
800193c0:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
800193c4:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
800193c8:	3b 00 3e 20 	mov %d2,992
800193cc:	59 a2 04 00 	st.w [%sp]4,%d2
800193d0:	91 00 00 28 	movh.a %a2,32768
800193d4:	d9 22 aa 41 	lea %a2,[%a2]6442 <8000192a <IfxCpu_Trap_vectorTable0_end+0x1736>>
800193d8:	f4 a2       	st.a [%sp],%a2
800193da:	91 00 00 28 	movh.a %a2,32768
800193de:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
800193e2:	6d ff aa 5f 	call 80005336 <Ifx_Lwip_printf>
800193e6:	00 90       	ret 

  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
800193e8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800193ec:	39 22 31 00 	ld.bu %d2,[%a2]49
800193f0:	8f 42 00 21 	and %d2,%d2,4
800193f4:	df 02 22 80 	jne %d2,0,80019438 <netif_set_link_up+0x8c>
    netif_set_flags(netif, NETIF_FLAG_LINK_UP);
800193f8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800193fc:	39 22 31 00 	ld.bu %d2,[%a2]49
80019400:	8f 42 40 21 	or %d2,%d2,4
80019404:	8f f2 0f 21 	and %d2,%d2,255
80019408:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001940c:	e9 22 31 00 	st.b [%a2]49,%d2

#if LWIP_DHCP
    dhcp_network_changed(netif);
80019410:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80019414:	6d ff 9f bd 	call 80010f52 <dhcp_network_changed>

#if LWIP_AUTOIP
    autoip_network_changed(netif);
#endif /* LWIP_AUTOIP */

    netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4 | NETIF_REPORT_TYPE_IPV6);
80019418:	82 34       	mov %d4,3
8001941a:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001941e:	6d ff 78 ff 	call 8001930e <netif_issue_reports>

    NETIF_LINK_CALLBACK(netif);
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    {
      netif_ext_callback_args_t args;
      args.link_changed.state = 1;
80019422:	82 12       	mov %d2,1
80019424:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
80019428:	d9 e2 f4 ff 	lea %a2,[%a14]-12
8001942c:	40 25       	mov.aa %a5,%a2
8001942e:	82 44       	mov %d4,4
80019430:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80019434:	6d 00 c8 00 	call 800195c4 <netif_invoke_ext_callback>
    }
#endif
  }
}
80019438:	00 90       	ret 

8001943a <netif_set_link_down>:
 * @ingroup netif
 * Called by a driver when its link goes down
 */
void
netif_set_link_down(struct netif *netif)
{
8001943a:	40 ae       	mov.aa %a14,%sp
8001943c:	20 28       	sub.a %sp,40
8001943e:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("netif_set_link_down: invalid netif", netif != NULL, return);
80019442:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80019446:	df 02 18 80 	jne %d2,0,80019476 <netif_set_link_down+0x3c>
8001944a:	91 00 00 28 	movh.a %a2,32768
8001944e:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80019452:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80019456:	3b 60 40 20 	mov %d2,1030
8001945a:	59 a2 04 00 	st.w [%sp]4,%d2
8001945e:	91 00 00 28 	movh.a %a2,32768
80019462:	d9 22 8b 51 	lea %a2,[%a2]6475 <8000194b <IfxCpu_Trap_vectorTable0_end+0x1757>>
80019466:	f4 a2       	st.a [%sp],%a2
80019468:	91 00 00 28 	movh.a %a2,32768
8001946c:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80019470:	6d ff 63 5f 	call 80005336 <Ifx_Lwip_printf>
80019474:	00 90       	ret 

  if (netif->flags & NETIF_FLAG_LINK_UP) {
80019476:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001947a:	39 22 31 00 	ld.bu %d2,[%a2]49
8001947e:	8f 42 00 21 	and %d2,%d2,4
80019482:	df 02 19 00 	jeq %d2,0,800194b4 <netif_set_link_down+0x7a>
    netif_clear_flags(netif, NETIF_FLAG_LINK_UP);
80019486:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001948a:	39 22 31 00 	ld.bu %d2,[%a2]49
8001948e:	8f 42 c0 21 	andn %d2,%d2,4
80019492:	8f f2 0f 21 	and %d2,%d2,255
80019496:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001949a:	e9 22 31 00 	st.b [%a2]49,%d2
    NETIF_LINK_CALLBACK(netif);
#if LWIP_NETIF_EXT_STATUS_CALLBACK
    {
      netif_ext_callback_args_t args;
      args.link_changed.state = 0;
8001949e:	82 02       	mov %d2,0
800194a0:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
      netif_invoke_ext_callback(netif, LWIP_NSC_LINK_CHANGED, &args);
800194a4:	d9 e2 f4 ff 	lea %a2,[%a14]-12
800194a8:	40 25       	mov.aa %a5,%a2
800194aa:	82 44       	mov %d4,4
800194ac:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800194b0:	6d 00 8a 00 	call 800195c4 <netif_invoke_ext_callback>
    }
#endif
  }
}
800194b4:	00 90       	ret 

800194b6 <netif_null_output_ip4>:
#if LWIP_IPV4
/** Dummy IPv4 output function for netifs not supporting IPv4
 */
static err_t
netif_null_output_ip4(struct netif *netif, struct pbuf *p, const ip4_addr_t *ipaddr)
{
800194b6:	40 ae       	mov.aa %a14,%sp
800194b8:	20 10       	sub.a %sp,16
800194ba:	b5 e4 fc ff 	st.a [%a14]-4,%a4
800194be:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
800194c2:	b5 e6 f4 ff 	st.a [%a14]-12,%a6
  LWIP_UNUSED_ARG(netif);
  LWIP_UNUSED_ARG(p);
  LWIP_UNUSED_ARG(ipaddr);

  return ERR_IF;
800194c6:	3b 40 ff 2f 	mov %d2,-12
}
800194ca:	00 90       	ret 

800194cc <netif_get_by_index>:
*
* @param idx index of netif to find
*/
struct netif *
netif_get_by_index(u8_t idx)
{
800194cc:	40 ae       	mov.aa %a14,%sp
800194ce:	20 10       	sub.a %sp,16
800194d0:	02 42       	mov %d2,%d4
800194d2:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
  struct netif *netif;

  LWIP_ASSERT_CORE_LOCKED();

  if (idx != NETIF_NO_INDEX) {
800194d6:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
800194da:	df 02 23 00 	jeq %d2,0,80019520 <netif_get_by_index+0x54>
    NETIF_FOREACH(netif) {
800194de:	91 10 00 27 	movh.a %a2,28673
800194e2:	d9 22 48 34 	lea %a2,[%a2]17608 <700144c8 <netif_list>>
800194e6:	54 22       	ld.w %d2,[%a2]
800194e8:	59 e2 fc ff 	st.w [%a14]-4 <700144c8 <netif_list>>,%d2
800194ec:	1d 00 16 00 	j 80019518 <netif_get_by_index+0x4c>
      if (idx == netif_get_index(netif)) {
800194f0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800194f4:	39 22 34 00 	ld.bu %d2,[%a2]52
800194f8:	c2 12       	add %d2,1
800194fa:	8f f2 0f 31 	and %d3,%d2,255
800194fe:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80019502:	5f 32 06 80 	jne %d2,%d3,8001950e <netif_get_by_index+0x42>
        return netif; /* found! */
80019506:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001950a:	1d 00 0c 00 	j 80019522 <netif_get_by_index+0x56>
    NETIF_FOREACH(netif) {
8001950e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019512:	54 22       	ld.w %d2,[%a2]
80019514:	59 e2 fc ff 	st.w [%a14]-4,%d2
80019518:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001951c:	df 02 ea ff 	jne %d2,0,800194f0 <netif_get_by_index+0x24>
      }
    }
  }

  return NULL;
80019520:	82 02       	mov %d2,0
}
80019522:	60 22       	mov.a %a2,%d2
80019524:	00 90       	ret 

80019526 <netif_add_ext_callback>:
 * @param callback pointer to listener structure
 * @param fn callback function
 */
void
netif_add_ext_callback(netif_ext_callback_t *callback, netif_ext_callback_fn fn)
{
80019526:	40 ae       	mov.aa %a14,%sp
80019528:	20 18       	sub.a %sp,24
8001952a:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001952e:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("callback must be != NULL", callback != NULL);
80019532:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019536:	df 02 17 80 	jne %d2,0,80019564 <netif_add_ext_callback+0x3e>
8001953a:	91 00 00 28 	movh.a %a2,32768
8001953e:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80019542:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80019546:	3b 90 6c 20 	mov %d2,1737
8001954a:	59 a2 04 00 	st.w [%sp]4,%d2
8001954e:	91 00 00 28 	movh.a %a2,32768
80019552:	d9 22 ae 51 	lea %a2,[%a2]6510 <8000196e <IfxCpu_Trap_vectorTable0_end+0x177a>>
80019556:	f4 a2       	st.a [%sp],%a2
80019558:	91 00 00 28 	movh.a %a2,32768
8001955c:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80019560:	6d ff eb 5e 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("fn must be != NULL", fn != NULL);
80019564:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80019568:	df 02 17 80 	jne %d2,0,80019596 <netif_add_ext_callback+0x70>
8001956c:	91 00 00 28 	movh.a %a2,32768
80019570:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
80019574:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
80019578:	3b a0 6c 20 	mov %d2,1738
8001957c:	59 a2 04 00 	st.w [%sp]4,%d2
80019580:	91 00 00 28 	movh.a %a2,32768
80019584:	d9 22 87 61 	lea %a2,[%a2]6535 <80001987 <IfxCpu_Trap_vectorTable0_end+0x1793>>
80019588:	f4 a2       	st.a [%sp],%a2
8001958a:	91 00 00 28 	movh.a %a2,32768
8001958e:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80019592:	6d ff d2 5e 	call 80005336 <Ifx_Lwip_printf>

  callback->callback_fn = fn;
80019596:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001959a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001959e:	74 22       	st.w [%a2],%d2
  callback->next        = ext_callback;
800195a0:	91 10 00 27 	movh.a %a2,28673
800195a4:	d9 22 44 34 	lea %a2,[%a2]17604 <700144c4 <ext_callback>>
800195a8:	54 22       	ld.w %d2,[%a2]
800195aa:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700144c4 <ext_callback>>
800195ae:	b0 42       	add.a %a2,4
800195b0:	74 22       	st.w [%a2],%d2
  ext_callback          = callback;
800195b2:	91 10 00 27 	movh.a %a2,28673
800195b6:	d9 22 44 34 	lea %a2,[%a2]17604 <700144c4 <ext_callback>>
800195ba:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <700144c4 <ext_callback>>
800195be:	74 22       	st.w [%a2],%d2
}
800195c0:	00 00       	nop 
800195c2:	00 90       	ret 

800195c4 <netif_invoke_ext_callback>:
 * @param reason change reason
 * @param args depends on reason, see reason description
 */
void
netif_invoke_ext_callback(struct netif *netif, netif_nsc_reason_t reason, const netif_ext_callback_args_t *args)
{
800195c4:	40 ae       	mov.aa %a14,%sp
800195c6:	20 28       	sub.a %sp,40
800195c8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
800195cc:	02 42       	mov %d2,%d4
800195ce:	b5 e5 ec ff 	st.a [%a14]-20,%a5
800195d2:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
  netif_ext_callback_t *callback = ext_callback;
800195d6:	91 10 00 27 	movh.a %a2,28673
800195da:	d9 22 44 34 	lea %a2,[%a2]17604 <700144c4 <ext_callback>>
800195de:	54 22       	ld.w %d2,[%a2]
800195e0:	59 e2 fc ff 	st.w [%a14]-4 <700144c4 <ext_callback>>,%d2

  LWIP_ASSERT("netif must be != NULL", netif != NULL);
800195e4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <700144c4 <ext_callback>>
800195e8:	df 02 2b 80 	jne %d2,0,8001963e <netif_invoke_ext_callback+0x7a>
800195ec:	91 00 00 28 	movh.a %a2,32768
800195f0:	d9 22 66 b1 	lea %a2,[%a2]5862 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>
800195f4:	b5 a2 08 00 	st.a [%sp]8 <800016e6 <IfxCpu_Trap_vectorTable0_end+0x14f2>>,%a2
800195f8:	3b c0 6f 20 	mov %d2,1788
800195fc:	59 a2 04 00 	st.w [%sp]4,%d2
80019600:	91 00 00 28 	movh.a %a2,32768
80019604:	d9 22 a7 61 	lea %a2,[%a2]6567 <800019a7 <IfxCpu_Trap_vectorTable0_end+0x17b3>>
80019608:	f4 a2       	st.a [%sp],%a2
8001960a:	91 00 00 28 	movh.a %a2,32768
8001960e:	d9 24 7e a1 	lea %a4,[%a2]5822 <800016be <IfxCpu_Trap_vectorTable0_end+0x14ca>>
80019612:	6d ff 92 5e 	call 80005336 <Ifx_Lwip_printf>

  while (callback != NULL) {
80019616:	1d 00 14 00 	j 8001963e <netif_invoke_ext_callback+0x7a>
    callback->callback_fn(netif, reason, args);
8001961a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001961e:	d4 22       	ld.a %a2,[%a2]
80019620:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
80019624:	99 e5 ec ff 	ld.a %a5,[%a14]-20
80019628:	02 24       	mov %d4,%d2
8001962a:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001962e:	2d 02 00 00 	calli %a2
    callback = callback->next;
80019632:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019636:	b0 42       	add.a %a2,4
80019638:	54 22       	ld.w %d2,[%a2]
8001963a:	59 e2 fc ff 	st.w [%a14]-4,%d2
  while (callback != NULL) {
8001963e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019642:	df 02 ec ff 	jne %d2,0,8001961a <netif_invoke_ext_callback+0x56>
  }
}
80019646:	00 90       	ret 

80019648 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
80019648:	40 ae       	mov.aa %a14,%sp
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
8001964a:	91 10 00 27 	movh.a %a2,28673
8001964e:	d9 22 51 34 	lea %a2,[%a2]17617 <700144d1 <pbuf_free_ooseq_pending>>
80019652:	82 12       	mov %d2,1
80019654:	34 22       	st.b [%a2],%d2
  if (!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
80019656:	00 00       	nop 
80019658:	00 90       	ret 

8001965a <pbuf_init_alloced_pbuf>:
#endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */

/* Initialize members of struct pbuf after allocation */
static void
pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
{
8001965a:	40 ae       	mov.aa %a14,%sp
8001965c:	20 18       	sub.a %sp,24
8001965e:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80019662:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
80019666:	02 42       	mov %d2,%d4
80019668:	02 54       	mov %d4,%d5
8001966a:	59 e6 ec ff 	st.w [%a14]-20,%d6
8001966e:	02 73       	mov %d3,%d7
80019670:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
80019674:	02 42       	mov %d2,%d4
80019676:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
8001967a:	02 32       	mov %d2,%d3
8001967c:	e9 e2 e8 ff 	st.b [%a14]-24,%d2
  p->next = NULL;
80019680:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019684:	82 02       	mov %d2,0
80019686:	74 22       	st.w [%a2],%d2
  p->payload = payload;
80019688:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001968c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80019690:	b0 42       	add.a %a2,4
80019692:	74 22       	st.w [%a2],%d2
  p->tot_len = tot_len;
80019694:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019698:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12
8001969c:	f9 22 08 00 	st.h [%a2]8,%d2
  p->len = len;
800196a0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800196a4:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
800196a8:	f9 22 0a 00 	st.h [%a2]10,%d2
  p->type_internal = (u8_t)type;
800196ac:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800196b0:	8f f2 0f 21 	and %d2,%d2,255
800196b4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800196b8:	e9 22 0c 00 	st.b [%a2]12,%d2
  p->flags = flags;
800196bc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800196c0:	79 e2 e8 ff 	ld.b %d2,[%a14]-24
800196c4:	e9 22 0d 00 	st.b [%a2]13,%d2
  p->ref = 1;
800196c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800196cc:	82 12       	mov %d2,1
800196ce:	e9 22 0e 00 	st.b [%a2]14,%d2
  p->if_idx = NETIF_NO_INDEX;
800196d2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800196d6:	82 02       	mov %d2,0
800196d8:	e9 22 0f 00 	st.b [%a2]15,%d2
}
800196dc:	00 00       	nop 
800196de:	00 90       	ret 

800196e0 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
800196e0:	40 ae       	mov.aa %a14,%sp
800196e2:	20 40       	sub.a %sp,64
800196e4:	59 e4 dc ff 	st.w [%a14]-36,%d4
800196e8:	02 52       	mov %d2,%d5
800196ea:	59 e6 d4 ff 	st.w [%a14]-44,%d6
800196ee:	f9 e2 d8 ff 	st.h [%a14]-40,%d2
  struct pbuf *p;
  u16_t offset = (u16_t)layer;
800196f2:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800196f6:	f9 e2 fa ff 	st.h [%a14]-6,%d2
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  switch (type) {
800196fa:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800196fe:	3b 00 28 30 	mov %d3,640
80019702:	5f 32 d8 00 	jeq %d2,%d3,800198b2 <pbuf_alloc+0x1d2>
80019706:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8001970a:	3b 10 28 30 	mov %d3,641
8001970e:	7f 32 48 81 	jge.u %d2,%d3,8001999e <pbuf_alloc+0x2be>
80019712:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
80019716:	3b 20 18 30 	mov %d3,386
8001971a:	5f 32 1e 00 	jeq %d2,%d3,80019756 <pbuf_alloc+0x76>
8001971e:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
80019722:	8b 32 b8 22 	ge.u %d2,%d2,387
80019726:	df 02 3c 81 	jne %d2,0,8001999e <pbuf_alloc+0x2be>
8001972a:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
8001972e:	df 12 08 00 	jeq %d2,1,8001973e <pbuf_alloc+0x5e>
80019732:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
80019736:	8b 12 24 22 	ne %d2,%d2,65
8001973a:	df 02 32 81 	jne %d2,0,8001999e <pbuf_alloc+0x2be>
    case PBUF_REF: /* fall through */
    case PBUF_ROM:
      p = pbuf_alloc_reference(NULL, length, type);
8001973e:	b9 e2 d8 ff 	ld.hu %d2,[%a14]-40
80019742:	19 e5 d4 ff 	ld.w %d5,[%a14]-44
80019746:	02 24       	mov %d4,%d2
80019748:	a0 04       	mov.a %a4,0
8001974a:	6d 00 46 01 	call 800199d6 <pbuf_alloc_reference>
8001974e:	b5 e2 fc ff 	st.a [%a14]-4,%a2
      break;
80019752:	1d 00 3e 01 	j 800199ce <pbuf_alloc+0x2ee>
    case PBUF_POOL: {
      struct pbuf *q, *last;
      u16_t rem_len; /* remaining length */
      p = NULL;
80019756:	82 02       	mov %d2,0
80019758:	59 e2 fc ff 	st.w [%a14]-4,%d2
      last = NULL;
8001975c:	82 02       	mov %d2,0
8001975e:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      rem_len = length;
80019762:	c9 e2 d8 ff 	ld.h %d2,[%a14]-40
80019766:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
      do {
        u16_t qlen;
        q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
8001976a:	3b 80 00 40 	mov %d4,8
8001976e:	6d ff 2e f9 	call 800189ca <memp_malloc>
80019772:	b5 e2 e8 ff 	st.a [%a14]-24,%a2
        if (q == NULL) {
80019776:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001977a:	df 02 0f 80 	jne %d2,0,80019798 <pbuf_alloc+0xb8>
          PBUF_POOL_IS_EMPTY();
8001977e:	6d ff 65 ff 	call 80019648 <pbuf_pool_is_empty>
          /* free chain so far allocated */
          if (p) {
80019782:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019786:	df 02 06 00 	jeq %d2,0,80019792 <pbuf_alloc+0xb2>
            pbuf_free(p);
8001978a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001978e:	6d 00 05 04 	call 80019f98 <pbuf_free>
          }
          /* bail out unsuccessfully */
          return NULL;
80019792:	82 02       	mov %d2,0
80019794:	1d 00 1f 01 	j 800199d2 <pbuf_alloc+0x2f2>
        }
        qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
80019798:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
8001979c:	c2 32       	add %d2,3
8001979e:	37 02 70 20 	extr.u %d2,%d2,0,16
800197a2:	8f 32 c0 21 	andn %d2,%d2,3
800197a6:	37 02 70 20 	extr.u %d2,%d2,0,16
800197aa:	3b 00 25 30 	mov %d3,592
800197ae:	0b 23 80 20 	sub %d2,%d3,%d2
800197b2:	37 02 70 20 	extr.u %d2,%d2,0,16
800197b6:	b9 e3 f2 ff 	ld.hu %d3,[%a14]-14
800197ba:	0b 23 90 21 	min.u %d2,%d3,%d2
800197be:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
        pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
800197c2:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
800197c6:	1b 02 01 20 	addi %d2,%d2,16
800197ca:	19 e3 e8 ff 	ld.w %d3,[%a14]-24
800197ce:	42 32       	add %d2,%d3
800197d0:	c2 32       	add %d2,3
800197d2:	8f 32 c0 21 	andn %d2,%d2,3
800197d6:	02 20       	mov %d0,%d2
800197d8:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
800197dc:	b9 e3 e6 ff 	ld.hu %d3,[%a14]-26
800197e0:	82 07       	mov %d7,0
800197e2:	19 e6 d4 ff 	ld.w %d6,[%a14]-44
800197e6:	02 35       	mov %d5,%d3
800197e8:	02 24       	mov %d4,%d2
800197ea:	60 05       	mov.a %a5,%d0
800197ec:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
800197f0:	6d ff 35 ff 	call 8001965a <pbuf_init_alloced_pbuf>
                               rem_len, qlen, type, 0);
        LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
800197f4:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800197f8:	b0 42       	add.a %a2,4
800197fa:	54 22       	ld.w %d2,[%a2]
800197fc:	8f 32 00 21 	and %d2,%d2,3
80019800:	df 02 17 00 	jeq %d2,0,8001982e <pbuf_alloc+0x14e>
80019804:	91 00 00 28 	movh.a %a2,32768
80019808:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001980c:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019810:	3b 00 10 20 	mov %d2,256
80019814:	59 a2 04 00 	st.w [%sp]4,%d2
80019818:	91 00 00 28 	movh.a %a2,32768
8001981c:	d9 22 90 81 	lea %a2,[%a2]6672 <80001a10 <IfxCpu_Trap_vectorTable0_end+0x181c>>
80019820:	f4 a2       	st.a [%sp],%a2
80019822:	91 00 00 28 	movh.a %a2,32768
80019826:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001982a:	6d ff 86 5d 	call 80005336 <Ifx_Lwip_printf>
                    ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
8001982e:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80019832:	c2 32       	add %d2,3
80019834:	8f 32 c0 21 	andn %d2,%d2,3
80019838:	3b 00 25 30 	mov %d3,592
8001983c:	5f 32 17 80 	jne %d2,%d3,8001986a <pbuf_alloc+0x18a>
80019840:	91 00 00 28 	movh.a %a2,32768
80019844:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019848:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001984c:	3b 20 10 20 	mov %d2,258
80019850:	59 a2 04 00 	st.w [%sp]4,%d2
80019854:	91 00 00 28 	movh.a %a2,32768
80019858:	d9 22 bd 81 	lea %a2,[%a2]6717 <80001a3d <IfxCpu_Trap_vectorTable0_end+0x1849>>
8001985c:	f4 a2       	st.a [%sp],%a2
8001985e:	91 00 00 28 	movh.a %a2,32768
80019862:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019866:	6d ff 68 5d 	call 80005336 <Ifx_Lwip_printf>
                    (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
        if (p == NULL) {
8001986a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001986e:	df 02 08 80 	jne %d2,0,8001987e <pbuf_alloc+0x19e>
          /* allocated head of pbuf chain (into p) */
          p = q;
80019872:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80019876:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001987a:	1d 00 07 00 	j 80019888 <pbuf_alloc+0x1a8>
        } else {
          /* make previous pbuf point to this pbuf */
          last->next = q;
8001987e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019882:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80019886:	74 22       	st.w [%a2],%d2
        }
        last = q;
80019888:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001988c:	59 e2 f4 ff 	st.w [%a14]-12,%d2
        rem_len = (u16_t)(rem_len - qlen);
80019890:	c9 e3 f2 ff 	ld.h %d3,[%a14]-14
80019894:	c9 e2 e6 ff 	ld.h %d2,[%a14]-26
80019898:	0b 23 80 20 	sub %d2,%d3,%d2
8001989c:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
        offset = 0;
800198a0:	82 02       	mov %d2,0
800198a2:	f9 e2 fa ff 	st.h [%a14]-6,%d2
      } while (rem_len > 0);
800198a6:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
800198aa:	df 02 60 ff 	jne %d2,0,8001976a <pbuf_alloc+0x8a>
      break;
800198ae:	1d 00 90 00 	j 800199ce <pbuf_alloc+0x2ee>
    }
    case PBUF_RAM: {
      u16_t payload_len = (u16_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
800198b2:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
800198b6:	c2 32       	add %d2,3
800198b8:	37 02 70 20 	extr.u %d2,%d2,0,16
800198bc:	8f 32 c0 21 	andn %d2,%d2,3
800198c0:	37 02 70 30 	extr.u %d3,%d2,0,16
800198c4:	c9 e2 d8 ff 	ld.h %d2,[%a14]-40
800198c8:	c2 32       	add %d2,3
800198ca:	37 02 70 20 	extr.u %d2,%d2,0,16
800198ce:	8f 32 c0 21 	andn %d2,%d2,3
800198d2:	37 02 70 20 	extr.u %d2,%d2,0,16
800198d6:	42 32       	add %d2,%d3
800198d8:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
      mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
800198dc:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
800198e0:	1b 02 01 20 	addi %d2,%d2,16
800198e4:	f9 e2 ee ff 	st.h [%a14]-18,%d2

      /* bug #50040: Check for integer overflow when calculating alloc_len */
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
800198e8:	b9 e3 f0 ff 	ld.hu %d3,[%a14]-16
800198ec:	b9 e2 d8 ff 	ld.hu %d2,[%a14]-40
800198f0:	c2 32       	add %d2,3
800198f2:	8f 32 c0 21 	andn %d2,%d2,3
800198f6:	3f 23 0b 80 	jlt.u %d3,%d2,8001990c <pbuf_alloc+0x22c>
          (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
800198fa:	b9 e3 ee ff 	ld.hu %d3,[%a14]-18
800198fe:	b9 e2 d8 ff 	ld.hu %d2,[%a14]-40
80019902:	c2 32       	add %d2,3
80019904:	8f 32 c0 21 	andn %d2,%d2,3
      if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
80019908:	7f 23 05 80 	jge.u %d3,%d2,80019912 <pbuf_alloc+0x232>
        return NULL;
8001990c:	82 02       	mov %d2,0
8001990e:	1d 00 62 00 	j 800199d2 <pbuf_alloc+0x2f2>
      }

      /* If pbuf is to be allocated in RAM, allocate memory for it. */
      p = (struct pbuf *)mem_malloc(alloc_len);
80019912:	b9 e2 ee ff 	ld.hu %d2,[%a14]-18
80019916:	02 24       	mov %d4,%d2
80019918:	6d ff 55 f5 	call 800183c2 <mem_malloc>
8001991c:	b5 e2 fc ff 	st.a [%a14]-4,%a2
      if (p == NULL) {
80019920:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019924:	df 02 05 80 	jne %d2,0,8001992e <pbuf_alloc+0x24e>
        return NULL;
80019928:	82 02       	mov %d2,0
8001992a:	1d 00 54 00 	j 800199d2 <pbuf_alloc+0x2f2>
      }
      pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
8001992e:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80019932:	1b 02 01 20 	addi %d2,%d2,16
80019936:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8001993a:	42 32       	add %d2,%d3
8001993c:	c2 32       	add %d2,3
8001993e:	8f 32 c0 21 	andn %d2,%d2,3
80019942:	02 20       	mov %d0,%d2
80019944:	b9 e2 d8 ff 	ld.hu %d2,[%a14]-40
80019948:	b9 e3 d8 ff 	ld.hu %d3,[%a14]-40
8001994c:	82 07       	mov %d7,0
8001994e:	19 e6 d4 ff 	ld.w %d6,[%a14]-44
80019952:	02 35       	mov %d5,%d3
80019954:	02 24       	mov %d4,%d2
80019956:	60 05       	mov.a %a5,%d0
80019958:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001995c:	6d ff 7f fe 	call 8001965a <pbuf_init_alloced_pbuf>
                             length, length, type, 0);
      LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
80019960:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019964:	b0 42       	add.a %a2,4
80019966:	54 22       	ld.w %d2,[%a2]
80019968:	8f 32 00 21 	and %d2,%d2,3
8001996c:	df 02 31 00 	jeq %d2,0,800199ce <pbuf_alloc+0x2ee>
80019970:	91 00 00 28 	movh.a %a2,32768
80019974:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019978:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001997c:	3b 20 12 20 	mov %d2,290
80019980:	59 a2 04 00 	st.w [%sp]4,%d2
80019984:	91 00 00 28 	movh.a %a2,32768
80019988:	d9 22 b1 91 	lea %a2,[%a2]6769 <80001a71 <IfxCpu_Trap_vectorTable0_end+0x187d>>
8001998c:	f4 a2       	st.a [%sp],%a2
8001998e:	91 00 00 28 	movh.a %a2,32768
80019992:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019996:	6d ff d0 5c 	call 80005336 <Ifx_Lwip_printf>
                  ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
      break;
8001999a:	1d 00 1a 00 	j 800199ce <pbuf_alloc+0x2ee>
    }
    default:
      LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
8001999e:	91 00 00 28 	movh.a %a2,32768
800199a2:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
800199a6:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
800199aa:	3b 70 12 20 	mov %d2,295
800199ae:	59 a2 04 00 	st.w [%sp]4,%d2
800199b2:	91 00 00 28 	movh.a %a2,32768
800199b6:	d9 22 9c a1 	lea %a2,[%a2]6812 <80001a9c <IfxCpu_Trap_vectorTable0_end+0x18a8>>
800199ba:	f4 a2       	st.a [%sp],%a2
800199bc:	91 00 00 28 	movh.a %a2,32768
800199c0:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
800199c4:	6d ff b9 5c 	call 80005336 <Ifx_Lwip_printf>
      return NULL;
800199c8:	82 02       	mov %d2,0
800199ca:	1d 00 04 00 	j 800199d2 <pbuf_alloc+0x2f2>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
800199ce:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
800199d2:	60 22       	mov.a %a2,%d2
800199d4:	00 90       	ret 

800199d6 <pbuf_alloc_reference>:
 *
 * @return the allocated pbuf.
 */
struct pbuf *
pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
{
800199d6:	40 ae       	mov.aa %a14,%sp
800199d8:	20 28       	sub.a %sp,40
800199da:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
800199de:	02 42       	mov %d2,%d4
800199e0:	59 e5 ec ff 	st.w [%a14]-20,%d5
800199e4:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
  struct pbuf *p;
  LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
800199e8:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800199ec:	8b 12 04 22 	eq %d2,%d2,65
800199f0:	df 02 1b 80 	jne %d2,0,80019a26 <pbuf_alloc_reference+0x50>
800199f4:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800199f8:	df 12 17 00 	jeq %d2,1,80019a26 <pbuf_alloc_reference+0x50>
800199fc:	91 00 00 28 	movh.a %a2,32768
80019a00:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019a04:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019a08:	3b a0 14 20 	mov %d2,330
80019a0c:	59 a2 04 00 	st.w [%sp]4,%d2
80019a10:	91 00 00 28 	movh.a %a2,32768
80019a14:	d9 22 b7 a1 	lea %a2,[%a2]6839 <80001ab7 <IfxCpu_Trap_vectorTable0_end+0x18c3>>
80019a18:	f4 a2       	st.a [%sp],%a2
80019a1a:	91 00 00 28 	movh.a %a2,32768
80019a1e:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019a22:	6d ff 8a 5c 	call 80005336 <Ifx_Lwip_printf>
  /* only allocate memory for the pbuf structure */
  p = (struct pbuf *)memp_malloc(MEMP_PBUF);
80019a26:	82 74       	mov %d4,7
80019a28:	6d ff d1 f7 	call 800189ca <memp_malloc>
80019a2c:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (p == NULL) {
80019a30:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019a34:	df 02 05 80 	jne %d2,0,80019a3e <pbuf_alloc_reference+0x68>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                 (type == PBUF_ROM) ? "ROM" : "REF"));
    return NULL;
80019a38:	82 02       	mov %d2,0
80019a3a:	1d 00 13 00 	j 80019a60 <pbuf_alloc_reference+0x8a>
  }
  pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
80019a3e:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
80019a42:	b9 e3 f0 ff 	ld.hu %d3,[%a14]-16
80019a46:	82 07       	mov %d7,0
80019a48:	19 e6 ec ff 	ld.w %d6,[%a14]-20
80019a4c:	02 35       	mov %d5,%d3
80019a4e:	02 24       	mov %d4,%d2
80019a50:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80019a54:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80019a58:	6d ff 01 fe 	call 8001965a <pbuf_init_alloced_pbuf>
  return p;
80019a5c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
80019a60:	60 22       	mov.a %a2,%d2
80019a62:	00 90       	ret 

80019a64 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf *
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
80019a64:	40 ae       	mov.aa %a14,%sp
80019a66:	20 20       	sub.a %sp,32
80019a68:	59 e4 f4 ff 	st.w [%a14]-12,%d4
80019a6c:	02 52       	mov %d2,%d5
80019a6e:	59 e6 ec ff 	st.w [%a14]-20,%d6
80019a72:	b5 e4 e8 ff 	st.a [%a14]-24,%a4
80019a76:	b5 e5 e4 ff 	st.a [%a14]-28,%a5
80019a7a:	02 73       	mov %d3,%d7
80019a7c:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
80019a80:	02 32       	mov %d2,%d3
80019a82:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
  u16_t offset = (u16_t)l;
80019a86:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019a8a:	f9 e2 fa ff 	st.h [%a14]-6,%d2
  void *payload;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
80019a8e:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80019a92:	c2 32       	add %d2,3
80019a94:	8f 32 c0 31 	andn %d3,%d2,3
80019a98:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
80019a9c:	42 23       	add %d3,%d2
80019a9e:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
80019aa2:	7f 32 05 80 	jge.u %d2,%d3,80019aac <pbuf_alloced_custom+0x48>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
80019aa6:	82 02       	mov %d2,0
80019aa8:	1d 00 27 00 	j 80019af6 <pbuf_alloced_custom+0x92>
  }

  if (payload_mem != NULL) {
80019aac:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80019ab0:	df 02 0e 00 	jeq %d2,0,80019acc <pbuf_alloced_custom+0x68>
    payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
80019ab4:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80019ab8:	c2 32       	add %d2,3
80019aba:	8f 32 c0 21 	andn %d2,%d2,3
80019abe:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
80019ac2:	42 32       	add %d2,%d3
80019ac4:	59 e2 fc ff 	st.w [%a14]-4,%d2
80019ac8:	1d 00 05 00 	j 80019ad2 <pbuf_alloced_custom+0x6e>
  } else {
    payload = NULL;
80019acc:	82 02       	mov %d2,0
80019ace:	59 e2 fc ff 	st.w [%a14]-4,%d2
  }
  pbuf_init_alloced_pbuf(&p->pbuf, payload, length, length, type, PBUF_FLAG_IS_CUSTOM);
80019ad2:	19 e0 e8 ff 	ld.w %d0,[%a14]-24
80019ad6:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
80019ada:	b9 e3 f0 ff 	ld.hu %d3,[%a14]-16
80019ade:	82 27       	mov %d7,2
80019ae0:	19 e6 ec ff 	ld.w %d6,[%a14]-20
80019ae4:	02 35       	mov %d5,%d3
80019ae6:	02 24       	mov %d4,%d2
80019ae8:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80019aec:	60 04       	mov.a %a4,%d0
80019aee:	6d ff b6 fd 	call 8001965a <pbuf_init_alloced_pbuf>
  return &p->pbuf;
80019af2:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
}
80019af6:	60 22       	mov.a %a2,%d2
80019af8:	00 90       	ret 

80019afa <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
80019afa:	40 ae       	mov.aa %a14,%sp
80019afc:	20 20       	sub.a %sp,32
80019afe:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80019b02:	02 42       	mov %d2,%d4
80019b04:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  u16_t shrink;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
80019b08:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019b0c:	df 02 17 80 	jne %d2,0,80019b3a <pbuf_realloc+0x40>
80019b10:	91 00 00 28 	movh.a %a2,32768
80019b14:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019b18:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019b1c:	3b 80 19 20 	mov %d2,408
80019b20:	59 a2 04 00 	st.w [%sp]4,%d2
80019b24:	91 00 00 28 	movh.a %a2,32768
80019b28:	d9 22 89 b1 	lea %a2,[%a2]6857 <80001ac9 <IfxCpu_Trap_vectorTable0_end+0x18d5>>
80019b2c:	f4 a2       	st.a [%sp],%a2
80019b2e:	91 00 00 28 	movh.a %a2,32768
80019b32:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019b36:	6d ff 00 5c 	call 80005336 <Ifx_Lwip_printf>

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
80019b3a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019b3e:	b9 22 08 00 	ld.hu %d2,[%a2]8
80019b42:	b9 e3 f0 ff 	ld.hu %d3,[%a14]-16
80019b46:	7f 23 b9 80 	jge.u %d3,%d2,80019cb8 <pbuf_realloc+0x1be>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  shrink = (u16_t)(p->tot_len - new_len);
80019b4a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019b4e:	b9 23 08 00 	ld.hu %d3,[%a2]8
80019b52:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
80019b56:	0b 23 80 20 	sub %d2,%d3,%d2
80019b5a:	f9 e2 f8 ff 	st.h [%a14]-8,%d2

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
80019b5e:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
80019b62:	f9 e2 fa ff 	st.h [%a14]-6,%d2
  q = p;
80019b66:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019b6a:	59 e2 fc ff 	st.w [%a14]-4,%d2
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
80019b6e:	1d 00 38 00 	j 80019bde <pbuf_realloc+0xe4>
    /* decrease remaining length by pbuf length */
    rem_len = (u16_t)(rem_len - q->len);
80019b72:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019b76:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80019b7a:	c9 e3 fa ff 	ld.h %d3,[%a14]-6
80019b7e:	0b 23 80 20 	sub %d2,%d3,%d2
80019b82:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    /* decrease total length indicator */
    q->tot_len = (u16_t)(q->tot_len - shrink);
80019b86:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019b8a:	b9 23 08 00 	ld.hu %d3,[%a2]8
80019b8e:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
80019b92:	0b 23 80 20 	sub %d2,%d3,%d2
80019b96:	37 02 70 20 	extr.u %d2,%d2,0,16
80019b9a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019b9e:	f9 22 08 00 	st.h [%a2]8,%d2
    /* proceed to next pbuf in chain */
    q = q->next;
80019ba2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019ba6:	54 22       	ld.w %d2,[%a2]
80019ba8:	59 e2 fc ff 	st.w [%a14]-4,%d2
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
80019bac:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019bb0:	df 02 17 80 	jne %d2,0,80019bde <pbuf_realloc+0xe4>
80019bb4:	91 00 00 28 	movh.a %a2,32768
80019bb8:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019bbc:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019bc0:	3b f0 1a 20 	mov %d2,431
80019bc4:	59 a2 04 00 	st.w [%sp]4,%d2
80019bc8:	91 00 00 28 	movh.a %a2,32768
80019bcc:	d9 22 a1 b1 	lea %a2,[%a2]6881 <80001ae1 <IfxCpu_Trap_vectorTable0_end+0x18ed>>
80019bd0:	f4 a2       	st.a [%sp],%a2
80019bd2:	91 00 00 28 	movh.a %a2,32768
80019bd6:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019bda:	6d ff ae 5b 	call 80005336 <Ifx_Lwip_printf>
  while (rem_len > q->len) {
80019bde:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019be2:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80019be6:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80019bea:	3f 23 c4 ff 	jlt.u %d3,%d2,80019b72 <pbuf_realloc+0x78>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
80019bee:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019bf2:	39 22 0c 00 	ld.bu %d2,[%a2]12
80019bf6:	8f f2 00 21 	and %d2,%d2,15
80019bfa:	df 02 41 80 	jne %d2,0,80019c7c <pbuf_realloc+0x182>
80019bfe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019c02:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80019c06:	b9 e3 fa ff 	ld.hu %d3,[%a14]-6
80019c0a:	5f 23 39 00 	jeq %d3,%d2,80019c7c <pbuf_realloc+0x182>
#if LWIP_SUPPORT_CUSTOM_PBUF
      && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
80019c0e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019c12:	39 22 0d 00 	ld.bu %d2,[%a2]13
80019c16:	8f 22 00 21 	and %d2,%d2,2
80019c1a:	df 02 31 80 	jne %d2,0,80019c7c <pbuf_realloc+0x182>
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
     ) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
80019c1e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019c22:	b0 42       	add.a %a2,4
80019c24:	54 23       	ld.w %d3,[%a2]
80019c26:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019c2a:	0b 23 80 20 	sub %d2,%d3,%d2
80019c2e:	37 02 70 30 	extr.u %d3,%d2,0,16
80019c32:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
80019c36:	42 32       	add %d2,%d3
80019c38:	37 02 70 20 	extr.u %d2,%d2,0,16
80019c3c:	02 24       	mov %d4,%d2
80019c3e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80019c42:	6d ff e3 f1 	call 80018008 <mem_trim>
80019c46:	b5 e2 fc ff 	st.a [%a14]-4,%a2
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
80019c4a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019c4e:	df 02 17 80 	jne %d2,0,80019c7c <pbuf_realloc+0x182>
80019c52:	91 00 00 28 	movh.a %a2,32768
80019c56:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019c5a:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019c5e:	3b d0 1b 20 	mov %d2,445
80019c62:	59 a2 04 00 	st.w [%sp]4,%d2
80019c66:	91 00 00 28 	movh.a %a2,32768
80019c6a:	d9 22 b9 b1 	lea %a2,[%a2]6905 <80001af9 <IfxCpu_Trap_vectorTable0_end+0x1905>>
80019c6e:	f4 a2       	st.a [%sp],%a2
80019c70:	91 00 00 28 	movh.a %a2,32768
80019c74:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019c78:	6d ff 5f 5b 	call 80005336 <Ifx_Lwip_printf>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
80019c7c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019c80:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
80019c84:	f9 22 0a 00 	st.h [%a2]10,%d2
  q->tot_len = q->len;
80019c88:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019c8c:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80019c90:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019c94:	f9 22 08 00 	st.h [%a2]8,%d2

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
80019c98:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019c9c:	54 22       	ld.w %d2,[%a2]
80019c9e:	df 02 08 00 	jeq %d2,0,80019cae <pbuf_realloc+0x1b4>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
80019ca2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019ca6:	54 22       	ld.w %d2,[%a2]
80019ca8:	60 24       	mov.a %a4,%d2
80019caa:	6d 00 77 01 	call 80019f98 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
80019cae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80019cb2:	82 02       	mov %d2,0
80019cb4:	74 22       	st.w [%a2],%d2
80019cb6:	00 90       	ret 

}
80019cb8:	00 90       	ret 

80019cba <pbuf_add_header_impl>:
 * @return non-zero on failure, zero on success.
 *
 */
static u8_t
pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
{
80019cba:	40 ae       	mov.aa %a14,%sp
80019cbc:	20 28       	sub.a %sp,40
80019cbe:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80019cc2:	59 e4 f0 ff 	st.w [%a14]-16,%d4
80019cc6:	02 52       	mov %d2,%d5
80019cc8:	e9 e2 ec ff 	st.b [%a14]-20,%d2
  u16_t type_internal;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
80019ccc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019cd0:	df 02 17 80 	jne %d2,0,80019cfe <pbuf_add_header_impl+0x44>
80019cd4:	91 00 00 28 	movh.a %a2,32768
80019cd8:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019cdc:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019ce0:	3b f0 1d 20 	mov %d2,479
80019ce4:	59 a2 04 00 	st.w [%sp]4,%d2
80019ce8:	91 00 00 28 	movh.a %a2,32768
80019cec:	d9 22 95 c1 	lea %a2,[%a2]6933 <80001b15 <IfxCpu_Trap_vectorTable0_end+0x1921>>
80019cf0:	f4 a2       	st.a [%sp],%a2
80019cf2:	91 00 00 28 	movh.a %a2,32768
80019cf6:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019cfa:	6d ff 1e 5b 	call 80005336 <Ifx_Lwip_printf>
  if ((p == NULL) || (header_size_increment > 0xFFFF)) {
80019cfe:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019d02:	df 02 08 00 	jeq %d2,0,80019d12 <pbuf_add_header_impl+0x58>
80019d06:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019d0a:	7b 10 00 30 	movh %d3,1
80019d0e:	3f 32 04 80 	jlt.u %d2,%d3,80019d16 <pbuf_add_header_impl+0x5c>
    return 1;
80019d12:	82 12       	mov %d2,1
80019d14:	00 90       	ret 
  }
  if (header_size_increment == 0) {
80019d16:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019d1a:	df 02 04 80 	jne %d2,0,80019d22 <pbuf_add_header_impl+0x68>
    return 0;
80019d1e:	82 02       	mov %d2,0
80019d20:	00 90       	ret 
  }

  increment_magnitude = (u16_t)header_size_increment;
80019d22:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019d26:	f9 e2 fa ff 	st.h [%a14]-6,%d2
  /* Do not allow tot_len to wrap as a result. */
  if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
80019d2a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019d2e:	b9 23 08 00 	ld.hu %d3,[%a2]8
80019d32:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
80019d36:	42 32       	add %d2,%d3
80019d38:	37 02 70 30 	extr.u %d3,%d2,0,16
80019d3c:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80019d40:	7f 23 04 80 	jge.u %d3,%d2,80019d48 <pbuf_add_header_impl+0x8e>
    return 1;
80019d44:	82 12       	mov %d2,1
80019d46:	00 90       	ret 
  }

  type_internal = p->type_internal;
80019d48:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019d4c:	39 22 0c 00 	ld.bu %d2,[%a2]12
80019d50:	f9 e2 f8 ff 	st.h [%a14]-8,%d2

  /* pbuf types containing payloads? */
  if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
80019d54:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80019d58:	8f 02 08 21 	and %d2,%d2,128
80019d5c:	df 02 16 00 	jeq %d2,0,80019d88 <pbuf_add_header_impl+0xce>
    /* set new payload pointer */
    payload = (u8_t *)p->payload - header_size_increment;
80019d60:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019d64:	b0 42       	add.a %a2,4
80019d66:	54 23       	ld.w %d3,[%a2]
80019d68:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019d6c:	32 52       	rsub %d2
80019d6e:	42 32       	add %d2,%d3
80019d70:	59 e2 fc ff 	st.w [%a14]-4,%d2
    /* boundary check fails? */
    if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
80019d74:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019d78:	1b 02 01 20 	addi %d2,%d2,16
80019d7c:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80019d80:	7f 23 16 80 	jge.u %d3,%d2,80019dac <pbuf_add_header_impl+0xf2>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
                   ("pbuf_add_header: failed as %p < %p (not enough space for new header size)\n",
                    (void *)payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
      /* bail out unsuccessfully */
      return 1;
80019d84:	82 12       	mov %d2,1
80019d86:	00 90       	ret 
    }
    /* pbuf types referring to external payloads? */
  } else {
    /* hide a header in the payload? */
    if (force) {
80019d88:	39 e2 ec ff 	ld.bu %d2,[%a14]-20
80019d8c:	df 02 0e 00 	jeq %d2,0,80019da8 <pbuf_add_header_impl+0xee>
      payload = (u8_t *)p->payload - header_size_increment;
80019d90:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019d94:	b0 42       	add.a %a2,4
80019d96:	54 23       	ld.w %d3,[%a2]
80019d98:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019d9c:	32 52       	rsub %d2
80019d9e:	42 32       	add %d2,%d3
80019da0:	59 e2 fc ff 	st.w [%a14]-4,%d2
80019da4:	1d 00 04 00 	j 80019dac <pbuf_add_header_impl+0xf2>
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccessfully */
      return 1;
80019da8:	82 12       	mov %d2,1
80019daa:	00 90       	ret 
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
              (void *)p->payload, (void *)payload, increment_magnitude));

  /* modify pbuf fields */
  p->payload = payload;
80019dac:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019db0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80019db4:	b0 42       	add.a %a2,4
80019db6:	74 22       	st.w [%a2],%d2
  p->len = (u16_t)(p->len + increment_magnitude);
80019db8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019dbc:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80019dc0:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
80019dc4:	42 32       	add %d2,%d3
80019dc6:	37 02 70 20 	extr.u %d2,%d2,0,16
80019dca:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019dce:	f9 22 0a 00 	st.h [%a2]10,%d2
  p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
80019dd2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019dd6:	b9 23 08 00 	ld.hu %d3,[%a2]8
80019dda:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
80019dde:	42 32       	add %d2,%d3
80019de0:	37 02 70 20 	extr.u %d2,%d2,0,16
80019de4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019de8:	f9 22 08 00 	st.h [%a2]8,%d2


  return 0;
80019dec:	82 02       	mov %d2,0
}
80019dee:	00 90       	ret 

80019df0 <pbuf_add_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_add_header(struct pbuf *p, size_t header_size_increment)
{
80019df0:	40 ae       	mov.aa %a14,%sp
80019df2:	20 08       	sub.a %sp,8
80019df4:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80019df8:	59 e4 f8 ff 	st.w [%a14]-8,%d4
  return pbuf_add_header_impl(p, header_size_increment, 0);
80019dfc:	82 05       	mov %d5,0
80019dfe:	19 e4 f8 ff 	ld.w %d4,[%a14]-8
80019e02:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80019e06:	6d ff 5a ff 	call 80019cba <pbuf_add_header_impl>
}
80019e0a:	00 90       	ret 

80019e0c <pbuf_remove_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
{
80019e0c:	40 ae       	mov.aa %a14,%sp
80019e0e:	20 20       	sub.a %sp,32
80019e10:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80019e14:	59 e4 f0 ff 	st.w [%a14]-16,%d4
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
80019e18:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019e1c:	df 02 17 80 	jne %d2,0,80019e4a <pbuf_remove_header+0x3e>
80019e20:	91 00 00 28 	movh.a %a2,32768
80019e24:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019e28:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019e2c:	3b b0 24 20 	mov %d2,587
80019e30:	59 a2 04 00 	st.w [%sp]4,%d2
80019e34:	91 00 00 28 	movh.a %a2,32768
80019e38:	d9 22 95 c1 	lea %a2,[%a2]6933 <80001b15 <IfxCpu_Trap_vectorTable0_end+0x1921>>
80019e3c:	f4 a2       	st.a [%sp],%a2
80019e3e:	91 00 00 28 	movh.a %a2,32768
80019e42:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019e46:	6d ff 78 5a 	call 80005336 <Ifx_Lwip_printf>
  if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
80019e4a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80019e4e:	df 02 08 00 	jeq %d2,0,80019e5e <pbuf_remove_header+0x52>
80019e52:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019e56:	7b 10 00 30 	movh %d3,1
80019e5a:	3f 32 04 80 	jlt.u %d2,%d3,80019e62 <pbuf_remove_header+0x56>
    return 1;
80019e5e:	82 12       	mov %d2,1
80019e60:	00 90       	ret 
  }
  if (header_size_decrement == 0) {
80019e62:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019e66:	df 02 04 80 	jne %d2,0,80019e6e <pbuf_remove_header+0x62>
    return 0;
80019e6a:	82 02       	mov %d2,0
80019e6c:	00 90       	ret 
  }

  increment_magnitude = (u16_t)header_size_decrement;
80019e6e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019e72:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  /* Check that we aren't going to move off the end of the pbuf */
  LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
80019e76:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019e7a:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80019e7e:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80019e82:	7f 23 19 80 	jge.u %d3,%d2,80019eb4 <pbuf_remove_header+0xa8>
80019e86:	91 00 00 28 	movh.a %a2,32768
80019e8a:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019e8e:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019e92:	3b 50 25 20 	mov %d2,597
80019e96:	59 a2 04 00 	st.w [%sp]4,%d2
80019e9a:	91 00 00 28 	movh.a %a2,32768
80019e9e:	d9 22 9f c1 	lea %a2,[%a2]6943 <80001b1f <IfxCpu_Trap_vectorTable0_end+0x192b>>
80019ea2:	f4 a2       	st.a [%sp],%a2
80019ea4:	91 00 00 28 	movh.a %a2,32768
80019ea8:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019eac:	6d ff 45 5a 	call 80005336 <Ifx_Lwip_printf>
80019eb0:	82 12       	mov %d2,1
80019eb2:	00 90       	ret 

  /* remember current payload pointer */
  payload = p->payload;
80019eb4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019eb8:	b0 42       	add.a %a2,4
80019eba:	54 22       	ld.w %d2,[%a2]
80019ebc:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */

  /* increase payload pointer (guarded by length check above) */
  p->payload = (u8_t *)p->payload + header_size_decrement;
80019ec0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019ec4:	b0 42       	add.a %a2,4
80019ec6:	54 23       	ld.w %d3,[%a2]
80019ec8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80019ecc:	42 32       	add %d2,%d3
80019ece:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019ed2:	b0 42       	add.a %a2,4
80019ed4:	74 22       	st.w [%a2],%d2
  /* modify pbuf length fields */
  p->len = (u16_t)(p->len - increment_magnitude);
80019ed6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019eda:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80019ede:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80019ee2:	0b 23 80 20 	sub %d2,%d3,%d2
80019ee6:	37 02 70 20 	extr.u %d2,%d2,0,16
80019eea:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019eee:	f9 22 0a 00 	st.h [%a2]10,%d2
  p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
80019ef2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019ef6:	b9 23 08 00 	ld.hu %d3,[%a2]8
80019efa:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80019efe:	0b 23 80 20 	sub %d2,%d3,%d2
80019f02:	37 02 70 20 	extr.u %d2,%d2,0,16
80019f06:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80019f0a:	f9 22 08 00 	st.h [%a2]8,%d2

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
              (void *)payload, (void *)p->payload, increment_magnitude));

  return 0;
80019f0e:	82 02       	mov %d2,0
}
80019f10:	00 90       	ret 

80019f12 <pbuf_header_impl>:

static u8_t
pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
{
80019f12:	40 ae       	mov.aa %a14,%sp
80019f14:	20 10       	sub.a %sp,16
80019f16:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80019f1a:	02 42       	mov %d2,%d4
80019f1c:	02 53       	mov %d3,%d5
80019f1e:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
80019f22:	02 32       	mov %d2,%d3
80019f24:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
  if (header_size_increment < 0) {
80019f28:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
80019f2c:	ff 02 0b 00 	jge %d2,0,80019f42 <pbuf_header_impl+0x30>
    return pbuf_remove_header(p, (size_t) - header_size_increment);
80019f30:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
80019f34:	32 52       	rsub %d2
80019f36:	02 24       	mov %d4,%d2
80019f38:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80019f3c:	6d ff 68 ff 	call 80019e0c <pbuf_remove_header>
80019f40:	00 90       	ret 
  } else {
    return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
80019f42:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
80019f46:	39 e3 f4 ff 	ld.bu %d3,[%a14]-12
80019f4a:	02 35       	mov %d5,%d3
80019f4c:	02 24       	mov %d4,%d2
80019f4e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80019f52:	6d ff b4 fe 	call 80019cba <pbuf_add_header_impl>
  }
}
80019f56:	00 90       	ret 

80019f58 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
80019f58:	40 ae       	mov.aa %a14,%sp
80019f5a:	20 08       	sub.a %sp,8
80019f5c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80019f60:	02 42       	mov %d2,%d4
80019f62:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
  return pbuf_header_impl(p, header_size_increment, 0);
80019f66:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
80019f6a:	82 05       	mov %d5,0
80019f6c:	02 24       	mov %d4,%d2
80019f6e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80019f72:	6d ff d0 ff 	call 80019f12 <pbuf_header_impl>
}
80019f76:	00 90       	ret 

80019f78 <pbuf_header_force>:
 * Same as pbuf_header but does not check if 'header_size > 0' is allowed.
 * This is used internally only, to allow PBUF_REF for RX.
 */
u8_t
pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
{
80019f78:	40 ae       	mov.aa %a14,%sp
80019f7a:	20 08       	sub.a %sp,8
80019f7c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80019f80:	02 42       	mov %d2,%d4
80019f82:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
  return pbuf_header_impl(p, header_size_increment, 1);
80019f86:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
80019f8a:	82 15       	mov %d5,1
80019f8c:	02 24       	mov %d4,%d2
80019f8e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80019f92:	6d ff c0 ff 	call 80019f12 <pbuf_header_impl>
}
80019f96:	00 90       	ret 

80019f98 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
80019f98:	40 ae       	mov.aa %a14,%sp
80019f9a:	20 28       	sub.a %sp,40
80019f9c:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  u8_t alloc_src;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
80019fa0:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80019fa4:	df 02 1d 80 	jne %d2,0,80019fde <pbuf_free+0x46>
    LWIP_ASSERT("p != NULL", p != NULL);
80019fa8:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80019fac:	df 02 17 80 	jne %d2,0,80019fda <pbuf_free+0x42>
80019fb0:	91 00 00 28 	movh.a %a2,32768
80019fb4:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019fb8:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
80019fbc:	3b c0 2d 20 	mov %d2,732
80019fc0:	59 a2 04 00 	st.w [%sp]4,%d2
80019fc4:	91 00 00 28 	movh.a %a2,32768
80019fc8:	d9 22 95 c1 	lea %a2,[%a2]6933 <80001b15 <IfxCpu_Trap_vectorTable0_end+0x1921>>
80019fcc:	f4 a2       	st.a [%sp],%a2
80019fce:	91 00 00 28 	movh.a %a2,32768
80019fd2:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
80019fd6:	6d ff b0 59 	call 80005336 <Ifx_Lwip_printf>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                ("pbuf_free(p == NULL) was called.\n"));
    return 0;
80019fda:	82 02       	mov %d2,0
80019fdc:	00 90       	ret 
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  count = 0;
80019fde:	82 02       	mov %d2,0
80019fe0:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
80019fe4:	1d 00 b6 00 	j 8001a150 <pbuf_free+0x1b8>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
80019fe8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80019fec:	39 22 0e 00 	ld.bu %d2,[%a2]14
80019ff0:	df 02 17 80 	jne %d2,0,8001a01e <pbuf_free+0x86>
80019ff4:	91 00 00 28 	movh.a %a2,32768
80019ff8:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
80019ffc:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a000:	3b 10 2f 20 	mov %d2,753
8001a004:	59 a2 04 00 	st.w [%sp]4,%d2
8001a008:	91 00 00 28 	movh.a %a2,32768
8001a00c:	d9 22 bd c1 	lea %a2,[%a2]6973 <80001b3d <IfxCpu_Trap_vectorTable0_end+0x1949>>
8001a010:	f4 a2       	st.a [%sp],%a2
8001a012:	91 00 00 28 	movh.a %a2,32768
8001a016:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a01a:	6d ff 8e 59 	call 80005336 <Ifx_Lwip_printf>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
8001a01e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a022:	39 22 0e 00 	ld.bu %d2,[%a2]14
8001a026:	c2 f2       	add %d2,-1
8001a028:	8f f2 0f 21 	and %d2,%d2,255
8001a02c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a030:	e9 22 0e 00 	st.b [%a2]14,%d2
8001a034:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a038:	79 22 0e 00 	ld.b %d2,[%a2]14
8001a03c:	e9 e2 fe ff 	st.b [%a14]-2,%d2
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
8001a040:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
8001a044:	df 02 83 80 	jne %d2,0,8001a14a <pbuf_free+0x1b2>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
8001a048:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a04c:	54 22       	ld.w %d2,[%a2]
8001a04e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      alloc_src = pbuf_get_allocsrc(p);
8001a052:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a056:	39 22 0c 00 	ld.bu %d2,[%a2]12
8001a05a:	8f f2 00 21 	and %d2,%d2,15
8001a05e:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
8001a062:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a066:	39 22 0d 00 	ld.bu %d2,[%a2]13
8001a06a:	8f 22 00 21 	and %d2,%d2,2
8001a06e:	df 02 2d 00 	jeq %d2,0,8001a0c8 <pbuf_free+0x130>
        struct pbuf_custom *pc = (struct pbuf_custom *)p;
8001a072:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001a076:	59 e2 f0 ff 	st.w [%a14]-16,%d2
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
8001a07a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001a07e:	d9 22 10 00 	lea %a2,[%a2]16
8001a082:	54 22       	ld.w %d2,[%a2]
8001a084:	df 02 17 80 	jne %d2,0,8001a0b2 <pbuf_free+0x11a>
8001a088:	91 00 00 28 	movh.a %a2,32768
8001a08c:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a090:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a094:	3b f0 2f 20 	mov %d2,767
8001a098:	59 a2 04 00 	st.w [%sp]4,%d2
8001a09c:	91 00 00 28 	movh.a %a2,32768
8001a0a0:	d9 22 93 d1 	lea %a2,[%a2]6995 <80001b53 <IfxCpu_Trap_vectorTable0_end+0x195f>>
8001a0a4:	f4 a2       	st.a [%sp],%a2
8001a0a6:	91 00 00 28 	movh.a %a2,32768
8001a0aa:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a0ae:	6d ff 44 59 	call 80005336 <Ifx_Lwip_printf>
        pc->custom_free_function(p);
8001a0b2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001a0b6:	d9 22 10 00 	lea %a2,[%a2]16
8001a0ba:	d4 22       	ld.a %a2,[%a2]
8001a0bc:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001a0c0:	2d 02 00 00 	calli %a2
8001a0c4:	1d 00 38 00 	j 8001a134 <pbuf_free+0x19c>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
8001a0c8:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
8001a0cc:	df 22 0a 80 	jne %d2,2,8001a0e0 <pbuf_free+0x148>
          memp_free(MEMP_PBUF_POOL, p);
8001a0d0:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001a0d4:	3b 80 00 40 	mov %d4,8
8001a0d8:	6d ff ef f4 	call 80018ab6 <memp_free>
8001a0dc:	1d 00 2c 00 	j 8001a134 <pbuf_free+0x19c>
          /* is this a ROM or RAM referencing pbuf? */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
8001a0e0:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
8001a0e4:	df 12 09 80 	jne %d2,1,8001a0f6 <pbuf_free+0x15e>
          memp_free(MEMP_PBUF, p);
8001a0e8:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001a0ec:	82 74       	mov %d4,7
8001a0ee:	6d ff e4 f4 	call 80018ab6 <memp_free>
8001a0f2:	1d 00 21 00 	j 8001a134 <pbuf_free+0x19c>
          /* type == PBUF_RAM */
        } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
8001a0f6:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
8001a0fa:	df 02 08 80 	jne %d2,0,8001a10a <pbuf_free+0x172>
          mem_free(p);
8001a0fe:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001a102:	6d ff 7e ee 	call 80017dfe <mem_free>
8001a106:	1d 00 17 00 	j 8001a134 <pbuf_free+0x19c>
        } else {
          /* @todo: support freeing other types */
          LWIP_ASSERT("invalid pbuf type", 0);
8001a10a:	91 00 00 28 	movh.a %a2,32768
8001a10e:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a112:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a116:	3b f0 30 20 	mov %d2,783
8001a11a:	59 a2 04 00 	st.w [%sp]4,%d2
8001a11e:	91 00 00 28 	movh.a %a2,32768
8001a122:	d9 22 b4 d1 	lea %a2,[%a2]7028 <80001b74 <IfxCpu_Trap_vectorTable0_end+0x1980>>
8001a126:	f4 a2       	st.a [%sp],%a2
8001a128:	91 00 00 28 	movh.a %a2,32768
8001a12c:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a130:	6d ff 03 59 	call 80005336 <Ifx_Lwip_printf>
        }
      }
      count++;
8001a134:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8001a138:	c2 12       	add %d2,1
8001a13a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
      /* proceed to next pbuf */
      p = q;
8001a13e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001a142:	59 e2 ec ff 	st.w [%a14]-20,%d2
8001a146:	1d 00 05 00 	j 8001a150 <pbuf_free+0x1b8>
      /* p->ref > 0, this pbuf is still referenced to */
      /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, (u16_t)ref));
      /* stop walking through the chain */
      p = NULL;
8001a14a:	82 02       	mov %d2,0
8001a14c:	59 e2 ec ff 	st.w [%a14]-20,%d2
  while (p != NULL) {
8001a150:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001a154:	df 02 4a ff 	jne %d2,0,80019fe8 <pbuf_free+0x50>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
8001a158:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
}
8001a15c:	00 90       	ret 

8001a15e <pbuf_clen>:
 * @param p first pbuf of chain
 * @return the number of pbufs in a chain
 */
u16_t
pbuf_clen(const struct pbuf *p)
{
8001a15e:	40 ae       	mov.aa %a14,%sp
8001a160:	20 10       	sub.a %sp,16
8001a162:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  u16_t len;

  len = 0;
8001a166:	82 02       	mov %d2,0
8001a168:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  while (p != NULL) {
8001a16c:	1d 00 0c 00 	j 8001a184 <pbuf_clen+0x26>
    ++len;
8001a170:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001a174:	c2 12       	add %d2,1
8001a176:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    p = p->next;
8001a17a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001a17e:	54 22       	ld.w %d2,[%a2]
8001a180:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  while (p != NULL) {
8001a184:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001a188:	df 02 f4 ff 	jne %d2,0,8001a170 <pbuf_clen+0x12>
  }
  return len;
8001a18c:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
}
8001a190:	00 90       	ret 

8001a192 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
8001a192:	40 ae       	mov.aa %a14,%sp
8001a194:	20 18       	sub.a %sp,24
8001a196:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  /* pbuf given? */
  if (p != NULL) {
8001a19a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a19e:	df 02 28 00 	jeq %d2,0,8001a1ee <pbuf_ref+0x5c>
    SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
8001a1a2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a1a6:	39 22 0e 00 	ld.bu %d2,[%a2]14
8001a1aa:	c2 12       	add %d2,1
8001a1ac:	8f f2 0f 21 	and %d2,%d2,255
8001a1b0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a1b4:	e9 22 0e 00 	st.b [%a2]14,%d2
    LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
8001a1b8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a1bc:	39 22 0e 00 	ld.bu %d2,[%a2]14
8001a1c0:	df 02 17 80 	jne %d2,0,8001a1ee <pbuf_ref+0x5c>
8001a1c4:	91 00 00 28 	movh.a %a2,32768
8001a1c8:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a1cc:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a1d0:	3b 20 34 20 	mov %d2,834
8001a1d4:	59 a2 04 00 	st.w [%sp]4,%d2
8001a1d8:	91 00 00 28 	movh.a %a2,32768
8001a1dc:	d9 22 86 e1 	lea %a2,[%a2]7046 <80001b86 <IfxCpu_Trap_vectorTable0_end+0x1992>>
8001a1e0:	f4 a2       	st.a [%sp],%a2
8001a1e2:	91 00 00 28 	movh.a %a2,32768
8001a1e6:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a1ea:	6d ff a6 58 	call 80005336 <Ifx_Lwip_printf>
  }
}
8001a1ee:	00 00       	nop 
8001a1f0:	00 90       	ret 

8001a1f2 <pbuf_cat>:
 *
 * @see pbuf_chain()
 */
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
8001a1f2:	40 ae       	mov.aa %a14,%sp
8001a1f4:	20 20       	sub.a %sp,32
8001a1f6:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001a1fa:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
8001a1fe:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001a202:	df 02 06 00 	jeq %d2,0,8001a20e <pbuf_cat+0x1c>
8001a206:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001a20a:	df 02 18 80 	jne %d2,0,8001a23a <pbuf_cat+0x48>
8001a20e:	91 00 00 28 	movh.a %a2,32768
8001a212:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a216:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a21a:	3b 90 35 20 	mov %d2,857
8001a21e:	59 a2 04 00 	st.w [%sp]4,%d2
8001a222:	91 00 00 28 	movh.a %a2,32768
8001a226:	d9 22 98 e1 	lea %a2,[%a2]7064 <80001b98 <IfxCpu_Trap_vectorTable0_end+0x19a4>>
8001a22a:	f4 a2       	st.a [%sp],%a2
8001a22c:	91 00 00 28 	movh.a %a2,32768
8001a230:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a234:	6d ff 81 58 	call 80005336 <Ifx_Lwip_printf>
8001a238:	00 90       	ret 
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
8001a23a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001a23e:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001a242:	1d 00 16 00 	j 8001a26e <pbuf_cat+0x7c>
    /* add total length of second chain to all totals of first chain */
    p->tot_len = (u16_t)(p->tot_len + t->tot_len);
8001a246:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a24a:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001a24e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001a252:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001a256:	42 32       	add %d2,%d3
8001a258:	37 02 70 20 	extr.u %d2,%d2,0,16
8001a25c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a260:	f9 22 08 00 	st.h [%a2]8,%d2
  for (p = h; p->next != NULL; p = p->next) {
8001a264:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a268:	54 22       	ld.w %d2,[%a2]
8001a26a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001a26e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a272:	54 22       	ld.w %d2,[%a2]
8001a274:	df 02 e9 ff 	jne %d2,0,8001a246 <pbuf_cat+0x54>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
8001a278:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a27c:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001a280:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a284:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a288:	5f 23 17 00 	jeq %d3,%d2,8001a2b6 <pbuf_cat+0xc4>
8001a28c:	91 00 00 28 	movh.a %a2,32768
8001a290:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a294:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a298:	3b 20 36 20 	mov %d2,866
8001a29c:	59 a2 04 00 	st.w [%sp]4,%d2
8001a2a0:	91 00 00 28 	movh.a %a2,32768
8001a2a4:	d9 22 8d f1 	lea %a2,[%a2]7117 <80001bcd <IfxCpu_Trap_vectorTable0_end+0x19d9>>
8001a2a8:	f4 a2       	st.a [%sp],%a2
8001a2aa:	91 00 00 28 	movh.a %a2,32768
8001a2ae:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a2b2:	6d ff 42 58 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
8001a2b6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a2ba:	54 22       	ld.w %d2,[%a2]
8001a2bc:	df 02 17 00 	jeq %d2,0,8001a2ea <pbuf_cat+0xf8>
8001a2c0:	91 00 00 28 	movh.a %a2,32768
8001a2c4:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a2c8:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a2cc:	3b 30 36 20 	mov %d2,867
8001a2d0:	59 a2 04 00 	st.w [%sp]4,%d2
8001a2d4:	91 00 00 28 	movh.a %a2,32768
8001a2d8:	d9 22 ba f1 	lea %a2,[%a2]7162 <80001bfa <IfxCpu_Trap_vectorTable0_end+0x1a06>>
8001a2dc:	f4 a2       	st.a [%sp],%a2
8001a2de:	91 00 00 28 	movh.a %a2,32768
8001a2e2:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a2e6:	6d ff 28 58 	call 80005336 <Ifx_Lwip_printf>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len = (u16_t)(p->tot_len + t->tot_len);
8001a2ea:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a2ee:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001a2f2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001a2f6:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001a2fa:	42 32       	add %d2,%d3
8001a2fc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001a300:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a304:	f9 22 08 00 	st.h [%a2]8,%d2
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
8001a308:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a30c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001a310:	74 22       	st.w [%a2],%d2
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
8001a312:	00 90       	ret 

8001a314 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
8001a314:	40 ae       	mov.aa %a14,%sp
8001a316:	20 08       	sub.a %sp,8
8001a318:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001a31c:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  pbuf_cat(h, t);
8001a320:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
8001a324:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001a328:	6d ff 65 ff 	call 8001a1f2 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
8001a32c:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001a330:	6d ff 31 ff 	call 8001a192 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
8001a334:	00 00       	nop 
8001a336:	00 90       	ret 

8001a338 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
{
8001a338:	40 ae       	mov.aa %a14,%sp
8001a33a:	20 28       	sub.a %sp,40
8001a33c:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8001a340:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
  size_t offset_to = 0, offset_from = 0, len;
8001a344:	82 02       	mov %d2,0
8001a346:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001a34a:	82 02       	mov %d2,0
8001a34c:	59 e2 f8 ff 	st.w [%a14]-8,%d2

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
              (const void *)p_to, (const void *)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
8001a350:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001a354:	df 02 10 00 	jeq %d2,0,8001a374 <pbuf_copy+0x3c>
8001a358:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001a35c:	df 02 0c 00 	jeq %d2,0,8001a374 <pbuf_copy+0x3c>
8001a360:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a364:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001a368:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a36c:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001a370:	7f 23 1a 80 	jge.u %d3,%d2,8001a3a4 <pbuf_copy+0x6c>
8001a374:	91 00 00 28 	movh.a %a2,32768
8001a378:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a37c:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a380:	3b 90 3c 20 	mov %d2,969
8001a384:	59 a2 04 00 	st.w [%sp]4,%d2
8001a388:	91 00 00 28 	movh.a %a2,32768
8001a38c:	d9 22 c1 11 	lea %a2,[%a2]7233 <80001c41 <IfxCpu_Trap_vectorTable0_end+0x1a4d>>
8001a390:	f4 a2       	st.a [%sp],%a2
8001a392:	91 00 00 28 	movh.a %a2,32768
8001a396:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a39a:	6d ff ce 57 	call 80005336 <Ifx_Lwip_printf>
8001a39e:	3b 00 ff 2f 	mov %d2,-16
8001a3a2:	00 90       	ret 
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
8001a3a4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a3a8:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a3ac:	02 23       	mov %d3,%d2
8001a3ae:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a3b2:	a2 23       	sub %d3,%d2
8001a3b4:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a3b8:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a3bc:	02 24       	mov %d4,%d2
8001a3be:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001a3c2:	0b 24 80 20 	sub %d2,%d4,%d2
8001a3c6:	3f 23 0f 80 	jlt.u %d3,%d2,8001a3e4 <pbuf_copy+0xac>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
8001a3ca:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a3ce:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a3d2:	02 23       	mov %d3,%d2
8001a3d4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001a3d8:	0b 23 80 20 	sub %d2,%d3,%d2
8001a3dc:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8001a3e0:	1d 00 0d 00 	j 8001a3fa <pbuf_copy+0xc2>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
8001a3e4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a3e8:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a3ec:	02 23       	mov %d3,%d2
8001a3ee:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a3f2:	0b 23 80 20 	sub %d2,%d3,%d2
8001a3f6:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    }
    MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
8001a3fa:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a3fe:	b0 42       	add.a %a2,4
8001a400:	54 23       	ld.w %d3,[%a2]
8001a402:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a406:	42 32       	add %d2,%d3
8001a408:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a40c:	b0 42       	add.a %a2,4
8001a40e:	54 24       	ld.w %d4,[%a2]
8001a410:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8001a414:	42 43       	add %d3,%d4
8001a416:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
8001a41a:	60 35       	mov.a %a5,%d3
8001a41c:	60 24       	mov.a %a4,%d2
8001a41e:	6d 00 ff 66 	call 8002721c <memcpy>
    offset_to += len;
8001a422:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8001a426:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001a42a:	42 32       	add %d2,%d3
8001a42c:	59 e2 fc ff 	st.w [%a14]-4,%d2
    offset_from += len;
8001a430:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8001a434:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001a438:	42 32       	add %d2,%d3
8001a43a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
8001a43e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a442:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a446:	02 23       	mov %d3,%d2
8001a448:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a44c:	7f 23 17 80 	jge.u %d3,%d2,8001a47a <pbuf_copy+0x142>
8001a450:	91 00 00 28 	movh.a %a2,32768
8001a454:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a458:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a45c:	3b 90 3d 20 	mov %d2,985
8001a460:	59 a2 04 00 	st.w [%sp]4,%d2
8001a464:	91 00 00 28 	movh.a %a2,32768
8001a468:	d9 22 f1 11 	lea %a2,[%a2]7281 <80001c71 <IfxCpu_Trap_vectorTable0_end+0x1a7d>>
8001a46c:	f4 a2       	st.a [%sp],%a2
8001a46e:	91 00 00 28 	movh.a %a2,32768
8001a472:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a476:	6d ff 60 57 	call 80005336 <Ifx_Lwip_printf>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
8001a47a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a47e:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a482:	02 23       	mov %d3,%d2
8001a484:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001a488:	7f 23 17 80 	jge.u %d3,%d2,8001a4b6 <pbuf_copy+0x17e>
8001a48c:	91 00 00 28 	movh.a %a2,32768
8001a490:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a494:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a498:	3b a0 3d 20 	mov %d2,986
8001a49c:	59 a2 04 00 	st.w [%sp]4,%d2
8001a4a0:	91 00 00 28 	movh.a %a2,32768
8001a4a4:	d9 22 c8 21 	lea %a2,[%a2]7304 <80001c88 <IfxCpu_Trap_vectorTable0_end+0x1a94>>
8001a4a8:	f4 a2       	st.a [%sp],%a2
8001a4aa:	91 00 00 28 	movh.a %a2,32768
8001a4ae:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a4b2:	6d ff 42 57 	call 80005336 <Ifx_Lwip_printf>
    if (offset_from >= p_from->len) {
8001a4b6:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a4ba:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a4be:	02 23       	mov %d3,%d2
8001a4c0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001a4c4:	3f 32 0a 80 	jlt.u %d2,%d3,8001a4d8 <pbuf_copy+0x1a0>
      /* on to next p_from (if any) */
      offset_from = 0;
8001a4c8:	82 02       	mov %d2,0
8001a4ca:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      p_from = p_from->next;
8001a4ce:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a4d2:	54 22       	ld.w %d2,[%a2]
8001a4d4:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    }
    if (offset_to == p_to->len) {
8001a4d8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a4dc:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a4e0:	02 23       	mov %d3,%d2
8001a4e2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a4e6:	5f 32 2a 80 	jne %d2,%d3,8001a53a <pbuf_copy+0x202>
      /* on to next p_to (if any) */
      offset_to = 0;
8001a4ea:	82 02       	mov %d2,0
8001a4ec:	59 e2 fc ff 	st.w [%a14]-4,%d2
      p_to = p_to->next;
8001a4f0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a4f4:	54 22       	ld.w %d2,[%a2]
8001a4f6:	59 e2 ec ff 	st.w [%a14]-20,%d2
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
8001a4fa:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001a4fe:	df 02 1e 80 	jne %d2,0,8001a53a <pbuf_copy+0x202>
8001a502:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001a506:	df 02 1a 00 	jeq %d2,0,8001a53a <pbuf_copy+0x202>
8001a50a:	91 00 00 28 	movh.a %a2,32768
8001a50e:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a512:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a516:	3b 40 3e 20 	mov %d2,996
8001a51a:	59 a2 04 00 	st.w [%sp]4,%d2
8001a51e:	91 00 00 28 	movh.a %a2,32768
8001a522:	d9 22 e3 21 	lea %a2,[%a2]7331 <80001ca3 <IfxCpu_Trap_vectorTable0_end+0x1aaf>>
8001a526:	f4 a2       	st.a [%sp],%a2
8001a528:	91 00 00 28 	movh.a %a2,32768
8001a52c:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a530:	6d ff 03 57 	call 80005336 <Ifx_Lwip_printf>
8001a534:	3b 00 ff 2f 	mov %d2,-16
8001a538:	00 90       	ret 
    }

    if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
8001a53a:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001a53e:	df 02 28 00 	jeq %d2,0,8001a58e <pbuf_copy+0x256>
8001a542:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a546:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8001a54a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a54e:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001a552:	5f 23 1e 80 	jne %d3,%d2,8001a58e <pbuf_copy+0x256>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
8001a556:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001a55a:	54 22       	ld.w %d2,[%a2]
8001a55c:	df 02 19 00 	jeq %d2,0,8001a58e <pbuf_copy+0x256>
8001a560:	91 00 00 28 	movh.a %a2,32768
8001a564:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a568:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a56c:	3b 90 3e 20 	mov %d2,1001
8001a570:	59 a2 04 00 	st.w [%sp]4,%d2
8001a574:	91 00 00 28 	movh.a %a2,32768
8001a578:	d9 22 f0 21 	lea %a2,[%a2]7344 <80001cb0 <IfxCpu_Trap_vectorTable0_end+0x1abc>>
8001a57c:	f4 a2       	st.a [%sp],%a2
8001a57e:	91 00 00 28 	movh.a %a2,32768
8001a582:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a586:	6d ff d8 56 	call 80005336 <Ifx_Lwip_printf>
8001a58a:	82 a2       	mov %d2,-6
8001a58c:	00 90       	ret 
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
8001a58e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001a592:	df 02 28 00 	jeq %d2,0,8001a5e2 <pbuf_copy+0x2aa>
8001a596:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a59a:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8001a59e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a5a2:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001a5a6:	5f 23 1e 80 	jne %d3,%d2,8001a5e2 <pbuf_copy+0x2aa>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!",
8001a5aa:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a5ae:	54 22       	ld.w %d2,[%a2]
8001a5b0:	df 02 19 00 	jeq %d2,0,8001a5e2 <pbuf_copy+0x2aa>
8001a5b4:	91 00 00 28 	movh.a %a2,32768
8001a5b8:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a5bc:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a5c0:	3b e0 3e 20 	mov %d2,1006
8001a5c4:	59 a2 04 00 	st.w [%sp]4,%d2
8001a5c8:	91 00 00 28 	movh.a %a2,32768
8001a5cc:	d9 22 f0 21 	lea %a2,[%a2]7344 <80001cb0 <IfxCpu_Trap_vectorTable0_end+0x1abc>>
8001a5d0:	f4 a2       	st.a [%sp],%a2
8001a5d2:	91 00 00 28 	movh.a %a2,32768
8001a5d6:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a5da:	6d ff ae 56 	call 80005336 <Ifx_Lwip_printf>
8001a5de:	82 a2       	mov %d2,-6
8001a5e0:	00 90       	ret 
                 (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
8001a5e2:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001a5e6:	df 02 df fe 	jne %d2,0,8001a3a4 <pbuf_copy+0x6c>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
8001a5ea:	82 02       	mov %d2,0
}
8001a5ec:	00 90       	ret 

8001a5ee <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
8001a5ee:	40 ae       	mov.aa %a14,%sp
8001a5f0:	20 30       	sub.a %sp,48
8001a5f2:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8001a5f6:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
8001a5fa:	02 42       	mov %d2,%d4
8001a5fc:	02 53       	mov %d3,%d5
8001a5fe:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
8001a602:	02 32       	mov %d2,%d3
8001a604:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
  const struct pbuf *p;
  u16_t left = 0;
8001a608:	82 02       	mov %d2,0
8001a60a:	f9 e2 fa ff 	st.h [%a14]-6,%d2
  u16_t buf_copy_len;
  u16_t copied_total = 0;
8001a60e:	82 02       	mov %d2,0
8001a610:	f9 e2 f6 ff 	st.h [%a14]-10,%d2

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
8001a614:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001a618:	df 02 19 80 	jne %d2,0,8001a64a <pbuf_copy_partial+0x5c>
8001a61c:	91 00 00 28 	movh.a %a2,32768
8001a620:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a624:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a628:	3b a0 40 20 	mov %d2,1034
8001a62c:	59 a2 04 00 	st.w [%sp]4,%d2
8001a630:	91 00 00 28 	movh.a %a2,32768
8001a634:	d9 22 da 31 	lea %a2,[%a2]7386 <80001cda <IfxCpu_Trap_vectorTable0_end+0x1ae6>>
8001a638:	f4 a2       	st.a [%sp],%a2
8001a63a:	91 00 00 28 	movh.a %a2,32768
8001a63e:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a642:	6d ff 7a 56 	call 80005336 <Ifx_Lwip_printf>
8001a646:	82 02       	mov %d2,0
8001a648:	00 90       	ret 
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
8001a64a:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001a64e:	df 02 19 80 	jne %d2,0,8001a680 <pbuf_copy_partial+0x92>
8001a652:	91 00 00 28 	movh.a %a2,32768
8001a656:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a65a:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a65e:	3b b0 40 20 	mov %d2,1035
8001a662:	59 a2 04 00 	st.w [%sp]4,%d2
8001a666:	91 00 00 28 	movh.a %a2,32768
8001a66a:	d9 22 f9 31 	lea %a2,[%a2]7417 <80001cf9 <IfxCpu_Trap_vectorTable0_end+0x1b05>>
8001a66e:	f4 a2       	st.a [%sp],%a2
8001a670:	91 00 00 28 	movh.a %a2,32768
8001a674:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a678:	6d ff 5f 56 	call 80005336 <Ifx_Lwip_printf>
8001a67c:	82 02       	mov %d2,0
8001a67e:	00 90       	ret 

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for (p = buf; len != 0 && p != NULL; p = p->next) {
8001a680:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001a684:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001a688:	1d 00 60 00 	j 8001a748 <pbuf_copy_partial+0x15a>
    if ((offset != 0) && (offset >= p->len)) {
8001a68c:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
8001a690:	df 02 16 00 	jeq %d2,0,8001a6bc <pbuf_copy_partial+0xce>
8001a694:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a698:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a69c:	b9 e3 e0 ff 	ld.hu %d3,[%a14]-32
8001a6a0:	3f 23 0e 80 	jlt.u %d3,%d2,8001a6bc <pbuf_copy_partial+0xce>
      /* don't copy from this buffer -> on to the next */
      offset = (u16_t)(offset - p->len);
8001a6a4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a6a8:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001a6ac:	c9 e3 e0 ff 	ld.h %d3,[%a14]-32
8001a6b0:	0b 23 80 20 	sub %d2,%d3,%d2
8001a6b4:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
8001a6b8:	1d 00 43 00 	j 8001a73e <pbuf_copy_partial+0x150>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = (u16_t)(p->len - offset);
8001a6bc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a6c0:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8001a6c4:	c9 e2 e0 ff 	ld.h %d2,[%a14]-32
8001a6c8:	0b 23 80 20 	sub %d2,%d3,%d2
8001a6cc:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
      if (buf_copy_len > len) {
8001a6d0:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
8001a6d4:	b9 e3 e4 ff 	ld.hu %d3,[%a14]-28
8001a6d8:	7f 23 06 80 	jge.u %d3,%d2,8001a6e4 <pbuf_copy_partial+0xf6>
        buf_copy_len = len;
8001a6dc:	c9 e2 e4 ff 	ld.h %d2,[%a14]-28
8001a6e0:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
      }
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
8001a6e4:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8001a6e8:	19 e3 e8 ff 	ld.w %d3,[%a14]-24
8001a6ec:	42 23       	add %d3,%d2
8001a6ee:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a6f2:	b0 42       	add.a %a2,4
8001a6f4:	54 24       	ld.w %d4,[%a2]
8001a6f6:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
8001a6fa:	0b 24 00 50 	add %d5,%d4,%d2
8001a6fe:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
8001a702:	02 24       	mov %d4,%d2
8001a704:	60 55       	mov.a %a5,%d5
8001a706:	60 34       	mov.a %a4,%d3
8001a708:	6d 00 8a 65 	call 8002721c <memcpy>
      copied_total = (u16_t)(copied_total + buf_copy_len);
8001a70c:	c9 e3 f6 ff 	ld.h %d3,[%a14]-10
8001a710:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
8001a714:	42 32       	add %d2,%d3
8001a716:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
      left = (u16_t)(left + buf_copy_len);
8001a71a:	c9 e3 fa ff 	ld.h %d3,[%a14]-6
8001a71e:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
8001a722:	42 32       	add %d2,%d3
8001a724:	f9 e2 fa ff 	st.h [%a14]-6,%d2
      len = (u16_t)(len - buf_copy_len);
8001a728:	c9 e3 e4 ff 	ld.h %d3,[%a14]-28
8001a72c:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
8001a730:	0b 23 80 20 	sub %d2,%d3,%d2
8001a734:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
      offset = 0;
8001a738:	82 02       	mov %d2,0
8001a73a:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
  for (p = buf; len != 0 && p != NULL; p = p->next) {
8001a73e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a742:	54 22       	ld.w %d2,[%a2]
8001a744:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001a748:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
8001a74c:	df 02 06 00 	jeq %d2,0,8001a758 <pbuf_copy_partial+0x16a>
8001a750:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a754:	df 02 9c ff 	jne %d2,0,8001a68c <pbuf_copy_partial+0x9e>
    }
  }
  return copied_total;
8001a758:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10
}
8001a75c:	00 90       	ret 

8001a75e <pbuf_clone>:
 *
 * @return a new pbuf or NULL if allocation fails
 */
struct pbuf *
pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
{
8001a75e:	40 ae       	mov.aa %a14,%sp
8001a760:	20 28       	sub.a %sp,40
8001a762:	59 e4 f4 ff 	st.w [%a14]-12,%d4
8001a766:	59 e5 f0 ff 	st.w [%a14]-16,%d5
8001a76a:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  struct pbuf *q;
  err_t err;
  q = pbuf_alloc(layer, p->tot_len, type);
8001a76e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001a772:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001a776:	19 e6 f0 ff 	ld.w %d6,[%a14]-16
8001a77a:	02 25       	mov %d5,%d2
8001a77c:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
8001a780:	6d ff b0 f7 	call 800196e0 <pbuf_alloc>
8001a784:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (q == NULL) {
8001a788:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a78c:	df 02 05 80 	jne %d2,0,8001a796 <pbuf_clone+0x38>
    return NULL;
8001a790:	82 02       	mov %d2,0
8001a792:	1d 00 25 00 	j 8001a7dc <pbuf_clone+0x7e>
  }
  err = pbuf_copy(q, p);
8001a796:	99 e5 ec ff 	ld.a %a5,[%a14]-20
8001a79a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001a79e:	6d ff cd fd 	call 8001a338 <pbuf_copy>
8001a7a2:	e9 e2 fb ff 	st.b [%a14]-5,%d2
  LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
8001a7a6:	79 e2 fb ff 	ld.b %d2,[%a14]-5
8001a7aa:	df 02 17 00 	jeq %d2,0,8001a7d8 <pbuf_clone+0x7a>
8001a7ae:	91 00 00 28 	movh.a %a2,32768
8001a7b2:	d9 22 a5 71 	lea %a2,[%a2]6629 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>
8001a7b6:	b5 a2 08 00 	st.a [%sp]8 <800019e5 <IfxCpu_Trap_vectorTable0_end+0x17f1>>,%a2
8001a7ba:	3b 40 52 20 	mov %d2,1316
8001a7be:	59 a2 04 00 	st.w [%sp]4,%d2
8001a7c2:	91 00 00 28 	movh.a %a2,32768
8001a7c6:	d9 22 f9 71 	lea %a2,[%a2]7673 <80001df9 <IfxCpu_Trap_vectorTable0_end+0x1c05>>
8001a7ca:	f4 a2       	st.a [%sp],%a2
8001a7cc:	91 00 00 28 	movh.a %a2,32768
8001a7d0:	d9 24 bd 61 	lea %a4,[%a2]6589 <800019bd <IfxCpu_Trap_vectorTable0_end+0x17c9>>
8001a7d4:	6d ff b1 55 	call 80005336 <Ifx_Lwip_printf>
  return q;
8001a7d8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8001a7dc:	60 22       	mov.a %a2,%d2
8001a7de:	00 90       	ret 

8001a7e0 <stats_init>:

struct stats_ lwip_stats;

void
stats_init(void)
{
8001a7e0:	40 ae       	mov.aa %a14,%sp
#ifdef LWIP_DEBUG
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
8001a7e2:	91 10 00 27 	movh.a %a2,28673
8001a7e6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001a7ea:	91 00 00 38 	movh.a %a3,32768
8001a7ee:	d9 33 ca 81 	lea %a3,[%a3]7690 <80001e0a <IfxCpu_Trap_vectorTable0_end+0x1c16>>
8001a7f2:	d9 22 28 20 	lea %a2,[%a2]168 <700100a8 <ram_heap+0x5014>>
8001a7f6:	f4 23       	st.a [%a2],%a3
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
8001a7f8:	00 00       	nop 
8001a7fa:	00 90       	ret 

8001a7fc <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
8001a7fc:	40 ae       	mov.aa %a14,%sp
#ifdef LWIP_RAND
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RAND */
}
8001a7fe:	00 00       	nop 
8001a800:	00 90       	ret 

8001a802 <tcp_free>:

/** Free a tcp pcb */
void
tcp_free(struct tcp_pcb *pcb)
{
8001a802:	40 ae       	mov.aa %a14,%sp
8001a804:	20 18       	sub.a %sp,24
8001a806:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
8001a80a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a80e:	d9 22 14 00 	lea %a2,[%a2]20
8001a812:	54 22       	ld.w %d2,[%a2]
8001a814:	df 12 17 80 	jne %d2,1,8001a842 <tcp_free+0x40>
8001a818:	91 00 00 28 	movh.a %a2,32768
8001a81c:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001a820:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001a824:	3b 40 0d 20 	mov %d2,212
8001a828:	59 a2 04 00 	st.w [%sp]4,%d2
8001a82c:	91 00 00 28 	movh.a %a2,32768
8001a830:	d9 22 c8 b1 	lea %a2,[%a2]7880 <80001ec8 <IfxCpu_Trap_vectorTable0_end+0x1cd4>>
8001a834:	f4 a2       	st.a [%sp],%a2
8001a836:	91 00 00 28 	movh.a %a2,32768
8001a83a:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001a83e:	6d ff 7c 55 	call 80005336 <Ifx_Lwip_printf>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB, pcb);
8001a842:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001a846:	82 14       	mov %d4,1
8001a848:	6d ff 37 f1 	call 80018ab6 <memp_free>
}
8001a84c:	00 00       	nop 
8001a84e:	00 90       	ret 

8001a850 <tcp_free_listen>:

/** Free a tcp listen pcb */
static void
tcp_free_listen(struct tcp_pcb *pcb)
{
8001a850:	40 ae       	mov.aa %a14,%sp
8001a852:	20 18       	sub.a %sp,24
8001a854:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
8001a858:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a85c:	d9 22 14 00 	lea %a2,[%a2]20
8001a860:	54 22       	ld.w %d2,[%a2]
8001a862:	df 12 17 80 	jne %d2,1,8001a890 <tcp_free_listen+0x40>
8001a866:	91 00 00 28 	movh.a %a2,32768
8001a86a:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001a86e:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001a872:	3b f0 0d 20 	mov %d2,223
8001a876:	59 a2 04 00 	st.w [%sp]4,%d2
8001a87a:	91 00 00 28 	movh.a %a2,32768
8001a87e:	d9 22 d9 b1 	lea %a2,[%a2]7897 <80001ed9 <IfxCpu_Trap_vectorTable0_end+0x1ce5>>
8001a882:	f4 a2       	st.a [%sp],%a2
8001a884:	91 00 00 28 	movh.a %a2,32768
8001a888:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001a88c:	6d ff 55 55 	call 80005336 <Ifx_Lwip_printf>
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
#endif
  memp_free(MEMP_TCP_PCB_LISTEN, pcb);
8001a890:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001a894:	82 24       	mov %d4,2
8001a896:	6d ff 10 f1 	call 80018ab6 <memp_free>
}
8001a89a:	00 00       	nop 
8001a89c:	00 90       	ret 

8001a89e <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
8001a89e:	40 ae       	mov.aa %a14,%sp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
8001a8a0:	6d 00 19 0d 	call 8001c2d2 <tcp_fasttmr>

  if (++tcp_timer & 1) {
8001a8a4:	91 10 00 27 	movh.a %a2,28673
8001a8a8:	d9 22 45 74 	lea %a2,[%a2]17861 <700145c5 <tcp_timer>>
8001a8ac:	14 22       	ld.bu %d2,[%a2]
8001a8ae:	c2 12       	add %d2,1
8001a8b0:	8f f2 0f 21 	and %d2,%d2,255
8001a8b4:	91 10 00 27 	movh.a %a2,28673
8001a8b8:	d9 22 45 74 	lea %a2,[%a2]17861 <700145c5 <tcp_timer>>
8001a8bc:	34 22       	st.b [%a2],%d2
8001a8be:	91 10 00 27 	movh.a %a2,28673
8001a8c2:	d9 22 45 74 	lea %a2,[%a2]17861 <700145c5 <tcp_timer>>
8001a8c6:	14 22       	ld.bu %d2,[%a2]
8001a8c8:	8f 12 00 21 	and %d2,%d2,1
8001a8cc:	df 02 04 00 	jeq %d2,0,8001a8d4 <tcp_tmr+0x36>
    /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
8001a8d0:	6d 00 ed 07 	call 8001b8aa <tcp_slowtmr>
  }
}
8001a8d4:	00 00       	nop 
8001a8d6:	00 90       	ret 

8001a8d8 <tcp_remove_listener>:
/** Called when a listen pcb is closed. Iterates one pcb list and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
{
8001a8d8:	40 ae       	mov.aa %a14,%sp
8001a8da:	20 20       	sub.a %sp,32
8001a8dc:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001a8e0:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct tcp_pcb *pcb;

  LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);
8001a8e4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001a8e8:	df 02 17 80 	jne %d2,0,8001a916 <tcp_remove_listener+0x3e>
8001a8ec:	91 00 00 28 	movh.a %a2,32768
8001a8f0:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001a8f4:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001a8f8:	3b f0 0f 20 	mov %d2,255
8001a8fc:	59 a2 04 00 	st.w [%sp]4,%d2
8001a900:	91 00 00 28 	movh.a %a2,32768
8001a904:	d9 22 f2 b1 	lea %a2,[%a2]7922 <80001ef2 <IfxCpu_Trap_vectorTable0_end+0x1cfe>>
8001a908:	f4 a2       	st.a [%sp],%a2
8001a90a:	91 00 00 28 	movh.a %a2,32768
8001a90e:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001a912:	6d ff 12 55 	call 80005336 <Ifx_Lwip_printf>

  for (pcb = list; pcb != NULL; pcb = pcb->next) {
8001a916:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001a91a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001a91e:	1d 00 18 00 	j 8001a94e <tcp_remove_listener+0x76>
    if (pcb->listener == lpcb) {
8001a922:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a926:	d9 22 00 20 	lea %a2,[%a2]128
8001a92a:	54 22       	ld.w %d2,[%a2]
8001a92c:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8001a930:	5f 23 08 80 	jne %d3,%d2,8001a940 <tcp_remove_listener+0x68>
      pcb->listener = NULL;
8001a934:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a938:	82 02       	mov %d2,0
8001a93a:	d9 22 00 20 	lea %a2,[%a2]128
8001a93e:	74 22       	st.w [%a2],%d2
  for (pcb = list; pcb != NULL; pcb = pcb->next) {
8001a940:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001a944:	d9 22 0c 00 	lea %a2,[%a2]12
8001a948:	54 22       	ld.w %d2,[%a2]
8001a94a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001a94e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a952:	df 02 e8 ff 	jne %d2,0,8001a922 <tcp_remove_listener+0x4a>
    }
  }
}
8001a956:	00 00       	nop 
8001a958:	00 00       	nop 
8001a95a:	00 90       	ret 

8001a95c <tcp_listen_closed>:
/** Called when a listen pcb is closed. Iterates all pcb lists and removes the
 * closed listener pcb from pcb->listener if matching.
 */
static void
tcp_listen_closed(struct tcp_pcb *pcb)
{
8001a95c:	40 ae       	mov.aa %a14,%sp
8001a95e:	20 20       	sub.a %sp,32
8001a960:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
  size_t i;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
8001a964:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001a968:	df 02 17 80 	jne %d2,0,8001a996 <tcp_listen_closed+0x3a>
8001a96c:	91 00 00 28 	movh.a %a2,32768
8001a970:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001a974:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001a978:	3b 10 11 20 	mov %d2,273
8001a97c:	59 a2 04 00 	st.w [%sp]4,%d2
8001a980:	91 00 00 28 	movh.a %a2,32768
8001a984:	d9 22 d8 c1 	lea %a2,[%a2]7960 <80001f18 <IfxCpu_Trap_vectorTable0_end+0x1d24>>
8001a988:	f4 a2       	st.a [%sp],%a2
8001a98a:	91 00 00 28 	movh.a %a2,32768
8001a98e:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001a992:	6d ff d2 54 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
8001a996:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001a99a:	d9 22 14 00 	lea %a2,[%a2]20
8001a99e:	54 22       	ld.w %d2,[%a2]
8001a9a0:	df 12 17 00 	jeq %d2,1,8001a9ce <tcp_listen_closed+0x72>
8001a9a4:	91 00 00 28 	movh.a %a2,32768
8001a9a8:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001a9ac:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001a9b0:	3b 20 11 20 	mov %d2,274
8001a9b4:	59 a2 04 00 	st.w [%sp]4,%d2
8001a9b8:	91 00 00 28 	movh.a %a2,32768
8001a9bc:	d9 22 e4 c1 	lea %a2,[%a2]7972 <80001f24 <IfxCpu_Trap_vectorTable0_end+0x1d30>>
8001a9c0:	f4 a2       	st.a [%sp],%a2
8001a9c2:	91 00 00 28 	movh.a %a2,32768
8001a9c6:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001a9ca:	6d ff b6 54 	call 80005336 <Ifx_Lwip_printf>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
8001a9ce:	82 12       	mov %d2,1
8001a9d0:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001a9d4:	1d 00 17 00 	j 8001aa02 <tcp_listen_closed+0xa6>
    tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
8001a9d8:	91 00 00 28 	movh.a %a2,32768
8001a9dc:	d9 22 50 84 	lea %a2,[%a2]17936 <80004610 <tcp_pcb_lists>>
8001a9e0:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <80004610 <tcp_pcb_lists>>
8001a9e4:	06 22       	sh %d2,2
8001a9e6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8001a9ea:	d4 22       	ld.a %a2,[%a2]
8001a9ec:	54 22       	ld.w %d2,[%a2]
8001a9ee:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8001a9f2:	60 24       	mov.a %a4,%d2
8001a9f4:	6d ff 72 ff 	call 8001a8d8 <tcp_remove_listener>
  for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
8001a9f8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001a9fc:	c2 12       	add %d2,1
8001a9fe:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001aa02:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001aa06:	bf 42 e9 ff 	jlt.u %d2,4,8001a9d8 <tcp_listen_closed+0x7c>
  }
#endif
  LWIP_UNUSED_ARG(pcb);
}
8001aa0a:	00 00       	nop 
8001aa0c:	00 00       	nop 
8001aa0e:	00 90       	ret 

8001aa10 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
8001aa10:	40 ae       	mov.aa %a14,%sp
8001aa12:	20 20       	sub.a %sp,32
8001aa14:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001aa18:	02 42       	mov %d2,%d4
8001aa1a:	e9 e2 f0 ff 	st.b [%a14]-16,%d2
  LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
8001aa1e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001aa22:	df 02 17 80 	jne %d2,0,8001aa50 <tcp_close_shutdown+0x40>
8001aa26:	91 00 00 28 	movh.a %a2,32768
8001aa2a:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001aa2e:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001aa32:	3b e0 15 20 	mov %d2,350
8001aa36:	59 a2 04 00 	st.w [%sp]4,%d2
8001aa3a:	91 00 00 28 	movh.a %a2,32768
8001aa3e:	d9 22 f9 c1 	lea %a2,[%a2]7993 <80001f39 <IfxCpu_Trap_vectorTable0_end+0x1d45>>
8001aa42:	f4 a2       	st.a [%sp],%a2
8001aa44:	91 00 00 28 	movh.a %a2,32768
8001aa48:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001aa4c:	6d ff 75 54 	call 80005336 <Ifx_Lwip_printf>

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
8001aa50:	39 e2 f0 ff 	ld.bu %d2,[%a14]-16
8001aa54:	df 02 c2 00 	jeq %d2,0,8001abd8 <tcp_close_shutdown+0x1c8>
8001aa58:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aa5c:	d9 22 14 00 	lea %a2,[%a2]20
8001aa60:	54 22       	ld.w %d2,[%a2]
8001aa62:	df 42 09 00 	jeq %d2,4,8001aa74 <tcp_close_shutdown+0x64>
8001aa66:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aa6a:	d9 22 14 00 	lea %a2,[%a2]20
8001aa6e:	54 22       	ld.w %d2,[%a2]
8001aa70:	df 72 b4 80 	jne %d2,7,8001abd8 <tcp_close_shutdown+0x1c8>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
8001aa74:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aa78:	d9 22 3c 10 	lea %a2,[%a2]124
8001aa7c:	54 22       	ld.w %d2,[%a2]
8001aa7e:	df 02 0a 80 	jne %d2,0,8001aa92 <tcp_close_shutdown+0x82>
8001aa82:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aa86:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8001aa8a:	3b 00 86 30 	mov %d3,2144
8001aa8e:	5f 32 a5 00 	jeq %d2,%d3,8001abd8 <tcp_close_shutdown+0x1c8>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
8001aa92:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aa96:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001aa9a:	8f 02 01 21 	and %d2,%d2,16
8001aa9e:	df 02 17 80 	jne %d2,0,8001aacc <tcp_close_shutdown+0xbc>
8001aaa2:	91 00 00 28 	movh.a %a2,32768
8001aaa6:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001aaaa:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001aaae:	3b 40 16 20 	mov %d2,356
8001aab2:	59 a2 04 00 	st.w [%sp]4,%d2
8001aab6:	91 00 00 28 	movh.a %a2,32768
8001aaba:	d9 22 d9 d1 	lea %a2,[%a2]8025 <80001f59 <IfxCpu_Trap_vectorTable0_end+0x1d65>>
8001aabe:	f4 a2       	st.a [%sp],%a2
8001aac0:	91 00 00 28 	movh.a %a2,32768
8001aac4:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001aac8:	6d ff 37 54 	call 80005336 <Ifx_Lwip_printf>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
8001aacc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aad0:	d9 22 14 10 	lea %a2,[%a2]84
8001aad4:	54 22       	ld.w %d2,[%a2]
8001aad6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aada:	d9 22 28 00 	lea %a2,[%a2]40
8001aade:	54 23       	ld.w %d3,[%a2]
8001aae0:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
8001aae4:	19 e5 f4 ff 	ld.w %d5,[%a14]-12
8001aae8:	c2 45       	add %d5,4
              pcb->local_port, pcb->remote_port);
8001aaea:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aaee:	b9 26 1a 00 	ld.hu %d6,[%a2]26
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
8001aaf2:	02 60       	mov %d0,%d6
              pcb->local_port, pcb->remote_port);
8001aaf4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aaf8:	b9 26 1c 00 	ld.hu %d6,[%a2]28
      tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
8001aafc:	02 67       	mov %d7,%d6
8001aafe:	02 06       	mov %d6,%d0
8001ab00:	60 56       	mov.a %a6,%d5
8001ab02:	60 45       	mov.a %a5,%d4
8001ab04:	02 35       	mov %d5,%d3
8001ab06:	02 24       	mov %d4,%d2
8001ab08:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001ab0c:	6d 00 98 4e 	call 8002483c <tcp_rst>

      tcp_pcb_purge(pcb);
8001ab10:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001ab14:	6d 00 5b 11 	call 8001cdca <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
8001ab18:	91 10 00 27 	movh.a %a2,28673
8001ab1c:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001ab20:	54 22       	ld.w %d2,[%a2]
8001ab22:	19 e3 f4 ff 	ld.w %d3,[%a14]-12 <700145bc <tcp_active_pcbs>>
8001ab26:	5f 23 11 80 	jne %d3,%d2,8001ab48 <tcp_close_shutdown+0x138>
8001ab2a:	91 10 00 27 	movh.a %a2,28673
8001ab2e:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001ab32:	d4 22       	ld.a %a2,[%a2]
8001ab34:	d9 22 0c 00 	lea %a2,[%a2]12 <700145bc <tcp_active_pcbs>>
8001ab38:	54 22       	ld.w %d2,[%a2]
8001ab3a:	91 10 00 27 	movh.a %a2,28673
8001ab3e:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001ab42:	74 22       	st.w [%a2],%d2
8001ab44:	1d 00 2b 00 	j 8001ab9a <tcp_close_shutdown+0x18a>
8001ab48:	91 10 00 27 	movh.a %a2,28673
8001ab4c:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001ab50:	54 22       	ld.w %d2,[%a2]
8001ab52:	59 e2 fc ff 	st.w [%a14]-4 <700145bc <tcp_active_pcbs>>,%d2
8001ab56:	1d 00 1e 00 	j 8001ab92 <tcp_close_shutdown+0x182>
8001ab5a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ab5e:	d9 22 0c 00 	lea %a2,[%a2]12
8001ab62:	54 22       	ld.w %d2,[%a2]
8001ab64:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8001ab68:	5f 23 0e 80 	jne %d3,%d2,8001ab84 <tcp_close_shutdown+0x174>
8001ab6c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ab70:	d9 22 0c 00 	lea %a2,[%a2]12
8001ab74:	54 22       	ld.w %d2,[%a2]
8001ab76:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ab7a:	d9 22 0c 00 	lea %a2,[%a2]12
8001ab7e:	74 22       	st.w [%a2],%d2
8001ab80:	1d 00 0d 00 	j 8001ab9a <tcp_close_shutdown+0x18a>
8001ab84:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ab88:	d9 22 0c 00 	lea %a2,[%a2]12
8001ab8c:	54 22       	ld.w %d2,[%a2]
8001ab8e:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001ab92:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001ab96:	df 02 e2 ff 	jne %d2,0,8001ab5a <tcp_close_shutdown+0x14a>
8001ab9a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ab9e:	82 02       	mov %d2,0
8001aba0:	d9 22 0c 00 	lea %a2,[%a2]12
8001aba4:	74 22       	st.w [%a2],%d2
8001aba6:	91 10 00 27 	movh.a %a2,28673
8001abaa:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001abae:	82 12       	mov %d2,1
8001abb0:	34 22       	st.b [%a2],%d2
      /* Deallocate the pcb since we already sent a RST for it */
      if (tcp_input_pcb == pcb) {
8001abb2:	91 10 00 27 	movh.a %a2,28673
8001abb6:	d9 22 40 84 	lea %a2,[%a2]17920 <70014600 <tcp_input_pcb>>
8001abba:	54 22       	ld.w %d2,[%a2]
8001abbc:	19 e3 f4 ff 	ld.w %d3,[%a14]-12 <70014600 <tcp_input_pcb>>
8001abc0:	5f 23 06 80 	jne %d3,%d2,8001abcc <tcp_close_shutdown+0x1bc>
        /* prevent using a deallocated pcb: free it from tcp_input later */
        tcp_trigger_input_pcb_close();
8001abc4:	6d 00 b1 36 	call 80021926 <tcp_trigger_input_pcb_close>
8001abc8:	1d 00 06 00 	j 8001abd4 <tcp_close_shutdown+0x1c4>
      } else {
        tcp_free(pcb);
8001abcc:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001abd0:	6d ff 19 fe 	call 8001a802 <tcp_free>
      }
      return ERR_OK;
8001abd4:	82 02       	mov %d2,0
8001abd6:	00 90       	ret 
    }
  }

  /* - states which free the pcb are handled here,
     - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
  switch (pcb->state) {
8001abd8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001abdc:	d9 22 14 00 	lea %a2,[%a2]20
8001abe0:	54 22       	ld.w %d2,[%a2]
8001abe2:	df 22 6f 00 	jeq %d2,2,8001acc0 <tcp_close_shutdown+0x2b0>
8001abe6:	ff 32 81 80 	jge.u %d2,3,8001ace8 <tcp_close_shutdown+0x2d8>
8001abea:	df 02 06 00 	jeq %d2,0,8001abf6 <tcp_close_shutdown+0x1e6>
8001abee:	df 12 57 00 	jeq %d2,1,8001ac9c <tcp_close_shutdown+0x28c>
8001abf2:	1d 00 7b 00 	j 8001ace8 <tcp_close_shutdown+0x2d8>
       * and the user needs some way to free it should the need arise.
       * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
       * or for a pcb that has been used and then entered the CLOSED state
       * is erroneous, but this should never happen as the pcb has in those cases
       * been freed, and so any remaining handles are bogus. */
      if (pcb->local_port != 0) {
8001abf6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001abfa:	b9 22 1a 00 	ld.hu %d2,[%a2]26
8001abfe:	df 02 49 00 	jeq %d2,0,8001ac90 <tcp_close_shutdown+0x280>
        TCP_RMV(&tcp_bound_pcbs, pcb);
8001ac02:	91 10 00 27 	movh.a %a2,28673
8001ac06:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001ac0a:	54 22       	ld.w %d2,[%a2]
8001ac0c:	19 e3 f4 ff 	ld.w %d3,[%a14]-12 <700145b4 <tcp_bound_pcbs>>
8001ac10:	5f 23 11 80 	jne %d3,%d2,8001ac32 <tcp_close_shutdown+0x222>
8001ac14:	91 10 00 27 	movh.a %a2,28673
8001ac18:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001ac1c:	d4 22       	ld.a %a2,[%a2]
8001ac1e:	d9 22 0c 00 	lea %a2,[%a2]12 <700145b4 <tcp_bound_pcbs>>
8001ac22:	54 22       	ld.w %d2,[%a2]
8001ac24:	91 10 00 27 	movh.a %a2,28673
8001ac28:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001ac2c:	74 22       	st.w [%a2],%d2
8001ac2e:	1d 00 2b 00 	j 8001ac84 <tcp_close_shutdown+0x274>
8001ac32:	91 10 00 27 	movh.a %a2,28673
8001ac36:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001ac3a:	54 22       	ld.w %d2,[%a2]
8001ac3c:	59 e2 f8 ff 	st.w [%a14]-8 <700145b4 <tcp_bound_pcbs>>,%d2
8001ac40:	1d 00 1e 00 	j 8001ac7c <tcp_close_shutdown+0x26c>
8001ac44:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001ac48:	d9 22 0c 00 	lea %a2,[%a2]12
8001ac4c:	54 22       	ld.w %d2,[%a2]
8001ac4e:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8001ac52:	5f 23 0e 80 	jne %d3,%d2,8001ac6e <tcp_close_shutdown+0x25e>
8001ac56:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ac5a:	d9 22 0c 00 	lea %a2,[%a2]12
8001ac5e:	54 22       	ld.w %d2,[%a2]
8001ac60:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001ac64:	d9 22 0c 00 	lea %a2,[%a2]12
8001ac68:	74 22       	st.w [%a2],%d2
8001ac6a:	1d 00 0d 00 	j 8001ac84 <tcp_close_shutdown+0x274>
8001ac6e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001ac72:	d9 22 0c 00 	lea %a2,[%a2]12
8001ac76:	54 22       	ld.w %d2,[%a2]
8001ac78:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8001ac7c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001ac80:	df 02 e2 ff 	jne %d2,0,8001ac44 <tcp_close_shutdown+0x234>
8001ac84:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ac88:	82 02       	mov %d2,0
8001ac8a:	d9 22 0c 00 	lea %a2,[%a2]12
8001ac8e:	74 22       	st.w [%a2],%d2
      }
      tcp_free(pcb);
8001ac90:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001ac94:	6d ff b7 fd 	call 8001a802 <tcp_free>
      break;
8001ac98:	1d 00 2d 00 	j 8001acf2 <tcp_close_shutdown+0x2e2>
    case LISTEN:
      tcp_listen_closed(pcb);
8001ac9c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001aca0:	6d ff 5e fe 	call 8001a95c <tcp_listen_closed>
      tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
8001aca4:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8001aca8:	91 10 00 27 	movh.a %a2,28673
8001acac:	d9 24 78 64 	lea %a4,[%a2]17848 <700145b8 <tcp_listen_pcbs>>
8001acb0:	6d 00 0d 11 	call 8001ceca <tcp_pcb_remove>
      tcp_free_listen(pcb);
8001acb4:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001acb8:	6d ff cc fd 	call 8001a850 <tcp_free_listen>
      break;
8001acbc:	1d 00 1b 00 	j 8001acf2 <tcp_close_shutdown+0x2e2>
    case SYN_SENT:
      TCP_PCB_REMOVE_ACTIVE(pcb);
8001acc0:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8001acc4:	91 10 00 27 	movh.a %a2,28673
8001acc8:	d9 24 7c 64 	lea %a4,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001accc:	6d 00 ff 10 	call 8001ceca <tcp_pcb_remove>
8001acd0:	91 10 00 27 	movh.a %a2,28673
8001acd4:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001acd8:	82 12       	mov %d2,1
8001acda:	34 22       	st.b [%a2],%d2
      tcp_free(pcb);
8001acdc:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001ace0:	6d ff 91 fd 	call 8001a802 <tcp_free>
      MIB2_STATS_INC(mib2.tcpattemptfails);
      break;
8001ace4:	1d 00 07 00 	j 8001acf2 <tcp_close_shutdown+0x2e2>
    default:
      return tcp_close_shutdown_fin(pcb);
8001ace8:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001acec:	6d 00 05 00 	call 8001acf6 <tcp_close_shutdown_fin>
8001acf0:	00 90       	ret 
  }
  return ERR_OK;
8001acf2:	82 02       	mov %d2,0
}
8001acf4:	00 90       	ret 

8001acf6 <tcp_close_shutdown_fin>:

static err_t
tcp_close_shutdown_fin(struct tcp_pcb *pcb)
{
8001acf6:	40 ae       	mov.aa %a14,%sp
8001acf8:	20 20       	sub.a %sp,32
8001acfa:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  err_t err;
  LWIP_ASSERT("pcb != NULL", pcb != NULL);
8001acfe:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001ad02:	df 02 17 80 	jne %d2,0,8001ad30 <tcp_close_shutdown_fin+0x3a>
8001ad06:	91 00 00 28 	movh.a %a2,32768
8001ad0a:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001ad0e:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001ad12:	3b c0 19 20 	mov %d2,412
8001ad16:	59 a2 04 00 	st.w [%sp]4,%d2
8001ad1a:	91 00 00 28 	movh.a %a2,32768
8001ad1e:	d9 22 d8 c1 	lea %a2,[%a2]7960 <80001f18 <IfxCpu_Trap_vectorTable0_end+0x1d24>>
8001ad22:	f4 a2       	st.a [%sp],%a2
8001ad24:	91 00 00 28 	movh.a %a2,32768
8001ad28:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001ad2c:	6d ff 05 53 	call 80005336 <Ifx_Lwip_printf>

  switch (pcb->state) {
8001ad30:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ad34:	d9 22 14 00 	lea %a2,[%a2]20
8001ad38:	54 22       	ld.w %d2,[%a2]
8001ad3a:	df 72 2e 00 	jeq %d2,7,8001ad96 <tcp_close_shutdown_fin+0xa0>
8001ad3e:	ff 82 3f 80 	jge.u %d2,8,8001adbc <tcp_close_shutdown_fin+0xc6>
8001ad42:	df 32 06 00 	jeq %d2,3,8001ad4e <tcp_close_shutdown_fin+0x58>
8001ad46:	df 42 16 00 	jeq %d2,4,8001ad72 <tcp_close_shutdown_fin+0x7c>
8001ad4a:	1d 00 39 00 	j 8001adbc <tcp_close_shutdown_fin+0xc6>
    case SYN_RCVD:
      err = tcp_send_fin(pcb);
8001ad4e:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001ad52:	6d 00 f9 40 	call 80022f44 <tcp_send_fin>
8001ad56:	e9 e2 ff ff 	st.b [%a14]-1,%d2
      if (err == ERR_OK) {
8001ad5a:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001ad5e:	df 02 31 80 	jne %d2,0,8001adc0 <tcp_close_shutdown_fin+0xca>
        tcp_backlog_accepted(pcb);
        MIB2_STATS_INC(mib2.tcpattemptfails);
        pcb->state = FIN_WAIT_1;
8001ad62:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ad66:	82 52       	mov %d2,5
8001ad68:	d9 22 14 00 	lea %a2,[%a2]20
8001ad6c:	74 22       	st.w [%a2],%d2
      }
      break;
8001ad6e:	1d 00 29 00 	j 8001adc0 <tcp_close_shutdown_fin+0xca>
    case ESTABLISHED:
      err = tcp_send_fin(pcb);
8001ad72:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001ad76:	6d 00 e7 40 	call 80022f44 <tcp_send_fin>
8001ad7a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
      if (err == ERR_OK) {
8001ad7e:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001ad82:	df 02 22 80 	jne %d2,0,8001adc6 <tcp_close_shutdown_fin+0xd0>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = FIN_WAIT_1;
8001ad86:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ad8a:	82 52       	mov %d2,5
8001ad8c:	d9 22 14 00 	lea %a2,[%a2]20
8001ad90:	74 22       	st.w [%a2],%d2
      }
      break;
8001ad92:	1d 00 1a 00 	j 8001adc6 <tcp_close_shutdown_fin+0xd0>
    case CLOSE_WAIT:
      err = tcp_send_fin(pcb);
8001ad96:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001ad9a:	6d 00 d5 40 	call 80022f44 <tcp_send_fin>
8001ad9e:	e9 e2 ff ff 	st.b [%a14]-1,%d2
      if (err == ERR_OK) {
8001ada2:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001ada6:	df 02 13 80 	jne %d2,0,8001adcc <tcp_close_shutdown_fin+0xd6>
        MIB2_STATS_INC(mib2.tcpestabresets);
        pcb->state = LAST_ACK;
8001adaa:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001adae:	3b 90 00 20 	mov %d2,9
8001adb2:	d9 22 14 00 	lea %a2,[%a2]20
8001adb6:	74 22       	st.w [%a2],%d2
      }
      break;
8001adb8:	1d 00 0a 00 	j 8001adcc <tcp_close_shutdown_fin+0xd6>
    default:
      /* Has already been closed, do nothing. */
      return ERR_OK;
8001adbc:	82 02       	mov %d2,0
8001adbe:	00 90       	ret 
      break;
8001adc0:	00 00       	nop 
8001adc2:	1d 00 06 00 	j 8001adce <tcp_close_shutdown_fin+0xd8>
      break;
8001adc6:	00 00       	nop 
8001adc8:	1d 00 03 00 	j 8001adce <tcp_close_shutdown_fin+0xd8>
      break;
8001adcc:	00 00       	nop 
  }

  if (err == ERR_OK) {
8001adce:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001add2:	df 02 08 80 	jne %d2,0,8001ade2 <tcp_close_shutdown_fin+0xec>
    /* To ensure all data has been sent when tcp_close returns, we have
       to make sure tcp_output doesn't fail.
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    tcp_output(pcb);
8001add6:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001adda:	6d 00 dd 42 	call 80023394 <tcp_output>
8001adde:	1d 00 14 00 	j 8001ae06 <tcp_close_shutdown_fin+0x110>
  } else if (err == ERR_MEM) {
8001ade2:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001ade6:	df f2 10 80 	jne %d2,-1,8001ae06 <tcp_close_shutdown_fin+0x110>
    /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
    tcp_set_flags(pcb, TF_CLOSEPEND);
8001adea:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001adee:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001adf2:	8f 82 40 21 	or %d2,%d2,8
8001adf6:	37 02 70 20 	extr.u %d2,%d2,0,16
8001adfa:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001adfe:	f9 22 1e 00 	st.h [%a2]30,%d2
    /* We have to return ERR_OK from here to indicate to the callers that this
       pcb should not be used any more as it will be freed soon via tcp_tmr.
       This is OK here since sending FIN does not guarantee a time frime for
       actually freeing the pcb, either (it is left in closure states for
       remote ACK or timeout) */
    return ERR_OK;
8001ae02:	82 02       	mov %d2,0
8001ae04:	00 90       	ret 
  }
  return err;
8001ae06:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
8001ae0a:	00 90       	ret 

8001ae0c <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
8001ae0c:	40 ae       	mov.aa %a14,%sp
8001ae0e:	20 18       	sub.a %sp,24
8001ae10:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
8001ae14:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001ae18:	df 02 1a 80 	jne %d2,0,8001ae4c <tcp_close+0x40>
8001ae1c:	91 00 00 28 	movh.a %a2,32768
8001ae20:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001ae24:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001ae28:	3b 80 1e 20 	mov %d2,488
8001ae2c:	59 a2 04 00 	st.w [%sp]4,%d2
8001ae30:	91 00 00 28 	movh.a %a2,32768
8001ae34:	d9 22 f2 d1 	lea %a2,[%a2]8050 <80001f72 <IfxCpu_Trap_vectorTable0_end+0x1d7e>>
8001ae38:	f4 a2       	st.a [%sp],%a2
8001ae3a:	91 00 00 28 	movh.a %a2,32768
8001ae3e:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001ae42:	6d ff 7a 52 	call 80005336 <Ifx_Lwip_printf>
8001ae46:	3b 00 ff 2f 	mov %d2,-16
8001ae4a:	00 90       	ret 
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));

  tcp_debug_print_state(pcb->state);

  if (pcb->state != LISTEN) {
8001ae4c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ae50:	d9 22 14 00 	lea %a2,[%a2]20
8001ae54:	54 22       	ld.w %d2,[%a2]
8001ae56:	df 12 0e 00 	jeq %d2,1,8001ae72 <tcp_close+0x66>
    /* Set a flag not to receive any more data... */
    tcp_set_flags(pcb, TF_RXCLOSED);
8001ae5a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ae5e:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001ae62:	8f 02 41 21 	or %d2,%d2,16
8001ae66:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ae6a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ae6e:	f9 22 1e 00 	st.h [%a2]30,%d2
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
8001ae72:	82 14       	mov %d4,1
8001ae74:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001ae78:	6d ff cc fd 	call 8001aa10 <tcp_close_shutdown>
}
8001ae7c:	00 90       	ret 

8001ae7e <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
8001ae7e:	40 ae       	mov.aa %a14,%sp
8001ae80:	20 38       	sub.a %sp,56
8001ae82:	b5 e4 dc ff 	st.a [%a14]-36,%a4
8001ae86:	59 e4 d8 ff 	st.w [%a14]-40,%d4
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
8001ae8a:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8001ae8e:	df 02 18 80 	jne %d2,0,8001aebe <tcp_abandon+0x40>
8001ae92:	91 00 00 28 	movh.a %a2,32768
8001ae96:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001ae9a:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001ae9e:	3b d0 23 20 	mov %d2,573
8001aea2:	59 a2 04 00 	st.w [%sp]4,%d2
8001aea6:	91 00 00 28 	movh.a %a2,32768
8001aeaa:	d9 22 e3 e1 	lea %a2,[%a2]8099 <80001fa3 <IfxCpu_Trap_vectorTable0_end+0x1daf>>
8001aeae:	f4 a2       	st.a [%sp],%a2
8001aeb0:	91 00 00 28 	movh.a %a2,32768
8001aeb4:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001aeb8:	6d ff 3f 52 	call 80005336 <Ifx_Lwip_printf>
8001aebc:	00 90       	ret 

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
8001aebe:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001aec2:	d9 22 14 00 	lea %a2,[%a2]20
8001aec6:	54 22       	ld.w %d2,[%a2]
8001aec8:	df 12 17 80 	jne %d2,1,8001aef6 <tcp_abandon+0x78>
8001aecc:	91 00 00 28 	movh.a %a2,32768
8001aed0:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001aed4:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001aed8:	3b 00 24 20 	mov %d2,576
8001aedc:	59 a2 04 00 	st.w [%sp]4,%d2
8001aee0:	91 00 00 28 	movh.a %a2,32768
8001aee4:	d9 22 fc e1 	lea %a2,[%a2]8124 <80001fbc <IfxCpu_Trap_vectorTable0_end+0x1dc8>>
8001aee8:	f4 a2       	st.a [%sp],%a2
8001aeea:	91 00 00 28 	movh.a %a2,32768
8001aeee:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001aef2:	6d ff 22 52 	call 80005336 <Ifx_Lwip_printf>
              pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
8001aef6:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001aefa:	d9 22 14 00 	lea %a2,[%a2]20
8001aefe:	54 22       	ld.w %d2,[%a2]
8001af00:	8b a2 20 22 	ne %d2,%d2,10
8001af04:	df 02 0f 80 	jne %d2,0,8001af22 <tcp_abandon+0xa4>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
8001af08:	99 e5 dc ff 	ld.a %a5,[%a14]-36
8001af0c:	91 10 00 27 	movh.a %a2,28673
8001af10:	d9 24 40 74 	lea %a4,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001af14:	6d 00 db 0f 	call 8001ceca <tcp_pcb_remove>
    tcp_free(pcb);
8001af18:	99 e4 dc ff 	ld.a %a4,[%a14]-36
8001af1c:	6d ff 73 fc 	call 8001a802 <tcp_free>
8001af20:	00 90       	ret 
  } else {
    int send_rst = 0;
8001af22:	82 02       	mov %d2,0
8001af24:	59 e2 fc ff 	st.w [%a14]-4,%d2
    u16_t local_port = 0;
8001af28:	82 02       	mov %d2,0
8001af2a:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    enum tcp_state last_state;
    seqno = pcb->snd_nxt;
8001af2e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001af32:	d9 22 14 10 	lea %a2,[%a2]84
8001af36:	54 22       	ld.w %d2,[%a2]
8001af38:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    ackno = pcb->rcv_nxt;
8001af3c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001af40:	d9 22 28 00 	lea %a2,[%a2]40
8001af44:	54 22       	ld.w %d2,[%a2]
8001af46:	59 e2 ec ff 	st.w [%a14]-20,%d2
#if LWIP_CALLBACK_API
    errf = pcb->errf;
8001af4a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001af4e:	d9 22 14 20 	lea %a2,[%a2]148
8001af52:	54 22       	ld.w %d2,[%a2]
8001af54:	59 e2 e8 ff 	st.w [%a14]-24,%d2
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
8001af58:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001af5c:	d9 22 10 00 	lea %a2,[%a2]16
8001af60:	54 22       	ld.w %d2,[%a2]
8001af62:	59 e2 e4 ff 	st.w [%a14]-28,%d2
    if (pcb->state == CLOSED) {
8001af66:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001af6a:	d9 22 14 00 	lea %a2,[%a2]20
8001af6e:	54 22       	ld.w %d2,[%a2]
8001af70:	df 02 51 80 	jne %d2,0,8001b012 <tcp_abandon+0x194>
      if (pcb->local_port != 0) {
8001af74:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001af78:	b9 22 1a 00 	ld.hu %d2,[%a2]26
8001af7c:	df 02 63 00 	jeq %d2,0,8001b042 <tcp_abandon+0x1c4>
        /* bound, not yet opened */
        TCP_RMV(&tcp_bound_pcbs, pcb);
8001af80:	91 10 00 27 	movh.a %a2,28673
8001af84:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001af88:	54 22       	ld.w %d2,[%a2]
8001af8a:	19 e3 dc ff 	ld.w %d3,[%a14]-36 <700145b4 <tcp_bound_pcbs>>
8001af8e:	5f 23 11 80 	jne %d3,%d2,8001afb0 <tcp_abandon+0x132>
8001af92:	91 10 00 27 	movh.a %a2,28673
8001af96:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001af9a:	d4 22       	ld.a %a2,[%a2]
8001af9c:	d9 22 0c 00 	lea %a2,[%a2]12 <700145b4 <tcp_bound_pcbs>>
8001afa0:	54 22       	ld.w %d2,[%a2]
8001afa2:	91 10 00 27 	movh.a %a2,28673
8001afa6:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001afaa:	74 22       	st.w [%a2],%d2
8001afac:	1d 00 2b 00 	j 8001b002 <tcp_abandon+0x184>
8001afb0:	91 10 00 27 	movh.a %a2,28673
8001afb4:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001afb8:	54 22       	ld.w %d2,[%a2]
8001afba:	59 e2 f4 ff 	st.w [%a14]-12 <700145b4 <tcp_bound_pcbs>>,%d2
8001afbe:	1d 00 1e 00 	j 8001affa <tcp_abandon+0x17c>
8001afc2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001afc6:	d9 22 0c 00 	lea %a2,[%a2]12
8001afca:	54 22       	ld.w %d2,[%a2]
8001afcc:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8001afd0:	5f 23 0e 80 	jne %d3,%d2,8001afec <tcp_abandon+0x16e>
8001afd4:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001afd8:	d9 22 0c 00 	lea %a2,[%a2]12
8001afdc:	54 22       	ld.w %d2,[%a2]
8001afde:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001afe2:	d9 22 0c 00 	lea %a2,[%a2]12
8001afe6:	74 22       	st.w [%a2],%d2
8001afe8:	1d 00 0d 00 	j 8001b002 <tcp_abandon+0x184>
8001afec:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001aff0:	d9 22 0c 00 	lea %a2,[%a2]12
8001aff4:	54 22       	ld.w %d2,[%a2]
8001aff6:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8001affa:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001affe:	df 02 e2 ff 	jne %d2,0,8001afc2 <tcp_abandon+0x144>
8001b002:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b006:	82 02       	mov %d2,0
8001b008:	d9 22 0c 00 	lea %a2,[%a2]12
8001b00c:	74 22       	st.w [%a2],%d2
8001b00e:	1d 00 1a 00 	j 8001b042 <tcp_abandon+0x1c4>
      }
    } else {
      send_rst = reset;
8001b012:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
8001b016:	59 e2 fc ff 	st.w [%a14]-4,%d2
      local_port = pcb->local_port;
8001b01a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b01e:	c9 22 1a 00 	ld.h %d2,[%a2]26
8001b022:	f9 e2 fa ff 	st.h [%a14]-6,%d2
      TCP_PCB_REMOVE_ACTIVE(pcb);
8001b026:	99 e5 dc ff 	ld.a %a5,[%a14]-36
8001b02a:	91 10 00 27 	movh.a %a2,28673
8001b02e:	d9 24 7c 64 	lea %a4,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001b032:	6d 00 4c 0f 	call 8001ceca <tcp_pcb_remove>
8001b036:	91 10 00 27 	movh.a %a2,28673
8001b03a:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001b03e:	82 12       	mov %d2,1
8001b040:	34 22       	st.b [%a2],%d2
    }
    if (pcb->unacked != NULL) {
8001b042:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b046:	d9 22 34 10 	lea %a2,[%a2]116
8001b04a:	54 22       	ld.w %d2,[%a2]
8001b04c:	df 02 0a 00 	jeq %d2,0,8001b060 <tcp_abandon+0x1e2>
      tcp_segs_free(pcb->unacked);
8001b050:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b054:	d9 22 34 10 	lea %a2,[%a2]116
8001b058:	54 22       	ld.w %d2,[%a2]
8001b05a:	60 24       	mov.a %a4,%d2
8001b05c:	6d 00 8e 0a 	call 8001c578 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
8001b060:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b064:	d9 22 30 10 	lea %a2,[%a2]112
8001b068:	54 22       	ld.w %d2,[%a2]
8001b06a:	df 02 0a 00 	jeq %d2,0,8001b07e <tcp_abandon+0x200>
      tcp_segs_free(pcb->unsent);
8001b06e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b072:	d9 22 30 10 	lea %a2,[%a2]112
8001b076:	54 22       	ld.w %d2,[%a2]
8001b078:	60 24       	mov.a %a4,%d2
8001b07a:	6d 00 7f 0a 	call 8001c578 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
8001b07e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b082:	d9 22 38 10 	lea %a2,[%a2]120
8001b086:	54 22       	ld.w %d2,[%a2]
8001b088:	df 02 0a 00 	jeq %d2,0,8001b09c <tcp_abandon+0x21e>
      tcp_segs_free(pcb->ooseq);
8001b08c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b090:	d9 22 38 10 	lea %a2,[%a2]120
8001b094:	54 22       	ld.w %d2,[%a2]
8001b096:	60 24       	mov.a %a4,%d2
8001b098:	6d 00 70 0a 	call 8001c578 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    tcp_backlog_accepted(pcb);
    if (send_rst) {
8001b09c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001b0a0:	df 02 1a 00 	jeq %d2,0,8001b0d4 <tcp_abandon+0x256>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
8001b0a4:	19 e3 dc ff 	ld.w %d3,[%a14]-36
8001b0a8:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8001b0ac:	1b 42 00 40 	addi %d4,%d2,4
8001b0b0:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8001b0b4:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b0b8:	b9 25 1c 00 	ld.hu %d5,[%a2]28
8001b0bc:	02 57       	mov %d7,%d5
8001b0be:	02 26       	mov %d6,%d2
8001b0c0:	60 46       	mov.a %a6,%d4
8001b0c2:	60 35       	mov.a %a5,%d3
8001b0c4:	19 e5 ec ff 	ld.w %d5,[%a14]-20
8001b0c8:	19 e4 f0 ff 	ld.w %d4,[%a14]-16
8001b0cc:	99 e4 dc ff 	ld.a %a4,[%a14]-36
8001b0d0:	6d 00 b6 4b 	call 8002483c <tcp_rst>
    }
    last_state = pcb->state;
8001b0d4:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001b0d8:	d9 22 14 00 	lea %a2,[%a2]20
8001b0dc:	54 22       	ld.w %d2,[%a2]
8001b0de:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    tcp_free(pcb);
8001b0e2:	99 e4 dc ff 	ld.a %a4,[%a14]-36
8001b0e6:	6d ff 8e fb 	call 8001a802 <tcp_free>
    TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
8001b0ea:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001b0ee:	df 02 0a 00 	jeq %d2,0,8001b102 <tcp_abandon+0x284>
8001b0f2:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001b0f6:	3b 30 ff 4f 	mov %d4,-13
8001b0fa:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001b0fe:	2d 02 00 00 	calli %a2
  }
}
8001b102:	00 90       	ret 

8001b104 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
8001b104:	40 ae       	mov.aa %a14,%sp
8001b106:	20 08       	sub.a %sp,8
8001b108:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  tcp_abandon(pcb, 1);
8001b10c:	82 14       	mov %d4,1
8001b10e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001b112:	6d ff b6 fe 	call 8001ae7e <tcp_abandon>
}
8001b116:	00 00       	nop 
8001b118:	00 90       	ret 

8001b11a <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
8001b11a:	40 ae       	mov.aa %a14,%sp
8001b11c:	20 30       	sub.a %sp,48
8001b11e:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8001b122:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
8001b126:	02 42       	mov %d2,%d4
8001b128:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
8001b12c:	82 42       	mov %d2,4
8001b12e:	59 e2 f4 ff 	st.w [%a14]-12,%d2

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
8001b132:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001b136:	df 02 08 80 	jne %d2,0,8001b146 <tcp_bind+0x2c>
    ipaddr = IP4_ADDR_ANY;
8001b13a:	91 00 00 28 	movh.a %a2,32768
8001b13e:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
8001b142:	b5 e2 e8 ff 	st.a [%a14]-24 <8000451c <ip_addr_any>>,%a2
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("tcp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("tcp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
8001b146:	19 e2 ec ff 	ld.w %d2,[%a14]-20 <8000451c <ip_addr_any>>
8001b14a:	df 02 1a 80 	jne %d2,0,8001b17e <tcp_bind+0x64>
8001b14e:	91 00 00 28 	movh.a %a2,32768
8001b152:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b156:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b15a:	3b 90 2a 20 	mov %d2,681
8001b15e:	59 a2 04 00 	st.w [%sp]4,%d2
8001b162:	91 00 00 28 	movh.a %a2,32768
8001b166:	d9 22 ed f1 	lea %a2,[%a2]8173 <80001fed <IfxCpu_Trap_vectorTable0_end+0x1df9>>
8001b16a:	f4 a2       	st.a [%sp],%a2
8001b16c:	91 00 00 28 	movh.a %a2,32768
8001b170:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b174:	6d ff e1 50 	call 80005336 <Ifx_Lwip_printf>
8001b178:	3b 00 ff 2f 	mov %d2,-16
8001b17c:	00 90       	ret 

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
8001b17e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b182:	d9 22 14 00 	lea %a2,[%a2]20
8001b186:	54 22       	ld.w %d2,[%a2]
8001b188:	df 02 19 00 	jeq %d2,0,8001b1ba <tcp_bind+0xa0>
8001b18c:	91 00 00 28 	movh.a %a2,32768
8001b190:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b194:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b198:	3b b0 2a 20 	mov %d2,683
8001b19c:	59 a2 04 00 	st.w [%sp]4,%d2
8001b1a0:	91 00 00 28 	movh.a %a2,32768
8001b1a4:	d9 22 03 02 	lea %a2,[%a2]8195 <80002003 <IfxCpu_Trap_vectorTable0_end+0x1e0f>>
8001b1a8:	f4 a2       	st.a [%sp],%a2
8001b1aa:	91 00 00 28 	movh.a %a2,32768
8001b1ae:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b1b2:	6d ff c2 50 	call 80005336 <Ifx_Lwip_printf>
8001b1b6:	82 a2       	mov %d2,-6
8001b1b8:	00 90       	ret 
    ip6_addr_select_zone(ip_2_ip6(&zoned_ipaddr), ip_2_ip6(&zoned_ipaddr));
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  if (port == 0) {
8001b1ba:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
8001b1be:	df 02 0c 80 	jne %d2,0,8001b1d6 <tcp_bind+0xbc>
    port = tcp_new_port();
8001b1c2:	6d 00 08 03 	call 8001b7d2 <tcp_new_port>
8001b1c6:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
    if (port == 0) {
8001b1ca:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
8001b1ce:	df 02 52 80 	jne %d2,0,8001b272 <tcp_bind+0x158>
      return ERR_BUF;
8001b1d2:	82 e2       	mov %d2,-2
8001b1d4:	00 90       	ret 
    }
  } else {
    /* Check if the address already is in use (on all lists) */
    for (i = 0; i < max_pcb_list; i++) {
8001b1d6:	82 02       	mov %d2,0
8001b1d8:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001b1dc:	1d 00 45 00 	j 8001b266 <tcp_bind+0x14c>
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
8001b1e0:	91 00 00 28 	movh.a %a2,32768
8001b1e4:	d9 22 50 84 	lea %a2,[%a2]17936 <80004610 <tcp_pcb_lists>>
8001b1e8:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <80004610 <tcp_pcb_lists>>
8001b1ec:	06 22       	sh %d2,2
8001b1ee:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8001b1f2:	d4 22       	ld.a %a2,[%a2]
8001b1f4:	54 22       	ld.w %d2,[%a2]
8001b1f6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8001b1fa:	1d 00 2d 00 	j 8001b254 <tcp_bind+0x13a>
        if (cpcb->local_port == port) {
8001b1fe:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001b202:	b9 22 1a 00 	ld.hu %d2,[%a2]26
8001b206:	b9 e3 e4 ff 	ld.hu %d3,[%a14]-28
8001b20a:	5f 23 1e 80 	jne %d3,%d2,8001b246 <tcp_bind+0x12c>
              !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
          {
            /* @todo: check accept_any_ip_version */
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
                (ip_addr_isany(&cpcb->local_ip) ||
8001b20e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
8001b212:	df 02 18 00 	jeq %d2,0,8001b242 <tcp_bind+0x128>
                (ip_addr_isany(&cpcb->local_ip) ||
8001b216:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001b21a:	54 22       	ld.w %d2,[%a2]
8001b21c:	df 02 13 00 	jeq %d2,0,8001b242 <tcp_bind+0x128>
8001b220:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001b224:	df 02 0f 00 	jeq %d2,0,8001b242 <tcp_bind+0x128>
                 ip_addr_isany(ipaddr) ||
8001b228:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001b22c:	54 22       	ld.w %d2,[%a2]
8001b22e:	df 02 0a 00 	jeq %d2,0,8001b242 <tcp_bind+0x128>
                 ip_addr_cmp(&cpcb->local_ip, ipaddr))) {
8001b232:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001b236:	54 23       	ld.w %d3,[%a2]
8001b238:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001b23c:	54 22       	ld.w %d2,[%a2]
            if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
8001b23e:	5f 23 04 80 	jne %d3,%d2,8001b246 <tcp_bind+0x12c>
              return ERR_USE;
8001b242:	82 82       	mov %d2,-8
8001b244:	00 90       	ret 
      for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
8001b246:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001b24a:	d9 22 0c 00 	lea %a2,[%a2]12
8001b24e:	54 22       	ld.w %d2,[%a2]
8001b250:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8001b254:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001b258:	df 02 d3 ff 	jne %d2,0,8001b1fe <tcp_bind+0xe4>
    for (i = 0; i < max_pcb_list; i++) {
8001b25c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001b260:	c2 12       	add %d2,1
8001b262:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001b266:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8001b26a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001b26e:	3f 23 b9 7f 	jlt %d3,%d2,8001b1e0 <tcp_bind+0xc6>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)
8001b272:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001b276:	df 02 14 00 	jeq %d2,0,8001b29e <tcp_bind+0x184>
8001b27a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001b27e:	54 22       	ld.w %d2,[%a2]
8001b280:	df 02 0f 00 	jeq %d2,0,8001b29e <tcp_bind+0x184>
#if LWIP_IPV4 && LWIP_IPV6
      || (IP_GET_TYPE(ipaddr) != IP_GET_TYPE(&pcb->local_ip))
#endif /* LWIP_IPV4 && LWIP_IPV6 */
     ) {
    ip_addr_set(&pcb->local_ip, ipaddr);
8001b284:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001b288:	df 02 07 00 	jeq %d2,0,8001b296 <tcp_bind+0x17c>
8001b28c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8001b290:	54 22       	ld.w %d2,[%a2]
8001b292:	1d 00 03 00 	j 8001b298 <tcp_bind+0x17e>
8001b296:	82 02       	mov %d2,0
8001b298:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b29c:	74 22       	st.w [%a2],%d2
  }
  pcb->local_port = port;
8001b29e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b2a2:	c9 e2 e4 ff 	ld.h %d2,[%a14]-28
8001b2a6:	f9 22 1a 00 	st.h [%a2]26,%d2
  TCP_REG(&tcp_bound_pcbs, pcb);
8001b2aa:	91 10 00 27 	movh.a %a2,28673
8001b2ae:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001b2b2:	54 22       	ld.w %d2,[%a2]
8001b2b4:	99 e2 ec ff 	ld.a %a2,[%a14]-20 <700145b4 <tcp_bound_pcbs>>
8001b2b8:	d9 22 0c 00 	lea %a2,[%a2]12 <700145b4 <tcp_bound_pcbs>>
8001b2bc:	74 22       	st.w [%a2],%d2
8001b2be:	91 10 00 27 	movh.a %a2,28673
8001b2c2:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001b2c6:	19 e2 ec ff 	ld.w %d2,[%a14]-20 <700145b4 <tcp_bound_pcbs>>
8001b2ca:	74 22       	st.w [%a2],%d2
8001b2cc:	6d 00 7e 4d 	call 80024dc8 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
8001b2d0:	82 02       	mov %d2,0
}
8001b2d2:	00 90       	ret 

8001b2d4 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
8001b2d4:	40 ae       	mov.aa %a14,%sp
8001b2d6:	20 20       	sub.a %sp,32
8001b2d8:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001b2dc:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
8001b2e0:	02 42       	mov %d2,%d4
8001b2e2:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(err);

  LWIP_ASSERT("tcp_accept_null: invalid pcb", pcb != NULL);
8001b2e6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001b2ea:	df 02 17 80 	jne %d2,0,8001b318 <tcp_accept_null+0x44>
8001b2ee:	91 00 00 28 	movh.a %a2,32768
8001b2f2:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b2f6:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b2fa:	3b f0 30 20 	mov %d2,783
8001b2fe:	59 a2 04 00 	st.w [%sp]4,%d2
8001b302:	91 00 00 28 	movh.a %a2,32768
8001b306:	d9 22 2b 02 	lea %a2,[%a2]8235 <8000202b <IfxCpu_Trap_vectorTable0_end+0x1e37>>
8001b30a:	f4 a2       	st.a [%sp],%a2
8001b30c:	91 00 00 28 	movh.a %a2,32768
8001b310:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b314:	6d ff 11 50 	call 80005336 <Ifx_Lwip_printf>

  tcp_abort(pcb);
8001b318:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001b31c:	6d ff f4 fe 	call 8001b104 <tcp_abort>

  return ERR_ABRT;
8001b320:	3b 30 ff 2f 	mov %d2,-13
}
8001b324:	00 90       	ret 

8001b326 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen_with_backlog(tpcb, backlog);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
8001b326:	40 ae       	mov.aa %a14,%sp
8001b328:	20 08       	sub.a %sp,8
8001b32a:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001b32e:	02 42       	mov %d2,%d4
8001b330:	e9 e2 f8 ff 	st.b [%a14]-8,%d2
  LWIP_ASSERT_CORE_LOCKED();
  return tcp_listen_with_backlog_and_err(pcb, backlog, NULL);
8001b334:	39 e2 f8 ff 	ld.bu %d2,[%a14]-8
8001b338:	a0 05       	mov.a %a5,0
8001b33a:	02 24       	mov %d4,%d2
8001b33c:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001b340:	6d 00 05 00 	call 8001b34a <tcp_listen_with_backlog_and_err>
8001b344:	80 22       	mov.d %d2,%a2
}
8001b346:	60 22       	mov.a %a2,%d2
8001b348:	00 90       	ret 

8001b34a <tcp_listen_with_backlog_and_err>:
 *       called like this:
 *             tpcb = tcp_listen_with_backlog_and_err(tpcb, backlog, &err);
 */
struct tcp_pcb *
tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err)
{
8001b34a:	40 ae       	mov.aa %a14,%sp
8001b34c:	20 30       	sub.a %sp,48
8001b34e:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8001b352:	02 42       	mov %d2,%d4
8001b354:	b5 e5 e4 ff 	st.a [%a14]-28,%a5
8001b358:	e9 e2 e8 ff 	st.b [%a14]-24,%d2
  struct tcp_pcb_listen *lpcb = NULL;
8001b35c:	82 02       	mov %d2,0
8001b35e:	59 e2 fc ff 	st.w [%a14]-4,%d2

  LWIP_UNUSED_ARG(backlog);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_listen_with_backlog_and_err: invalid pcb", pcb != NULL, res = ERR_ARG; goto done);
8001b362:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001b366:	df 02 1d 80 	jne %d2,0,8001b3a0 <tcp_listen_with_backlog_and_err+0x56>
8001b36a:	91 00 00 28 	movh.a %a2,32768
8001b36e:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b372:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b376:	3b 90 35 20 	mov %d2,857
8001b37a:	59 a2 04 00 	st.w [%sp]4,%d2
8001b37e:	91 00 00 28 	movh.a %a2,32768
8001b382:	d9 22 08 12 	lea %a2,[%a2]8264 <80002048 <IfxCpu_Trap_vectorTable0_end+0x1e54>>
8001b386:	f4 a2       	st.a [%sp],%a2
8001b388:	91 00 00 28 	movh.a %a2,32768
8001b38c:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b390:	6d ff d3 4f 	call 80005336 <Ifx_Lwip_printf>
8001b394:	3b 00 ff 2f 	mov %d2,-16
8001b398:	e9 e2 fb ff 	st.b [%a14]-5,%d2
8001b39c:	1d 00 f6 00 	j 8001b588 <tcp_listen_with_backlog_and_err+0x23e>
  LWIP_ERROR("tcp_listen_with_backlog_and_err: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
8001b3a0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b3a4:	d9 22 14 00 	lea %a2,[%a2]20
8001b3a8:	54 22       	ld.w %d2,[%a2]
8001b3aa:	df 02 1d 00 	jeq %d2,0,8001b3e4 <tcp_listen_with_backlog_and_err+0x9a>
8001b3ae:	91 00 00 28 	movh.a %a2,32768
8001b3b2:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b3b6:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b3ba:	3b a0 35 20 	mov %d2,858
8001b3be:	59 a2 04 00 	st.w [%sp]4,%d2
8001b3c2:	91 00 00 28 	movh.a %a2,32768
8001b3c6:	d9 22 35 12 	lea %a2,[%a2]8309 <80002075 <IfxCpu_Trap_vectorTable0_end+0x1e81>>
8001b3ca:	f4 a2       	st.a [%sp],%a2
8001b3cc:	91 00 00 28 	movh.a %a2,32768
8001b3d0:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b3d4:	6d ff b1 4f 	call 80005336 <Ifx_Lwip_printf>
8001b3d8:	3b 10 ff 2f 	mov %d2,-15
8001b3dc:	e9 e2 fb ff 	st.b [%a14]-5,%d2
8001b3e0:	1d 00 d4 00 	j 8001b588 <tcp_listen_with_backlog_and_err+0x23e>

  /* already listening? */
  if (pcb->state == LISTEN) {
8001b3e4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b3e8:	d9 22 14 00 	lea %a2,[%a2]20
8001b3ec:	54 22       	ld.w %d2,[%a2]
8001b3ee:	df 12 0c 80 	jne %d2,1,8001b406 <tcp_listen_with_backlog_and_err+0xbc>
    lpcb = (struct tcp_pcb_listen *)pcb;
8001b3f2:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001b3f6:	59 e2 fc ff 	st.w [%a14]-4,%d2
    res = ERR_ALREADY;
8001b3fa:	3b 70 ff 2f 	mov %d2,-9
8001b3fe:	e9 e2 fb ff 	st.b [%a14]-5,%d2
    goto done;
8001b402:	1d 00 c3 00 	j 8001b588 <tcp_listen_with_backlog_and_err+0x23e>
        goto done;
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
8001b406:	82 24       	mov %d4,2
8001b408:	6d ff e1 ea 	call 800189ca <memp_malloc>
8001b40c:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (lpcb == NULL) {
8001b410:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001b414:	df 02 07 80 	jne %d2,0,8001b422 <tcp_listen_with_backlog_and_err+0xd8>
    res = ERR_MEM;
8001b418:	82 f2       	mov %d2,-1
8001b41a:	e9 e2 fb ff 	st.b [%a14]-5,%d2
    goto done;
8001b41e:	1d 00 b5 00 	j 8001b588 <tcp_listen_with_backlog_and_err+0x23e>
  }
  lpcb->callback_arg = pcb->callback_arg;
8001b422:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b426:	d9 22 10 00 	lea %a2,[%a2]16
8001b42a:	54 22       	ld.w %d2,[%a2]
8001b42c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b430:	d9 22 10 00 	lea %a2,[%a2]16
8001b434:	74 22       	st.w [%a2],%d2
  lpcb->local_port = pcb->local_port;
8001b436:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b43a:	b9 22 1a 00 	ld.hu %d2,[%a2]26
8001b43e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b442:	f9 22 1a 00 	st.h [%a2]26,%d2
  lpcb->state = LISTEN;
8001b446:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b44a:	82 12       	mov %d2,1
8001b44c:	d9 22 14 00 	lea %a2,[%a2]20
8001b450:	74 22       	st.w [%a2],%d2
  lpcb->prio = pcb->prio;
8001b452:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b456:	39 22 18 00 	ld.bu %d2,[%a2]24
8001b45a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b45e:	e9 22 18 00 	st.b [%a2]24,%d2
  lpcb->so_options = pcb->so_options;
8001b462:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b466:	39 22 09 00 	ld.bu %d2,[%a2]9
8001b46a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b46e:	e9 22 09 00 	st.b [%a2]9,%d2
  lpcb->netif_idx = NETIF_NO_INDEX;
8001b472:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b476:	82 02       	mov %d2,0
8001b478:	e9 22 08 00 	st.b [%a2]8,%d2
  lpcb->ttl = pcb->ttl;
8001b47c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b480:	39 22 0b 00 	ld.bu %d2,[%a2]11
8001b484:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b488:	e9 22 0b 00 	st.b [%a2]11,%d2
  lpcb->tos = pcb->tos;
8001b48c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b490:	39 22 0a 00 	ld.bu %d2,[%a2]10
8001b494:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b498:	e9 22 0a 00 	st.b [%a2]10,%d2
#if LWIP_IPV4 && LWIP_IPV6
  IP_SET_TYPE_VAL(lpcb->remote_ip, pcb->local_ip.type);
#endif /* LWIP_IPV4 && LWIP_IPV6 */
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
8001b49c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b4a0:	54 22       	ld.w %d2,[%a2]
8001b4a2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b4a6:	74 22       	st.w [%a2],%d2
  if (pcb->local_port != 0) {
8001b4a8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b4ac:	b9 22 1a 00 	ld.hu %d2,[%a2]26
8001b4b0:	df 02 49 00 	jeq %d2,0,8001b542 <tcp_listen_with_backlog_and_err+0x1f8>
    TCP_RMV(&tcp_bound_pcbs, pcb);
8001b4b4:	91 10 00 27 	movh.a %a2,28673
8001b4b8:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001b4bc:	54 22       	ld.w %d2,[%a2]
8001b4be:	19 e3 ec ff 	ld.w %d3,[%a14]-20 <700145b4 <tcp_bound_pcbs>>
8001b4c2:	5f 23 11 80 	jne %d3,%d2,8001b4e4 <tcp_listen_with_backlog_and_err+0x19a>
8001b4c6:	91 10 00 27 	movh.a %a2,28673
8001b4ca:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001b4ce:	d4 22       	ld.a %a2,[%a2]
8001b4d0:	d9 22 0c 00 	lea %a2,[%a2]12 <700145b4 <tcp_bound_pcbs>>
8001b4d4:	54 22       	ld.w %d2,[%a2]
8001b4d6:	91 10 00 27 	movh.a %a2,28673
8001b4da:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001b4de:	74 22       	st.w [%a2],%d2
8001b4e0:	1d 00 2b 00 	j 8001b536 <tcp_listen_with_backlog_and_err+0x1ec>
8001b4e4:	91 10 00 27 	movh.a %a2,28673
8001b4e8:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001b4ec:	54 22       	ld.w %d2,[%a2]
8001b4ee:	59 e2 f4 ff 	st.w [%a14]-12 <700145b4 <tcp_bound_pcbs>>,%d2
8001b4f2:	1d 00 1e 00 	j 8001b52e <tcp_listen_with_backlog_and_err+0x1e4>
8001b4f6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b4fa:	d9 22 0c 00 	lea %a2,[%a2]12
8001b4fe:	54 22       	ld.w %d2,[%a2]
8001b500:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8001b504:	5f 23 0e 80 	jne %d3,%d2,8001b520 <tcp_listen_with_backlog_and_err+0x1d6>
8001b508:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b50c:	d9 22 0c 00 	lea %a2,[%a2]12
8001b510:	54 22       	ld.w %d2,[%a2]
8001b512:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b516:	d9 22 0c 00 	lea %a2,[%a2]12
8001b51a:	74 22       	st.w [%a2],%d2
8001b51c:	1d 00 0d 00 	j 8001b536 <tcp_listen_with_backlog_and_err+0x1ec>
8001b520:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b524:	d9 22 0c 00 	lea %a2,[%a2]12
8001b528:	54 22       	ld.w %d2,[%a2]
8001b52a:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8001b52e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001b532:	df 02 e2 ff 	jne %d2,0,8001b4f6 <tcp_listen_with_backlog_and_err+0x1ac>
8001b536:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001b53a:	82 02       	mov %d2,0
8001b53c:	d9 22 0c 00 	lea %a2,[%a2]12
8001b540:	74 22       	st.w [%a2],%d2
  }
#if LWIP_TCP_PCB_NUM_EXT_ARGS
  /* copy over ext_args to listening pcb  */
  memcpy(&lpcb->ext_args, &pcb->ext_args, sizeof(pcb->ext_args));
#endif
  tcp_free(pcb);
8001b542:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8001b546:	6d ff 5e f9 	call 8001a802 <tcp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
8001b54a:	99 e3 fc ff 	ld.a %a3,[%a14]-4
8001b54e:	91 20 00 28 	movh.a %a2,32770
8001b552:	d9 22 14 bb 	lea %a2,[%a2]-19756 <8001b2d4 <tcp_accept_null>>
8001b556:	d9 33 1c 00 	lea %a3,[%a3]28 <8001b2d4 <tcp_accept_null>>
8001b55a:	f4 32       	st.a [%a3],%a2
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  tcp_backlog_set(lpcb, backlog);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
8001b55c:	91 10 00 27 	movh.a %a2,28673
8001b560:	d9 22 78 64 	lea %a2,[%a2]17848 <700145b8 <tcp_listen_pcbs>>
8001b564:	54 22       	ld.w %d2,[%a2]
8001b566:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b8 <tcp_listen_pcbs>>
8001b56a:	d9 22 0c 00 	lea %a2,[%a2]12 <700145b8 <tcp_listen_pcbs>>
8001b56e:	74 22       	st.w [%a2],%d2
8001b570:	91 10 00 27 	movh.a %a2,28673
8001b574:	d9 22 78 64 	lea %a2,[%a2]17848 <700145b8 <tcp_listen_pcbs>>
8001b578:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <700145b8 <tcp_listen_pcbs>>
8001b57c:	74 22       	st.w [%a2],%d2
8001b57e:	6d 00 25 4c 	call 80024dc8 <tcp_timer_needed>
  res = ERR_OK;
8001b582:	82 02       	mov %d2,0
8001b584:	e9 e2 fb ff 	st.b [%a14]-5,%d2
done:
  if (err != NULL) {
8001b588:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8001b58c:	df 02 07 00 	jeq %d2,0,8001b59a <tcp_listen_with_backlog_and_err+0x250>
    *err = res;
8001b590:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001b594:	79 e2 fb ff 	ld.b %d2,[%a14]-5
8001b598:	34 22       	st.b [%a2],%d2
  }
  return (struct tcp_pcb *)lpcb;
8001b59a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8001b59e:	60 22       	mov.a %a2,%d2
8001b5a0:	00 90       	ret 

8001b5a2 <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t
tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
8001b5a2:	40 ae       	mov.aa %a14,%sp
8001b5a4:	20 20       	sub.a %sp,32
8001b5a6:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  u32_t new_right_edge;

  LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
8001b5aa:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001b5ae:	df 02 17 80 	jne %d2,0,8001b5dc <tcp_update_rcv_ann_wnd+0x3a>
8001b5b2:	91 00 00 28 	movh.a %a2,32768
8001b5b6:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b5ba:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b5be:	3b 60 3a 20 	mov %d2,934
8001b5c2:	59 a2 04 00 	st.w [%sp]4,%d2
8001b5c6:	91 00 00 28 	movh.a %a2,32768
8001b5ca:	d9 22 2c 22 	lea %a2,[%a2]8364 <800020ac <IfxCpu_Trap_vectorTable0_end+0x1eb8>>
8001b5ce:	f4 a2       	st.a [%sp],%a2
8001b5d0:	91 00 00 28 	movh.a %a2,32768
8001b5d4:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b5d8:	6d ff af 4e 	call 80005336 <Ifx_Lwip_printf>
  new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
8001b5dc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b5e0:	d9 22 28 00 	lea %a2,[%a2]40
8001b5e4:	54 23       	ld.w %d3,[%a2]
8001b5e6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b5ea:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8001b5ee:	42 32       	add %d2,%d3
8001b5f0:	59 e2 fc ff 	st.w [%a14]-4,%d2

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
8001b5f4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b5f8:	d9 22 30 00 	lea %a2,[%a2]48
8001b5fc:	54 23       	ld.w %d3,[%a2]
8001b5fe:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b602:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001b606:	3b 00 43 40 	mov %d4,1072
8001b60a:	0b 42 90 21 	min.u %d2,%d2,%d4
8001b60e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001b612:	42 32       	add %d2,%d3
8001b614:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8001b618:	0b 23 80 20 	sub %d2,%d3,%d2
8001b61c:	bf 02 14 00 	jlt %d2,0,8001b644 <tcp_update_rcv_ann_wnd+0xa2>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
8001b620:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b624:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8001b628:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b62c:	f9 22 2e 00 	st.h [%a2]46,%d2
    return new_right_edge - pcb->rcv_ann_right_edge;
8001b630:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b634:	d9 22 30 00 	lea %a2,[%a2]48
8001b638:	54 22       	ld.w %d2,[%a2]
8001b63a:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8001b63e:	0b 23 80 20 	sub %d2,%d3,%d2
8001b642:	00 90       	ret 
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
8001b644:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b648:	d9 22 28 00 	lea %a2,[%a2]40
8001b64c:	54 23       	ld.w %d3,[%a2]
8001b64e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b652:	d9 22 30 00 	lea %a2,[%a2]48
8001b656:	54 22       	ld.w %d2,[%a2]
8001b658:	0b 23 80 20 	sub %d2,%d3,%d2
8001b65c:	bf 12 09 00 	jlt %d2,1,8001b66e <tcp_update_rcv_ann_wnd+0xcc>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
8001b660:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b664:	82 02       	mov %d2,0
8001b666:	f9 22 2e 00 	st.h [%a2]46,%d2
8001b66a:	1d 00 33 00 	j 8001b6d0 <tcp_update_rcv_ann_wnd+0x12e>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
8001b66e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b672:	d9 22 30 00 	lea %a2,[%a2]48
8001b676:	54 23       	ld.w %d3,[%a2]
8001b678:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b67c:	d9 22 28 00 	lea %a2,[%a2]40
8001b680:	54 22       	ld.w %d2,[%a2]
8001b682:	0b 23 80 20 	sub %d2,%d3,%d2
8001b686:	59 e2 f8 ff 	st.w [%a14]-8,%d2
#if !LWIP_WND_SCALE
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
8001b68a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001b68e:	7b 10 00 30 	movh %d3,1
8001b692:	3f 32 17 80 	jlt.u %d2,%d3,8001b6c0 <tcp_update_rcv_ann_wnd+0x11e>
8001b696:	91 00 00 28 	movh.a %a2,32768
8001b69a:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b69e:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b6a2:	3b 60 3b 20 	mov %d2,950
8001b6a6:	59 a2 04 00 	st.w [%sp]4,%d2
8001b6aa:	91 00 00 28 	movh.a %a2,32768
8001b6ae:	d9 22 10 32 	lea %a2,[%a2]8400 <800020d0 <IfxCpu_Trap_vectorTable0_end+0x1edc>>
8001b6b2:	f4 a2       	st.a [%sp],%a2
8001b6b4:	91 00 00 28 	movh.a %a2,32768
8001b6b8:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b6bc:	6d ff 3d 4e 	call 80005336 <Ifx_Lwip_printf>
#endif
      pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
8001b6c0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001b6c4:	37 02 70 20 	extr.u %d2,%d2,0,16
8001b6c8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b6cc:	f9 22 2e 00 	st.h [%a2]46,%d2
    }
    return 0;
8001b6d0:	82 02       	mov %d2,0
  }
}
8001b6d2:	00 90       	ret 

8001b6d4 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
8001b6d4:	40 ae       	mov.aa %a14,%sp
8001b6d6:	20 20       	sub.a %sp,32
8001b6d8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001b6dc:	02 42       	mov %d2,%d4
8001b6de:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
  u32_t wnd_inflation;
  tcpwnd_size_t rcv_wnd;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
8001b6e2:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001b6e6:	df 02 18 80 	jne %d2,0,8001b716 <tcp_recved+0x42>
8001b6ea:	91 00 00 28 	movh.a %a2,32768
8001b6ee:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b6f2:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b6f6:	3b f0 3c 20 	mov %d2,975
8001b6fa:	59 a2 04 00 	st.w [%sp]4,%d2
8001b6fe:	91 00 00 28 	movh.a %a2,32768
8001b702:	d9 22 2a 32 	lea %a2,[%a2]8426 <800020ea <IfxCpu_Trap_vectorTable0_end+0x1ef6>>
8001b706:	f4 a2       	st.a [%sp],%a2
8001b708:	91 00 00 28 	movh.a %a2,32768
8001b70c:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b710:	6d ff 13 4e 	call 80005336 <Ifx_Lwip_printf>
8001b714:	00 90       	ret 

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
8001b716:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b71a:	d9 22 14 00 	lea %a2,[%a2]20
8001b71e:	54 22       	ld.w %d2,[%a2]
8001b720:	df 12 17 80 	jne %d2,1,8001b74e <tcp_recved+0x7a>
8001b724:	91 00 00 28 	movh.a %a2,32768
8001b728:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b72c:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b730:	3b 20 3d 20 	mov %d2,978
8001b734:	59 a2 04 00 	st.w [%sp]4,%d2
8001b738:	91 00 00 28 	movh.a %a2,32768
8001b73c:	d9 22 02 42 	lea %a2,[%a2]8450 <80002102 <IfxCpu_Trap_vectorTable0_end+0x1f0e>>
8001b740:	f4 a2       	st.a [%sp],%a2
8001b742:	91 00 00 28 	movh.a %a2,32768
8001b746:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b74a:	6d ff f6 4d 	call 80005336 <Ifx_Lwip_printf>
              pcb->state != LISTEN);

  rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
8001b74e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b752:	b9 23 2c 00 	ld.hu %d3,[%a2]44
8001b756:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
8001b75a:	42 32       	add %d2,%d3
8001b75c:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
8001b760:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8001b764:	3b 10 86 30 	mov %d3,2145
8001b768:	7f 32 0a 80 	jge.u %d2,%d3,8001b77c <tcp_recved+0xa8>
8001b76c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b770:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8001b774:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
8001b778:	7f 23 0a 80 	jge.u %d3,%d2,8001b78c <tcp_recved+0xb8>
    /* window got too big or tcpwnd_size_t overflow */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: window got too big or tcpwnd_size_t overflow\n"));
    pcb->rcv_wnd = TCP_WND_MAX(pcb);
8001b77c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b780:	3b 00 86 20 	mov %d2,2144
8001b784:	f9 22 2c 00 	st.h [%a2]44,%d2
8001b788:	1d 00 08 00 	j 8001b798 <tcp_recved+0xc4>
  } else  {
    pcb->rcv_wnd = rcv_wnd;
8001b78c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b790:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8001b794:	f9 22 2c 00 	st.h [%a2]44,%d2
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
8001b798:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001b79c:	6d ff 03 ff 	call 8001b5a2 <tcp_update_rcv_ann_wnd>
8001b7a0:	59 e2 f8 ff 	st.w [%a14]-8,%d2

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
8001b7a4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001b7a8:	3b 80 21 30 	mov %d3,536
8001b7ac:	3f 32 12 80 	jlt.u %d2,%d3,8001b7d0 <tcp_recved+0xfc>
    tcp_ack_now(pcb);
8001b7b0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b7b4:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001b7b8:	8f 22 40 21 	or %d2,%d2,2
8001b7bc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001b7c0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001b7c4:	f9 22 1e 00 	st.h [%a2]30,%d2
    tcp_output(pcb);
8001b7c8:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001b7cc:	6d 00 e4 3d 	call 80023394 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
                          len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
}
8001b7d0:	00 90       	ret 

8001b7d2 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
8001b7d2:	40 ae       	mov.aa %a14,%sp
8001b7d4:	20 08       	sub.a %sp,8
  u8_t i;
  u16_t n = 0;
8001b7d6:	82 02       	mov %d2,0
8001b7d8:	f9 e2 fc ff 	st.h [%a14]-4,%d2
  struct tcp_pcb *pcb;

again:
  tcp_port++;
8001b7dc:	91 10 00 27 	movh.a %a2,28673
8001b7e0:	d9 22 b0 4a 	lea %a2,[%a2]-22224 <7000a930 <tcp_port>>
8001b7e4:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001b7e8:	c2 12       	add %d2,1
8001b7ea:	37 02 70 20 	extr.u %d2,%d2,0,16
8001b7ee:	91 10 00 27 	movh.a %a2,28673
8001b7f2:	d9 22 b0 4a 	lea %a2,[%a2]-22224 <7000a930 <tcp_port>>
8001b7f6:	b4 22       	st.h [%a2],%d2
  if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
8001b7f8:	91 10 00 27 	movh.a %a2,28673
8001b7fc:	d9 22 b0 4a 	lea %a2,[%a2]-22224 <7000a930 <tcp_port>>
8001b800:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001b804:	bb f0 ff 3f 	mov.u %d3,65535
8001b808:	5f 32 09 80 	jne %d2,%d3,8001b81a <tcp_new_port+0x48>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
8001b80c:	91 10 00 27 	movh.a %a2,28673
8001b810:	d9 22 b0 4a 	lea %a2,[%a2]-22224 <7000a930 <tcp_port>>
8001b814:	3b 00 00 2c 	mov %d2,-16384
8001b818:	b4 22       	st.h [%a2],%d2
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
8001b81a:	82 02       	mov %d2,0
8001b81c:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8001b820:	1d 00 3a 00 	j 8001b894 <tcp_new_port+0xc2>
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
8001b824:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8001b828:	91 00 00 28 	movh.a %a2,32768
8001b82c:	d9 22 50 84 	lea %a2,[%a2]17936 <80004610 <tcp_pcb_lists>>
8001b830:	06 22       	sh %d2,2
8001b832:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8001b836:	d4 22       	ld.a %a2,[%a2]
8001b838:	54 22       	ld.w %d2,[%a2]
8001b83a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8001b83e:	1d 00 22 00 	j 8001b882 <tcp_new_port+0xb0>
      if (pcb->local_port == tcp_port) {
8001b842:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001b846:	b9 23 1a 00 	ld.hu %d3,[%a2]26
8001b84a:	91 10 00 27 	movh.a %a2,28673
8001b84e:	d9 22 b0 4a 	lea %a2,[%a2]-22224 <7000a930 <tcp_port>>
8001b852:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001b856:	5f 23 0f 80 	jne %d3,%d2,8001b874 <tcp_new_port+0xa2>
        n++;
8001b85a:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8001b85e:	c2 12       	add %d2,1
8001b860:	f9 e2 fc ff 	st.h [%a14]-4,%d2
        if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
8001b864:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8001b868:	3b 00 00 34 	mov %d3,16384
8001b86c:	3f 32 b8 ff 	jlt.u %d2,%d3,8001b7dc <tcp_new_port+0xa>
          return 0;
8001b870:	82 02       	mov %d2,0
8001b872:	00 90       	ret 
    for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
8001b874:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001b878:	d9 22 0c 00 	lea %a2,[%a2]12
8001b87c:	54 22       	ld.w %d2,[%a2]
8001b87e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8001b882:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001b886:	df 02 de ff 	jne %d2,0,8001b842 <tcp_new_port+0x70>
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
8001b88a:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8001b88e:	c2 12       	add %d2,1
8001b890:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8001b894:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8001b898:	bf 42 c6 ff 	jlt.u %d2,4,8001b824 <tcp_new_port+0x52>
        }
        goto again;
      }
    }
  }
  return tcp_port;
8001b89c:	91 10 00 27 	movh.a %a2,28673
8001b8a0:	d9 22 b0 4a 	lea %a2,[%a2]-22224 <7000a930 <tcp_port>>
8001b8a4:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
}
8001b8a8:	00 90       	ret 

8001b8aa <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
8001b8aa:	40 ae       	mov.aa %a14,%sp
8001b8ac:	20 40       	sub.a %sp,64
  tcpwnd_size_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
8001b8ae:	82 02       	mov %d2,0
8001b8b0:	e9 e2 f5 ff 	st.b [%a14]-11,%d2

  ++tcp_ticks;
8001b8b4:	91 10 00 27 	movh.a %a2,28673
8001b8b8:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001b8bc:	54 22       	ld.w %d2,[%a2]
8001b8be:	c2 12       	add %d2,1
8001b8c0:	91 10 00 27 	movh.a %a2,28673
8001b8c4:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001b8c8:	74 22       	st.w [%a2],%d2
  ++tcp_timer_ctr;
8001b8ca:	91 10 00 27 	movh.a %a2,28673
8001b8ce:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001b8d2:	14 22       	ld.bu %d2,[%a2]
8001b8d4:	c2 12       	add %d2,1
8001b8d6:	8f f2 0f 21 	and %d2,%d2,255
8001b8da:	91 10 00 27 	movh.a %a2,28673
8001b8de:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001b8e2:	34 22       	st.b [%a2],%d2

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
8001b8e4:	82 02       	mov %d2,0
8001b8e6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  pcb = tcp_active_pcbs;
8001b8ea:	91 10 00 27 	movh.a %a2,28673
8001b8ee:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001b8f2:	54 22       	ld.w %d2,[%a2]
8001b8f4:	59 e2 fc ff 	st.w [%a14]-4 <700145bc <tcp_active_pcbs>>,%d2
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
8001b8f8:	1d 00 26 04 	j 8001c144 <tcp_slowtmr+0x89a>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
8001b8fc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b900:	d9 22 14 00 	lea %a2,[%a2]20
8001b904:	54 22       	ld.w %d2,[%a2]
8001b906:	df 02 17 80 	jne %d2,0,8001b934 <tcp_slowtmr+0x8a>
8001b90a:	91 00 00 28 	movh.a %a2,32768
8001b90e:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b912:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b916:	3b e0 4b 20 	mov %d2,1214
8001b91a:	59 a2 04 00 	st.w [%sp]4,%d2
8001b91e:	91 00 00 28 	movh.a %a2,32768
8001b922:	d9 22 0d 62 	lea %a2,[%a2]8589 <8000218d <IfxCpu_Trap_vectorTable0_end+0x1f99>>
8001b926:	f4 a2       	st.a [%sp],%a2
8001b928:	91 00 00 28 	movh.a %a2,32768
8001b92c:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b930:	6d ff 03 4d 	call 80005336 <Ifx_Lwip_printf>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
8001b934:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b938:	d9 22 14 00 	lea %a2,[%a2]20
8001b93c:	54 22       	ld.w %d2,[%a2]
8001b93e:	df 12 17 80 	jne %d2,1,8001b96c <tcp_slowtmr+0xc2>
8001b942:	91 00 00 28 	movh.a %a2,32768
8001b946:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b94a:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b94e:	3b f0 4b 20 	mov %d2,1215
8001b952:	59 a2 04 00 	st.w [%sp]4,%d2
8001b956:	91 00 00 28 	movh.a %a2,32768
8001b95a:	d9 22 37 62 	lea %a2,[%a2]8631 <800021b7 <IfxCpu_Trap_vectorTable0_end+0x1fc3>>
8001b95e:	f4 a2       	st.a [%sp],%a2
8001b960:	91 00 00 28 	movh.a %a2,32768
8001b964:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b968:	6d ff e7 4c 	call 80005336 <Ifx_Lwip_printf>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
8001b96c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b970:	d9 22 14 00 	lea %a2,[%a2]20
8001b974:	54 22       	ld.w %d2,[%a2]
8001b976:	8b a2 20 22 	ne %d2,%d2,10
8001b97a:	df 02 17 80 	jne %d2,0,8001b9a8 <tcp_slowtmr+0xfe>
8001b97e:	91 00 00 28 	movh.a %a2,32768
8001b982:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001b986:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001b98a:	3b 00 4c 20 	mov %d2,1216
8001b98e:	59 a2 04 00 	st.w [%sp]4,%d2
8001b992:	91 00 00 28 	movh.a %a2,32768
8001b996:	d9 22 21 72 	lea %a2,[%a2]8673 <800021e1 <IfxCpu_Trap_vectorTable0_end+0x1fed>>
8001b99a:	f4 a2       	st.a [%sp],%a2
8001b99c:	91 00 00 28 	movh.a %a2,32768
8001b9a0:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001b9a4:	6d ff c9 4c 	call 80005336 <Ifx_Lwip_printf>
    if (pcb->last_timer == tcp_timer_ctr) {
8001b9a8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b9ac:	39 23 22 00 	ld.bu %d3,[%a2]34
8001b9b0:	91 10 00 27 	movh.a %a2,28673
8001b9b4:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001b9b8:	14 22       	ld.bu %d2,[%a2]
8001b9ba:	5f 23 0f 80 	jne %d3,%d2,8001b9d8 <tcp_slowtmr+0x12e>
      /* skip this pcb, we have already processed it */
      prev = pcb;
8001b9be:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001b9c2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      pcb = pcb->next;
8001b9c6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b9ca:	d9 22 0c 00 	lea %a2,[%a2]12
8001b9ce:	54 22       	ld.w %d2,[%a2]
8001b9d0:	59 e2 fc ff 	st.w [%a14]-4,%d2
      continue;
8001b9d4:	1d 00 b8 03 	j 8001c144 <tcp_slowtmr+0x89a>
    }
    pcb->last_timer = tcp_timer_ctr;
8001b9d8:	91 10 00 27 	movh.a %a2,28673
8001b9dc:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001b9e0:	14 22       	ld.bu %d2,[%a2]
8001b9e2:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145c6 <tcp_timer_ctr>>
8001b9e6:	e9 22 22 00 	st.b [%a2]34 <700145c6 <tcp_timer_ctr>>,%d2

    pcb_remove = 0;
8001b9ea:	82 02       	mov %d2,0
8001b9ec:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
    pcb_reset = 0;
8001b9f0:	82 02       	mov %d2,0
8001b9f2:	e9 e2 f6 ff 	st.b [%a14]-10,%d2

    if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
8001b9f6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001b9fa:	d9 22 14 00 	lea %a2,[%a2]20
8001b9fe:	54 22       	ld.w %d2,[%a2]
8001ba00:	df 22 0f 80 	jne %d2,2,8001ba1e <tcp_slowtmr+0x174>
8001ba04:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ba08:	39 22 06 10 	ld.bu %d2,[%a2]70
8001ba0c:	bf 62 09 80 	jlt.u %d2,6,8001ba1e <tcp_slowtmr+0x174>
      ++pcb_remove;
8001ba10:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001ba14:	c2 12       	add %d2,1
8001ba16:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
8001ba1a:	1d 00 81 01 	j 8001bd1c <tcp_slowtmr+0x472>
    } else if (pcb->nrtx >= TCP_MAXRTX) {
8001ba1e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ba22:	39 22 06 10 	ld.bu %d2,[%a2]70
8001ba26:	bf c2 09 80 	jlt.u %d2,12,8001ba38 <tcp_slowtmr+0x18e>
      ++pcb_remove;
8001ba2a:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001ba2e:	c2 12       	add %d2,1
8001ba30:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
8001ba34:	1d 00 74 01 	j 8001bd1c <tcp_slowtmr+0x472>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
8001ba38:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ba3c:	39 22 1d 20 	ld.bu %d2,[%a2]157
8001ba40:	df 02 b5 00 	jeq %d2,0,8001bbaa <tcp_slowtmr+0x300>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
8001ba44:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ba48:	d9 22 34 10 	lea %a2,[%a2]116
8001ba4c:	54 22       	ld.w %d2,[%a2]
8001ba4e:	df 02 17 00 	jeq %d2,0,8001ba7c <tcp_slowtmr+0x1d2>
8001ba52:	91 00 00 28 	movh.a %a2,32768
8001ba56:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001ba5a:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001ba5e:	3b 40 4d 20 	mov %d2,1236
8001ba62:	59 a2 04 00 	st.w [%sp]4,%d2
8001ba66:	91 00 00 28 	movh.a %a2,32768
8001ba6a:	d9 22 0e 82 	lea %a2,[%a2]8718 <8000220e <IfxCpu_Trap_vectorTable0_end+0x201a>>
8001ba6e:	f4 a2       	st.a [%sp],%a2
8001ba70:	91 00 00 28 	movh.a %a2,32768
8001ba74:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001ba78:	6d ff 5f 4c 	call 80005336 <Ifx_Lwip_printf>
        LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
8001ba7c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ba80:	d9 22 30 10 	lea %a2,[%a2]112
8001ba84:	54 22       	ld.w %d2,[%a2]
8001ba86:	df 02 17 80 	jne %d2,0,8001bab4 <tcp_slowtmr+0x20a>
8001ba8a:	91 00 00 28 	movh.a %a2,32768
8001ba8e:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001ba92:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001ba96:	3b 50 4d 20 	mov %d2,1237
8001ba9a:	59 a2 04 00 	st.w [%sp]4,%d2
8001ba9e:	91 00 00 28 	movh.a %a2,32768
8001baa2:	d9 22 00 92 	lea %a2,[%a2]8768 <80002240 <IfxCpu_Trap_vectorTable0_end+0x204c>>
8001baa6:	f4 a2       	st.a [%sp],%a2
8001baa8:	91 00 00 28 	movh.a %a2,32768
8001baac:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001bab0:	6d ff 43 4c 	call 80005336 <Ifx_Lwip_printf>
        if (pcb->persist_probe >= TCP_MAXRTX) {
8001bab4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bab8:	39 22 1e 20 	ld.bu %d2,[%a2]158
8001babc:	bf c2 09 80 	jlt.u %d2,12,8001bace <tcp_slowtmr+0x224>
          ++pcb_remove; /* max probes reached */
8001bac0:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001bac4:	c2 12       	add %d2,1
8001bac6:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
8001baca:	1d 00 29 01 	j 8001bd1c <tcp_slowtmr+0x472>
        } else {
          u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
8001bace:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bad2:	39 22 1d 20 	ld.bu %d2,[%a2]157
8001bad6:	c2 f2       	add %d2,-1
8001bad8:	91 00 00 28 	movh.a %a2,32768
8001badc:	d9 22 49 84 	lea %a2,[%a2]17929 <80004609 <tcp_persist_backoff>>
8001bae0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8001bae4:	79 22 00 00 	ld.b %d2,[%a2]0
8001bae8:	e9 e2 e1 ff 	st.b [%a14]-31,%d2
          if (pcb->persist_cnt < backoff_cnt) {
8001baec:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001baf0:	39 23 1c 20 	ld.bu %d3,[%a2]156
8001baf4:	39 e2 e1 ff 	ld.bu %d2,[%a14]-31
8001baf8:	7f 23 0d 80 	jge.u %d3,%d2,8001bb12 <tcp_slowtmr+0x268>
            pcb->persist_cnt++;
8001bafc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bb00:	39 22 1c 20 	ld.bu %d2,[%a2]156
8001bb04:	c2 12       	add %d2,1
8001bb06:	8f f2 0f 21 	and %d2,%d2,255
8001bb0a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bb0e:	e9 22 1c 20 	st.b [%a2]156,%d2
          }
          if (pcb->persist_cnt >= backoff_cnt) {
8001bb12:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bb16:	39 23 1c 20 	ld.bu %d3,[%a2]156
8001bb1a:	39 e2 e1 ff 	ld.bu %d2,[%a14]-31
8001bb1e:	3f 23 ff 80 	jlt.u %d3,%d2,8001bd1c <tcp_slowtmr+0x472>
            int next_slot = 1; /* increment timer to next slot */
8001bb22:	82 12       	mov %d2,1
8001bb24:	59 e2 f0 ff 	st.w [%a14]-16,%d2
            /* If snd_wnd is zero, send 1 byte probes */
            if (pcb->snd_wnd == 0) {
8001bb28:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bb2c:	b9 22 24 10 	ld.hu %d2,[%a2]100
8001bb30:	df 02 0d 80 	jne %d2,0,8001bb4a <tcp_slowtmr+0x2a0>
              if (tcp_zero_window_probe(pcb) != ERR_OK) {
8001bb34:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001bb38:	6d 00 e9 47 	call 80024b0a <tcp_zero_window_probe>
8001bb3c:	df 02 1b 00 	jeq %d2,0,8001bb72 <tcp_slowtmr+0x2c8>
                next_slot = 0; /* try probe again with current slot */
8001bb40:	82 02       	mov %d2,0
8001bb42:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8001bb46:	1d 00 16 00 	j 8001bb72 <tcp_slowtmr+0x2c8>
              }
              /* snd_wnd not fully closed, split unsent head and fill window */
            } else {
              if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
8001bb4a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bb4e:	b9 22 24 10 	ld.hu %d2,[%a2]100
8001bb52:	02 24       	mov %d4,%d2
8001bb54:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001bb58:	6d 00 c7 37 	call 80022ae6 <tcp_split_unsent_seg>
8001bb5c:	df 02 0b 80 	jne %d2,0,8001bb72 <tcp_slowtmr+0x2c8>
                if (tcp_output(pcb) == ERR_OK) {
8001bb60:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001bb64:	6d 00 18 3c 	call 80023394 <tcp_output>
8001bb68:	df 02 05 80 	jne %d2,0,8001bb72 <tcp_slowtmr+0x2c8>
                  /* sending will cancel persist timer, else retry with current slot */
                  next_slot = 0;
8001bb6c:	82 02       	mov %d2,0
8001bb6e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
                }
              }
            }
            if (next_slot) {
8001bb72:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001bb76:	df 02 d3 00 	jeq %d2,0,8001bd1c <tcp_slowtmr+0x472>
              pcb->persist_cnt = 0;
8001bb7a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bb7e:	82 02       	mov %d2,0
8001bb80:	e9 22 1c 20 	st.b [%a2]156,%d2
              if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
8001bb84:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bb88:	39 22 1d 20 	ld.bu %d2,[%a2]157
8001bb8c:	ff 72 c8 80 	jge.u %d2,7,8001bd1c <tcp_slowtmr+0x472>
                pcb->persist_backoff++;
8001bb90:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bb94:	39 22 1d 20 	ld.bu %d2,[%a2]157
8001bb98:	c2 12       	add %d2,1
8001bb9a:	8f f2 0f 21 	and %d2,%d2,255
8001bb9e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bba2:	e9 22 1d 20 	st.b [%a2]157,%d2
8001bba6:	1d 00 bb 00 	j 8001bd1c <tcp_slowtmr+0x472>
            }
          }
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
8001bbaa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bbae:	c9 22 34 00 	ld.h %d2,[%a2]52
8001bbb2:	bf 02 19 00 	jlt %d2,0,8001bbe4 <tcp_slowtmr+0x33a>
8001bbb6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bbba:	c9 22 34 00 	ld.h %d2,[%a2]52
8001bbbe:	3b f0 ff 37 	mov %d3,32767
8001bbc2:	5f 32 11 00 	jeq %d2,%d3,8001bbe4 <tcp_slowtmr+0x33a>
          ++pcb->rtime;
8001bbc6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bbca:	c9 22 34 00 	ld.h %d2,[%a2]52
8001bbce:	37 02 70 20 	extr.u %d2,%d2,0,16
8001bbd2:	c2 12       	add %d2,1
8001bbd4:	37 02 70 20 	extr.u %d2,%d2,0,16
8001bbd8:	37 02 50 20 	extr %d2,%d2,0,16
8001bbdc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bbe0:	f9 22 34 00 	st.h [%a2]52,%d2
        }

        if (pcb->rtime >= pcb->rto) {
8001bbe4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bbe8:	c9 23 34 00 	ld.h %d3,[%a2]52
8001bbec:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bbf0:	c9 22 04 10 	ld.h %d2,[%a2]68
8001bbf4:	3f 23 94 00 	jlt %d3,%d2,8001bd1c <tcp_slowtmr+0x472>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));
          /* If prepare phase fails but we have unsent data but no unacked data,
             still execute the backoff calculations below, as this means we somehow
             failed to send segment. */
          if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
8001bbf8:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001bbfc:	6d 00 4a 41 	call 80023e90 <tcp_rexmit_rto_prepare>
8001bc00:	df 02 10 00 	jeq %d2,0,8001bc20 <tcp_slowtmr+0x376>
8001bc04:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bc08:	d9 22 34 10 	lea %a2,[%a2]116
8001bc0c:	54 22       	ld.w %d2,[%a2]
8001bc0e:	df 02 87 80 	jne %d2,0,8001bd1c <tcp_slowtmr+0x472>
8001bc12:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bc16:	d9 22 30 10 	lea %a2,[%a2]112
8001bc1a:	54 22       	ld.w %d2,[%a2]
8001bc1c:	df 02 80 00 	jeq %d2,0,8001bd1c <tcp_slowtmr+0x472>
            /* Double retransmission time-out unless we are trying to
             * connect to somebody (i.e., we are in SYN_SENT). */
            if (pcb->state != SYN_SENT) {
8001bc20:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bc24:	d9 22 14 00 	lea %a2,[%a2]20
8001bc28:	54 22       	ld.w %d2,[%a2]
8001bc2a:	df 22 36 00 	jeq %d2,2,8001bc96 <tcp_slowtmr+0x3ec>
              u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
8001bc2e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bc32:	39 22 06 10 	ld.bu %d2,[%a2]70
8001bc36:	8b c2 20 23 	min.u %d2,%d2,12
8001bc3a:	e9 e2 eb ff 	st.b [%a14]-21,%d2
              int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
8001bc3e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bc42:	c9 22 00 10 	ld.h %d2,[%a2]64
8001bc46:	86 d2       	sha %d2,-3
8001bc48:	37 02 50 20 	extr %d2,%d2,0,16
8001bc4c:	02 23       	mov %d3,%d2
8001bc4e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bc52:	c9 22 02 10 	ld.h %d2,[%a2]66
8001bc56:	42 32       	add %d2,%d3
8001bc58:	39 e3 eb ff 	ld.bu %d3,[%a14]-21
8001bc5c:	91 00 00 28 	movh.a %a2,32768
8001bc60:	d9 22 7c 74 	lea %a2,[%a2]17916 <800045fc <tcp_backoff>>
8001bc64:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8001bc68:	14 23       	ld.bu %d3,[%a2]
8001bc6a:	0f 32 00 20 	sh %d2,%d2,%d3
8001bc6e:	59 e2 e4 ff 	st.w [%a14]-28,%d2
              pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
8001bc72:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8001bc76:	3b f0 ff 37 	mov %d3,32767
8001bc7a:	7f 32 08 00 	jge %d2,%d3,8001bc8a <tcp_slowtmr+0x3e0>
8001bc7e:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8001bc82:	37 02 50 20 	extr %d2,%d2,0,16
8001bc86:	1d 00 04 00 	j 8001bc8e <tcp_slowtmr+0x3e4>
8001bc8a:	3b f0 ff 27 	mov %d2,32767
8001bc8e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bc92:	f9 22 04 10 	st.h [%a2]68,%d2
            }

            /* Reset the retransmission timer. */
            pcb->rtime = 0;
8001bc96:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bc9a:	82 02       	mov %d2,0
8001bc9c:	f9 22 34 00 	st.h [%a2]52,%d2

            /* Reduce congestion window and ssthresh. */
            eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
8001bca0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bca4:	b9 23 24 10 	ld.hu %d3,[%a2]100
8001bca8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bcac:	b9 22 0c 10 	ld.hu %d2,[%a2]76
8001bcb0:	0b 23 90 21 	min.u %d2,%d3,%d2
8001bcb4:	f9 e2 e2 ff 	st.h [%a14]-30,%d2
            pcb->ssthresh = eff_wnd >> 1;
8001bcb8:	b9 e2 e2 ff 	ld.hu %d2,[%a14]-30
8001bcbc:	06 f2       	sh %d2,-1
8001bcbe:	37 02 70 20 	extr.u %d2,%d2,0,16
8001bcc2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bcc6:	f9 22 0e 10 	st.h [%a2]78,%d2
            if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
8001bcca:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bcce:	b9 23 0e 10 	ld.hu %d3,[%a2]78
8001bcd2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bcd6:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001bcda:	06 12       	sh %d2,1
8001bcdc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001bce0:	7f 23 0d 80 	jge.u %d3,%d2,8001bcfa <tcp_slowtmr+0x450>
              pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
8001bce4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bce8:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001bcec:	06 12       	sh %d2,1
8001bcee:	37 02 70 20 	extr.u %d2,%d2,0,16
8001bcf2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bcf6:	f9 22 0e 10 	st.h [%a2]78,%d2
            }
            pcb->cwnd = pcb->mss;
8001bcfa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bcfe:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001bd02:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bd06:	f9 22 0c 10 	st.h [%a2]76,%d2
            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
                                         " ssthresh %"TCPWNDSIZE_F"\n",
                                         pcb->cwnd, pcb->ssthresh));
            pcb->bytes_acked = 0;
8001bd0a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bd0e:	82 02       	mov %d2,0
8001bd10:	f9 22 2e 10 	st.h [%a2]110,%d2

            /* The following needs to be called AFTER cwnd is set to one
               mss - STJ */
            tcp_rexmit_rto_commit(pcb);
8001bd14:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001bd18:	6d 00 82 41 	call 8002401c <tcp_rexmit_rto_commit>
          }
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
8001bd1c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bd20:	d9 22 14 00 	lea %a2,[%a2]20
8001bd24:	54 22       	ld.w %d2,[%a2]
8001bd26:	df 62 1f 80 	jne %d2,6,8001bd64 <tcp_slowtmr+0x4ba>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
8001bd2a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bd2e:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001bd32:	8f 02 01 21 	and %d2,%d2,16
8001bd36:	df 02 17 00 	jeq %d2,0,8001bd64 <tcp_slowtmr+0x4ba>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
8001bd3a:	91 10 00 27 	movh.a %a2,28673
8001bd3e:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001bd42:	54 23       	ld.w %d3,[%a2]
8001bd44:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001bd48:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001bd4c:	54 22       	ld.w %d2,[%a2]
8001bd4e:	0b 23 80 20 	sub %d2,%d3,%d2
8001bd52:	8b 92 62 22 	lt.u %d2,%d2,41
8001bd56:	df 02 07 80 	jne %d2,0,8001bd64 <tcp_slowtmr+0x4ba>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
8001bd5a:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001bd5e:	c2 12       	add %d2,1
8001bd60:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
8001bd64:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bd68:	39 22 09 00 	ld.bu %d2,[%a2]9
8001bd6c:	8f 82 00 21 	and %d2,%d2,8
8001bd70:	df 02 76 00 	jeq %d2,0,8001be5c <tcp_slowtmr+0x5b2>
        ((pcb->state == ESTABLISHED) ||
8001bd74:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bd78:	d9 22 14 00 	lea %a2,[%a2]20
8001bd7c:	54 22       	ld.w %d2,[%a2]
    if (ip_get_option(pcb, SOF_KEEPALIVE) &&
8001bd7e:	df 42 09 00 	jeq %d2,4,8001bd90 <tcp_slowtmr+0x4e6>
         (pcb->state == CLOSE_WAIT))) {
8001bd82:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bd86:	d9 22 14 00 	lea %a2,[%a2]20
8001bd8a:	54 22       	ld.w %d2,[%a2]
        ((pcb->state == ESTABLISHED) ||
8001bd8c:	df 72 68 80 	jne %d2,7,8001be5c <tcp_slowtmr+0x5b2>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
8001bd90:	91 10 00 27 	movh.a %a2,28673
8001bd94:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001bd98:	54 23       	ld.w %d3,[%a2]
8001bd9a:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001bd9e:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001bda2:	54 22       	ld.w %d2,[%a2]
8001bda4:	0b 23 80 40 	sub %d4,%d3,%d2
          (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
8001bda8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bdac:	d9 22 18 20 	lea %a2,[%a2]152
8001bdb0:	54 22       	ld.w %d2,[%a2]
8001bdb2:	1b 82 cb 24 	addi %d2,%d2,19640
8001bdb6:	9b a2 00 20 	addih %d2,%d2,10
8001bdba:	7b 20 06 31 	movh %d3,4194
8001bdbe:	1b 33 dd 34 	addi %d3,%d3,19923
8001bdc2:	73 32 68 20 	mul.u %e2,%d2,%d3
8001bdc6:	8f b3 1f 20 	sh %d2,%d3,-5
      if ((u32_t)(tcp_ticks - pcb->tmr) >
8001bdca:	7f 42 0e 80 	jge.u %d2,%d4,8001bde6 <tcp_slowtmr+0x53c>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
        ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
        LWIP_DEBUGF(TCP_DEBUG, ("\n"));

        ++pcb_remove;
8001bdce:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001bdd2:	c2 12       	add %d2,1
8001bdd4:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
        ++pcb_reset;
8001bdd8:	79 e2 f6 ff 	ld.b %d2,[%a14]-10
8001bddc:	c2 12       	add %d2,1
8001bdde:	e9 e2 f6 ff 	st.b [%a14]-10,%d2
8001bde2:	1d 00 3d 00 	j 8001be5c <tcp_slowtmr+0x5b2>
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
8001bde6:	91 10 00 27 	movh.a %a2,28673
8001bdea:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001bdee:	54 23       	ld.w %d3,[%a2]
8001bdf0:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001bdf4:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001bdf8:	54 22       	ld.w %d2,[%a2]
8001bdfa:	0b 23 80 40 	sub %d4,%d3,%d2
                 (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
8001bdfe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001be02:	d9 22 18 20 	lea %a2,[%a2]152
8001be06:	54 25       	ld.w %d5,[%a2]
8001be08:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001be0c:	39 22 1f 20 	ld.bu %d2,[%a2]159
8001be10:	02 23       	mov %d3,%d2
8001be12:	7b 10 00 20 	movh %d2,1
8001be16:	1b 82 4f 22 	addi %d2,%d2,9464
8001be1a:	e2 32       	mul %d2,%d3
8001be1c:	42 52       	add %d2,%d5
                 / TCP_SLOW_INTERVAL) {
8001be1e:	7b 20 06 31 	movh %d3,4194
8001be22:	1b 33 dd 34 	addi %d3,%d3,19923
8001be26:	73 32 68 20 	mul.u %e2,%d2,%d3
8001be2a:	8f b3 1f 20 	sh %d2,%d3,-5
      } else if ((u32_t)(tcp_ticks - pcb->tmr) >
8001be2e:	7f 42 17 80 	jge.u %d2,%d4,8001be5c <tcp_slowtmr+0x5b2>
        err = tcp_keepalive(pcb);
8001be32:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001be36:	6d 00 14 46 	call 80024a5e <tcp_keepalive>
8001be3a:	e9 e2 f5 ff 	st.b [%a14]-11,%d2
        if (err == ERR_OK) {
8001be3e:	79 e2 f5 ff 	ld.b %d2,[%a14]-11
8001be42:	df 02 0d 80 	jne %d2,0,8001be5c <tcp_slowtmr+0x5b2>
          pcb->keep_cnt_sent++;
8001be46:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001be4a:	39 22 1f 20 	ld.bu %d2,[%a2]159
8001be4e:	c2 12       	add %d2,1
8001be50:	8f f2 0f 21 	and %d2,%d2,255
8001be54:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001be58:	e9 22 1f 20 	st.b [%a2]159,%d2

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
8001be5c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001be60:	d9 22 38 10 	lea %a2,[%a2]120
8001be64:	54 22       	ld.w %d2,[%a2]
8001be66:	df 02 19 00 	jeq %d2,0,8001be98 <tcp_slowtmr+0x5ee>
        (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
8001be6a:	91 10 00 27 	movh.a %a2,28673
8001be6e:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001be72:	54 23       	ld.w %d3,[%a2]
8001be74:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001be78:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001be7c:	54 22       	ld.w %d2,[%a2]
8001be7e:	a2 23       	sub %d3,%d2
8001be80:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001be84:	c9 22 04 10 	ld.h %d2,[%a2]68
8001be88:	53 62 20 20 	mul %d2,%d2,6
    if (pcb->ooseq != NULL &&
8001be8c:	3f 23 06 80 	jlt.u %d3,%d2,8001be98 <tcp_slowtmr+0x5ee>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
      tcp_free_ooseq(pcb);
8001be90:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001be94:	6d 00 53 0a 	call 8001d33a <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
8001be98:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001be9c:	d9 22 14 00 	lea %a2,[%a2]20
8001bea0:	54 22       	ld.w %d2,[%a2]
8001bea2:	df 32 17 80 	jne %d2,3,8001bed0 <tcp_slowtmr+0x626>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
8001bea6:	91 10 00 27 	movh.a %a2,28673
8001beaa:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001beae:	54 23       	ld.w %d3,[%a2]
8001beb0:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001beb4:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001beb8:	54 22       	ld.w %d2,[%a2]
8001beba:	0b 23 80 20 	sub %d2,%d3,%d2
8001bebe:	8b 92 62 22 	lt.u %d2,%d2,41
8001bec2:	df 02 07 80 	jne %d2,0,8001bed0 <tcp_slowtmr+0x626>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
8001bec6:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001beca:	c2 12       	add %d2,1
8001becc:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
8001bed0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bed4:	d9 22 14 00 	lea %a2,[%a2]20
8001bed8:	54 22       	ld.w %d2,[%a2]
8001beda:	8b 92 20 22 	ne %d2,%d2,9
8001bede:	df 02 17 80 	jne %d2,0,8001bf0c <tcp_slowtmr+0x662>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
8001bee2:	91 10 00 27 	movh.a %a2,28673
8001bee6:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001beea:	54 23       	ld.w %d3,[%a2]
8001beec:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001bef0:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001bef4:	54 22       	ld.w %d2,[%a2]
8001bef6:	0b 23 80 20 	sub %d2,%d3,%d2
8001befa:	8b 12 6f 22 	lt.u %d2,%d2,241
8001befe:	df 02 07 80 	jne %d2,0,8001bf0c <tcp_slowtmr+0x662>
        ++pcb_remove;
8001bf02:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001bf06:	c2 12       	add %d2,1
8001bf08:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
8001bf0c:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
8001bf10:	df 02 c1 00 	jeq %d2,0,8001c092 <tcp_slowtmr+0x7e8>
      struct tcp_pcb *pcb2;
#if LWIP_CALLBACK_API
      tcp_err_fn err_fn = pcb->errf;
8001bf14:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bf18:	d9 22 14 20 	lea %a2,[%a2]148
8001bf1c:	54 22       	ld.w %d2,[%a2]
8001bf1e:	59 e2 dc ff 	st.w [%a14]-36,%d2
#endif /* LWIP_CALLBACK_API */
      void *err_arg;
      enum tcp_state last_state;
      tcp_pcb_purge(pcb);
8001bf22:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001bf26:	6d 00 52 07 	call 8001cdca <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
8001bf2a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001bf2e:	df 02 2c 00 	jeq %d2,0,8001bf86 <tcp_slowtmr+0x6dc>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
8001bf32:	91 10 00 27 	movh.a %a2,28673
8001bf36:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001bf3a:	54 22       	ld.w %d2,[%a2]
8001bf3c:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700145bc <tcp_active_pcbs>>
8001bf40:	5f 23 17 80 	jne %d3,%d2,8001bf6e <tcp_slowtmr+0x6c4>
8001bf44:	91 00 00 28 	movh.a %a2,32768
8001bf48:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001bf4c:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001bf50:	3b d0 56 20 	mov %d2,1389
8001bf54:	59 a2 04 00 	st.w [%sp]4,%d2
8001bf58:	91 00 00 28 	movh.a %a2,32768
8001bf5c:	d9 22 35 92 	lea %a2,[%a2]8821 <80002275 <IfxCpu_Trap_vectorTable0_end+0x2081>>
8001bf60:	f4 a2       	st.a [%sp],%a2
8001bf62:	91 00 00 28 	movh.a %a2,32768
8001bf66:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001bf6a:	6d ff e6 49 	call 80005336 <Ifx_Lwip_printf>
        prev->next = pcb->next;
8001bf6e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bf72:	d9 22 0c 00 	lea %a2,[%a2]12
8001bf76:	54 22       	ld.w %d2,[%a2]
8001bf78:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001bf7c:	d9 22 0c 00 	lea %a2,[%a2]12
8001bf80:	74 22       	st.w [%a2],%d2
8001bf82:	1d 00 2a 00 	j 8001bfd6 <tcp_slowtmr+0x72c>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
8001bf86:	91 10 00 27 	movh.a %a2,28673
8001bf8a:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001bf8e:	54 22       	ld.w %d2,[%a2]
8001bf90:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700145bc <tcp_active_pcbs>>
8001bf94:	5f 23 17 00 	jeq %d3,%d2,8001bfc2 <tcp_slowtmr+0x718>
8001bf98:	91 00 00 28 	movh.a %a2,32768
8001bf9c:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001bfa0:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001bfa4:	3b 10 57 20 	mov %d2,1393
8001bfa8:	59 a2 04 00 	st.w [%sp]4,%d2
8001bfac:	91 00 00 28 	movh.a %a2,32768
8001bfb0:	d9 22 20 a2 	lea %a2,[%a2]8864 <800022a0 <IfxCpu_Trap_vectorTable0_end+0x20ac>>
8001bfb4:	f4 a2       	st.a [%sp],%a2
8001bfb6:	91 00 00 28 	movh.a %a2,32768
8001bfba:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001bfbe:	6d ff bc 49 	call 80005336 <Ifx_Lwip_printf>
        tcp_active_pcbs = pcb->next;
8001bfc2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bfc6:	d9 22 0c 00 	lea %a2,[%a2]12
8001bfca:	54 22       	ld.w %d2,[%a2]
8001bfcc:	91 10 00 27 	movh.a %a2,28673
8001bfd0:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001bfd4:	74 22       	st.w [%a2],%d2
      }

      if (pcb_reset) {
8001bfd6:	39 e2 f6 ff 	ld.bu %d2,[%a14]-10 <700145bc <tcp_active_pcbs>>
8001bfda:	df 02 24 00 	jeq %d2,0,8001c022 <tcp_slowtmr+0x778>
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
8001bfde:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bfe2:	d9 22 14 10 	lea %a2,[%a2]84
8001bfe6:	54 22       	ld.w %d2,[%a2]
8001bfe8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001bfec:	d9 22 28 00 	lea %a2,[%a2]40
8001bff0:	54 23       	ld.w %d3,[%a2]
8001bff2:	19 e4 fc ff 	ld.w %d4,[%a14]-4
8001bff6:	19 e5 fc ff 	ld.w %d5,[%a14]-4
8001bffa:	c2 45       	add %d5,4
                pcb->local_port, pcb->remote_port);
8001bffc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c000:	b9 26 1a 00 	ld.hu %d6,[%a2]26
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
8001c004:	02 60       	mov %d0,%d6
                pcb->local_port, pcb->remote_port);
8001c006:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c00a:	b9 26 1c 00 	ld.hu %d6,[%a2]28
        tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
8001c00e:	02 67       	mov %d7,%d6
8001c010:	02 06       	mov %d6,%d0
8001c012:	60 56       	mov.a %a6,%d5
8001c014:	60 45       	mov.a %a5,%d4
8001c016:	02 35       	mov %d5,%d3
8001c018:	02 24       	mov %d4,%d2
8001c01a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001c01e:	6d 00 0f 44 	call 8002483c <tcp_rst>
      }

      err_arg = pcb->callback_arg;
8001c022:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c026:	d9 22 10 00 	lea %a2,[%a2]16
8001c02a:	54 22       	ld.w %d2,[%a2]
8001c02c:	59 e2 d8 ff 	st.w [%a14]-40,%d2
      last_state = pcb->state;
8001c030:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c034:	d9 22 14 00 	lea %a2,[%a2]20
8001c038:	54 22       	ld.w %d2,[%a2]
8001c03a:	59 e2 d4 ff 	st.w [%a14]-44,%d2
      pcb2 = pcb;
8001c03e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c042:	59 e2 d0 ff 	st.w [%a14]-48,%d2
      pcb = pcb->next;
8001c046:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c04a:	d9 22 0c 00 	lea %a2,[%a2]12
8001c04e:	54 22       	ld.w %d2,[%a2]
8001c050:	59 e2 fc ff 	st.w [%a14]-4,%d2
      tcp_free(pcb2);
8001c054:	99 e4 d0 ff 	ld.a %a4,[%a14]-48
8001c058:	6d ff d5 f3 	call 8001a802 <tcp_free>

      tcp_active_pcbs_changed = 0;
8001c05c:	91 10 00 27 	movh.a %a2,28673
8001c060:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001c064:	82 02       	mov %d2,0
8001c066:	34 22       	st.b [%a2],%d2
      TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
8001c068:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8001c06c:	df 02 0a 00 	jeq %d2,0,8001c080 <tcp_slowtmr+0x7d6>
8001c070:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8001c074:	3b 30 ff 4f 	mov %d4,-13
8001c078:	99 e4 d8 ff 	ld.a %a4,[%a14]-40
8001c07c:	2d 02 00 00 	calli %a2
      if (tcp_active_pcbs_changed) {
8001c080:	91 10 00 27 	movh.a %a2,28673
8001c084:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001c088:	14 22       	ld.bu %d2,[%a2]
8001c08a:	df 02 5d 00 	jeq %d2,0,8001c144 <tcp_slowtmr+0x89a>
        goto tcp_slowtmr_start;
8001c08e:	1d ff 2b fc 	j 8001b8e4 <tcp_slowtmr+0x3a>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
8001c092:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c096:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      pcb = pcb->next;
8001c09a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c09e:	d9 22 0c 00 	lea %a2,[%a2]12
8001c0a2:	54 22       	ld.w %d2,[%a2]
8001c0a4:	59 e2 fc ff 	st.w [%a14]-4,%d2

      /* We check if we should poll the connection. */
      ++prev->polltmr;
8001c0a8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001c0ac:	39 22 20 00 	ld.bu %d2,[%a2]32
8001c0b0:	c2 12       	add %d2,1
8001c0b2:	8f f2 0f 21 	and %d2,%d2,255
8001c0b6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001c0ba:	e9 22 20 00 	st.b [%a2]32,%d2
      if (prev->polltmr >= prev->pollinterval) {
8001c0be:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001c0c2:	39 23 20 00 	ld.bu %d3,[%a2]32
8001c0c6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001c0ca:	39 22 21 00 	ld.bu %d2,[%a2]33
8001c0ce:	3f 23 3b 80 	jlt.u %d3,%d2,8001c144 <tcp_slowtmr+0x89a>
        prev->polltmr = 0;
8001c0d2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001c0d6:	82 02       	mov %d2,0
8001c0d8:	e9 22 20 00 	st.b [%a2]32,%d2
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
8001c0dc:	91 10 00 27 	movh.a %a2,28673
8001c0e0:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001c0e4:	82 02       	mov %d2,0
8001c0e6:	34 22       	st.b [%a2],%d2
        TCP_EVENT_POLL(prev, err);
8001c0e8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001c0ec:	d9 22 10 20 	lea %a2,[%a2]144
8001c0f0:	54 22       	ld.w %d2,[%a2]
8001c0f2:	df 02 15 00 	jeq %d2,0,8001c11c <tcp_slowtmr+0x872>
8001c0f6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001c0fa:	d9 22 10 20 	lea %a2,[%a2]144
8001c0fe:	d4 22       	ld.a %a2,[%a2]
8001c100:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
8001c104:	d9 33 10 00 	lea %a3,[%a3]16
8001c108:	54 32       	ld.w %d2,[%a3]
8001c10a:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
8001c10e:	60 24       	mov.a %a4,%d2
8001c110:	2d 02 00 00 	calli %a2
8001c114:	e9 e2 f5 ff 	st.b [%a14]-11,%d2
8001c118:	1d 00 05 00 	j 8001c122 <tcp_slowtmr+0x878>
8001c11c:	82 02       	mov %d2,0
8001c11e:	e9 e2 f5 ff 	st.b [%a14]-11,%d2
        if (tcp_active_pcbs_changed) {
8001c122:	91 10 00 27 	movh.a %a2,28673
8001c126:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001c12a:	14 22       	ld.bu %d2,[%a2]
8001c12c:	df 02 04 00 	jeq %d2,0,8001c134 <tcp_slowtmr+0x88a>
          goto tcp_slowtmr_start;
8001c130:	1d ff da fb 	j 8001b8e4 <tcp_slowtmr+0x3a>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
8001c134:	79 e2 f5 ff 	ld.b %d2,[%a14]-11
8001c138:	df 02 06 80 	jne %d2,0,8001c144 <tcp_slowtmr+0x89a>
          tcp_output(prev);
8001c13c:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001c140:	6d 00 2a 39 	call 80023394 <tcp_output>
  while (pcb != NULL) {
8001c144:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c148:	df 02 da fb 	jne %d2,0,8001b8fc <tcp_slowtmr+0x52>
    }
  }


  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
8001c14c:	82 02       	mov %d2,0
8001c14e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  pcb = tcp_tw_pcbs;
8001c152:	91 10 00 27 	movh.a %a2,28673
8001c156:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001c15a:	54 22       	ld.w %d2,[%a2]
8001c15c:	59 e2 fc ff 	st.w [%a14]-4 <700145c0 <tcp_tw_pcbs>>,%d2
  while (pcb != NULL) {
8001c160:	1d 00 b2 00 	j 8001c2c4 <tcp_slowtmr+0xa1a>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
8001c164:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c168:	d9 22 14 00 	lea %a2,[%a2]20
8001c16c:	54 22       	ld.w %d2,[%a2]
8001c16e:	8b a2 00 22 	eq %d2,%d2,10
8001c172:	df 02 17 80 	jne %d2,0,8001c1a0 <tcp_slowtmr+0x8f6>
8001c176:	91 00 00 28 	movh.a %a2,32768
8001c17a:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001c17e:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001c182:	3b 10 5a 20 	mov %d2,1441
8001c186:	59 a2 04 00 	st.w [%sp]4,%d2
8001c18a:	91 00 00 28 	movh.a %a2,32768
8001c18e:	d9 22 0a b2 	lea %a2,[%a2]8906 <800022ca <IfxCpu_Trap_vectorTable0_end+0x20d6>>
8001c192:	f4 a2       	st.a [%sp],%a2
8001c194:	91 00 00 28 	movh.a %a2,32768
8001c198:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001c19c:	6d ff cd 48 	call 80005336 <Ifx_Lwip_printf>
    pcb_remove = 0;
8001c1a0:	82 02       	mov %d2,0
8001c1a2:	e9 e2 f7 ff 	st.b [%a14]-9,%d2

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
8001c1a6:	91 10 00 27 	movh.a %a2,28673
8001c1aa:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001c1ae:	54 23       	ld.w %d3,[%a2]
8001c1b0:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001c1b4:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001c1b8:	54 22       	ld.w %d2,[%a2]
8001c1ba:	0b 23 80 20 	sub %d2,%d3,%d2
8001c1be:	8b 12 6f 22 	lt.u %d2,%d2,241
8001c1c2:	df 02 07 80 	jne %d2,0,8001c1d0 <tcp_slowtmr+0x926>
      ++pcb_remove;
8001c1c6:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001c1ca:	c2 12       	add %d2,1
8001c1cc:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
8001c1d0:	39 e2 f7 ff 	ld.bu %d2,[%a14]-9
8001c1d4:	df 02 6d 00 	jeq %d2,0,8001c2ae <tcp_slowtmr+0xa04>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
8001c1d8:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001c1dc:	6d 00 f7 05 	call 8001cdca <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
8001c1e0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001c1e4:	df 02 2c 00 	jeq %d2,0,8001c23c <tcp_slowtmr+0x992>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
8001c1e8:	91 10 00 27 	movh.a %a2,28673
8001c1ec:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001c1f0:	54 22       	ld.w %d2,[%a2]
8001c1f2:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700145c0 <tcp_tw_pcbs>>
8001c1f6:	5f 23 17 80 	jne %d3,%d2,8001c224 <tcp_slowtmr+0x97a>
8001c1fa:	91 00 00 28 	movh.a %a2,32768
8001c1fe:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001c202:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001c206:	3b f0 5a 20 	mov %d2,1455
8001c20a:	59 a2 04 00 	st.w [%sp]4,%d2
8001c20e:	91 00 00 28 	movh.a %a2,32768
8001c212:	d9 22 39 b2 	lea %a2,[%a2]8953 <800022f9 <IfxCpu_Trap_vectorTable0_end+0x2105>>
8001c216:	f4 a2       	st.a [%sp],%a2
8001c218:	91 00 00 28 	movh.a %a2,32768
8001c21c:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001c220:	6d ff 8b 48 	call 80005336 <Ifx_Lwip_printf>
        prev->next = pcb->next;
8001c224:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c228:	d9 22 0c 00 	lea %a2,[%a2]12
8001c22c:	54 22       	ld.w %d2,[%a2]
8001c22e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001c232:	d9 22 0c 00 	lea %a2,[%a2]12
8001c236:	74 22       	st.w [%a2],%d2
8001c238:	1d 00 2a 00 	j 8001c28c <tcp_slowtmr+0x9e2>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
8001c23c:	91 10 00 27 	movh.a %a2,28673
8001c240:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001c244:	54 22       	ld.w %d2,[%a2]
8001c246:	19 e3 fc ff 	ld.w %d3,[%a14]-4 <700145c0 <tcp_tw_pcbs>>
8001c24a:	5f 23 17 00 	jeq %d3,%d2,8001c278 <tcp_slowtmr+0x9ce>
8001c24e:	91 00 00 28 	movh.a %a2,32768
8001c252:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001c256:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001c25a:	3b 30 5b 20 	mov %d2,1459
8001c25e:	59 a2 04 00 	st.w [%sp]4,%d2
8001c262:	91 00 00 28 	movh.a %a2,32768
8001c266:	d9 22 20 c2 	lea %a2,[%a2]8992 <80002320 <IfxCpu_Trap_vectorTable0_end+0x212c>>
8001c26a:	f4 a2       	st.a [%sp],%a2
8001c26c:	91 00 00 28 	movh.a %a2,32768
8001c270:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001c274:	6d ff 61 48 	call 80005336 <Ifx_Lwip_printf>
        tcp_tw_pcbs = pcb->next;
8001c278:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c27c:	d9 22 0c 00 	lea %a2,[%a2]12
8001c280:	54 22       	ld.w %d2,[%a2]
8001c282:	91 10 00 27 	movh.a %a2,28673
8001c286:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001c28a:	74 22       	st.w [%a2],%d2
      }
      pcb2 = pcb;
8001c28c:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <700145c0 <tcp_tw_pcbs>>
8001c290:	59 e2 ec ff 	st.w [%a14]-20 <700145c0 <tcp_tw_pcbs>>,%d2
      pcb = pcb->next;
8001c294:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145c0 <tcp_tw_pcbs>>
8001c298:	d9 22 0c 00 	lea %a2,[%a2]12 <700145c0 <tcp_tw_pcbs>>
8001c29c:	54 22       	ld.w %d2,[%a2]
8001c29e:	59 e2 fc ff 	st.w [%a14]-4 <700145c0 <tcp_tw_pcbs>>,%d2
      tcp_free(pcb2);
8001c2a2:	99 e4 ec ff 	ld.a %a4,[%a14]-20 <700145c0 <tcp_tw_pcbs>>
8001c2a6:	6d ff ae f2 	call 8001a802 <tcp_free>
8001c2aa:	1d 00 0d 00 	j 8001c2c4 <tcp_slowtmr+0xa1a>
    } else {
      prev = pcb;
8001c2ae:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c2b2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      pcb = pcb->next;
8001c2b6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c2ba:	d9 22 0c 00 	lea %a2,[%a2]12
8001c2be:	54 22       	ld.w %d2,[%a2]
8001c2c0:	59 e2 fc ff 	st.w [%a14]-4,%d2
  while (pcb != NULL) {
8001c2c4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c2c8:	df 02 4e ff 	jne %d2,0,8001c164 <tcp_slowtmr+0x8ba>
    }
  }
}
8001c2cc:	00 00       	nop 
8001c2ce:	00 00       	nop 
8001c2d0:	00 90       	ret 

8001c2d2 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
8001c2d2:	40 ae       	mov.aa %a14,%sp
8001c2d4:	20 08       	sub.a %sp,8
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
8001c2d6:	91 10 00 27 	movh.a %a2,28673
8001c2da:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001c2de:	14 22       	ld.bu %d2,[%a2]
8001c2e0:	c2 12       	add %d2,1
8001c2e2:	8f f2 0f 21 	and %d2,%d2,255
8001c2e6:	91 10 00 27 	movh.a %a2,28673
8001c2ea:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001c2ee:	34 22       	st.b [%a2],%d2

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
8001c2f0:	91 10 00 27 	movh.a %a2,28673
8001c2f4:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001c2f8:	54 22       	ld.w %d2,[%a2]
8001c2fa:	59 e2 fc ff 	st.w [%a14]-4 <700145bc <tcp_active_pcbs>>,%d2

  while (pcb != NULL) {
8001c2fe:	1d 00 80 00 	j 8001c3fe <tcp_fasttmr+0x12c>
    if (pcb->last_timer != tcp_timer_ctr) {
8001c302:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c306:	39 23 22 00 	ld.bu %d3,[%a2]34
8001c30a:	91 10 00 27 	movh.a %a2,28673
8001c30e:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001c312:	14 22       	ld.bu %d2,[%a2]
8001c314:	5f 23 6e 00 	jeq %d3,%d2,8001c3f0 <tcp_fasttmr+0x11e>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
8001c318:	91 10 00 27 	movh.a %a2,28673
8001c31c:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001c320:	14 22       	ld.bu %d2,[%a2]
8001c322:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145c6 <tcp_timer_ctr>>
8001c326:	e9 22 22 00 	st.b [%a2]34 <700145c6 <tcp_timer_ctr>>,%d2
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
8001c32a:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145c6 <tcp_timer_ctr>>
8001c32e:	b9 22 1e 00 	ld.hu %d2,[%a2]30 <700145c6 <tcp_timer_ctr>>
8001c332:	8f 12 00 21 	and %d2,%d2,1
8001c336:	df 02 1e 00 	jeq %d2,0,8001c372 <tcp_fasttmr+0xa0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
8001c33a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c33e:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001c342:	8f 22 40 21 	or %d2,%d2,2
8001c346:	37 02 70 20 	extr.u %d2,%d2,0,16
8001c34a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c34e:	f9 22 1e 00 	st.h [%a2]30,%d2
        tcp_output(pcb);
8001c352:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001c356:	6d 00 1f 38 	call 80023394 <tcp_output>
        tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
8001c35a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c35e:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001c362:	8f 32 c0 21 	andn %d2,%d2,3
8001c366:	37 02 70 20 	extr.u %d2,%d2,0,16
8001c36a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c36e:	f9 22 1e 00 	st.h [%a2]30,%d2
      }
      /* send pending FIN */
      if (pcb->flags & TF_CLOSEPEND) {
8001c372:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c376:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001c37a:	8f 82 00 21 	and %d2,%d2,8
8001c37e:	df 02 12 00 	jeq %d2,0,8001c3a2 <tcp_fasttmr+0xd0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
        tcp_clear_flags(pcb, TF_CLOSEPEND);
8001c382:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c386:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001c38a:	8f 82 c0 21 	andn %d2,%d2,8
8001c38e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001c392:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c396:	f9 22 1e 00 	st.h [%a2]30,%d2
        tcp_close_shutdown_fin(pcb);
8001c39a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001c39e:	6d ff ac f4 	call 8001acf6 <tcp_close_shutdown_fin>
      }

      next = pcb->next;
8001c3a2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c3a6:	d9 22 0c 00 	lea %a2,[%a2]12
8001c3aa:	54 22       	ld.w %d2,[%a2]
8001c3ac:	59 e2 f8 ff 	st.w [%a14]-8,%d2

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
8001c3b0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c3b4:	d9 22 3c 10 	lea %a2,[%a2]124
8001c3b8:	54 22       	ld.w %d2,[%a2]
8001c3ba:	df 02 15 00 	jeq %d2,0,8001c3e4 <tcp_fasttmr+0x112>
        tcp_active_pcbs_changed = 0;
8001c3be:	91 10 00 27 	movh.a %a2,28673
8001c3c2:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001c3c6:	82 02       	mov %d2,0
8001c3c8:	34 22       	st.b [%a2],%d2
        tcp_process_refused_data(pcb);
8001c3ca:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001c3ce:	6d 00 1f 00 	call 8001c40c <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
8001c3d2:	91 10 00 27 	movh.a %a2,28673
8001c3d6:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001c3da:	14 22       	ld.bu %d2,[%a2]
8001c3dc:	df 02 04 00 	jeq %d2,0,8001c3e4 <tcp_fasttmr+0x112>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
8001c3e0:	1d ff 88 ff 	j 8001c2f0 <tcp_fasttmr+0x1e>
        }
      }
      pcb = next;
8001c3e4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001c3e8:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001c3ec:	1d 00 09 00 	j 8001c3fe <tcp_fasttmr+0x12c>
    } else {
      pcb = pcb->next;
8001c3f0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c3f4:	d9 22 0c 00 	lea %a2,[%a2]12
8001c3f8:	54 22       	ld.w %d2,[%a2]
8001c3fa:	59 e2 fc ff 	st.w [%a14]-4,%d2
  while (pcb != NULL) {
8001c3fe:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c402:	df 02 80 ff 	jne %d2,0,8001c302 <tcp_fasttmr+0x30>
    }
  }
}
8001c406:	00 00       	nop 
8001c408:	00 00       	nop 
8001c40a:	00 90       	ret 

8001c40c <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
8001c40c:	40 ae       	mov.aa %a14,%sp
8001c40e:	20 20       	sub.a %sp,32
8001c410:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  struct pbuf *rest;
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

  LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
8001c414:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001c418:	df 02 1a 80 	jne %d2,0,8001c44c <tcp_process_refused_data+0x40>
8001c41c:	91 00 00 28 	movh.a %a2,32768
8001c420:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001c424:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001c428:	3b 90 60 20 	mov %d2,1545
8001c42c:	59 a2 04 00 	st.w [%sp]4,%d2
8001c430:	91 00 00 28 	movh.a %a2,32768
8001c434:	d9 22 06 d2 	lea %a2,[%a2]9030 <80002346 <IfxCpu_Trap_vectorTable0_end+0x2152>>
8001c438:	f4 a2       	st.a [%sp],%a2
8001c43a:	91 00 00 28 	movh.a %a2,32768
8001c43e:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001c442:	6d ff 7a 47 	call 80005336 <Ifx_Lwip_printf>
8001c446:	3b 00 ff 2f 	mov %d2,-16
8001c44a:	00 90       	ret 
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
  while (pcb->refused_data != NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
  {
    err_t err;
    u8_t refused_flags = pcb->refused_data->flags;
8001c44c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c450:	d9 22 3c 10 	lea %a2,[%a2]124
8001c454:	d4 22       	ld.a %a2,[%a2]
8001c456:	79 22 0d 00 	ld.b %d2,[%a2]13
8001c45a:	e9 e2 fe ff 	st.b [%a14]-2,%d2
    /* set pcb->refused_data to NULL in case the callback frees it and then
       closes the pcb */
    struct pbuf *refused_data = pcb->refused_data;
8001c45e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c462:	d9 22 3c 10 	lea %a2,[%a2]124
8001c466:	54 22       	ld.w %d2,[%a2]
8001c468:	59 e2 f8 ff 	st.w [%a14]-8,%d2
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
    pbuf_split_64k(refused_data, &rest);
    pcb->refused_data = rest;
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    pcb->refused_data = NULL;
8001c46c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c470:	82 02       	mov %d2,0
8001c472:	d9 22 3c 10 	lea %a2,[%a2]124
8001c476:	74 22       	st.w [%a2],%d2
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
    /* Notify again application with data previously received. */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
    TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
8001c478:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c47c:	d9 22 08 20 	lea %a2,[%a2]136
8001c480:	54 22       	ld.w %d2,[%a2]
8001c482:	df 02 18 00 	jeq %d2,0,8001c4b2 <tcp_process_refused_data+0xa6>
8001c486:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c48a:	d9 22 08 20 	lea %a2,[%a2]136
8001c48e:	d4 22       	ld.a %a2,[%a2]
8001c490:	99 e3 f4 ff 	ld.a %a3,[%a14]-12
8001c494:	d9 33 10 00 	lea %a3,[%a3]16
8001c498:	54 32       	ld.w %d2,[%a3]
8001c49a:	82 04       	mov %d4,0
8001c49c:	99 e6 f8 ff 	ld.a %a6,[%a14]-8
8001c4a0:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8001c4a4:	60 24       	mov.a %a4,%d2
8001c4a6:	2d 02 00 00 	calli %a2
8001c4aa:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8001c4ae:	1d 00 0c 00 	j 8001c4c6 <tcp_process_refused_data+0xba>
8001c4b2:	82 04       	mov %d4,0
8001c4b4:	99 e6 f8 ff 	ld.a %a6,[%a14]-8
8001c4b8:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8001c4bc:	a0 04       	mov.a %a4,0
8001c4be:	6d 00 cf 00 	call 8001c65c <tcp_recv_null>
8001c4c2:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    if (err == ERR_OK) {
8001c4c6:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001c4ca:	df 02 43 80 	jne %d2,0,8001c550 <tcp_process_refused_data+0x144>
      /* did refused_data include a FIN? */
      if ((refused_flags & PBUF_FLAG_TCP_FIN)
8001c4ce:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
8001c4d2:	8f 02 02 21 	and %d2,%d2,32
8001c4d6:	df 02 4f 00 	jeq %d2,0,8001c574 <tcp_process_refused_data+0x168>
          && (rest == NULL)
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
         ) {
        /* correct rcv_wnd as the application won't call tcp_recved()
           for the FIN's seqno */
        if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
8001c4da:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c4de:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8001c4e2:	3b 00 86 30 	mov %d3,2144
8001c4e6:	5f 32 0d 00 	jeq %d2,%d3,8001c500 <tcp_process_refused_data+0xf4>
          pcb->rcv_wnd++;
8001c4ea:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c4ee:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8001c4f2:	c2 12       	add %d2,1
8001c4f4:	37 02 70 20 	extr.u %d2,%d2,0,16
8001c4f8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c4fc:	f9 22 2c 00 	st.h [%a2]44,%d2
        }
        TCP_EVENT_CLOSED(pcb, err);
8001c500:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c504:	d9 22 08 20 	lea %a2,[%a2]136
8001c508:	54 22       	ld.w %d2,[%a2]
8001c50a:	df 02 17 00 	jeq %d2,0,8001c538 <tcp_process_refused_data+0x12c>
8001c50e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c512:	d9 22 08 20 	lea %a2,[%a2]136
8001c516:	d4 22       	ld.a %a2,[%a2]
8001c518:	99 e3 f4 ff 	ld.a %a3,[%a14]-12
8001c51c:	d9 33 10 00 	lea %a3,[%a3]16
8001c520:	54 32       	ld.w %d2,[%a3]
8001c522:	82 04       	mov %d4,0
8001c524:	a0 06       	mov.a %a6,0
8001c526:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8001c52a:	60 24       	mov.a %a4,%d2
8001c52c:	2d 02 00 00 	calli %a2
8001c530:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8001c534:	1d 00 05 00 	j 8001c53e <tcp_process_refused_data+0x132>
8001c538:	82 02       	mov %d2,0
8001c53a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
        if (err == ERR_ABRT) {
8001c53e:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001c542:	8b 32 3f 22 	ne %d2,%d2,-13
8001c546:	df 02 17 80 	jne %d2,0,8001c574 <tcp_process_refused_data+0x168>
          return ERR_ABRT;
8001c54a:	3b 30 ff 2f 	mov %d2,-13
8001c54e:	00 90       	ret 
        }
      }
    } else if (err == ERR_ABRT) {
8001c550:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8001c554:	8b 32 3f 22 	ne %d2,%d2,-13
8001c558:	df 02 05 80 	jne %d2,0,8001c562 <tcp_process_refused_data+0x156>
      /* if err == ERR_ABRT, 'pcb' is already deallocated */
      /* Drop incoming packets because pcb is "full" (only if the incoming
         segment contains data). */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
      return ERR_ABRT;
8001c55c:	3b 30 ff 2f 	mov %d2,-13
8001c560:	00 90       	ret 
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
      if (rest != NULL) {
        pbuf_cat(refused_data, rest);
      }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
      pcb->refused_data = refused_data;
8001c562:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c566:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001c56a:	d9 22 3c 10 	lea %a2,[%a2]124
8001c56e:	74 22       	st.w [%a2],%d2
      return ERR_INPROGRESS;
8001c570:	82 b2       	mov %d2,-5
8001c572:	00 90       	ret 
    }
  }
  return ERR_OK;
8001c574:	82 02       	mov %d2,0
}
8001c576:	00 90       	ret 

8001c578 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
8001c578:	40 ae       	mov.aa %a14,%sp
8001c57a:	20 10       	sub.a %sp,16
8001c57c:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  while (seg != NULL) {
8001c580:	1d 00 0f 00 	j 8001c59e <tcp_segs_free+0x26>
    struct tcp_seg *next = seg->next;
8001c584:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c588:	54 22       	ld.w %d2,[%a2]
8001c58a:	59 e2 fc ff 	st.w [%a14]-4,%d2
    tcp_seg_free(seg);
8001c58e:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001c592:	6d 00 0d 00 	call 8001c5ac <tcp_seg_free>
    seg = next;
8001c596:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c59a:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  while (seg != NULL) {
8001c59e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001c5a2:	df 02 f1 ff 	jne %d2,0,8001c584 <tcp_segs_free+0xc>
  }
}
8001c5a6:	00 00       	nop 
8001c5a8:	00 00       	nop 
8001c5aa:	00 90       	ret 

8001c5ac <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
8001c5ac:	40 ae       	mov.aa %a14,%sp
8001c5ae:	20 08       	sub.a %sp,8
8001c5b0:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  if (seg != NULL) {
8001c5b4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c5b8:	df 02 14 00 	jeq %d2,0,8001c5e0 <tcp_seg_free+0x34>
    if (seg->p != NULL) {
8001c5bc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c5c0:	b0 42       	add.a %a2,4
8001c5c2:	54 22       	ld.w %d2,[%a2]
8001c5c4:	df 02 09 00 	jeq %d2,0,8001c5d6 <tcp_seg_free+0x2a>
      pbuf_free(seg->p);
8001c5c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c5cc:	b0 42       	add.a %a2,4
8001c5ce:	54 22       	ld.w %d2,[%a2]
8001c5d0:	60 24       	mov.a %a4,%d2
8001c5d2:	6d ff e3 ec 	call 80019f98 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
8001c5d6:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001c5da:	82 34       	mov %d4,3
8001c5dc:	6d ff 6d e2 	call 80018ab6 <memp_free>
  }
}
8001c5e0:	00 00       	nop 
8001c5e2:	00 90       	ret 

8001c5e4 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
8001c5e4:	40 ae       	mov.aa %a14,%sp
8001c5e6:	20 20       	sub.a %sp,32
8001c5e8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct tcp_seg *cseg;

  LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
8001c5ec:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001c5f0:	df 02 17 80 	jne %d2,0,8001c61e <tcp_seg_copy+0x3a>
8001c5f4:	91 00 00 28 	movh.a %a2,32768
8001c5f8:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001c5fc:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001c600:	3b 20 68 20 	mov %d2,1666
8001c604:	59 a2 04 00 	st.w [%sp]4,%d2
8001c608:	91 00 00 28 	movh.a %a2,32768
8001c60c:	d9 22 05 e2 	lea %a2,[%a2]9093 <80002385 <IfxCpu_Trap_vectorTable0_end+0x2191>>
8001c610:	f4 a2       	st.a [%sp],%a2
8001c612:	91 00 00 28 	movh.a %a2,32768
8001c616:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001c61a:	6d ff 8e 46 	call 80005336 <Ifx_Lwip_printf>

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
8001c61e:	82 34       	mov %d4,3
8001c620:	6d ff d5 e1 	call 800189ca <memp_malloc>
8001c624:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (cseg == NULL) {
8001c628:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c62c:	df 02 05 80 	jne %d2,0,8001c636 <tcp_seg_copy+0x52>
    return NULL;
8001c630:	82 02       	mov %d2,0
8001c632:	1d 00 13 00 	j 8001c658 <tcp_seg_copy+0x74>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
8001c636:	3b 40 01 40 	mov %d4,20
8001c63a:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8001c63e:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001c642:	6d 00 ed 55 	call 8002721c <memcpy>
  pbuf_ref(cseg->p);
8001c646:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c64a:	b0 42       	add.a %a2,4
8001c64c:	54 22       	ld.w %d2,[%a2]
8001c64e:	60 24       	mov.a %a4,%d2
8001c650:	6d ff a1 ed 	call 8001a192 <pbuf_ref>
  return cseg;
8001c654:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8001c658:	60 22       	mov.a %a2,%d2
8001c65a:	00 90       	ret 

8001c65c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
8001c65c:	40 ae       	mov.aa %a14,%sp
8001c65e:	20 20       	sub.a %sp,32
8001c660:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001c664:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
8001c668:	b5 e6 f4 ff 	st.a [%a14]-12,%a6
8001c66c:	02 42       	mov %d2,%d4
8001c66e:	e9 e2 f0 ff 	st.b [%a14]-16,%d2
  LWIP_UNUSED_ARG(arg);

  LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
8001c672:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001c676:	df 02 1a 80 	jne %d2,0,8001c6aa <tcp_recv_null+0x4e>
8001c67a:	91 00 00 28 	movh.a %a2,32768
8001c67e:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001c682:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001c686:	3b 80 69 20 	mov %d2,1688
8001c68a:	59 a2 04 00 	st.w [%sp]4,%d2
8001c68e:	91 00 00 28 	movh.a %a2,32768
8001c692:	d9 22 1f e2 	lea %a2,[%a2]9119 <8000239f <IfxCpu_Trap_vectorTable0_end+0x21ab>>
8001c696:	f4 a2       	st.a [%sp],%a2
8001c698:	91 00 00 28 	movh.a %a2,32768
8001c69c:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001c6a0:	6d ff 4b 46 	call 80005336 <Ifx_Lwip_printf>
8001c6a4:	3b 00 ff 2f 	mov %d2,-16
8001c6a8:	00 90       	ret 

  if (p != NULL) {
8001c6aa:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001c6ae:	df 02 11 00 	jeq %d2,0,8001c6d0 <tcp_recv_null+0x74>
    tcp_recved(pcb, p->tot_len);
8001c6b2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001c6b6:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001c6ba:	02 24       	mov %d4,%d2
8001c6bc:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001c6c0:	6d ff 0a f8 	call 8001b6d4 <tcp_recved>
    pbuf_free(p);
8001c6c4:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001c6c8:	6d ff 68 ec 	call 80019f98 <pbuf_free>
8001c6cc:	1d 00 0b 00 	j 8001c6e2 <tcp_recv_null+0x86>
  } else if (err == ERR_OK) {
8001c6d0:	79 e2 f0 ff 	ld.b %d2,[%a14]-16
8001c6d4:	df 02 07 80 	jne %d2,0,8001c6e2 <tcp_recv_null+0x86>
    return tcp_close(pcb);
8001c6d8:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001c6dc:	6d ff 98 f3 	call 8001ae0c <tcp_close>
8001c6e0:	00 90       	ret 
  }
  return ERR_OK;
8001c6e2:	82 02       	mov %d2,0
}
8001c6e4:	00 90       	ret 

8001c6e6 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
8001c6e6:	40 ae       	mov.aa %a14,%sp
8001c6e8:	20 18       	sub.a %sp,24
8001c6ea:	02 42       	mov %d2,%d4
8001c6ec:	e9 e2 ec ff 	st.b [%a14]-20,%d2
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;

  mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
8001c6f0:	79 e2 ec ff 	ld.b %d2,[%a14]-20
8001c6f4:	bf 02 06 00 	jlt %d2,0,8001c700 <tcp_kill_prio+0x1a>
8001c6f8:	39 e2 ec ff 	ld.bu %d2,[%a14]-20
8001c6fc:	1d 00 04 00 	j 8001c704 <tcp_kill_prio+0x1e>
8001c700:	3b f0 07 20 	mov %d2,127
8001c704:	e9 e2 f3 ff 	st.b [%a14]-13,%d2

  /* We want to kill connections with a lower prio, so bail out if 
   * supplied prio is 0 - there can never be a lower prio
   */
  if (mprio == 0) {
8001c708:	39 e2 f3 ff 	ld.bu %d2,[%a14]-13
8001c70c:	df 02 61 00 	jeq %d2,0,8001c7ce <tcp_kill_prio+0xe8>
  /* We only want kill connections with a lower prio, so decrement prio by one 
   * and start searching for oldest connection with same or lower priority than mprio.
   * We want to find the connections with the lowest possible prio, and among
   * these the one with the longest inactivity time.
   */
  mprio--;
8001c710:	39 e2 f3 ff 	ld.bu %d2,[%a14]-13
8001c714:	c2 f2       	add %d2,-1
8001c716:	e9 e2 f3 ff 	st.b [%a14]-13,%d2

  inactivity = 0;
8001c71a:	82 02       	mov %d2,0
8001c71c:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  inactive = NULL;
8001c720:	82 02       	mov %d2,0
8001c722:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
8001c726:	91 10 00 27 	movh.a %a2,28673
8001c72a:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001c72e:	54 22       	ld.w %d2,[%a2]
8001c730:	59 e2 fc ff 	st.w [%a14]-4 <700145bc <tcp_active_pcbs>>,%d2
8001c734:	1d 00 40 00 	j 8001c7b4 <tcp_kill_prio+0xce>
        /* lower prio is always a kill candidate */
    if ((pcb->prio < mprio) ||
8001c738:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c73c:	39 23 18 00 	ld.bu %d3,[%a2]24
8001c740:	39 e2 f3 ff 	ld.bu %d2,[%a14]-13
8001c744:	3f 23 19 80 	jlt.u %d3,%d2,8001c776 <tcp_kill_prio+0x90>
        /* longer inactivity is also a kill candidate */
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
8001c748:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c74c:	39 22 18 00 	ld.bu %d2,[%a2]24
    if ((pcb->prio < mprio) ||
8001c750:	39 e3 f3 ff 	ld.bu %d3,[%a14]-13
8001c754:	5f 23 29 80 	jne %d3,%d2,8001c7a6 <tcp_kill_prio+0xc0>
        ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
8001c758:	91 10 00 27 	movh.a %a2,28673
8001c75c:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001c760:	54 23       	ld.w %d3,[%a2]
8001c762:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001c766:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001c76a:	54 22       	ld.w %d2,[%a2]
8001c76c:	a2 23       	sub %d3,%d2
8001c76e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001c772:	3f 23 1a 80 	jlt.u %d3,%d2,8001c7a6 <tcp_kill_prio+0xc0>
      inactivity = tcp_ticks - pcb->tmr;
8001c776:	91 10 00 27 	movh.a %a2,28673
8001c77a:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001c77e:	54 23       	ld.w %d3,[%a2]
8001c780:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001c784:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001c788:	54 22       	ld.w %d2,[%a2]
8001c78a:	0b 23 80 20 	sub %d2,%d3,%d2
8001c78e:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      inactive   = pcb;
8001c792:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c796:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      mprio      = pcb->prio;
8001c79a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c79e:	79 22 18 00 	ld.b %d2,[%a2]24
8001c7a2:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
8001c7a6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c7aa:	d9 22 0c 00 	lea %a2,[%a2]12
8001c7ae:	54 22       	ld.w %d2,[%a2]
8001c7b0:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001c7b4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c7b8:	df 02 c0 ff 	jne %d2,0,8001c738 <tcp_kill_prio+0x52>
    }
  }
  if (inactive != NULL) {
8001c7bc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001c7c0:	df 02 07 00 	jeq %d2,0,8001c7ce <tcp_kill_prio+0xe8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
8001c7c4:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001c7c8:	6d ff 9e f4 	call 8001b104 <tcp_abort>
8001c7cc:	00 90       	ret 
  }
}
8001c7ce:	00 90       	ret 

8001c7d0 <tcp_kill_state>:
 * Kills the oldest connection that is in specific state.
 * Called from tcp_alloc() for LAST_ACK and CLOSING if no more connections are available.
 */
static void
tcp_kill_state(enum tcp_state state)
{
8001c7d0:	40 ae       	mov.aa %a14,%sp
8001c7d2:	20 28       	sub.a %sp,40
8001c7d4:	59 e4 ec ff 	st.w [%a14]-20,%d4
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
8001c7d8:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001c7dc:	8b 82 00 22 	eq %d2,%d2,8
8001c7e0:	df 02 1d 80 	jne %d2,0,8001c81a <tcp_kill_state+0x4a>
8001c7e4:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001c7e8:	8b 92 00 22 	eq %d2,%d2,9
8001c7ec:	df 02 17 80 	jne %d2,0,8001c81a <tcp_kill_state+0x4a>
8001c7f0:	91 00 00 28 	movh.a %a2,32768
8001c7f4:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001c7f8:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001c7fc:	3b d0 6d 20 	mov %d2,1757
8001c800:	59 a2 04 00 	st.w [%sp]4,%d2
8001c804:	91 00 00 28 	movh.a %a2,32768
8001c808:	d9 22 3a e2 	lea %a2,[%a2]9146 <800023ba <IfxCpu_Trap_vectorTable0_end+0x21c6>>
8001c80c:	f4 a2       	st.a [%sp],%a2
8001c80e:	91 00 00 28 	movh.a %a2,32768
8001c812:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001c816:	6d ff 90 45 	call 80005336 <Ifx_Lwip_printf>

  inactivity = 0;
8001c81a:	82 02       	mov %d2,0
8001c81c:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  inactive = NULL;
8001c820:	82 02       	mov %d2,0
8001c822:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  /* Go through the list of active pcbs and get the oldest pcb that is in state
     CLOSING/LAST_ACK. */
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
8001c826:	91 10 00 27 	movh.a %a2,28673
8001c82a:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001c82e:	54 22       	ld.w %d2,[%a2]
8001c830:	59 e2 fc ff 	st.w [%a14]-4 <700145bc <tcp_active_pcbs>>,%d2
8001c834:	1d 00 33 00 	j 8001c89a <tcp_kill_state+0xca>
    if (pcb->state == state) {
8001c838:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c83c:	d9 22 14 00 	lea %a2,[%a2]20
8001c840:	54 22       	ld.w %d2,[%a2]
8001c842:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8001c846:	5f 23 23 80 	jne %d3,%d2,8001c88c <tcp_kill_state+0xbc>
      if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
8001c84a:	91 10 00 27 	movh.a %a2,28673
8001c84e:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001c852:	54 23       	ld.w %d3,[%a2]
8001c854:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001c858:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001c85c:	54 22       	ld.w %d2,[%a2]
8001c85e:	a2 23       	sub %d3,%d2
8001c860:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001c864:	3f 23 14 80 	jlt.u %d3,%d2,8001c88c <tcp_kill_state+0xbc>
        inactivity = tcp_ticks - pcb->tmr;
8001c868:	91 10 00 27 	movh.a %a2,28673
8001c86c:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001c870:	54 23       	ld.w %d3,[%a2]
8001c872:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001c876:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001c87a:	54 22       	ld.w %d2,[%a2]
8001c87c:	0b 23 80 20 	sub %d2,%d3,%d2
8001c880:	59 e2 f4 ff 	st.w [%a14]-12,%d2
        inactive = pcb;
8001c884:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c888:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
8001c88c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c890:	d9 22 0c 00 	lea %a2,[%a2]12
8001c894:	54 22       	ld.w %d2,[%a2]
8001c896:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001c89a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c89e:	df 02 cd ff 	jne %d2,0,8001c838 <tcp_kill_state+0x68>
      }
    }
  }
  if (inactive != NULL) {
8001c8a2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001c8a6:	df 02 07 00 	jeq %d2,0,8001c8b4 <tcp_kill_state+0xe4>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
                            tcp_state_str[state], (void *)inactive, inactivity));
    /* Don't send a RST, since no data is lost. */
    tcp_abandon(inactive, 0);
8001c8aa:	82 04       	mov %d4,0
8001c8ac:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001c8b0:	6d ff e7 f2 	call 8001ae7e <tcp_abandon>
  }
}
8001c8b4:	00 00       	nop 
8001c8b6:	00 90       	ret 

8001c8b8 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
8001c8b8:	40 ae       	mov.aa %a14,%sp
8001c8ba:	20 10       	sub.a %sp,16
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
8001c8bc:	82 02       	mov %d2,0
8001c8be:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  inactive = NULL;
8001c8c2:	82 02       	mov %d2,0
8001c8c4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
8001c8c8:	91 10 00 27 	movh.a %a2,28673
8001c8cc:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001c8d0:	54 22       	ld.w %d2,[%a2]
8001c8d2:	59 e2 fc ff 	st.w [%a14]-4 <700145c0 <tcp_tw_pcbs>>,%d2
8001c8d6:	1d 00 2a 00 	j 8001c92a <tcp_kill_timewait+0x72>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
8001c8da:	91 10 00 27 	movh.a %a2,28673
8001c8de:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001c8e2:	54 23       	ld.w %d3,[%a2]
8001c8e4:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001c8e8:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001c8ec:	54 22       	ld.w %d2,[%a2]
8001c8ee:	a2 23       	sub %d3,%d2
8001c8f0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001c8f4:	3f 23 14 80 	jlt.u %d3,%d2,8001c91c <tcp_kill_timewait+0x64>
      inactivity = tcp_ticks - pcb->tmr;
8001c8f8:	91 10 00 27 	movh.a %a2,28673
8001c8fc:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001c900:	54 23       	ld.w %d3,[%a2]
8001c902:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001c906:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001c90a:	54 22       	ld.w %d2,[%a2]
8001c90c:	0b 23 80 20 	sub %d2,%d3,%d2
8001c910:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      inactive = pcb;
8001c914:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c918:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
8001c91c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c920:	d9 22 0c 00 	lea %a2,[%a2]12
8001c924:	54 22       	ld.w %d2,[%a2]
8001c926:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001c92a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c92e:	df 02 d6 ff 	jne %d2,0,8001c8da <tcp_kill_timewait+0x22>
    }
  }
  if (inactive != NULL) {
8001c932:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001c936:	df 02 06 00 	jeq %d2,0,8001c942 <tcp_kill_timewait+0x8a>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
                            (void *)inactive, inactivity));
    tcp_abort(inactive);
8001c93a:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001c93e:	6d ff e3 f3 	call 8001b104 <tcp_abort>
  }
}
8001c942:	00 00       	nop 
8001c944:	00 90       	ret 

8001c946 <tcp_handle_closepend>:
 * now send the FIN (which failed before), the pcb might be in a state that is
 * OK for us to now free it.
 */
static void
tcp_handle_closepend(void)
{
8001c946:	40 ae       	mov.aa %a14,%sp
8001c948:	20 08       	sub.a %sp,8
  struct tcp_pcb *pcb = tcp_active_pcbs;
8001c94a:	91 10 00 27 	movh.a %a2,28673
8001c94e:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001c952:	54 22       	ld.w %d2,[%a2]
8001c954:	59 e2 fc ff 	st.w [%a14]-4 <700145bc <tcp_active_pcbs>>,%d2

  while (pcb != NULL) {
8001c958:	1d 00 25 00 	j 8001c9a2 <tcp_handle_closepend+0x5c>
    struct tcp_pcb *next = pcb->next;
8001c95c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c960:	d9 22 0c 00 	lea %a2,[%a2]12
8001c964:	54 22       	ld.w %d2,[%a2]
8001c966:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    /* send pending FIN */
    if (pcb->flags & TF_CLOSEPEND) {
8001c96a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c96e:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001c972:	8f 82 00 21 	and %d2,%d2,8
8001c976:	df 02 12 00 	jeq %d2,0,8001c99a <tcp_handle_closepend+0x54>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
      tcp_clear_flags(pcb, TF_CLOSEPEND);
8001c97a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c97e:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001c982:	8f 82 c0 21 	andn %d2,%d2,8
8001c986:	37 02 70 20 	extr.u %d2,%d2,0,16
8001c98a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001c98e:	f9 22 1e 00 	st.h [%a2]30,%d2
      tcp_close_shutdown_fin(pcb);
8001c992:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001c996:	6d ff b0 f1 	call 8001acf6 <tcp_close_shutdown_fin>
    }
    pcb = next;
8001c99a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001c99e:	59 e2 fc ff 	st.w [%a14]-4,%d2
  while (pcb != NULL) {
8001c9a2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c9a6:	df 02 db ff 	jne %d2,0,8001c95c <tcp_handle_closepend+0x16>
  }
}
8001c9aa:	00 00       	nop 
8001c9ac:	00 00       	nop 
8001c9ae:	00 90       	ret 

8001c9b0 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
8001c9b0:	40 ae       	mov.aa %a14,%sp
8001c9b2:	20 10       	sub.a %sp,16
8001c9b4:	02 42       	mov %d2,%d4
8001c9b6:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
  struct tcp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
8001c9ba:	82 14       	mov %d4,1
8001c9bc:	6d ff 07 e0 	call 800189ca <memp_malloc>
8001c9c0:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (pcb == NULL) {
8001c9c4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c9c8:	df 02 7b 80 	jne %d2,0,8001cabe <tcp_alloc+0x10e>
    /* Try to send FIN for all pcbs stuck in TF_CLOSEPEND first */
    tcp_handle_closepend();
8001c9cc:	6d ff bd ff 	call 8001c946 <tcp_handle_closepend>

    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
8001c9d0:	6d ff 74 ff 	call 8001c8b8 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
8001c9d4:	82 14       	mov %d4,1
8001c9d6:	6d ff fa df 	call 800189ca <memp_malloc>
8001c9da:	b5 e2 fc ff 	st.a [%a14]-4,%a2
    if (pcb == NULL) {
8001c9de:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c9e2:	df 02 5c 80 	jne %d2,0,8001ca9a <tcp_alloc+0xea>
      /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
      tcp_kill_state(LAST_ACK);
8001c9e6:	3b 90 00 40 	mov %d4,9
8001c9ea:	6d ff f3 fe 	call 8001c7d0 <tcp_kill_state>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
8001c9ee:	82 14       	mov %d4,1
8001c9f0:	6d ff ed df 	call 800189ca <memp_malloc>
8001c9f4:	b5 e2 fc ff 	st.a [%a14]-4,%a2
      if (pcb == NULL) {
8001c9f8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001c9fc:	df 02 3d 80 	jne %d2,0,8001ca76 <tcp_alloc+0xc6>
        /* Try killing oldest connection in CLOSING. */
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
        tcp_kill_state(CLOSING);
8001ca00:	3b 80 00 40 	mov %d4,8
8001ca04:	6d ff e6 fe 	call 8001c7d0 <tcp_kill_state>
        /* Try to allocate a tcp_pcb again. */
        pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
8001ca08:	82 14       	mov %d4,1
8001ca0a:	6d ff e0 df 	call 800189ca <memp_malloc>
8001ca0e:	b5 e2 fc ff 	st.a [%a14]-4,%a2
        if (pcb == NULL) {
8001ca12:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001ca16:	df 02 1e 80 	jne %d2,0,8001ca52 <tcp_alloc+0xa2>
          /* Try killing oldest active connection with lower priority than the new one. */
          LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing oldest connection with prio lower than %d\n", prio));
          tcp_kill_prio(prio);
8001ca1a:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
8001ca1e:	02 24       	mov %d4,%d2
8001ca20:	6d ff 63 fe 	call 8001c6e6 <tcp_kill_prio>
          /* Try to allocate a tcp_pcb again. */
          pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
8001ca24:	82 14       	mov %d4,1
8001ca26:	6d ff d2 df 	call 800189ca <memp_malloc>
8001ca2a:	b5 e2 fc ff 	st.a [%a14]-4,%a2
          if (pcb != NULL) {
8001ca2e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001ca32:	df 02 10 00 	jeq %d2,0,8001ca52 <tcp_alloc+0xa2>
            /* adjust err stats: memp_malloc failed multiple times before */
            MEMP_STATS_DEC(err, MEMP_TCP_PCB);
8001ca36:	91 10 00 27 	movh.a %a2,28673
8001ca3a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001ca3e:	d9 22 3c 20 	lea %a2,[%a2]188 <700100bc <ram_heap+0x5028>>
8001ca42:	d4 22       	ld.a %a2,[%a2]
8001ca44:	b9 22 04 00 	ld.hu %d2,[%a2]4 <700100bc <ram_heap+0x5028>>
8001ca48:	c2 f2       	add %d2,-1
8001ca4a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ca4e:	f9 22 04 00 	st.h [%a2]4,%d2
          }
        }
        if (pcb != NULL) {
8001ca52:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001ca56:	df 02 10 00 	jeq %d2,0,8001ca76 <tcp_alloc+0xc6>
          /* adjust err stats: memp_malloc failed multiple times before */
          MEMP_STATS_DEC(err, MEMP_TCP_PCB);
8001ca5a:	91 10 00 27 	movh.a %a2,28673
8001ca5e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001ca62:	d9 22 3c 20 	lea %a2,[%a2]188 <700100bc <ram_heap+0x5028>>
8001ca66:	d4 22       	ld.a %a2,[%a2]
8001ca68:	b9 22 04 00 	ld.hu %d2,[%a2]4 <700100bc <ram_heap+0x5028>>
8001ca6c:	c2 f2       	add %d2,-1
8001ca6e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ca72:	f9 22 04 00 	st.h [%a2]4,%d2
        }
      }
      if (pcb != NULL) {
8001ca76:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001ca7a:	df 02 10 00 	jeq %d2,0,8001ca9a <tcp_alloc+0xea>
        /* adjust err stats: memp_malloc failed multiple times before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
8001ca7e:	91 10 00 27 	movh.a %a2,28673
8001ca82:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001ca86:	d9 22 3c 20 	lea %a2,[%a2]188 <700100bc <ram_heap+0x5028>>
8001ca8a:	d4 22       	ld.a %a2,[%a2]
8001ca8c:	b9 22 04 00 	ld.hu %d2,[%a2]4 <700100bc <ram_heap+0x5028>>
8001ca90:	c2 f2       	add %d2,-1
8001ca92:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ca96:	f9 22 04 00 	st.h [%a2]4,%d2
      }
    }
    if (pcb != NULL) {
8001ca9a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001ca9e:	df 02 10 00 	jeq %d2,0,8001cabe <tcp_alloc+0x10e>
      /* adjust err stats: memp_malloc failed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
8001caa2:	91 10 00 27 	movh.a %a2,28673
8001caa6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001caaa:	d9 22 3c 20 	lea %a2,[%a2]188 <700100bc <ram_heap+0x5028>>
8001caae:	d4 22       	ld.a %a2,[%a2]
8001cab0:	b9 22 04 00 	ld.hu %d2,[%a2]4 <700100bc <ram_heap+0x5028>>
8001cab4:	c2 f2       	add %d2,-1
8001cab6:	37 02 70 20 	extr.u %d2,%d2,0,16
8001caba:	f9 22 04 00 	st.h [%a2]4,%d2
    }
  }
  if (pcb != NULL) {
8001cabe:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001cac2:	df 02 6d 00 	jeq %d2,0,8001cb9c <tcp_alloc+0x1ec>
    /* zero out the whole pcb, so there is no need to initialize members to zero */
    memset(pcb, 0, sizeof(struct tcp_pcb));
8001cac6:	3b 00 0a 50 	mov %d5,160
8001caca:	82 04       	mov %d4,0
8001cacc:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001cad0:	6d 00 b0 53 	call 80027230 <memset>
    pcb->prio = prio;
8001cad4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cad8:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
8001cadc:	e9 22 18 00 	st.b [%a2]24,%d2
    pcb->snd_buf = TCP_SND_BUF;
8001cae0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cae4:	3b 00 43 20 	mov %d2,1072
8001cae8:	f9 22 28 10 	st.h [%a2]104,%d2
    /* Start with a window that does not need scaling. When window scaling is
       enabled and used, the window is enlarged when both sides agree on scaling. */
    pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
8001caec:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001caf0:	3b 00 86 20 	mov %d2,2144
8001caf4:	f9 22 2e 00 	st.h [%a2]46,%d2
8001caf8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cafc:	b9 22 2e 00 	ld.hu %d2,[%a2]46
8001cb00:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cb04:	f9 22 2c 00 	st.h [%a2]44,%d2
    pcb->ttl = TCP_TTL;
8001cb08:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cb0c:	82 f2       	mov %d2,-1
8001cb0e:	e9 22 0b 00 	st.b [%a2]11,%d2
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = INITIAL_MSS;
8001cb12:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cb16:	3b 80 21 20 	mov %d2,536
8001cb1a:	f9 22 36 00 	st.h [%a2]54,%d2
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
8001cb1e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cb22:	82 62       	mov %d2,6
8001cb24:	f9 22 04 10 	st.h [%a2]68,%d2
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
8001cb28:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cb2c:	82 62       	mov %d2,6
8001cb2e:	f9 22 02 10 	st.h [%a2]66,%d2
    pcb->rtime = -1;
8001cb32:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cb36:	82 f2       	mov %d2,-1
8001cb38:	f9 22 34 00 	st.h [%a2]52,%d2
    pcb->cwnd = 1;
8001cb3c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cb40:	82 12       	mov %d2,1
8001cb42:	f9 22 0c 10 	st.h [%a2]76,%d2
    pcb->tmr = tcp_ticks;
8001cb46:	91 10 00 27 	movh.a %a2,28673
8001cb4a:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001cb4e:	54 22       	ld.w %d2,[%a2]
8001cb50:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001cb54:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001cb58:	74 22       	st.w [%a2],%d2
    pcb->last_timer = tcp_timer_ctr;
8001cb5a:	91 10 00 27 	movh.a %a2,28673
8001cb5e:	d9 22 46 74 	lea %a2,[%a2]17862 <700145c6 <tcp_timer_ctr>>
8001cb62:	14 22       	ld.bu %d2,[%a2]
8001cb64:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145c6 <tcp_timer_ctr>>
8001cb68:	e9 22 22 00 	st.b [%a2]34 <700145c6 <tcp_timer_ctr>>,%d2
    of using the largest advertised receive window.  We've seen complications with
    receiving TCPs that use window scaling and/or window auto-tuning where the
    initial advertised window is very small and then grows rapidly once the
    connection is established. To avoid these complications, we set ssthresh to the
    largest effective cwnd (amount of in-flight data) that the sender can have. */
    pcb->ssthresh = TCP_SND_BUF;
8001cb6c:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145c6 <tcp_timer_ctr>>
8001cb70:	3b 00 43 20 	mov %d2,1072
8001cb74:	f9 22 0e 10 	st.h [%a2]78,%d2

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
8001cb78:	99 e3 fc ff 	ld.a %a3,[%a14]-4
8001cb7c:	91 20 00 28 	movh.a %a2,32770
8001cb80:	d9 22 5c 9c 	lea %a2,[%a2]-14756 <8001c65c <tcp_recv_null>>
8001cb84:	d9 33 08 20 	lea %a3,[%a3]136 <8001c65c <tcp_recv_null>>
8001cb88:	f4 32       	st.a [%a3],%a2
#endif /* LWIP_CALLBACK_API */

    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
8001cb8a:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <8001c65c <tcp_recv_null>>
8001cb8e:	7b e0 06 20 	movh %d2,110
8001cb92:	1b 02 d0 2d 	addi %d2,%d2,-8960
8001cb96:	d9 22 18 20 	lea %a2,[%a2]152
8001cb9a:	74 22       	st.w [%a2],%d2
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */
  }
  return pcb;
8001cb9c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8001cba0:	60 22       	mov.a %a2,%d2
8001cba2:	00 90       	ret 

8001cba4 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
8001cba4:	40 ae       	mov.aa %a14,%sp
  return tcp_alloc(TCP_PRIO_NORMAL);
8001cba6:	3b 00 04 40 	mov %d4,64
8001cbaa:	6d ff 03 ff 	call 8001c9b0 <tcp_alloc>
8001cbae:	80 22       	mov.d %d2,%a2
}
8001cbb0:	60 22       	mov.a %a2,%d2
8001cbb2:	00 90       	ret 

8001cbb4 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
8001cbb4:	40 ae       	mov.aa %a14,%sp
8001cbb6:	20 08       	sub.a %sp,8
8001cbb8:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001cbbc:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  LWIP_ASSERT_CORE_LOCKED();
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  if (pcb != NULL) {
8001cbc0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001cbc4:	df 02 09 00 	jeq %d2,0,8001cbd6 <tcp_arg+0x22>
    pcb->callback_arg = arg;
8001cbc8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cbcc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001cbd0:	d9 22 10 00 	lea %a2,[%a2]16
8001cbd4:	74 22       	st.w [%a2],%d2
  }
}
8001cbd6:	00 00       	nop 
8001cbd8:	00 90       	ret 

8001cbda <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
8001cbda:	40 ae       	mov.aa %a14,%sp
8001cbdc:	20 18       	sub.a %sp,24
8001cbde:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001cbe2:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
8001cbe6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001cbea:	df 02 25 00 	jeq %d2,0,8001cc34 <tcp_recv+0x5a>
    LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
8001cbee:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cbf2:	d9 22 14 00 	lea %a2,[%a2]20
8001cbf6:	54 22       	ld.w %d2,[%a2]
8001cbf8:	df 12 17 80 	jne %d2,1,8001cc26 <tcp_recv+0x4c>
8001cbfc:	91 00 00 28 	movh.a %a2,32768
8001cc00:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001cc04:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001cc08:	3b f0 7d 20 	mov %d2,2015
8001cc0c:	59 a2 04 00 	st.w [%sp]4,%d2
8001cc10:	91 00 00 28 	movh.a %a2,32768
8001cc14:	d9 22 08 f2 	lea %a2,[%a2]9160 <800023c8 <IfxCpu_Trap_vectorTable0_end+0x21d4>>
8001cc18:	f4 a2       	st.a [%sp],%a2
8001cc1a:	91 00 00 28 	movh.a %a2,32768
8001cc1e:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001cc22:	6d ff 8a 43 	call 80005336 <Ifx_Lwip_printf>
    pcb->recv = recv;
8001cc26:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cc2a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001cc2e:	d9 22 08 20 	lea %a2,[%a2]136
8001cc32:	74 22       	st.w [%a2],%d2
  }
}
8001cc34:	00 00       	nop 
8001cc36:	00 90       	ret 

8001cc38 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
8001cc38:	40 ae       	mov.aa %a14,%sp
8001cc3a:	20 18       	sub.a %sp,24
8001cc3c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001cc40:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
8001cc44:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001cc48:	df 02 25 00 	jeq %d2,0,8001cc92 <tcp_sent+0x5a>
    LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
8001cc4c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cc50:	d9 22 14 00 	lea %a2,[%a2]20
8001cc54:	54 22       	ld.w %d2,[%a2]
8001cc56:	df 12 17 80 	jne %d2,1,8001cc84 <tcp_sent+0x4c>
8001cc5a:	91 00 00 28 	movh.a %a2,32768
8001cc5e:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001cc62:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001cc66:	3b 30 7f 20 	mov %d2,2035
8001cc6a:	59 a2 04 00 	st.w [%sp]4,%d2
8001cc6e:	91 00 00 28 	movh.a %a2,32768
8001cc72:	d9 22 2f f2 	lea %a2,[%a2]9199 <800023ef <IfxCpu_Trap_vectorTable0_end+0x21fb>>
8001cc76:	f4 a2       	st.a [%sp],%a2
8001cc78:	91 00 00 28 	movh.a %a2,32768
8001cc7c:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001cc80:	6d ff 5b 43 	call 80005336 <Ifx_Lwip_printf>
    pcb->sent = sent;
8001cc84:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cc88:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001cc8c:	d9 22 04 20 	lea %a2,[%a2]132
8001cc90:	74 22       	st.w [%a2],%d2
  }
}
8001cc92:	00 00       	nop 
8001cc94:	00 90       	ret 

8001cc96 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occurred on the connection
 */
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
8001cc96:	40 ae       	mov.aa %a14,%sp
8001cc98:	20 18       	sub.a %sp,24
8001cc9a:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001cc9e:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
  LWIP_ASSERT_CORE_LOCKED();
  if (pcb != NULL) {
8001cca2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001cca6:	df 02 25 00 	jeq %d2,0,8001ccf0 <tcp_err+0x5a>
    LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
8001ccaa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ccae:	d9 22 14 00 	lea %a2,[%a2]20
8001ccb2:	54 22       	ld.w %d2,[%a2]
8001ccb4:	df 12 17 80 	jne %d2,1,8001cce2 <tcp_err+0x4c>
8001ccb8:	91 00 00 28 	movh.a %a2,32768
8001ccbc:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001ccc0:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001ccc4:	3b d0 80 20 	mov %d2,2061
8001ccc8:	59 a2 04 00 	st.w [%sp]4,%d2
8001cccc:	91 00 00 28 	movh.a %a2,32768
8001ccd0:	d9 22 56 02 	lea %a2,[%a2]9238 <80002416 <IfxCpu_Trap_vectorTable0_end+0x2222>>
8001ccd4:	f4 a2       	st.a [%sp],%a2
8001ccd6:	91 00 00 28 	movh.a %a2,32768
8001ccda:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001ccde:	6d ff 2c 43 	call 80005336 <Ifx_Lwip_printf>
    pcb->errf = err;
8001cce2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cce6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001ccea:	d9 22 14 20 	lea %a2,[%a2]148
8001ccee:	74 22       	st.w [%a2],%d2
  }
}
8001ccf0:	00 00       	nop 
8001ccf2:	00 90       	ret 

8001ccf4 <tcp_accept>:
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
8001ccf4:	40 ae       	mov.aa %a14,%sp
8001ccf6:	20 10       	sub.a %sp,16
8001ccf8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001ccfc:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  LWIP_ASSERT_CORE_LOCKED();
  if ((pcb != NULL) && (pcb->state == LISTEN)) {
8001cd00:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001cd04:	df 02 14 00 	jeq %d2,0,8001cd2c <tcp_accept+0x38>
8001cd08:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001cd0c:	d9 22 14 00 	lea %a2,[%a2]20
8001cd10:	54 22       	ld.w %d2,[%a2]
8001cd12:	df 12 0d 80 	jne %d2,1,8001cd2c <tcp_accept+0x38>
    struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen *)pcb;
8001cd16:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001cd1a:	59 e2 fc ff 	st.w [%a14]-4,%d2
    lpcb->accept = accept;
8001cd1e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cd22:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001cd26:	d9 22 1c 00 	lea %a2,[%a2]28
8001cd2a:	74 22       	st.w [%a2],%d2
  }
}
8001cd2c:	00 00       	nop 
8001cd2e:	00 90       	ret 

8001cd30 <tcp_poll>:
 * the application may use the polling functionality to call tcp_write()
 * again when the connection has been idle for a while.
 */
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
8001cd30:	40 ae       	mov.aa %a14,%sp
8001cd32:	20 20       	sub.a %sp,32
8001cd34:	b5 e4 fc ff 	st.a [%a14]-4,%a4
8001cd38:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
8001cd3c:	02 42       	mov %d2,%d4
8001cd3e:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
8001cd42:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001cd46:	df 02 18 80 	jne %d2,0,8001cd76 <tcp_poll+0x46>
8001cd4a:	91 00 00 28 	movh.a %a2,32768
8001cd4e:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001cd52:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001cd56:	3b d0 83 20 	mov %d2,2109
8001cd5a:	59 a2 04 00 	st.w [%sp]4,%d2
8001cd5e:	91 00 00 28 	movh.a %a2,32768
8001cd62:	d9 22 7c 02 	lea %a2,[%a2]9276 <8000243c <IfxCpu_Trap_vectorTable0_end+0x2248>>
8001cd66:	f4 a2       	st.a [%sp],%a2
8001cd68:	91 00 00 28 	movh.a %a2,32768
8001cd6c:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001cd70:	6d ff e3 42 	call 80005336 <Ifx_Lwip_printf>
8001cd74:	00 90       	ret 
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
8001cd76:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cd7a:	d9 22 14 00 	lea %a2,[%a2]20
8001cd7e:	54 22       	ld.w %d2,[%a2]
8001cd80:	df 12 17 80 	jne %d2,1,8001cdae <tcp_poll+0x7e>
8001cd84:	91 00 00 28 	movh.a %a2,32768
8001cd88:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001cd8c:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001cd90:	3b e0 83 20 	mov %d2,2110
8001cd94:	59 a2 04 00 	st.w [%sp]4,%d2
8001cd98:	91 00 00 28 	movh.a %a2,32768
8001cd9c:	d9 22 52 12 	lea %a2,[%a2]9298 <80002452 <IfxCpu_Trap_vectorTable0_end+0x225e>>
8001cda0:	f4 a2       	st.a [%sp],%a2
8001cda2:	91 00 00 28 	movh.a %a2,32768
8001cda6:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001cdaa:	6d ff c6 42 	call 80005336 <Ifx_Lwip_printf>

#if LWIP_CALLBACK_API
  pcb->poll = poll;
8001cdae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cdb2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001cdb6:	d9 22 10 20 	lea %a2,[%a2]144
8001cdba:	74 22       	st.w [%a2],%d2
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */
  pcb->pollinterval = interval;
8001cdbc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cdc0:	79 e2 f4 ff 	ld.b %d2,[%a14]-12
8001cdc4:	e9 22 21 00 	st.b [%a2]33,%d2
}
8001cdc8:	00 90       	ret 

8001cdca <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
8001cdca:	40 ae       	mov.aa %a14,%sp
8001cdcc:	20 18       	sub.a %sp,24
8001cdce:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
8001cdd2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001cdd6:	df 02 18 80 	jne %d2,0,8001ce06 <tcp_pcb_purge+0x3c>
8001cdda:	91 00 00 28 	movh.a %a2,32768
8001cdde:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001cde2:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001cde6:	3b 10 85 20 	mov %d2,2129
8001cdea:	59 a2 04 00 	st.w [%sp]4,%d2
8001cdee:	91 00 00 28 	movh.a %a2,32768
8001cdf2:	d9 22 70 12 	lea %a2,[%a2]9328 <80002470 <IfxCpu_Trap_vectorTable0_end+0x227c>>
8001cdf6:	f4 a2       	st.a [%sp],%a2
8001cdf8:	91 00 00 28 	movh.a %a2,32768
8001cdfc:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001ce00:	6d ff 9b 42 	call 80005336 <Ifx_Lwip_printf>
8001ce04:	00 90       	ret 

  if (pcb->state != CLOSED &&
8001ce06:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce0a:	d9 22 14 00 	lea %a2,[%a2]20
8001ce0e:	54 22       	ld.w %d2,[%a2]
8001ce10:	df 02 5c 00 	jeq %d2,0,8001cec8 <tcp_pcb_purge+0xfe>
      pcb->state != TIME_WAIT &&
8001ce14:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce18:	d9 22 14 00 	lea %a2,[%a2]20
8001ce1c:	54 22       	ld.w %d2,[%a2]
  if (pcb->state != CLOSED &&
8001ce1e:	8b a2 00 22 	eq %d2,%d2,10
8001ce22:	df 02 53 80 	jne %d2,0,8001cec8 <tcp_pcb_purge+0xfe>
      pcb->state != LISTEN) {
8001ce26:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce2a:	d9 22 14 00 	lea %a2,[%a2]20
8001ce2e:	54 22       	ld.w %d2,[%a2]
      pcb->state != TIME_WAIT &&
8001ce30:	df 12 4c 00 	jeq %d2,1,8001cec8 <tcp_pcb_purge+0xfe>

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    tcp_backlog_accepted(pcb);

    if (pcb->refused_data != NULL) {
8001ce34:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce38:	d9 22 3c 10 	lea %a2,[%a2]124
8001ce3c:	54 22       	ld.w %d2,[%a2]
8001ce3e:	df 02 10 00 	jeq %d2,0,8001ce5e <tcp_pcb_purge+0x94>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
8001ce42:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce46:	d9 22 3c 10 	lea %a2,[%a2]124
8001ce4a:	54 22       	ld.w %d2,[%a2]
8001ce4c:	60 24       	mov.a %a4,%d2
8001ce4e:	6d ff a5 e8 	call 80019f98 <pbuf_free>
      pcb->refused_data = NULL;
8001ce52:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce56:	82 02       	mov %d2,0
8001ce58:	d9 22 3c 10 	lea %a2,[%a2]124
8001ce5c:	74 22       	st.w [%a2],%d2
    }
    if (pcb->unacked != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
8001ce5e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce62:	d9 22 38 10 	lea %a2,[%a2]120
8001ce66:	54 22       	ld.w %d2,[%a2]
8001ce68:	df 02 06 00 	jeq %d2,0,8001ce74 <tcp_pcb_purge+0xaa>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
      tcp_free_ooseq(pcb);
8001ce6c:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001ce70:	6d 00 65 02 	call 8001d33a <tcp_free_ooseq>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
8001ce74:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce78:	82 f2       	mov %d2,-1
8001ce7a:	f9 22 34 00 	st.h [%a2]52,%d2

    tcp_segs_free(pcb->unsent);
8001ce7e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce82:	d9 22 30 10 	lea %a2,[%a2]112
8001ce86:	54 22       	ld.w %d2,[%a2]
8001ce88:	60 24       	mov.a %a4,%d2
8001ce8a:	6d ff 77 fb 	call 8001c578 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
8001ce8e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ce92:	d9 22 34 10 	lea %a2,[%a2]116
8001ce96:	54 22       	ld.w %d2,[%a2]
8001ce98:	60 24       	mov.a %a4,%d2
8001ce9a:	6d ff 6f fb 	call 8001c578 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
8001ce9e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cea2:	82 02       	mov %d2,0
8001cea4:	d9 22 30 10 	lea %a2,[%a2]112
8001cea8:	74 22       	st.w [%a2],%d2
8001ceaa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ceae:	d9 22 30 10 	lea %a2,[%a2]112
8001ceb2:	54 22       	ld.w %d2,[%a2]
8001ceb4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001ceb8:	d9 22 34 10 	lea %a2,[%a2]116
8001cebc:	74 22       	st.w [%a2],%d2
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
8001cebe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cec2:	82 02       	mov %d2,0
8001cec4:	f9 22 2c 10 	st.h [%a2]108,%d2
#endif /* TCP_OVERSIZE */
  }
}
8001cec8:	00 90       	ret 

8001ceca <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
8001ceca:	40 ae       	mov.aa %a14,%sp
8001cecc:	20 20       	sub.a %sp,32
8001cece:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001ced2:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
8001ced6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001ceda:	df 02 17 80 	jne %d2,0,8001cf08 <tcp_pcb_remove+0x3e>
8001cede:	91 00 00 28 	movh.a %a2,32768
8001cee2:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001cee6:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001ceea:	3b 30 88 20 	mov %d2,2179
8001ceee:	59 a2 04 00 	st.w [%sp]4,%d2
8001cef2:	91 00 00 28 	movh.a %a2,32768
8001cef6:	d9 22 4b 22 	lea %a2,[%a2]9355 <8000248b <IfxCpu_Trap_vectorTable0_end+0x2297>>
8001cefa:	f4 a2       	st.a [%sp],%a2
8001cefc:	91 00 00 28 	movh.a %a2,32768
8001cf00:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001cf04:	6d ff 19 42 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
8001cf08:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001cf0c:	df 02 17 80 	jne %d2,0,8001cf3a <tcp_pcb_remove+0x70>
8001cf10:	91 00 00 28 	movh.a %a2,32768
8001cf14:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001cf18:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001cf1c:	3b 40 88 20 	mov %d2,2180
8001cf20:	59 a2 04 00 	st.w [%sp]4,%d2
8001cf24:	91 00 00 28 	movh.a %a2,32768
8001cf28:	d9 22 67 22 	lea %a2,[%a2]9383 <800024a7 <IfxCpu_Trap_vectorTable0_end+0x22b3>>
8001cf2c:	f4 a2       	st.a [%sp],%a2
8001cf2e:	91 00 00 28 	movh.a %a2,32768
8001cf32:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001cf36:	6d ff 00 42 	call 80005336 <Ifx_Lwip_printf>

  TCP_RMV(pcblist, pcb);
8001cf3a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001cf3e:	54 22       	ld.w %d2,[%a2]
8001cf40:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8001cf44:	5f 23 0d 80 	jne %d3,%d2,8001cf5e <tcp_pcb_remove+0x94>
8001cf48:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001cf4c:	d4 22       	ld.a %a2,[%a2]
8001cf4e:	d9 22 0c 00 	lea %a2,[%a2]12
8001cf52:	54 22       	ld.w %d2,[%a2]
8001cf54:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001cf58:	74 22       	st.w [%a2],%d2
8001cf5a:	1d 00 29 00 	j 8001cfac <tcp_pcb_remove+0xe2>
8001cf5e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001cf62:	54 22       	ld.w %d2,[%a2]
8001cf64:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001cf68:	1d 00 1e 00 	j 8001cfa4 <tcp_pcb_remove+0xda>
8001cf6c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cf70:	d9 22 0c 00 	lea %a2,[%a2]12
8001cf74:	54 22       	ld.w %d2,[%a2]
8001cf76:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8001cf7a:	5f 23 0e 80 	jne %d3,%d2,8001cf96 <tcp_pcb_remove+0xcc>
8001cf7e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001cf82:	d9 22 0c 00 	lea %a2,[%a2]12
8001cf86:	54 22       	ld.w %d2,[%a2]
8001cf88:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cf8c:	d9 22 0c 00 	lea %a2,[%a2]12
8001cf90:	74 22       	st.w [%a2],%d2
8001cf92:	1d 00 0d 00 	j 8001cfac <tcp_pcb_remove+0xe2>
8001cf96:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001cf9a:	d9 22 0c 00 	lea %a2,[%a2]12
8001cf9e:	54 22       	ld.w %d2,[%a2]
8001cfa0:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001cfa4:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001cfa8:	df 02 e2 ff 	jne %d2,0,8001cf6c <tcp_pcb_remove+0xa2>
8001cfac:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001cfb0:	82 02       	mov %d2,0
8001cfb2:	d9 22 0c 00 	lea %a2,[%a2]12
8001cfb6:	74 22       	st.w [%a2],%d2

  tcp_pcb_purge(pcb);
8001cfb8:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
8001cfbc:	6d ff 07 ff 	call 8001cdca <tcp_pcb_purge>

  /* if there is an outstanding delayed ACKs, send it */
  if ((pcb->state != TIME_WAIT) &&
8001cfc0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001cfc4:	d9 22 14 00 	lea %a2,[%a2]20
8001cfc8:	54 22       	ld.w %d2,[%a2]
8001cfca:	8b a2 00 22 	eq %d2,%d2,10
8001cfce:	df 02 21 80 	jne %d2,0,8001d010 <tcp_pcb_remove+0x146>
      (pcb->state != LISTEN) &&
8001cfd2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001cfd6:	d9 22 14 00 	lea %a2,[%a2]20
8001cfda:	54 22       	ld.w %d2,[%a2]
  if ((pcb->state != TIME_WAIT) &&
8001cfdc:	df 12 1a 00 	jeq %d2,1,8001d010 <tcp_pcb_remove+0x146>
      (pcb->flags & TF_ACK_DELAY)) {
8001cfe0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001cfe4:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001cfe8:	8f 12 00 21 	and %d2,%d2,1
      (pcb->state != LISTEN) &&
8001cfec:	df 02 12 00 	jeq %d2,0,8001d010 <tcp_pcb_remove+0x146>
    tcp_ack_now(pcb);
8001cff0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001cff4:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001cff8:	8f 22 40 21 	or %d2,%d2,2
8001cffc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d000:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d004:	f9 22 1e 00 	st.h [%a2]30,%d2
    tcp_output(pcb);
8001d008:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
8001d00c:	6d 00 c4 31 	call 80023394 <tcp_output>
  }

  if (pcb->state != LISTEN) {
8001d010:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d014:	d9 22 14 00 	lea %a2,[%a2]20
8001d018:	54 22       	ld.w %d2,[%a2]
8001d01a:	df 12 56 00 	jeq %d2,1,8001d0c6 <tcp_pcb_remove+0x1fc>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
8001d01e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d022:	d9 22 30 10 	lea %a2,[%a2]112
8001d026:	54 22       	ld.w %d2,[%a2]
8001d028:	df 02 17 00 	jeq %d2,0,8001d056 <tcp_pcb_remove+0x18c>
8001d02c:	91 00 00 28 	movh.a %a2,32768
8001d030:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001d034:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001d038:	3b 30 89 20 	mov %d2,2195
8001d03c:	59 a2 04 00 	st.w [%sp]4,%d2
8001d040:	91 00 00 28 	movh.a %a2,32768
8001d044:	d9 22 47 32 	lea %a2,[%a2]9415 <800024c7 <IfxCpu_Trap_vectorTable0_end+0x22d3>>
8001d048:	f4 a2       	st.a [%sp],%a2
8001d04a:	91 00 00 28 	movh.a %a2,32768
8001d04e:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001d052:	6d ff 72 41 	call 80005336 <Ifx_Lwip_printf>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
8001d056:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d05a:	d9 22 34 10 	lea %a2,[%a2]116
8001d05e:	54 22       	ld.w %d2,[%a2]
8001d060:	df 02 17 00 	jeq %d2,0,8001d08e <tcp_pcb_remove+0x1c4>
8001d064:	91 00 00 28 	movh.a %a2,32768
8001d068:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001d06c:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001d070:	3b 40 89 20 	mov %d2,2196
8001d074:	59 a2 04 00 	st.w [%sp]4,%d2
8001d078:	91 00 00 28 	movh.a %a2,32768
8001d07c:	d9 22 5f 32 	lea %a2,[%a2]9439 <800024df <IfxCpu_Trap_vectorTable0_end+0x22eb>>
8001d080:	f4 a2       	st.a [%sp],%a2
8001d082:	91 00 00 28 	movh.a %a2,32768
8001d086:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001d08a:	6d ff 56 41 	call 80005336 <Ifx_Lwip_printf>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
8001d08e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d092:	d9 22 38 10 	lea %a2,[%a2]120
8001d096:	54 22       	ld.w %d2,[%a2]
8001d098:	df 02 17 00 	jeq %d2,0,8001d0c6 <tcp_pcb_remove+0x1fc>
8001d09c:	91 00 00 28 	movh.a %a2,32768
8001d0a0:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001d0a4:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001d0a8:	3b 60 89 20 	mov %d2,2198
8001d0ac:	59 a2 04 00 	st.w [%sp]4,%d2
8001d0b0:	91 00 00 28 	movh.a %a2,32768
8001d0b4:	d9 22 78 32 	lea %a2,[%a2]9464 <800024f8 <IfxCpu_Trap_vectorTable0_end+0x2304>>
8001d0b8:	f4 a2       	st.a [%sp],%a2
8001d0ba:	91 00 00 28 	movh.a %a2,32768
8001d0be:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001d0c2:	6d ff 3a 41 	call 80005336 <Ifx_Lwip_printf>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
8001d0c6:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d0ca:	82 02       	mov %d2,0
8001d0cc:	d9 22 14 00 	lea %a2,[%a2]20
8001d0d0:	74 22       	st.w [%a2],%d2
  /* reset the local port to prevent the pcb from being 'bound' */
  pcb->local_port = 0;
8001d0d2:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d0d6:	82 02       	mov %d2,0
8001d0d8:	f9 22 1a 00 	st.h [%a2]26,%d2

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
8001d0dc:	00 00       	nop 
8001d0de:	00 90       	ret 

8001d0e0 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
8001d0e0:	40 ae       	mov.aa %a14,%sp
8001d0e2:	20 18       	sub.a %sp,24
8001d0e4:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
8001d0e8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001d0ec:	df 02 17 80 	jne %d2,0,8001d11a <tcp_next_iss+0x3a>
8001d0f0:	91 00 00 28 	movh.a %a2,32768
8001d0f4:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001d0f8:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001d0fc:	3b f0 8a 20 	mov %d2,2223
8001d100:	59 a2 04 00 	st.w [%sp]4,%d2
8001d104:	91 00 00 28 	movh.a %a2,32768
8001d108:	d9 22 4f 42 	lea %a2,[%a2]9487 <8000250f <IfxCpu_Trap_vectorTable0_end+0x231b>>
8001d10c:	f4 a2       	st.a [%sp],%a2
8001d10e:	91 00 00 28 	movh.a %a2,32768
8001d112:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001d116:	6d ff 10 41 	call 80005336 <Ifx_Lwip_printf>
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
8001d11a:	91 10 00 27 	movh.a %a2,28673
8001d11e:	d9 22 b4 4a 	lea %a2,[%a2]-22220 <7000a934 <iss.0>>
8001d122:	54 23       	ld.w %d3,[%a2]
8001d124:	91 10 00 27 	movh.a %a2,28673
8001d128:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001d12c:	54 22       	ld.w %d2,[%a2]
8001d12e:	42 32       	add %d2,%d3
8001d130:	91 10 00 27 	movh.a %a2,28673
8001d134:	d9 22 b4 4a 	lea %a2,[%a2]-22220 <7000a934 <iss.0>>
8001d138:	74 22       	st.w [%a2],%d2
  return iss;
8001d13a:	91 10 00 27 	movh.a %a2,28673
8001d13e:	d9 22 b4 4a 	lea %a2,[%a2]-22220 <7000a934 <iss.0>>
8001d142:	54 22       	ld.w %d2,[%a2]
#endif /* LWIP_HOOK_TCP_ISN */
}
8001d144:	00 90       	ret 

8001d146 <tcp_eff_send_mss_netif>:
 * by calculating the minimum of TCP_MSS and the mtu (if set) of the target
 * netif (if not NULL).
 */
u16_t
tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
{
8001d146:	40 ae       	mov.aa %a14,%sp
8001d148:	20 28       	sub.a %sp,40
8001d14a:	02 42       	mov %d2,%d4
8001d14c:	b5 e4 f0 ff 	st.a [%a14]-16,%a4
8001d150:	b5 e5 ec ff 	st.a [%a14]-20,%a5
8001d154:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
  u16_t mss_s;
  u16_t mtu;

  LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */

  LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
8001d158:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001d15c:	df 02 17 80 	jne %d2,0,8001d18a <tcp_eff_send_mss_netif+0x44>
8001d160:	91 00 00 28 	movh.a %a2,32768
8001d164:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001d168:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001d16c:	3b 50 8c 20 	mov %d2,2245
8001d170:	59 a2 04 00 	st.w [%sp]4,%d2
8001d174:	91 00 00 28 	movh.a %a2,32768
8001d178:	d9 22 69 42 	lea %a2,[%a2]9513 <80002529 <IfxCpu_Trap_vectorTable0_end+0x2335>>
8001d17c:	f4 a2       	st.a [%sp],%a2
8001d17e:	91 00 00 28 	movh.a %a2,32768
8001d182:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001d186:	6d ff d8 40 	call 80005336 <Ifx_Lwip_printf>
  else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
  {
    if (outif == NULL) {
8001d18a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001d18e:	df 02 05 80 	jne %d2,0,8001d198 <tcp_eff_send_mss_netif+0x52>
      return sendmss;
8001d192:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8001d196:	00 90       	ret 
    }
    mtu = outif->mtu;
8001d198:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d19c:	c9 22 28 00 	ld.h %d2,[%a2]40
8001d1a0:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  }
#endif /* LWIP_IPV4 */

  if (mtu != 0) {
8001d1a4:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8001d1a8:	df 02 21 00 	jeq %d2,0,8001d1ea <tcp_eff_send_mss_netif+0xa4>
    else
#endif /* LWIP_IPV4 */
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    {
      offset = IP_HLEN + TCP_HLEN;
8001d1ac:	3b 80 02 20 	mov %d2,40
8001d1b0:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    }
#endif /* LWIP_IPV4 */
    mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
8001d1b4:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8001d1b8:	b9 e3 fc ff 	ld.hu %d3,[%a14]-4
8001d1bc:	7f 23 0c 80 	jge.u %d3,%d2,8001d1d4 <tcp_eff_send_mss_netif+0x8e>
8001d1c0:	c9 e3 fe ff 	ld.h %d3,[%a14]-2
8001d1c4:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
8001d1c8:	0b 23 80 20 	sub %d2,%d3,%d2
8001d1cc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d1d0:	1d 00 03 00 	j 8001d1d6 <tcp_eff_send_mss_netif+0x90>
8001d1d4:	82 02       	mov %d2,0
8001d1d6:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
8001d1da:	b9 e3 fa ff 	ld.hu %d3,[%a14]-6
8001d1de:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
8001d1e2:	0b 23 90 21 	min.u %d2,%d3,%d2
8001d1e6:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
  }
  return sendmss;
8001d1ea:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
}
8001d1ee:	00 90       	ret 

8001d1f0 <tcp_netif_ip_addr_changed_pcblist>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

/** Helper function for tcp_netif_ip_addr_changed() that iterates a pcb list */
static void
tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb_list)
{
8001d1f0:	40 ae       	mov.aa %a14,%sp
8001d1f2:	20 20       	sub.a %sp,32
8001d1f4:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001d1f8:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct tcp_pcb *pcb;
  pcb = pcb_list;
8001d1fc:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001d200:	59 e2 fc ff 	st.w [%a14]-4,%d2

  LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
8001d204:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001d208:	df 02 42 80 	jne %d2,0,8001d28c <tcp_netif_ip_addr_changed_pcblist+0x9c>
8001d20c:	91 00 00 28 	movh.a %a2,32768
8001d210:	d9 22 de a1 	lea %a2,[%a2]7838 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>
8001d214:	b5 a2 08 00 	st.a [%sp]8 <80001e9e <IfxCpu_Trap_vectorTable0_end+0x1caa>>,%a2
8001d218:	3b 00 90 20 	mov %d2,2304
8001d21c:	59 a2 04 00 	st.w [%sp]4,%d2
8001d220:	91 00 00 28 	movh.a %a2,32768
8001d224:	d9 22 50 52 	lea %a2,[%a2]9552 <80002550 <IfxCpu_Trap_vectorTable0_end+0x235c>>
8001d228:	f4 a2       	st.a [%sp],%a2
8001d22a:	91 00 00 28 	movh.a %a2,32768
8001d22e:	d9 24 f6 91 	lea %a4,[%a2]7798 <80001e76 <IfxCpu_Trap_vectorTable0_end+0x1c82>>
8001d232:	6d ff 82 40 	call 80005336 <Ifx_Lwip_printf>

  while (pcb != NULL) {
8001d236:	1d 00 2b 00 	j 8001d28c <tcp_netif_ip_addr_changed_pcblist+0x9c>
    /* PCB bound to current local interface address? */
    if (ip_addr_cmp(&pcb->local_ip, old_addr)
8001d23a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d23e:	54 23       	ld.w %d3,[%a2]
8001d240:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001d244:	54 22       	ld.w %d2,[%a2]
8001d246:	5f 23 1c 80 	jne %d3,%d2,8001d27e <tcp_netif_ip_addr_changed_pcblist+0x8e>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
#endif /* LWIP_AUTOIP */
       ) {
      /* this connection must be aborted */
      struct tcp_pcb *next = pcb->next;
8001d24a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d24e:	d9 22 0c 00 	lea %a2,[%a2]12
8001d252:	54 22       	ld.w %d2,[%a2]
8001d254:	59 e2 f8 ff 	st.w [%a14]-8,%d2
      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
8001d258:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001d25c:	74 a2       	st.w [%sp],%d2
8001d25e:	91 00 00 28 	movh.a %a2,32768
8001d262:	d9 24 44 62 	lea %a4,[%a2]9604 <80002584 <IfxCpu_Trap_vectorTable0_end+0x2390>>
8001d266:	6d ff 68 40 	call 80005336 <Ifx_Lwip_printf>
      tcp_abort(pcb);
8001d26a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001d26e:	6d ff 4b ef 	call 8001b104 <tcp_abort>
      pcb = next;
8001d272:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001d276:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001d27a:	1d 00 09 00 	j 8001d28c <tcp_netif_ip_addr_changed_pcblist+0x9c>
    } else {
      pcb = pcb->next;
8001d27e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d282:	d9 22 0c 00 	lea %a2,[%a2]12
8001d286:	54 22       	ld.w %d2,[%a2]
8001d288:	59 e2 fc ff 	st.w [%a14]-4,%d2
  while (pcb != NULL) {
8001d28c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001d290:	df 02 d5 ff 	jne %d2,0,8001d23a <tcp_netif_ip_addr_changed_pcblist+0x4a>
    }
  }
}
8001d294:	00 00       	nop 
8001d296:	00 00       	nop 
8001d298:	00 90       	ret 

8001d29a <tcp_netif_ip_addr_changed>:
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change or NULL if netif has been removed
 */
void
tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
8001d29a:	40 ae       	mov.aa %a14,%sp
8001d29c:	20 10       	sub.a %sp,16
8001d29e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001d2a2:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct tcp_pcb_listen *lpcb;

  if (!ip_addr_isany(old_addr)) {
8001d2a6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001d2aa:	df 02 46 00 	jeq %d2,0,8001d336 <tcp_netif_ip_addr_changed+0x9c>
8001d2ae:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001d2b2:	54 22       	ld.w %d2,[%a2]
8001d2b4:	df 02 41 00 	jeq %d2,0,8001d336 <tcp_netif_ip_addr_changed+0x9c>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
8001d2b8:	91 10 00 27 	movh.a %a2,28673
8001d2bc:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001d2c0:	54 22       	ld.w %d2,[%a2]
8001d2c2:	60 25       	mov.a %a5,%d2
8001d2c4:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001d2c8:	6d ff 94 ff 	call 8001d1f0 <tcp_netif_ip_addr_changed_pcblist>
    tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
8001d2cc:	91 10 00 27 	movh.a %a2,28673
8001d2d0:	d9 22 74 64 	lea %a2,[%a2]17844 <700145b4 <tcp_bound_pcbs>>
8001d2d4:	54 22       	ld.w %d2,[%a2]
8001d2d6:	60 25       	mov.a %a5,%d2
8001d2d8:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001d2dc:	6d ff 8a ff 	call 8001d1f0 <tcp_netif_ip_addr_changed_pcblist>

    if (!ip_addr_isany(new_addr)) {
8001d2e0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001d2e4:	df 02 29 00 	jeq %d2,0,8001d336 <tcp_netif_ip_addr_changed+0x9c>
8001d2e8:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d2ec:	54 22       	ld.w %d2,[%a2]
8001d2ee:	df 02 24 00 	jeq %d2,0,8001d336 <tcp_netif_ip_addr_changed+0x9c>
      /* PCB bound to current local interface address? */
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
8001d2f2:	91 10 00 27 	movh.a %a2,28673
8001d2f6:	d9 22 78 64 	lea %a2,[%a2]17848 <700145b8 <tcp_listen_pcbs>>
8001d2fa:	54 22       	ld.w %d2,[%a2]
8001d2fc:	59 e2 fc ff 	st.w [%a14]-4 <700145b8 <tcp_listen_pcbs>>,%d2
8001d300:	1d 00 17 00 	j 8001d32e <tcp_netif_ip_addr_changed+0x94>
        /* PCB bound to current local interface address? */
        if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
8001d304:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d308:	54 23       	ld.w %d3,[%a2]
8001d30a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001d30e:	54 22       	ld.w %d2,[%a2]
8001d310:	5f 23 08 80 	jne %d3,%d2,8001d320 <tcp_netif_ip_addr_changed+0x86>
          /* The PCB is listening to the old ipaddr and
            * is set to listen to the new one instead */
          ip_addr_copy(lpcb->local_ip, *new_addr);
8001d314:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001d318:	54 22       	ld.w %d2,[%a2]
8001d31a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d31e:	74 22       	st.w [%a2],%d2
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
8001d320:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d324:	d9 22 0c 00 	lea %a2,[%a2]12
8001d328:	54 22       	ld.w %d2,[%a2]
8001d32a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8001d32e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001d332:	df 02 e9 ff 	jne %d2,0,8001d304 <tcp_netif_ip_addr_changed+0x6a>
        }
      }
    }
  }
}
8001d336:	00 00       	nop 
8001d338:	00 90       	ret 

8001d33a <tcp_free_ooseq>:

#if TCP_QUEUE_OOSEQ
/* Free all ooseq pbufs (and possibly reset SACK state) */
void
tcp_free_ooseq(struct tcp_pcb *pcb)
{
8001d33a:	40 ae       	mov.aa %a14,%sp
8001d33c:	20 08       	sub.a %sp,8
8001d33e:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  if (pcb->ooseq) {
8001d342:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d346:	d9 22 38 10 	lea %a2,[%a2]120
8001d34a:	54 22       	ld.w %d2,[%a2]
8001d34c:	df 02 10 00 	jeq %d2,0,8001d36c <tcp_free_ooseq+0x32>
    tcp_segs_free(pcb->ooseq);
8001d350:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d354:	d9 22 38 10 	lea %a2,[%a2]120
8001d358:	54 22       	ld.w %d2,[%a2]
8001d35a:	60 24       	mov.a %a4,%d2
8001d35c:	6d ff 0e f9 	call 8001c578 <tcp_segs_free>
    pcb->ooseq = NULL;
8001d360:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001d364:	82 02       	mov %d2,0
8001d366:	d9 22 38 10 	lea %a2,[%a2]120
8001d36a:	74 22       	st.w [%a2],%d2
#if LWIP_TCP_SACK_OUT
    memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
#endif /* LWIP_TCP_SACK_OUT */
  }
}
8001d36c:	00 00       	nop 
8001d36e:	00 90       	ret 

8001d370 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
8001d370:	40 ae       	mov.aa %a14,%sp
8001d372:	20 30       	sub.a %sp,48
8001d374:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
8001d378:	b5 e5 e0 ff 	st.a [%a14]-32,%a5
  u8_t hdrlen_bytes;
  err_t err;

  LWIP_UNUSED_ARG(inp);
  LWIP_ASSERT_CORE_LOCKED();
  LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
8001d37c:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8001d380:	df 02 17 80 	jne %d2,0,8001d3ae <tcp_input+0x3e>
8001d384:	91 00 00 28 	movh.a %a2,32768
8001d388:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001d38c:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001d390:	3b 30 08 20 	mov %d2,131
8001d394:	59 a2 04 00 	st.w [%sp]4,%d2
8001d398:	91 00 00 28 	movh.a %a2,32768
8001d39c:	d9 22 40 82 	lea %a2,[%a2]9728 <80002600 <IfxCpu_Trap_vectorTable0_end+0x240c>>
8001d3a0:	f4 a2       	st.a [%sp],%a2
8001d3a2:	91 00 00 28 	movh.a %a2,32768
8001d3a6:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001d3aa:	6d ff c6 3f 	call 80005336 <Ifx_Lwip_printf>

  PERF_START;

  TCP_STATS_INC(tcp.recv);
8001d3ae:	91 10 00 27 	movh.a %a2,28673
8001d3b2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d3b6:	b9 22 12 20 	ld.hu %d2,[%a2]146 <70010092 <ram_heap+0x4ffe>>
8001d3ba:	c2 12       	add %d2,1
8001d3bc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d3c0:	91 10 00 27 	movh.a %a2,28673
8001d3c4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d3c8:	f9 22 12 20 	st.h [%a2]146 <70010092 <ram_heap+0x4ffe>>,%d2
  MIB2_STATS_INC(mib2.tcpinsegs);

  tcphdr = (struct tcp_hdr *)p->payload;
8001d3cc:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <70010092 <ram_heap+0x4ffe>>
8001d3d0:	b0 42       	add.a %a2,4
8001d3d2:	54 22       	ld.w %d2,[%a2]
8001d3d4:	91 10 00 27 	movh.a %a2,28673
8001d3d8:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d3dc:	74 22       	st.w [%a2],%d2
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* Check that TCP header fits in payload */
  if (p->len < TCP_HLEN) {
8001d3de:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145dc <tcphdr>>
8001d3e2:	b9 22 0a 00 	ld.hu %d2,[%a2]10 <700145dc <tcphdr>>
8001d3e6:	8b 42 a1 22 	ge.u %d2,%d2,20
8001d3ea:	df 02 13 80 	jne %d2,0,8001d410 <tcp_input+0xa0>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
8001d3ee:	91 10 00 27 	movh.a %a2,28673
8001d3f2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d3f6:	b9 22 1a 20 	ld.hu %d2,[%a2]154 <7001009a <ram_heap+0x5006>>
8001d3fa:	c2 12       	add %d2,1
8001d3fc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d400:	91 10 00 27 	movh.a %a2,28673
8001d404:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d408:	f9 22 1a 20 	st.h [%a2]154 <7001009a <ram_heap+0x5006>>,%d2
    goto dropped;
8001d40c:	1d 00 fa 07 	j 8001e400 <tcp_input+0x1090>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
8001d410:	91 10 00 27 	movh.a %a2,28673
8001d414:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001d418:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
8001d41c:	54 22       	ld.w %d2,[%a2]
8001d41e:	91 10 00 27 	movh.a %a2,28673
8001d422:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001d426:	54 23       	ld.w %d3,[%a2]
8001d428:	60 34       	mov.a %a4,%d3
8001d42a:	02 24       	mov %d4,%d2
8001d42c:	6d ff 10 c4 	call 80015c4c <ip4_addr_isbroadcast_u32>
8001d430:	df 02 0f 80 	jne %d2,0,8001d44e <tcp_input+0xde>
      ip_addr_ismulticast(ip_current_dest_addr())) {
8001d434:	91 10 00 27 	movh.a %a2,28673
8001d438:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001d43c:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
8001d440:	54 22       	ld.w %d2,[%a2]
8001d442:	8f 02 0f 21 	and %d2,%d2,240
  if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
8001d446:	8b 02 2e 22 	ne %d2,%d2,224
8001d44a:	df 02 13 80 	jne %d2,0,8001d470 <tcp_input+0x100>
    TCP_STATS_INC(tcp.proterr);
8001d44e:	91 10 00 27 	movh.a %a2,28673
8001d452:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d456:	b9 22 20 20 	ld.hu %d2,[%a2]160 <700100a0 <ram_heap+0x500c>>
8001d45a:	c2 12       	add %d2,1
8001d45c:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d460:	91 10 00 27 	movh.a %a2,28673
8001d464:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d468:	f9 22 20 20 	st.h [%a2]160 <700100a0 <ram_heap+0x500c>>,%d2
    goto dropped;
8001d46c:	1d 00 ca 07 	j 8001e400 <tcp_input+0x1090>
  }

#if CHECKSUM_CHECK_TCP
  IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
    /* Verify TCP checksum. */
    u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
8001d470:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d474:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001d478:	91 10 00 27 	movh.a %a2,28673
8001d47c:	d9 26 10 2b 	lea %a6,[%a2]-20336 <7000b090 <ip_data+0x14>>
8001d480:	91 10 00 27 	movh.a %a2,28673
8001d484:	d9 25 0c 2b 	lea %a5,[%a2]-20340 <7000b08c <ip_data+0x10>>
8001d488:	02 25       	mov %d5,%d2
8001d48a:	82 64       	mov %d4,6
8001d48c:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001d490:	6d ff 2c d2 	call 800178e8 <ip_chksum_pseudo>
8001d494:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
                                    ip_current_src_addr(), ip_current_dest_addr());
    if (chksum != 0) {
8001d498:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
8001d49c:	df 02 13 00 	jeq %d2,0,8001d4c2 <tcp_input+0x152>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
                                    chksum));
      tcp_debug_print(tcphdr);
      TCP_STATS_INC(tcp.chkerr);
8001d4a0:	91 10 00 27 	movh.a %a2,28673
8001d4a4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d4a8:	b9 22 18 20 	ld.hu %d2,[%a2]152 <70010098 <ram_heap+0x5004>>
8001d4ac:	c2 12       	add %d2,1
8001d4ae:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d4b2:	91 10 00 27 	movh.a %a2,28673
8001d4b6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d4ba:	f9 22 18 20 	st.h [%a2]152 <70010098 <ram_heap+0x5004>>,%d2
      goto dropped;
8001d4be:	1d 00 a1 07 	j 8001e400 <tcp_input+0x1090>
    }
  }
#endif /* CHECKSUM_CHECK_TCP */

  /* sanity-check header length */
  hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
8001d4c2:	91 10 00 27 	movh.a %a2,28673
8001d4c6:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d4ca:	d4 22       	ld.a %a2,[%a2]
8001d4cc:	39 23 0c 00 	ld.bu %d3,[%a2]12 <700145dc <tcphdr>>
8001d4d0:	39 22 0d 00 	ld.bu %d2,[%a2]13 <700145dc <tcphdr>>
8001d4d4:	8f 82 00 20 	sh %d2,%d2,8
8001d4d8:	a6 32       	or %d2,%d3
8001d4da:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d4de:	02 24       	mov %d4,%d2
8001d4e0:	6d ff 3a d0 	call 80017554 <lwip_htons>
8001d4e4:	8f 42 1f 20 	sh %d2,%d2,-12
8001d4e8:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d4ec:	8f f2 0f 21 	and %d2,%d2,255
8001d4f0:	06 22       	sh %d2,2
8001d4f2:	e9 e2 ef ff 	st.b [%a14]-17,%d2
  if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
8001d4f6:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
8001d4fa:	8b 42 61 22 	lt.u %d2,%d2,20
8001d4fe:	df 02 0c 80 	jne %d2,0,8001d516 <tcp_input+0x1a6>
8001d502:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
8001d506:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d50a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d50e:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001d512:	7f 23 13 80 	jge.u %d3,%d2,8001d538 <tcp_input+0x1c8>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_bytes));
    TCP_STATS_INC(tcp.lenerr);
8001d516:	91 10 00 27 	movh.a %a2,28673
8001d51a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d51e:	b9 22 1a 20 	ld.hu %d2,[%a2]154 <7001009a <ram_heap+0x5006>>
8001d522:	c2 12       	add %d2,1
8001d524:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d528:	91 10 00 27 	movh.a %a2,28673
8001d52c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d530:	f9 22 1a 20 	st.h [%a2]154 <7001009a <ram_heap+0x5006>>,%d2
    goto dropped;
8001d534:	1d 00 66 07 	j 8001e400 <tcp_input+0x1090>
  }

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
8001d538:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
8001d53c:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d540:	1b c2 fe 2f 	addi %d2,%d2,-20
8001d544:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d548:	91 10 00 27 	movh.a %a2,28673
8001d54c:	d9 22 60 74 	lea %a2,[%a2]17888 <700145e0 <tcphdr_optlen>>
8001d550:	b4 22       	st.h [%a2],%d2
  tcphdr_opt2 = NULL;
8001d552:	91 10 00 27 	movh.a %a2,28673
8001d556:	d9 22 64 74 	lea %a2,[%a2]17892 <700145e4 <tcphdr_opt2>>
8001d55a:	82 02       	mov %d2,0
8001d55c:	74 22       	st.w [%a2],%d2
  if (p->len >= hdrlen_bytes) {
8001d55e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d562:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8001d566:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
8001d56a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d56e:	3f 23 16 80 	jlt.u %d3,%d2,8001d59a <tcp_input+0x22a>
    /* all options are in the first pbuf */
    tcphdr_opt1len = tcphdr_optlen;
8001d572:	91 10 00 27 	movh.a %a2,28673
8001d576:	d9 22 60 74 	lea %a2,[%a2]17888 <700145e0 <tcphdr_optlen>>
8001d57a:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001d57e:	91 10 00 27 	movh.a %a2,28673
8001d582:	d9 22 62 74 	lea %a2,[%a2]17890 <700145e2 <tcphdr_opt1len>>
8001d586:	b4 22       	st.h [%a2],%d2
    pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
8001d588:	39 e2 ef ff 	ld.bu %d2,[%a14]-17 <700145e2 <tcphdr_opt1len>>
8001d58c:	02 24       	mov %d4,%d2
8001d58e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001d592:	6d ff 3d e4 	call 80019e0c <pbuf_remove_header>
8001d596:	1d 00 bc 00 	j 8001d70e <tcp_input+0x39e>
  } else {
    u16_t opt2len;
    /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
    /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
    LWIP_ASSERT("p->next != NULL", p->next != NULL);
8001d59a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d59e:	54 22       	ld.w %d2,[%a2]
8001d5a0:	df 02 17 80 	jne %d2,0,8001d5ce <tcp_input+0x25e>
8001d5a4:	91 00 00 28 	movh.a %a2,32768
8001d5a8:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001d5ac:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001d5b0:	3b 20 0c 20 	mov %d2,194
8001d5b4:	59 a2 04 00 	st.w [%sp]4,%d2
8001d5b8:	91 00 00 28 	movh.a %a2,32768
8001d5bc:	d9 22 58 82 	lea %a2,[%a2]9752 <80002618 <IfxCpu_Trap_vectorTable0_end+0x2424>>
8001d5c0:	f4 a2       	st.a [%sp],%a2
8001d5c2:	91 00 00 28 	movh.a %a2,32768
8001d5c6:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001d5ca:	6d ff b6 3e 	call 80005336 <Ifx_Lwip_printf>

    /* advance over the TCP header (cannot fail) */
    pbuf_remove_header(p, TCP_HLEN);
8001d5ce:	3b 40 01 40 	mov %d4,20
8001d5d2:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001d5d6:	6d ff 1b e4 	call 80019e0c <pbuf_remove_header>

    /* determine how long the first and second parts of the options are */
    tcphdr_opt1len = p->len;
8001d5da:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d5de:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001d5e2:	91 10 00 27 	movh.a %a2,28673
8001d5e6:	d9 22 62 74 	lea %a2,[%a2]17890 <700145e2 <tcphdr_opt1len>>
8001d5ea:	b4 22       	st.h [%a2],%d2
    opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
8001d5ec:	91 10 00 27 	movh.a %a2,28673
8001d5f0:	d9 22 60 74 	lea %a2,[%a2]17888 <700145e0 <tcphdr_optlen>>
8001d5f4:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001d5f8:	91 10 00 27 	movh.a %a2,28673
8001d5fc:	d9 22 62 74 	lea %a2,[%a2]17890 <700145e2 <tcphdr_opt1len>>
8001d600:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001d604:	0b 23 80 20 	sub %d2,%d3,%d2
8001d608:	f9 e2 ec ff 	st.h [%a14]-20,%d2

    /* options continue in the next pbuf: set p to zero length and hide the
        options in the next pbuf (adjusting p->tot_len) */
    pbuf_remove_header(p, tcphdr_opt1len);
8001d60c:	91 10 00 27 	movh.a %a2,28673
8001d610:	d9 22 62 74 	lea %a2,[%a2]17890 <700145e2 <tcphdr_opt1len>>
8001d614:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001d618:	02 24       	mov %d4,%d2
8001d61a:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001d61e:	6d ff f7 e3 	call 80019e0c <pbuf_remove_header>

    /* check that the options fit in the second pbuf */
    if (opt2len > p->next->len) {
8001d622:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d626:	d4 22       	ld.a %a2,[%a2]
8001d628:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8001d62c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
8001d630:	7f 23 13 80 	jge.u %d3,%d2,8001d656 <tcp_input+0x2e6>
      /* drop short packets */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: options overflow second pbuf (%"U16_F" bytes)\n", p->next->len));
      TCP_STATS_INC(tcp.lenerr);
8001d634:	91 10 00 27 	movh.a %a2,28673
8001d638:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d63c:	b9 22 1a 20 	ld.hu %d2,[%a2]154 <7001009a <ram_heap+0x5006>>
8001d640:	c2 12       	add %d2,1
8001d642:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d646:	91 10 00 27 	movh.a %a2,28673
8001d64a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d64e:	f9 22 1a 20 	st.h [%a2]154 <7001009a <ram_heap+0x5006>>,%d2
      goto dropped;
8001d652:	1d 00 d7 06 	j 8001e400 <tcp_input+0x1090>
    }

    /* remember the pointer to the second part of the options */
    tcphdr_opt2 = (u8_t *)p->next->payload;
8001d656:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d65a:	d4 22       	ld.a %a2,[%a2]
8001d65c:	b0 42       	add.a %a2,4
8001d65e:	54 22       	ld.w %d2,[%a2]
8001d660:	91 10 00 27 	movh.a %a2,28673
8001d664:	d9 22 64 74 	lea %a2,[%a2]17892 <700145e4 <tcphdr_opt2>>
8001d668:	74 22       	st.w [%a2],%d2

    /* advance p->next to point after the options, and manually
        adjust p->tot_len to keep it consistent with the changed p->next */
    pbuf_remove_header(p->next, opt2len);
8001d66a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145e4 <tcphdr_opt2>>
8001d66e:	54 23       	ld.w %d3,[%a2]
8001d670:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20 <700145e4 <tcphdr_opt2>>
8001d674:	02 24       	mov %d4,%d2
8001d676:	60 34       	mov.a %a4,%d3
8001d678:	6d ff ca e3 	call 80019e0c <pbuf_remove_header>
    p->tot_len = (u16_t)(p->tot_len - opt2len);
8001d67c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d680:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001d684:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
8001d688:	0b 23 80 20 	sub %d2,%d3,%d2
8001d68c:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d690:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d694:	f9 22 08 00 	st.h [%a2]8,%d2

    LWIP_ASSERT("p->len == 0", p->len == 0);
8001d698:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d69c:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8001d6a0:	df 02 17 00 	jeq %d2,0,8001d6ce <tcp_input+0x35e>
8001d6a4:	91 00 00 28 	movh.a %a2,32768
8001d6a8:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001d6ac:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001d6b0:	3b f0 0d 20 	mov %d2,223
8001d6b4:	59 a2 04 00 	st.w [%sp]4,%d2
8001d6b8:	91 00 00 28 	movh.a %a2,32768
8001d6bc:	d9 22 68 82 	lea %a2,[%a2]9768 <80002628 <IfxCpu_Trap_vectorTable0_end+0x2434>>
8001d6c0:	f4 a2       	st.a [%sp],%a2
8001d6c2:	91 00 00 28 	movh.a %a2,32768
8001d6c6:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001d6ca:	6d ff 36 3e 	call 80005336 <Ifx_Lwip_printf>
    LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
8001d6ce:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d6d2:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001d6d6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001d6da:	d4 22       	ld.a %a2,[%a2]
8001d6dc:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001d6e0:	5f 23 17 00 	jeq %d3,%d2,8001d70e <tcp_input+0x39e>
8001d6e4:	91 00 00 28 	movh.a %a2,32768
8001d6e8:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001d6ec:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001d6f0:	3b 00 0e 20 	mov %d2,224
8001d6f4:	59 a2 04 00 	st.w [%sp]4,%d2
8001d6f8:	91 00 00 28 	movh.a %a2,32768
8001d6fc:	d9 22 74 82 	lea %a2,[%a2]9780 <80002634 <IfxCpu_Trap_vectorTable0_end+0x2440>>
8001d700:	f4 a2       	st.a [%sp],%a2
8001d702:	91 00 00 28 	movh.a %a2,32768
8001d706:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001d70a:	6d ff 16 3e 	call 80005336 <Ifx_Lwip_printf>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = lwip_ntohs(tcphdr->src);
8001d70e:	91 10 00 27 	movh.a %a2,28673
8001d712:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d716:	d4 22       	ld.a %a2,[%a2]
8001d718:	14 23       	ld.bu %d3,[%a2]
8001d71a:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001d71e:	8f 82 00 20 	sh %d2,%d2,8
8001d722:	a6 32       	or %d2,%d3
8001d724:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d728:	91 10 00 27 	movh.a %a2,28673
8001d72c:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d730:	d4 2c       	ld.a %a12,[%a2]
8001d732:	02 24       	mov %d4,%d2
8001d734:	6d ff 10 cf 	call 80017554 <lwip_htons>
8001d738:	8f f2 0f 31 	and %d3,%d2,255
8001d73c:	82 04       	mov %d4,0
8001d73e:	a6 43       	or %d3,%d4
8001d740:	34 c3       	st.b [%a12],%d3
8001d742:	06 82       	sh %d2,-8
8001d744:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d748:	82 03       	mov %d3,0
8001d74a:	a6 32       	or %d2,%d3
8001d74c:	e9 c2 01 00 	st.b [%a12]1,%d2
  tcphdr->dest = lwip_ntohs(tcphdr->dest);
8001d750:	91 10 00 27 	movh.a %a2,28673
8001d754:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d758:	d4 22       	ld.a %a2,[%a2]
8001d75a:	39 23 02 00 	ld.bu %d3,[%a2]2 <700145dc <tcphdr>>
8001d75e:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001d762:	8f 82 00 20 	sh %d2,%d2,8
8001d766:	a6 32       	or %d2,%d3
8001d768:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d76c:	91 10 00 27 	movh.a %a2,28673
8001d770:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d774:	d4 2c       	ld.a %a12,[%a2]
8001d776:	02 24       	mov %d4,%d2
8001d778:	6d ff ee ce 	call 80017554 <lwip_htons>
8001d77c:	8f f2 0f 31 	and %d3,%d2,255
8001d780:	82 04       	mov %d4,0
8001d782:	a6 43       	or %d3,%d4
8001d784:	e9 c3 02 00 	st.b [%a12]2,%d3
8001d788:	06 82       	sh %d2,-8
8001d78a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d78e:	82 03       	mov %d3,0
8001d790:	a6 32       	or %d2,%d3
8001d792:	e9 c2 03 00 	st.b [%a12]3,%d2
  seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
8001d796:	91 10 00 27 	movh.a %a2,28673
8001d79a:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d79e:	d4 22       	ld.a %a2,[%a2]
8001d7a0:	39 23 04 00 	ld.bu %d3,[%a2]4 <700145dc <tcphdr>>
8001d7a4:	39 22 05 00 	ld.bu %d2,[%a2]5 <700145dc <tcphdr>>
8001d7a8:	8f 82 00 20 	sh %d2,%d2,8
8001d7ac:	a6 32       	or %d2,%d3
8001d7ae:	39 23 06 00 	ld.bu %d3,[%a2]6
8001d7b2:	8f 03 01 30 	sh %d3,%d3,16
8001d7b6:	a6 32       	or %d2,%d3
8001d7b8:	39 23 07 00 	ld.bu %d3,[%a2]7
8001d7bc:	8f 83 01 30 	sh %d3,%d3,24
8001d7c0:	a6 32       	or %d2,%d3
8001d7c2:	91 10 00 27 	movh.a %a2,28673
8001d7c6:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d7ca:	d4 2c       	ld.a %a12,[%a2]
8001d7cc:	02 24       	mov %d4,%d2
8001d7ce:	6d ff db ce 	call 80017584 <lwip_htonl>
8001d7d2:	8f f2 0f 31 	and %d3,%d2,255
8001d7d6:	82 04       	mov %d4,0
8001d7d8:	a6 43       	or %d3,%d4
8001d7da:	e9 c3 04 00 	st.b [%a12]4,%d3
8001d7de:	8f 82 1f 30 	sh %d3,%d2,-8
8001d7e2:	8f f3 0f 31 	and %d3,%d3,255
8001d7e6:	82 04       	mov %d4,0
8001d7e8:	a6 43       	or %d3,%d4
8001d7ea:	e9 c3 05 00 	st.b [%a12]5,%d3
8001d7ee:	8f 02 1f 30 	sh %d3,%d2,-16
8001d7f2:	8f f3 0f 31 	and %d3,%d3,255
8001d7f6:	82 04       	mov %d4,0
8001d7f8:	a6 43       	or %d3,%d4
8001d7fa:	e9 c3 06 00 	st.b [%a12]6,%d3
8001d7fe:	8f 82 1e 20 	sh %d2,%d2,-24
8001d802:	82 03       	mov %d3,0
8001d804:	a6 32       	or %d2,%d3
8001d806:	e9 c2 07 00 	st.b [%a12]7,%d2
8001d80a:	39 c3 04 00 	ld.bu %d3,[%a12]4
8001d80e:	39 c2 05 00 	ld.bu %d2,[%a12]5
8001d812:	8f 82 00 20 	sh %d2,%d2,8
8001d816:	a6 32       	or %d2,%d3
8001d818:	39 c3 06 00 	ld.bu %d3,[%a12]6
8001d81c:	8f 03 01 30 	sh %d3,%d3,16
8001d820:	a6 32       	or %d2,%d3
8001d822:	39 c3 07 00 	ld.bu %d3,[%a12]7
8001d826:	8f 83 01 30 	sh %d3,%d3,24
8001d82a:	a6 32       	or %d2,%d3
8001d82c:	91 10 00 27 	movh.a %a2,28673
8001d830:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001d834:	74 22       	st.w [%a2],%d2
  ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
8001d836:	91 10 00 27 	movh.a %a2,28673
8001d83a:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d83e:	d4 22       	ld.a %a2,[%a2]
8001d840:	39 23 08 00 	ld.bu %d3,[%a2]8 <700145dc <tcphdr>>
8001d844:	39 22 09 00 	ld.bu %d2,[%a2]9 <700145dc <tcphdr>>
8001d848:	8f 82 00 20 	sh %d2,%d2,8
8001d84c:	a6 32       	or %d2,%d3
8001d84e:	39 23 0a 00 	ld.bu %d3,[%a2]10
8001d852:	8f 03 01 30 	sh %d3,%d3,16
8001d856:	a6 32       	or %d2,%d3
8001d858:	39 23 0b 00 	ld.bu %d3,[%a2]11
8001d85c:	8f 83 01 30 	sh %d3,%d3,24
8001d860:	a6 32       	or %d2,%d3
8001d862:	91 10 00 27 	movh.a %a2,28673
8001d866:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d86a:	d4 2c       	ld.a %a12,[%a2]
8001d86c:	02 24       	mov %d4,%d2
8001d86e:	6d ff 8b ce 	call 80017584 <lwip_htonl>
8001d872:	8f f2 0f 31 	and %d3,%d2,255
8001d876:	82 04       	mov %d4,0
8001d878:	a6 43       	or %d3,%d4
8001d87a:	e9 c3 08 00 	st.b [%a12]8,%d3
8001d87e:	8f 82 1f 30 	sh %d3,%d2,-8
8001d882:	8f f3 0f 31 	and %d3,%d3,255
8001d886:	82 04       	mov %d4,0
8001d888:	a6 43       	or %d3,%d4
8001d88a:	e9 c3 09 00 	st.b [%a12]9,%d3
8001d88e:	8f 02 1f 30 	sh %d3,%d2,-16
8001d892:	8f f3 0f 31 	and %d3,%d3,255
8001d896:	82 04       	mov %d4,0
8001d898:	a6 43       	or %d3,%d4
8001d89a:	e9 c3 0a 00 	st.b [%a12]10,%d3
8001d89e:	8f 82 1e 20 	sh %d2,%d2,-24
8001d8a2:	82 03       	mov %d3,0
8001d8a4:	a6 32       	or %d2,%d3
8001d8a6:	e9 c2 0b 00 	st.b [%a12]11,%d2
8001d8aa:	39 c3 08 00 	ld.bu %d3,[%a12]8
8001d8ae:	39 c2 09 00 	ld.bu %d2,[%a12]9
8001d8b2:	8f 82 00 20 	sh %d2,%d2,8
8001d8b6:	a6 32       	or %d2,%d3
8001d8b8:	39 c3 0a 00 	ld.bu %d3,[%a12]10
8001d8bc:	8f 03 01 30 	sh %d3,%d3,16
8001d8c0:	a6 32       	or %d2,%d3
8001d8c2:	39 c3 0b 00 	ld.bu %d3,[%a12]11
8001d8c6:	8f 83 01 30 	sh %d3,%d3,24
8001d8ca:	a6 32       	or %d2,%d3
8001d8cc:	91 10 00 27 	movh.a %a2,28673
8001d8d0:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001d8d4:	74 22       	st.w [%a2],%d2
  tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
8001d8d6:	91 10 00 27 	movh.a %a2,28673
8001d8da:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d8de:	d4 22       	ld.a %a2,[%a2]
8001d8e0:	39 23 0e 00 	ld.bu %d3,[%a2]14 <700145dc <tcphdr>>
8001d8e4:	39 22 0f 00 	ld.bu %d2,[%a2]15 <700145dc <tcphdr>>
8001d8e8:	8f 82 00 20 	sh %d2,%d2,8
8001d8ec:	a6 32       	or %d2,%d3
8001d8ee:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d8f2:	91 10 00 27 	movh.a %a2,28673
8001d8f6:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d8fa:	d4 2c       	ld.a %a12,[%a2]
8001d8fc:	02 24       	mov %d4,%d2
8001d8fe:	6d ff 2b ce 	call 80017554 <lwip_htons>
8001d902:	8f f2 0f 31 	and %d3,%d2,255
8001d906:	82 04       	mov %d4,0
8001d908:	a6 43       	or %d3,%d4
8001d90a:	e9 c3 0e 00 	st.b [%a12]14,%d3
8001d90e:	06 82       	sh %d2,-8
8001d910:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d914:	82 03       	mov %d3,0
8001d916:	a6 32       	or %d2,%d3
8001d918:	e9 c2 0f 00 	st.b [%a12]15,%d2

  flags = TCPH_FLAGS(tcphdr);
8001d91c:	91 10 00 27 	movh.a %a2,28673
8001d920:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001d924:	d4 22       	ld.a %a2,[%a2]
8001d926:	39 23 0c 00 	ld.bu %d3,[%a2]12 <700145dc <tcphdr>>
8001d92a:	39 22 0d 00 	ld.bu %d2,[%a2]13 <700145dc <tcphdr>>
8001d92e:	8f 82 00 20 	sh %d2,%d2,8
8001d932:	a6 32       	or %d2,%d3
8001d934:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d938:	02 24       	mov %d4,%d2
8001d93a:	6d ff 0d ce 	call 80017554 <lwip_htons>
8001d93e:	8f f2 0f 21 	and %d2,%d2,255
8001d942:	8f f2 03 21 	and %d2,%d2,63
8001d946:	8f f2 0f 21 	and %d2,%d2,255
8001d94a:	91 10 00 27 	movh.a %a2,28673
8001d94e:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001d952:	34 22       	st.b [%a2],%d2
  tcplen = p->tot_len;
8001d954:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145f8 <flags>>
8001d958:	b9 22 08 00 	ld.hu %d2,[%a2]8 <700145f8 <flags>>
8001d95c:	91 10 00 27 	movh.a %a2,28673
8001d960:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001d964:	b4 22       	st.h [%a2],%d2
  if (flags & (TCP_FIN | TCP_SYN)) {
8001d966:	91 10 00 27 	movh.a %a2,28673
8001d96a:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001d96e:	14 22       	ld.bu %d2,[%a2]
8001d970:	8f 32 00 21 	and %d2,%d2,3
8001d974:	df 02 2d 00 	jeq %d2,0,8001d9ce <tcp_input+0x65e>
    tcplen++;
8001d978:	91 10 00 27 	movh.a %a2,28673
8001d97c:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001d980:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001d984:	c2 12       	add %d2,1
8001d986:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d98a:	91 10 00 27 	movh.a %a2,28673
8001d98e:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001d992:	b4 22       	st.h [%a2],%d2
    if (tcplen < p->tot_len) {
8001d994:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145f6 <tcplen>>
8001d998:	b9 22 08 00 	ld.hu %d2,[%a2]8 <700145f6 <tcplen>>
8001d99c:	91 10 00 27 	movh.a %a2,28673
8001d9a0:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001d9a4:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001d9a8:	7f 23 13 80 	jge.u %d3,%d2,8001d9ce <tcp_input+0x65e>
      /* u16_t overflow, cannot handle this */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: length u16_t overflow, cannot handle this\n"));
      TCP_STATS_INC(tcp.lenerr);
8001d9ac:	91 10 00 27 	movh.a %a2,28673
8001d9b0:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d9b4:	b9 22 1a 20 	ld.hu %d2,[%a2]154 <7001009a <ram_heap+0x5006>>
8001d9b8:	c2 12       	add %d2,1
8001d9ba:	37 02 70 20 	extr.u %d2,%d2,0,16
8001d9be:	91 10 00 27 	movh.a %a2,28673
8001d9c2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001d9c6:	f9 22 1a 20 	st.h [%a2]154 <7001009a <ram_heap+0x5006>>,%d2
      goto dropped;
8001d9ca:	1d 00 1b 05 	j 8001e400 <tcp_input+0x1090>
    }
  }

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
8001d9ce:	82 02       	mov %d2,0
8001d9d0:	59 e2 fc ff 	st.w [%a14]-4,%d2

  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
8001d9d4:	91 10 00 27 	movh.a %a2,28673
8001d9d8:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001d9dc:	54 22       	ld.w %d2,[%a2]
8001d9de:	59 e2 f8 ff 	st.w [%a14]-8 <700145bc <tcp_active_pcbs>>,%d2
8001d9e2:	1d 00 2e 01 	j 8001dc3e <tcp_input+0x8ce>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
8001d9e6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001d9ea:	d9 22 14 00 	lea %a2,[%a2]20
8001d9ee:	54 22       	ld.w %d2,[%a2]
8001d9f0:	df 02 17 80 	jne %d2,0,8001da1e <tcp_input+0x6ae>
8001d9f4:	91 00 00 28 	movh.a %a2,32768
8001d9f8:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001d9fc:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001da00:	3b b0 0f 20 	mov %d2,251
8001da04:	59 a2 04 00 	st.w [%sp]4,%d2
8001da08:	91 00 00 28 	movh.a %a2,32768
8001da0c:	d9 22 53 92 	lea %a2,[%a2]9811 <80002653 <IfxCpu_Trap_vectorTable0_end+0x245f>>
8001da10:	f4 a2       	st.a [%sp],%a2
8001da12:	91 00 00 28 	movh.a %a2,32768
8001da16:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001da1a:	6d ff 8e 3c 	call 80005336 <Ifx_Lwip_printf>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
8001da1e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001da22:	d9 22 14 00 	lea %a2,[%a2]20
8001da26:	54 22       	ld.w %d2,[%a2]
8001da28:	8b a2 20 22 	ne %d2,%d2,10
8001da2c:	df 02 17 80 	jne %d2,0,8001da5a <tcp_input+0x6ea>
8001da30:	91 00 00 28 	movh.a %a2,32768
8001da34:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001da38:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001da3c:	3b c0 0f 20 	mov %d2,252
8001da40:	59 a2 04 00 	st.w [%sp]4,%d2
8001da44:	91 00 00 28 	movh.a %a2,32768
8001da48:	d9 22 7a 92 	lea %a2,[%a2]9850 <8000267a <IfxCpu_Trap_vectorTable0_end+0x2486>>
8001da4c:	f4 a2       	st.a [%sp],%a2
8001da4e:	91 00 00 28 	movh.a %a2,32768
8001da52:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001da56:	6d ff 70 3c 	call 80005336 <Ifx_Lwip_printf>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
8001da5a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001da5e:	d9 22 14 00 	lea %a2,[%a2]20
8001da62:	54 22       	ld.w %d2,[%a2]
8001da64:	df 12 17 80 	jne %d2,1,8001da92 <tcp_input+0x722>
8001da68:	91 00 00 28 	movh.a %a2,32768
8001da6c:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001da70:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001da74:	3b d0 0f 20 	mov %d2,253
8001da78:	59 a2 04 00 	st.w [%sp]4,%d2
8001da7c:	91 00 00 28 	movh.a %a2,32768
8001da80:	d9 22 64 a2 	lea %a2,[%a2]9892 <800026a4 <IfxCpu_Trap_vectorTable0_end+0x24b0>>
8001da84:	f4 a2       	st.a [%sp],%a2
8001da86:	91 00 00 28 	movh.a %a2,32768
8001da8a:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001da8e:	6d ff 54 3c 	call 80005336 <Ifx_Lwip_printf>

    /* check if PCB is bound to specific netif */
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
8001da92:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001da96:	39 22 08 00 	ld.bu %d2,[%a2]8
8001da9a:	df 02 19 00 	jeq %d2,0,8001dacc <tcp_input+0x75c>
        (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
8001da9e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001daa2:	39 22 08 00 	ld.bu %d2,[%a2]8
8001daa6:	91 10 00 27 	movh.a %a2,28673
8001daaa:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001daae:	b0 42       	add.a %a2,4
8001dab0:	d4 22       	ld.a %a2,[%a2]
8001dab2:	39 23 34 00 	ld.bu %d3,[%a2]52
8001dab6:	c2 13       	add %d3,1
8001dab8:	8f f3 0f 31 	and %d3,%d3,255
    if ((pcb->netif_idx != NETIF_NO_INDEX) &&
8001dabc:	5f 32 08 00 	jeq %d2,%d3,8001dacc <tcp_input+0x75c>
      prev = pcb;
8001dac0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001dac4:	59 e2 fc ff 	st.w [%a14]-4,%d2
      continue;
8001dac8:	1d 00 b4 00 	j 8001dc30 <tcp_input+0x8c0>
    }

    if (pcb->remote_port == tcphdr->src &&
8001dacc:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dad0:	b9 23 1c 00 	ld.hu %d3,[%a2]28
8001dad4:	91 10 00 27 	movh.a %a2,28673
8001dad8:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001dadc:	d4 22       	ld.a %a2,[%a2]
8001dade:	14 24       	ld.bu %d4,[%a2]
8001dae0:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001dae4:	8f 82 00 20 	sh %d2,%d2,8
8001dae8:	a6 42       	or %d2,%d4
8001daea:	37 02 70 20 	extr.u %d2,%d2,0,16
8001daee:	5f 23 9d 80 	jne %d3,%d2,8001dc28 <tcp_input+0x8b8>
        pcb->local_port == tcphdr->dest &&
8001daf2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001daf6:	b9 23 1a 00 	ld.hu %d3,[%a2]26
8001dafa:	91 10 00 27 	movh.a %a2,28673
8001dafe:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001db02:	d4 22       	ld.a %a2,[%a2]
8001db04:	39 24 02 00 	ld.bu %d4,[%a2]2 <700145dc <tcphdr>>
8001db08:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001db0c:	8f 82 00 20 	sh %d2,%d2,8
8001db10:	a6 42       	or %d2,%d4
8001db12:	37 02 70 20 	extr.u %d2,%d2,0,16
    if (pcb->remote_port == tcphdr->src &&
8001db16:	5f 23 89 80 	jne %d3,%d2,8001dc28 <tcp_input+0x8b8>
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
8001db1a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001db1e:	b0 42       	add.a %a2,4
8001db20:	54 23       	ld.w %d3,[%a2]
8001db22:	91 10 00 27 	movh.a %a2,28673
8001db26:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001db2a:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
8001db2e:	54 22       	ld.w %d2,[%a2]
        pcb->local_port == tcphdr->dest &&
8001db30:	5f 23 7c 80 	jne %d3,%d2,8001dc28 <tcp_input+0x8b8>
        ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
8001db34:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001db38:	54 23       	ld.w %d3,[%a2]
8001db3a:	91 10 00 27 	movh.a %a2,28673
8001db3e:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001db42:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
8001db46:	54 22       	ld.w %d2,[%a2]
        ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
8001db48:	5f 23 70 80 	jne %d3,%d2,8001dc28 <tcp_input+0x8b8>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
8001db4c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001db50:	d9 22 0c 00 	lea %a2,[%a2]12
8001db54:	54 22       	ld.w %d2,[%a2]
8001db56:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
8001db5a:	5f 23 17 80 	jne %d3,%d2,8001db88 <tcp_input+0x818>
8001db5e:	91 00 00 28 	movh.a %a2,32768
8001db62:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001db66:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001db6a:	3b d0 10 20 	mov %d2,269
8001db6e:	59 a2 04 00 	st.w [%sp]4,%d2
8001db72:	91 00 00 28 	movh.a %a2,32768
8001db76:	d9 22 4b b2 	lea %a2,[%a2]9931 <800026cb <IfxCpu_Trap_vectorTable0_end+0x24d7>>
8001db7a:	f4 a2       	st.a [%sp],%a2
8001db7c:	91 00 00 28 	movh.a %a2,32768
8001db80:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001db84:	6d ff d9 3b 	call 80005336 <Ifx_Lwip_printf>
      if (prev != NULL) {
8001db88:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001db8c:	df 02 1f 00 	jeq %d2,0,8001dbca <tcp_input+0x85a>
        prev->next = pcb->next;
8001db90:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001db94:	d9 22 0c 00 	lea %a2,[%a2]12
8001db98:	54 22       	ld.w %d2,[%a2]
8001db9a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001db9e:	d9 22 0c 00 	lea %a2,[%a2]12
8001dba2:	74 22       	st.w [%a2],%d2
        pcb->next = tcp_active_pcbs;
8001dba4:	91 10 00 27 	movh.a %a2,28673
8001dba8:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001dbac:	54 22       	ld.w %d2,[%a2]
8001dbae:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <700145bc <tcp_active_pcbs>>
8001dbb2:	d9 22 0c 00 	lea %a2,[%a2]12 <700145bc <tcp_active_pcbs>>
8001dbb6:	74 22       	st.w [%a2],%d2
        tcp_active_pcbs = pcb;
8001dbb8:	91 10 00 27 	movh.a %a2,28673
8001dbbc:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001dbc0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <700145bc <tcp_active_pcbs>>
8001dbc4:	74 22       	st.w [%a2],%d2
8001dbc6:	1d 00 11 00 	j 8001dbe8 <tcp_input+0x878>
      } else {
        TCP_STATS_INC(tcp.cachehit);
8001dbca:	91 10 00 27 	movh.a %a2,28673
8001dbce:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001dbd2:	b9 22 26 20 	ld.hu %d2,[%a2]166 <700100a6 <ram_heap+0x5012>>
8001dbd6:	c2 12       	add %d2,1
8001dbd8:	37 02 70 20 	extr.u %d2,%d2,0,16
8001dbdc:	91 10 00 27 	movh.a %a2,28673
8001dbe0:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001dbe4:	f9 22 26 20 	st.h [%a2]166 <700100a6 <ram_heap+0x5012>>,%d2
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
8001dbe8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <700100a6 <ram_heap+0x5012>>
8001dbec:	d9 22 0c 00 	lea %a2,[%a2]12 <700100a6 <ram_heap+0x5012>>
8001dbf0:	54 22       	ld.w %d2,[%a2]
8001dbf2:	19 e3 f8 ff 	ld.w %d3,[%a14]-8 <700100a6 <ram_heap+0x5012>>
8001dbf6:	5f 23 2a 80 	jne %d3,%d2,8001dc4a <tcp_input+0x8da>
8001dbfa:	91 00 00 28 	movh.a %a2,32768
8001dbfe:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001dc02:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001dc06:	3b 50 11 20 	mov %d2,277
8001dc0a:	59 a2 04 00 	st.w [%sp]4,%d2
8001dc0e:	91 00 00 28 	movh.a %a2,32768
8001dc12:	d9 22 76 b2 	lea %a2,[%a2]9974 <800026f6 <IfxCpu_Trap_vectorTable0_end+0x2502>>
8001dc16:	f4 a2       	st.a [%sp],%a2
8001dc18:	91 00 00 28 	movh.a %a2,32768
8001dc1c:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001dc20:	6d ff 8b 3b 	call 80005336 <Ifx_Lwip_printf>
      break;
8001dc24:	1d 00 13 00 	j 8001dc4a <tcp_input+0x8da>
    }
    prev = pcb;
8001dc28:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001dc2c:	59 e2 fc ff 	st.w [%a14]-4,%d2
  for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
8001dc30:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dc34:	d9 22 0c 00 	lea %a2,[%a2]12
8001dc38:	54 22       	ld.w %d2,[%a2]
8001dc3a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8001dc3e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001dc42:	df 02 d2 fe 	jne %d2,0,8001d9e6 <tcp_input+0x676>
8001dc46:	1d 00 03 00 	j 8001dc4c <tcp_input+0x8dc>
      break;
8001dc4a:	00 00       	nop 
  }

  if (pcb == NULL) {
8001dc4c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001dc50:	df 02 36 81 	jne %d2,0,8001debc <tcp_input+0xb4c>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
8001dc54:	91 10 00 27 	movh.a %a2,28673
8001dc58:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001dc5c:	54 22       	ld.w %d2,[%a2]
8001dc5e:	59 e2 f8 ff 	st.w [%a14]-8 <700145c0 <tcp_tw_pcbs>>,%d2
8001dc62:	1d 00 88 00 	j 8001dd72 <tcp_input+0xa02>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
8001dc66:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dc6a:	d9 22 14 00 	lea %a2,[%a2]20
8001dc6e:	54 22       	ld.w %d2,[%a2]
8001dc70:	8b a2 00 22 	eq %d2,%d2,10
8001dc74:	df 02 17 80 	jne %d2,0,8001dca2 <tcp_input+0x932>
8001dc78:	91 00 00 28 	movh.a %a2,32768
8001dc7c:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001dc80:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001dc84:	3b f0 11 20 	mov %d2,287
8001dc88:	59 a2 04 00 	st.w [%sp]4,%d2
8001dc8c:	91 00 00 28 	movh.a %a2,32768
8001dc90:	d9 22 60 c2 	lea %a2,[%a2]10016 <80002720 <IfxCpu_Trap_vectorTable0_end+0x252c>>
8001dc94:	f4 a2       	st.a [%sp],%a2
8001dc96:	91 00 00 28 	movh.a %a2,32768
8001dc9a:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001dc9e:	6d ff 4c 3b 	call 80005336 <Ifx_Lwip_printf>

      /* check if PCB is bound to specific netif */
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
8001dca2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dca6:	39 22 08 00 	ld.bu %d2,[%a2]8
8001dcaa:	df 02 13 00 	jeq %d2,0,8001dcd0 <tcp_input+0x960>
          (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
8001dcae:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dcb2:	39 22 08 00 	ld.bu %d2,[%a2]8
8001dcb6:	91 10 00 27 	movh.a %a2,28673
8001dcba:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001dcbe:	b0 42       	add.a %a2,4
8001dcc0:	d4 22       	ld.a %a2,[%a2]
8001dcc2:	39 23 34 00 	ld.bu %d3,[%a2]52
8001dcc6:	c2 13       	add %d3,1
8001dcc8:	8f f3 0f 31 	and %d3,%d3,255
      if ((pcb->netif_idx != NETIF_NO_INDEX) &&
8001dccc:	5f 32 4b 80 	jne %d2,%d3,8001dd62 <tcp_input+0x9f2>
        continue;
      }

      if (pcb->remote_port == tcphdr->src &&
8001dcd0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dcd4:	b9 23 1c 00 	ld.hu %d3,[%a2]28
8001dcd8:	91 10 00 27 	movh.a %a2,28673
8001dcdc:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001dce0:	d4 22       	ld.a %a2,[%a2]
8001dce2:	14 24       	ld.bu %d4,[%a2]
8001dce4:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001dce8:	8f 82 00 20 	sh %d2,%d2,8
8001dcec:	a6 42       	or %d2,%d4
8001dcee:	37 02 70 20 	extr.u %d2,%d2,0,16
8001dcf2:	5f 23 39 80 	jne %d3,%d2,8001dd64 <tcp_input+0x9f4>
          pcb->local_port == tcphdr->dest &&
8001dcf6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dcfa:	b9 23 1a 00 	ld.hu %d3,[%a2]26
8001dcfe:	91 10 00 27 	movh.a %a2,28673
8001dd02:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001dd06:	d4 22       	ld.a %a2,[%a2]
8001dd08:	39 24 02 00 	ld.bu %d4,[%a2]2 <700145dc <tcphdr>>
8001dd0c:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001dd10:	8f 82 00 20 	sh %d2,%d2,8
8001dd14:	a6 42       	or %d2,%d4
8001dd16:	37 02 70 20 	extr.u %d2,%d2,0,16
      if (pcb->remote_port == tcphdr->src &&
8001dd1a:	5f 23 25 80 	jne %d3,%d2,8001dd64 <tcp_input+0x9f4>
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
8001dd1e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dd22:	b0 42       	add.a %a2,4
8001dd24:	54 23       	ld.w %d3,[%a2]
8001dd26:	91 10 00 27 	movh.a %a2,28673
8001dd2a:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001dd2e:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
8001dd32:	54 22       	ld.w %d2,[%a2]
          pcb->local_port == tcphdr->dest &&
8001dd34:	5f 23 18 80 	jne %d3,%d2,8001dd64 <tcp_input+0x9f4>
          ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
8001dd38:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dd3c:	54 23       	ld.w %d3,[%a2]
8001dd3e:	91 10 00 27 	movh.a %a2,28673
8001dd42:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001dd46:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
8001dd4a:	54 22       	ld.w %d2,[%a2]
          ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
8001dd4c:	5f 23 0c 80 	jne %d3,%d2,8001dd64 <tcp_input+0x9f4>
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
        if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
                                       tcphdr_opt2, p) == ERR_OK)
#endif
        {
          tcp_timewait_input(pcb);
8001dd50:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001dd54:	6d 00 76 05 	call 8001e840 <tcp_timewait_input>
        }
        pbuf_free(p);
8001dd58:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001dd5c:	6d ff 1e e1 	call 80019f98 <pbuf_free>
        return;
8001dd60:	00 90       	ret 
        continue;
8001dd62:	00 00       	nop 
    for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
8001dd64:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001dd68:	d9 22 0c 00 	lea %a2,[%a2]12
8001dd6c:	54 22       	ld.w %d2,[%a2]
8001dd6e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8001dd72:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001dd76:	df 02 78 ff 	jne %d2,0,8001dc66 <tcp_input+0x8f6>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
8001dd7a:	82 02       	mov %d2,0
8001dd7c:	59 e2 fc ff 	st.w [%a14]-4,%d2
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
8001dd80:	91 10 00 27 	movh.a %a2,28673
8001dd84:	d9 22 78 64 	lea %a2,[%a2]17848 <700145b8 <tcp_listen_pcbs>>
8001dd88:	54 22       	ld.w %d2,[%a2]
8001dd8a:	59 e2 f4 ff 	st.w [%a14]-12 <700145b8 <tcp_listen_pcbs>>,%d2
8001dd8e:	1d 00 53 00 	j 8001de34 <tcp_input+0xac4>
      /* check if PCB is bound to specific netif */
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
8001dd92:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001dd96:	39 22 08 00 	ld.bu %d2,[%a2]8
8001dd9a:	df 02 19 00 	jeq %d2,0,8001ddcc <tcp_input+0xa5c>
          (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
8001dd9e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001dda2:	39 22 08 00 	ld.bu %d2,[%a2]8
8001dda6:	91 10 00 27 	movh.a %a2,28673
8001ddaa:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001ddae:	b0 42       	add.a %a2,4
8001ddb0:	d4 22       	ld.a %a2,[%a2]
8001ddb2:	39 23 34 00 	ld.bu %d3,[%a2]52
8001ddb6:	c2 13       	add %d3,1
8001ddb8:	8f f3 0f 31 	and %d3,%d3,255
      if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
8001ddbc:	5f 32 08 00 	jeq %d2,%d3,8001ddcc <tcp_input+0xa5c>
        prev = (struct tcp_pcb *)lpcb;
8001ddc0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001ddc4:	59 e2 fc ff 	st.w [%a14]-4,%d2
        continue;
8001ddc8:	1d 00 2f 00 	j 8001de26 <tcp_input+0xab6>
      }

      if (lpcb->local_port == tcphdr->dest) {
8001ddcc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ddd0:	b9 23 1a 00 	ld.hu %d3,[%a2]26
8001ddd4:	91 10 00 27 	movh.a %a2,28673
8001ddd8:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001dddc:	d4 22       	ld.a %a2,[%a2]
8001ddde:	39 24 02 00 	ld.bu %d4,[%a2]2 <700145dc <tcphdr>>
8001dde2:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001dde6:	8f 82 00 20 	sh %d2,%d2,8
8001ddea:	a6 42       	or %d2,%d4
8001ddec:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ddf0:	5f 23 17 80 	jne %d3,%d2,8001de1e <tcp_input+0xaae>
          lpcb_prev = prev;
#else /* SO_REUSE */
          break;
#endif /* SO_REUSE */
        } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
          if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
8001ddf4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ddf8:	54 23       	ld.w %d3,[%a2]
8001ddfa:	91 10 00 27 	movh.a %a2,28673
8001ddfe:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001de02:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
8001de06:	54 22       	ld.w %d2,[%a2]
8001de08:	5f 23 1c 00 	jeq %d3,%d2,8001de40 <tcp_input+0xad0>
            /* found an exact match */
            break;
          } else if (ip_addr_isany(&lpcb->local_ip)) {
8001de0c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001de10:	df 02 19 00 	jeq %d2,0,8001de42 <tcp_input+0xad2>
8001de14:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001de18:	54 22       	ld.w %d2,[%a2]
8001de1a:	df 02 14 00 	jeq %d2,0,8001de42 <tcp_input+0xad2>
            break;
#endif /* SO_REUSE */
          }
        }
      }
      prev = (struct tcp_pcb *)lpcb;
8001de1e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001de22:	59 e2 fc ff 	st.w [%a14]-4,%d2
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
8001de26:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001de2a:	d9 22 0c 00 	lea %a2,[%a2]12
8001de2e:	54 22       	ld.w %d2,[%a2]
8001de30:	59 e2 f4 ff 	st.w [%a14]-12,%d2
8001de34:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001de38:	df 02 ad ff 	jne %d2,0,8001dd92 <tcp_input+0xa22>
8001de3c:	1d 00 03 00 	j 8001de42 <tcp_input+0xad2>
            break;
8001de40:	00 00       	nop 
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
      prev = lpcb_prev;
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
8001de42:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001de46:	df 02 3b 00 	jeq %d2,0,8001debc <tcp_input+0xb4c>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
8001de4a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001de4e:	df 02 1f 00 	jeq %d2,0,8001de8c <tcp_input+0xb1c>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
8001de52:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001de56:	d9 22 0c 00 	lea %a2,[%a2]12
8001de5a:	54 22       	ld.w %d2,[%a2]
8001de5c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001de60:	d9 22 0c 00 	lea %a2,[%a2]12
8001de64:	74 22       	st.w [%a2],%d2
        /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
8001de66:	91 10 00 27 	movh.a %a2,28673
8001de6a:	d9 22 78 64 	lea %a2,[%a2]17848 <700145b8 <tcp_listen_pcbs>>
8001de6e:	54 22       	ld.w %d2,[%a2]
8001de70:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <700145b8 <tcp_listen_pcbs>>
8001de74:	d9 22 0c 00 	lea %a2,[%a2]12 <700145b8 <tcp_listen_pcbs>>
8001de78:	74 22       	st.w [%a2],%d2
        /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
8001de7a:	91 10 00 27 	movh.a %a2,28673
8001de7e:	d9 22 78 64 	lea %a2,[%a2]17848 <700145b8 <tcp_listen_pcbs>>
8001de82:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <700145b8 <tcp_listen_pcbs>>
8001de86:	74 22       	st.w [%a2],%d2
8001de88:	1d 00 11 00 	j 8001deaa <tcp_input+0xb3a>
      } else {
        TCP_STATS_INC(tcp.cachehit);
8001de8c:	91 10 00 27 	movh.a %a2,28673
8001de90:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001de94:	b9 22 26 20 	ld.hu %d2,[%a2]166 <700100a6 <ram_heap+0x5012>>
8001de98:	c2 12       	add %d2,1
8001de9a:	37 02 70 20 	extr.u %d2,%d2,0,16
8001de9e:	91 10 00 27 	movh.a %a2,28673
8001dea2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001dea6:	f9 22 26 20 	st.h [%a2]166 <700100a6 <ram_heap+0x5012>>,%d2
#ifdef LWIP_HOOK_TCP_INPACKET_PCB
      if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
                                     tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
#endif
      {
        tcp_listen_input(lpcb);
8001deaa:	99 e4 f4 ff 	ld.a %a4,[%a14]-12 <700100a6 <ram_heap+0x5012>>
8001deae:	6d 00 13 03 	call 8001e4d4 <tcp_listen_input>
      }
      pbuf_free(p);
8001deb2:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001deb6:	6d ff 71 e0 	call 80019f98 <pbuf_free>
      return;
8001deba:	00 90       	ret 
      tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
    pbuf_free(p);
    return;
  }
#endif
  if (pcb != NULL) {
8001debc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001dec0:	df 02 2a 02 	jeq %d2,0,8001e314 <tcp_input+0xfa4>
#if TCP_INPUT_DEBUG
    tcp_debug_print_state(pcb->state);
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
8001dec4:	91 10 00 27 	movh.a %a2,28673
8001dec8:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8001decc:	82 02       	mov %d2,0
8001dece:	74 22       	st.w [%a2],%d2
    inseg.len = p->tot_len;
8001ded0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ded4:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001ded8:	91 10 00 27 	movh.a %a2,28673
8001dedc:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8001dee0:	f9 22 08 00 	st.h [%a2]8 <70010008 <ram_heap+0x4f74>>,%d2
    inseg.p = p;
8001dee4:	91 10 00 27 	movh.a %a2,28673
8001dee8:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8001deec:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <700145c8 <inseg>>
8001def0:	b0 42       	add.a %a2,4
8001def2:	74 22       	st.w [%a2],%d2
    inseg.tcphdr = tcphdr;
8001def4:	91 10 00 27 	movh.a %a2,28673
8001def8:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001defc:	54 22       	ld.w %d2,[%a2]
8001defe:	91 10 00 27 	movh.a %a2,28673
8001df02:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8001df06:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
8001df0a:	74 22       	st.w [%a2],%d2

    recv_data = NULL;
8001df0c:	91 10 00 27 	movh.a %a2,28673
8001df10:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
8001df14:	82 02       	mov %d2,0
8001df16:	74 22       	st.w [%a2],%d2
    recv_flags = 0;
8001df18:	91 10 00 27 	movh.a %a2,28673
8001df1c:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001df20:	82 02       	mov %d2,0
8001df22:	34 22       	st.b [%a2],%d2
    recv_acked = 0;
8001df24:	91 10 00 27 	movh.a %a2,28673
8001df28:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001df2c:	82 02       	mov %d2,0
8001df2e:	b4 22       	st.h [%a2],%d2

    if (flags & TCP_PSH) {
8001df30:	91 10 00 27 	movh.a %a2,28673
8001df34:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001df38:	14 22       	ld.bu %d2,[%a2]
8001df3a:	8f 82 00 21 	and %d2,%d2,8
8001df3e:	df 02 0e 00 	jeq %d2,0,8001df5a <tcp_input+0xbea>
      p->flags |= PBUF_FLAG_PUSH;
8001df42:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001df46:	39 22 0d 00 	ld.bu %d2,[%a2]13
8001df4a:	8f 12 40 21 	or %d2,%d2,1
8001df4e:	8f f2 0f 21 	and %d2,%d2,255
8001df52:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001df56:	e9 22 0d 00 	st.b [%a2]13,%d2
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
8001df5a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001df5e:	d9 22 3c 10 	lea %a2,[%a2]124
8001df62:	54 22       	ld.w %d2,[%a2]
8001df64:	df 02 34 00 	jeq %d2,0,8001dfcc <tcp_input+0xc5c>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
8001df68:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001df6c:	6d ff 50 f2 	call 8001c40c <tcp_process_refused_data>
8001df70:	8b 32 1f 22 	eq %d2,%d2,-13
8001df74:	df 02 11 80 	jne %d2,0,8001df96 <tcp_input+0xc26>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
8001df78:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001df7c:	d9 22 3c 10 	lea %a2,[%a2]124
8001df80:	54 22       	ld.w %d2,[%a2]
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
8001df82:	df 02 25 00 	jeq %d2,0,8001dfcc <tcp_input+0xc5c>
          ((pcb->refused_data != NULL) && (tcplen > 0))) {
8001df86:	91 10 00 27 	movh.a %a2,28673
8001df8a:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001df8e:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001df92:	df 02 1d 00 	jeq %d2,0,8001dfcc <tcp_input+0xc5c>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        if (pcb->rcv_ann_wnd == 0) {
8001df96:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001df9a:	b9 22 2e 00 	ld.hu %d2,[%a2]46
8001df9e:	df 02 06 80 	jne %d2,0,8001dfaa <tcp_input+0xc3a>
          /* this is a zero-window probe, we respond to it with current RCV.NXT
          and drop the data segment */
          tcp_send_empty_ack(pcb);
8001dfa2:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001dfa6:	6d 00 cf 34 	call 80024944 <tcp_send_empty_ack>
        }
        TCP_STATS_INC(tcp.drop);
8001dfaa:	91 10 00 27 	movh.a %a2,28673
8001dfae:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001dfb2:	b9 22 16 20 	ld.hu %d2,[%a2]150 <70010096 <ram_heap+0x5002>>
8001dfb6:	c2 12       	add %d2,1
8001dfb8:	37 02 70 20 	extr.u %d2,%d2,0,16
8001dfbc:	91 10 00 27 	movh.a %a2,28673
8001dfc0:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001dfc4:	f9 22 16 20 	st.h [%a2]150 <70010096 <ram_heap+0x5002>>,%d2
        MIB2_STATS_INC(mib2.tcpinerrs);
        goto aborted;
8001dfc8:	1d 00 80 01 	j 8001e2c8 <tcp_input+0xf58>
      }
    }
    tcp_input_pcb = pcb;
8001dfcc:	91 10 00 27 	movh.a %a2,28673
8001dfd0:	d9 22 40 84 	lea %a2,[%a2]17920 <70014600 <tcp_input_pcb>>
8001dfd4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <70014600 <tcp_input_pcb>>
8001dfd8:	74 22       	st.w [%a2],%d2
    err = tcp_process(pcb);
8001dfda:	99 e4 f8 ff 	ld.a %a4,[%a14]-8 <70014600 <tcp_input_pcb>>
8001dfde:	6d 00 ef 04 	call 8001e9bc <tcp_process>
8001dfe2:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
8001dfe6:	79 e2 f3 ff 	ld.b %d2,[%a14]-13
8001dfea:	8b 32 1f 22 	eq %d2,%d2,-13
8001dfee:	df 02 5d 81 	jne %d2,0,8001e2a8 <tcp_input+0xf38>
      if (recv_flags & TF_RESET) {
8001dff2:	91 10 00 27 	movh.a %a2,28673
8001dff6:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001dffa:	14 22       	ld.bu %d2,[%a2]
8001dffc:	8f 82 00 21 	and %d2,%d2,8
8001e000:	df 02 26 00 	jeq %d2,0,8001e04c <tcp_input+0xcdc>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
8001e004:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e008:	d9 22 14 20 	lea %a2,[%a2]148
8001e00c:	54 22       	ld.w %d2,[%a2]
8001e00e:	df 02 11 00 	jeq %d2,0,8001e030 <tcp_input+0xcc0>
8001e012:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e016:	d9 22 14 20 	lea %a2,[%a2]148
8001e01a:	d4 22       	ld.a %a2,[%a2]
8001e01c:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
8001e020:	d9 33 10 00 	lea %a3,[%a3]16
8001e024:	54 32       	ld.w %d2,[%a3]
8001e026:	3b 20 ff 4f 	mov %d4,-14
8001e02a:	60 24       	mov.a %a4,%d2
8001e02c:	2d 02 00 00 	calli %a2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
8001e030:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
8001e034:	91 10 00 27 	movh.a %a2,28673
8001e038:	d9 24 7c 64 	lea %a4,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001e03c:	6d ff 47 f7 	call 8001ceca <tcp_pcb_remove>
        tcp_free(pcb);
8001e040:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001e044:	6d ff df e3 	call 8001a802 <tcp_free>
8001e048:	1d 00 40 01 	j 8001e2c8 <tcp_input+0xf58>
      } else {
        err = ERR_OK;
8001e04c:	82 02       	mov %d2,0
8001e04e:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (recv_acked > 0) {
8001e052:	91 10 00 27 	movh.a %a2,28673
8001e056:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001e05a:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001e05e:	df 02 35 00 	jeq %d2,0,8001e0c8 <tcp_input+0xd58>
          while (acked > 0) {
            acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
            acked -= acked16;
#else
          {
            acked16 = recv_acked;
8001e062:	91 10 00 27 	movh.a %a2,28673
8001e066:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001e06a:	94 22       	ld.h %d2,[%a2]
8001e06c:	f9 e2 ea ff 	st.h [%a14]-22 <700145f4 <recv_acked>>,%d2
#endif
            TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
8001e070:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <700145f4 <recv_acked>>
8001e074:	d9 22 04 20 	lea %a2,[%a2]132 <700145f4 <recv_acked>>
8001e078:	54 22       	ld.w %d2,[%a2]
8001e07a:	df 02 18 00 	jeq %d2,0,8001e0aa <tcp_input+0xd3a>
8001e07e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e082:	d9 22 04 20 	lea %a2,[%a2]132
8001e086:	d4 22       	ld.a %a2,[%a2]
8001e088:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
8001e08c:	d9 33 10 00 	lea %a3,[%a3]16
8001e090:	54 33       	ld.w %d3,[%a3]
8001e092:	b9 e2 ea ff 	ld.hu %d2,[%a14]-22
8001e096:	02 24       	mov %d4,%d2
8001e098:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
8001e09c:	60 34       	mov.a %a4,%d3
8001e09e:	2d 02 00 00 	calli %a2
8001e0a2:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
8001e0a6:	1d 00 05 00 	j 8001e0b0 <tcp_input+0xd40>
8001e0aa:	82 02       	mov %d2,0
8001e0ac:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
            if (err == ERR_ABRT) {
8001e0b0:	79 e2 f3 ff 	ld.b %d2,[%a14]-13
8001e0b4:	8b 32 3f 22 	ne %d2,%d2,-13
8001e0b8:	df 02 fb 00 	jeq %d2,0,8001e2ae <tcp_input+0xf3e>
              goto aborted;
            }
          }
          recv_acked = 0;
8001e0bc:	91 10 00 27 	movh.a %a2,28673
8001e0c0:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001e0c4:	82 02       	mov %d2,0
8001e0c6:	b4 22       	st.h [%a2],%d2
        }
        if (tcp_input_delayed_close(pcb)) {
8001e0c8:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001e0cc:	6d 00 b0 01 	call 8001e42c <tcp_input_delayed_close>
8001e0d0:	df 02 f2 80 	jne %d2,0,8001e2b4 <tcp_input+0xf44>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
        while (recv_data != NULL) {
          struct pbuf *rest = NULL;
          pbuf_split_64k(recv_data, &rest);
#else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
        if (recv_data != NULL) {
8001e0d4:	91 10 00 27 	movh.a %a2,28673
8001e0d8:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
8001e0dc:	54 22       	ld.w %d2,[%a2]
8001e0de:	df 02 77 00 	jeq %d2,0,8001e1cc <tcp_input+0xe5c>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */

          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
8001e0e2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e0e6:	d9 22 3c 10 	lea %a2,[%a2]124
8001e0ea:	54 22       	ld.w %d2,[%a2]
8001e0ec:	df 02 17 00 	jeq %d2,0,8001e11a <tcp_input+0xdaa>
8001e0f0:	91 00 00 28 	movh.a %a2,32768
8001e0f4:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001e0f8:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001e0fc:	3b 60 1e 20 	mov %d2,486
8001e100:	59 a2 04 00 	st.w [%sp]4,%d2
8001e104:	91 00 00 28 	movh.a %a2,32768
8001e108:	d9 22 4d d2 	lea %a2,[%a2]10061 <8000274d <IfxCpu_Trap_vectorTable0_end+0x2559>>
8001e10c:	f4 a2       	st.a [%sp],%a2
8001e10e:	91 00 00 28 	movh.a %a2,32768
8001e112:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001e116:	6d ff 10 39 	call 80005336 <Ifx_Lwip_printf>
          if (pcb->flags & TF_RXCLOSED) {
8001e11a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e11e:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001e122:	8f 02 01 21 	and %d2,%d2,16
8001e126:	df 02 10 00 	jeq %d2,0,8001e146 <tcp_input+0xdd6>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
8001e12a:	91 10 00 27 	movh.a %a2,28673
8001e12e:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
8001e132:	54 22       	ld.w %d2,[%a2]
8001e134:	60 24       	mov.a %a4,%d2
8001e136:	6d ff 31 df 	call 80019f98 <pbuf_free>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_free(rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            tcp_abort(pcb);
8001e13a:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001e13e:	6d ff e3 e7 	call 8001b104 <tcp_abort>
            goto aborted;
8001e142:	1d 00 c3 00 	j 8001e2c8 <tcp_input+0xf58>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
8001e146:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e14a:	d9 22 08 20 	lea %a2,[%a2]136
8001e14e:	54 22       	ld.w %d2,[%a2]
8001e150:	df 02 1c 00 	jeq %d2,0,8001e188 <tcp_input+0xe18>
8001e154:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e158:	d9 22 08 20 	lea %a2,[%a2]136
8001e15c:	d4 23       	ld.a %a3,[%a2]
8001e15e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e162:	d9 22 10 00 	lea %a2,[%a2]16
8001e166:	54 22       	ld.w %d2,[%a2]
8001e168:	91 10 00 27 	movh.a %a2,28673
8001e16c:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
8001e170:	54 23       	ld.w %d3,[%a2]
8001e172:	82 04       	mov %d4,0
8001e174:	60 36       	mov.a %a6,%d3
8001e176:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
8001e17a:	60 24       	mov.a %a4,%d2
8001e17c:	2d 03 00 00 	calli %a3
8001e180:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
8001e184:	1d 00 10 00 	j 8001e1a4 <tcp_input+0xe34>
8001e188:	91 10 00 27 	movh.a %a2,28673
8001e18c:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
8001e190:	54 22       	ld.w %d2,[%a2]
8001e192:	82 04       	mov %d4,0
8001e194:	60 26       	mov.a %a6,%d2
8001e196:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
8001e19a:	a0 04       	mov.a %a4,0
8001e19c:	6d ff 60 f2 	call 8001c65c <tcp_recv_null>
8001e1a0:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
          if (err == ERR_ABRT) {
8001e1a4:	79 e2 f3 ff 	ld.b %d2,[%a14]-13
8001e1a8:	8b 32 3f 22 	ne %d2,%d2,-13
8001e1ac:	df 02 87 00 	jeq %d2,0,8001e2ba <tcp_input+0xf4a>
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
8001e1b0:	79 e2 f3 ff 	ld.b %d2,[%a14]-13
8001e1b4:	df 02 0c 00 	jeq %d2,0,8001e1cc <tcp_input+0xe5c>
#if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
            if (rest != NULL) {
              pbuf_cat(recv_data, rest);
            }
#endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
            pcb->refused_data = recv_data;
8001e1b8:	91 10 00 27 	movh.a %a2,28673
8001e1bc:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
8001e1c0:	54 22       	ld.w %d2,[%a2]
8001e1c2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <700145fc <recv_data>>
8001e1c6:	d9 22 3c 10 	lea %a2,[%a2]124 <700145fc <recv_data>>
8001e1ca:	74 22       	st.w [%a2],%d2
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
8001e1cc:	91 10 00 27 	movh.a %a2,28673
8001e1d0:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001e1d4:	14 22       	ld.bu %d2,[%a2]
8001e1d6:	8f 02 02 21 	and %d2,%d2,32
8001e1da:	df 02 55 00 	jeq %d2,0,8001e284 <tcp_input+0xf14>
          if (pcb->refused_data != NULL) {
8001e1de:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e1e2:	d9 22 3c 10 	lea %a2,[%a2]124
8001e1e6:	54 22       	ld.w %d2,[%a2]
8001e1e8:	df 02 16 00 	jeq %d2,0,8001e214 <tcp_input+0xea4>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
8001e1ec:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e1f0:	d9 22 3c 10 	lea %a2,[%a2]124
8001e1f4:	d4 22       	ld.a %a2,[%a2]
8001e1f6:	39 22 0d 00 	ld.bu %d2,[%a2]13
8001e1fa:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e1fe:	d9 22 3c 10 	lea %a2,[%a2]124
8001e202:	d4 22       	ld.a %a2,[%a2]
8001e204:	8f 02 42 21 	or %d2,%d2,32
8001e208:	8f f2 0f 21 	and %d2,%d2,255
8001e20c:	e9 22 0d 00 	st.b [%a2]13,%d2
8001e210:	1d 00 3a 00 	j 8001e284 <tcp_input+0xf14>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
8001e214:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e218:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8001e21c:	3b 00 86 30 	mov %d3,2144
8001e220:	5f 32 0d 00 	jeq %d2,%d3,8001e23a <tcp_input+0xeca>
              pcb->rcv_wnd++;
8001e224:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e228:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8001e22c:	c2 12       	add %d2,1
8001e22e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e232:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e236:	f9 22 2c 00 	st.h [%a2]44,%d2
            }
            TCP_EVENT_CLOSED(pcb, err);
8001e23a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e23e:	d9 22 08 20 	lea %a2,[%a2]136
8001e242:	54 22       	ld.w %d2,[%a2]
8001e244:	df 02 17 00 	jeq %d2,0,8001e272 <tcp_input+0xf02>
8001e248:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001e24c:	d9 22 08 20 	lea %a2,[%a2]136
8001e250:	d4 22       	ld.a %a2,[%a2]
8001e252:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
8001e256:	d9 33 10 00 	lea %a3,[%a3]16
8001e25a:	54 32       	ld.w %d2,[%a3]
8001e25c:	82 04       	mov %d4,0
8001e25e:	a0 06       	mov.a %a6,0
8001e260:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
8001e264:	60 24       	mov.a %a4,%d2
8001e266:	2d 02 00 00 	calli %a2
8001e26a:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
8001e26e:	1d 00 05 00 	j 8001e278 <tcp_input+0xf08>
8001e272:	82 02       	mov %d2,0
8001e274:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
            if (err == ERR_ABRT) {
8001e278:	79 e2 f3 ff 	ld.b %d2,[%a14]-13
8001e27c:	8b 32 3f 22 	ne %d2,%d2,-13
8001e280:	df 02 20 00 	jeq %d2,0,8001e2c0 <tcp_input+0xf50>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
8001e284:	91 10 00 27 	movh.a %a2,28673
8001e288:	d9 22 40 84 	lea %a2,[%a2]17920 <70014600 <tcp_input_pcb>>
8001e28c:	82 02       	mov %d2,0
8001e28e:	74 22       	st.w [%a2],%d2
        if (tcp_input_delayed_close(pcb)) {
8001e290:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001e294:	6d 00 cc 00 	call 8001e42c <tcp_input_delayed_close>
8001e298:	df 02 17 80 	jne %d2,0,8001e2c6 <tcp_input+0xf56>
          goto aborted;
        }
        /* Try to send something out. */
        tcp_output(pcb);
8001e29c:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8001e2a0:	6d 00 7a 28 	call 80023394 <tcp_output>
8001e2a4:	1d 00 12 00 	j 8001e2c8 <tcp_input+0xf58>
#endif /* TCP_INPUT_DEBUG */
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
8001e2a8:	00 00       	nop 
8001e2aa:	1d 00 0f 00 	j 8001e2c8 <tcp_input+0xf58>
              goto aborted;
8001e2ae:	00 00       	nop 
8001e2b0:	1d 00 0c 00 	j 8001e2c8 <tcp_input+0xf58>
          goto aborted;
8001e2b4:	00 00       	nop 
8001e2b6:	1d 00 09 00 	j 8001e2c8 <tcp_input+0xf58>
            goto aborted;
8001e2ba:	00 00       	nop 
8001e2bc:	1d 00 06 00 	j 8001e2c8 <tcp_input+0xf58>
              goto aborted;
8001e2c0:	00 00       	nop 
8001e2c2:	1d 00 03 00 	j 8001e2c8 <tcp_input+0xf58>
          goto aborted;
8001e2c6:	00 00       	nop 
    tcp_input_pcb = NULL;
8001e2c8:	91 10 00 27 	movh.a %a2,28673
8001e2cc:	d9 22 40 84 	lea %a2,[%a2]17920 <70014600 <tcp_input_pcb>>
8001e2d0:	82 02       	mov %d2,0
8001e2d2:	74 22       	st.w [%a2],%d2
    recv_data = NULL;
8001e2d4:	91 10 00 27 	movh.a %a2,28673
8001e2d8:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
8001e2dc:	82 02       	mov %d2,0
8001e2de:	74 22       	st.w [%a2],%d2

    /* give up our reference to inseg.p */
    if (inseg.p != NULL) {
8001e2e0:	91 10 00 27 	movh.a %a2,28673
8001e2e4:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8001e2e8:	b0 42       	add.a %a2,4
8001e2ea:	54 22       	ld.w %d2,[%a2]
8001e2ec:	df 02 9e 00 	jeq %d2,0,8001e428 <tcp_input+0x10b8>
      pbuf_free(inseg.p);
8001e2f0:	91 10 00 27 	movh.a %a2,28673
8001e2f4:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8001e2f8:	b0 42       	add.a %a2,4
8001e2fa:	54 22       	ld.w %d2,[%a2]
8001e2fc:	60 24       	mov.a %a4,%d2
8001e2fe:	6d ff 4d de 	call 80019f98 <pbuf_free>
      inseg.p = NULL;
8001e302:	91 10 00 27 	movh.a %a2,28673
8001e306:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8001e30a:	82 02       	mov %d2,0
8001e30c:	b0 42       	add.a %a2,4
8001e30e:	74 22       	st.w [%a2],%d2
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
8001e310:	1d 00 8c 00 	j 8001e428 <tcp_input+0x10b8>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
8001e314:	91 10 00 27 	movh.a %a2,28673
8001e318:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e31c:	d4 22       	ld.a %a2,[%a2]
8001e31e:	39 23 0c 00 	ld.bu %d3,[%a2]12 <700145dc <tcphdr>>
8001e322:	39 22 0d 00 	ld.bu %d2,[%a2]13 <700145dc <tcphdr>>
8001e326:	8f 82 00 20 	sh %d2,%d2,8
8001e32a:	a6 32       	or %d2,%d3
8001e32c:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e330:	02 24       	mov %d4,%d2
8001e332:	6d ff 11 c9 	call 80017554 <lwip_htons>
8001e336:	8f f2 0f 21 	and %d2,%d2,255
8001e33a:	8f 42 00 21 	and %d2,%d2,4
8001e33e:	df 02 5b 80 	jne %d2,0,8001e3f4 <tcp_input+0x1084>
      TCP_STATS_INC(tcp.proterr);
8001e342:	91 10 00 27 	movh.a %a2,28673
8001e346:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001e34a:	b9 22 20 20 	ld.hu %d2,[%a2]160 <700100a0 <ram_heap+0x500c>>
8001e34e:	c2 12       	add %d2,1
8001e350:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e354:	91 10 00 27 	movh.a %a2,28673
8001e358:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001e35c:	f9 22 20 20 	st.h [%a2]160 <700100a0 <ram_heap+0x500c>>,%d2
      TCP_STATS_INC(tcp.drop);
8001e360:	91 10 00 27 	movh.a %a2,28673
8001e364:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001e368:	b9 22 16 20 	ld.hu %d2,[%a2]150 <70010096 <ram_heap+0x5002>>
8001e36c:	c2 12       	add %d2,1
8001e36e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e372:	91 10 00 27 	movh.a %a2,28673
8001e376:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001e37a:	f9 22 16 20 	st.h [%a2]150 <70010096 <ram_heap+0x5002>>,%d2
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e37e:	91 10 00 27 	movh.a %a2,28673
8001e382:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001e386:	54 24       	ld.w %d4,[%a2]
8001e388:	91 10 00 27 	movh.a %a2,28673
8001e38c:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001e390:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001e394:	02 23       	mov %d3,%d2
8001e396:	91 10 00 27 	movh.a %a2,28673
8001e39a:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001e39e:	54 22       	ld.w %d2,[%a2]
8001e3a0:	0b 23 00 50 	add %d5,%d3,%d2
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001e3a4:	91 10 00 27 	movh.a %a2,28673
8001e3a8:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e3ac:	d4 22       	ld.a %a2,[%a2]
8001e3ae:	39 23 02 00 	ld.bu %d3,[%a2]2 <700145dc <tcphdr>>
8001e3b2:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001e3b6:	8f 82 00 20 	sh %d2,%d2,8
8001e3ba:	a6 32       	or %d2,%d3
8001e3bc:	37 02 70 20 	extr.u %d2,%d2,0,16
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e3c0:	02 26       	mov %d6,%d2
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001e3c2:	91 10 00 27 	movh.a %a2,28673
8001e3c6:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e3ca:	d4 22       	ld.a %a2,[%a2]
8001e3cc:	14 23       	ld.bu %d3,[%a2]
8001e3ce:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001e3d2:	8f 82 00 20 	sh %d2,%d2,8
8001e3d6:	a6 32       	or %d2,%d3
8001e3d8:	37 02 70 20 	extr.u %d2,%d2,0,16
      tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e3dc:	02 27       	mov %d7,%d2
8001e3de:	91 10 00 27 	movh.a %a2,28673
8001e3e2:	d9 26 0c 2b 	lea %a6,[%a2]-20340 <7000b08c <ip_data+0x10>>
8001e3e6:	91 10 00 27 	movh.a %a2,28673
8001e3ea:	d9 25 10 2b 	lea %a5,[%a2]-20336 <7000b090 <ip_data+0x14>>
8001e3ee:	a0 04       	mov.a %a4,0
8001e3f0:	6d 00 26 32 	call 8002483c <tcp_rst>
    pbuf_free(p);
8001e3f4:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001e3f8:	6d ff d0 dd 	call 80019f98 <pbuf_free>
  return;
8001e3fc:	1d 00 16 00 	j 8001e428 <tcp_input+0x10b8>
dropped:
  TCP_STATS_INC(tcp.drop);
8001e400:	91 10 00 27 	movh.a %a2,28673
8001e404:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001e408:	b9 22 16 20 	ld.hu %d2,[%a2]150 <70010096 <ram_heap+0x5002>>
8001e40c:	c2 12       	add %d2,1
8001e40e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e412:	91 10 00 27 	movh.a %a2,28673
8001e416:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001e41a:	f9 22 16 20 	st.h [%a2]150 <70010096 <ram_heap+0x5002>>,%d2
  MIB2_STATS_INC(mib2.tcpinerrs);
  pbuf_free(p);
8001e41e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28 <70010096 <ram_heap+0x5002>>
8001e422:	6d ff bb dd 	call 80019f98 <pbuf_free>
8001e426:	00 90       	ret 
  return;
8001e428:	00 00       	nop 
}
8001e42a:	00 90       	ret 

8001e42c <tcp_input_delayed_close>:
 * any more.
 * @returns 1 if the pcb has been closed and deallocated, 0 otherwise
 */
static int
tcp_input_delayed_close(struct tcp_pcb *pcb)
{
8001e42c:	40 ae       	mov.aa %a14,%sp
8001e42e:	20 18       	sub.a %sp,24
8001e430:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
8001e434:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001e438:	df 02 17 80 	jne %d2,0,8001e466 <tcp_input_delayed_close+0x3a>
8001e43c:	91 00 00 28 	movh.a %a2,32768
8001e440:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001e444:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001e448:	3b a0 25 20 	mov %d2,602
8001e44c:	59 a2 04 00 	st.w [%sp]4,%d2
8001e450:	91 00 00 28 	movh.a %a2,32768
8001e454:	d9 22 67 d2 	lea %a2,[%a2]10087 <80002767 <IfxCpu_Trap_vectorTable0_end+0x2573>>
8001e458:	f4 a2       	st.a [%sp],%a2
8001e45a:	91 00 00 28 	movh.a %a2,32768
8001e45e:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001e462:	6d ff 6a 37 	call 80005336 <Ifx_Lwip_printf>

  if (recv_flags & TF_CLOSED) {
8001e466:	91 10 00 27 	movh.a %a2,28673
8001e46a:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001e46e:	14 22       	ld.bu %d2,[%a2]
8001e470:	8f 02 01 21 	and %d2,%d2,16
8001e474:	df 02 2e 00 	jeq %d2,0,8001e4d0 <tcp_input_delayed_close+0xa4>
    /* The connection has been closed and we will deallocate the
        PCB. */
    if (!(pcb->flags & TF_RXCLOSED)) {
8001e478:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e47c:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001e480:	8f 02 01 21 	and %d2,%d2,16
8001e484:	df 02 18 80 	jne %d2,0,8001e4b4 <tcp_input_delayed_close+0x88>
      /* Connection closed although the application has only shut down the
          tx side: call the PCB's err callback and indicate the closure to
          ensure the application doesn't continue using the PCB. */
      TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
8001e488:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e48c:	d9 22 14 20 	lea %a2,[%a2]148
8001e490:	54 22       	ld.w %d2,[%a2]
8001e492:	df 02 11 00 	jeq %d2,0,8001e4b4 <tcp_input_delayed_close+0x88>
8001e496:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e49a:	d9 22 14 20 	lea %a2,[%a2]148
8001e49e:	d4 22       	ld.a %a2,[%a2]
8001e4a0:	99 e3 fc ff 	ld.a %a3,[%a14]-4
8001e4a4:	d9 33 10 00 	lea %a3,[%a3]16
8001e4a8:	54 32       	ld.w %d2,[%a3]
8001e4aa:	3b 10 ff 4f 	mov %d4,-15
8001e4ae:	60 24       	mov.a %a4,%d2
8001e4b0:	2d 02 00 00 	calli %a2
    }
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
8001e4b4:	99 e5 fc ff 	ld.a %a5,[%a14]-4
8001e4b8:	91 10 00 27 	movh.a %a2,28673
8001e4bc:	d9 24 7c 64 	lea %a4,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001e4c0:	6d ff 05 f5 	call 8001ceca <tcp_pcb_remove>
    tcp_free(pcb);
8001e4c4:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001e4c8:	6d ff 9d e1 	call 8001a802 <tcp_free>
    return 1;
8001e4cc:	82 12       	mov %d2,1
8001e4ce:	00 90       	ret 
  }
  return 0;
8001e4d0:	82 02       	mov %d2,0
}
8001e4d2:	00 90       	ret 

8001e4d4 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
8001e4d4:	40 ae       	mov.aa %a14,%sp
8001e4d6:	20 28       	sub.a %sp,40
8001e4d8:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  struct tcp_pcb *npcb;
  u32_t iss;
  err_t rc;

  if (flags & TCP_RST) {
8001e4dc:	91 10 00 27 	movh.a %a2,28673
8001e4e0:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001e4e4:	14 22       	ld.bu %d2,[%a2]
8001e4e6:	8f 42 00 21 	and %d2,%d2,4
8001e4ea:	df 02 a7 81 	jne %d2,0,8001e838 <tcp_listen_input+0x364>
    /* An incoming RST should be ignored. Return. */
    return;
  }

  LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
8001e4ee:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001e4f2:	df 02 17 80 	jne %d2,0,8001e520 <tcp_listen_input+0x4c>
8001e4f6:	91 00 00 28 	movh.a %a2,32768
8001e4fa:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001e4fe:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001e502:	3b 10 28 20 	mov %d2,641
8001e506:	59 a2 04 00 	st.w [%sp]4,%d2
8001e50a:	91 00 00 28 	movh.a %a2,32768
8001e50e:	d9 22 4c e2 	lea %a2,[%a2]10124 <8000278c <IfxCpu_Trap_vectorTable0_end+0x2598>>
8001e512:	f4 a2       	st.a [%sp],%a2
8001e514:	91 00 00 28 	movh.a %a2,32768
8001e518:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001e51c:	6d ff 0d 37 	call 80005336 <Ifx_Lwip_printf>

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
8001e520:	91 10 00 27 	movh.a %a2,28673
8001e524:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001e528:	14 22       	ld.bu %d2,[%a2]
8001e52a:	8f 02 01 21 	and %d2,%d2,16
8001e52e:	df 02 40 00 	jeq %d2,0,8001e5ae <tcp_listen_input+0xda>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e532:	91 10 00 27 	movh.a %a2,28673
8001e536:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001e53a:	54 24       	ld.w %d4,[%a2]
8001e53c:	91 10 00 27 	movh.a %a2,28673
8001e540:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001e544:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001e548:	02 23       	mov %d3,%d2
8001e54a:	91 10 00 27 	movh.a %a2,28673
8001e54e:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001e552:	54 22       	ld.w %d2,[%a2]
8001e554:	0b 23 00 50 	add %d5,%d3,%d2
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001e558:	91 10 00 27 	movh.a %a2,28673
8001e55c:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e560:	d4 22       	ld.a %a2,[%a2]
8001e562:	39 23 02 00 	ld.bu %d3,[%a2]2 <700145dc <tcphdr>>
8001e566:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001e56a:	8f 82 00 20 	sh %d2,%d2,8
8001e56e:	a6 32       	or %d2,%d3
8001e570:	37 02 70 20 	extr.u %d2,%d2,0,16
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e574:	02 26       	mov %d6,%d2
            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001e576:	91 10 00 27 	movh.a %a2,28673
8001e57a:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e57e:	d4 22       	ld.a %a2,[%a2]
8001e580:	14 23       	ld.bu %d3,[%a2]
8001e582:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001e586:	8f 82 00 20 	sh %d2,%d2,8
8001e58a:	a6 32       	or %d2,%d3
8001e58c:	37 02 70 20 	extr.u %d2,%d2,0,16
    tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e590:	02 27       	mov %d7,%d2
8001e592:	91 10 00 27 	movh.a %a2,28673
8001e596:	d9 26 0c 2b 	lea %a6,[%a2]-20340 <7000b08c <ip_data+0x10>>
8001e59a:	91 10 00 27 	movh.a %a2,28673
8001e59e:	d9 25 10 2b 	lea %a5,[%a2]-20336 <7000b090 <ip_data+0x14>>
8001e5a2:	99 e4 ec ff 	ld.a %a4,[%a14]-20 <7000b090 <ip_data+0x14>>
8001e5a6:	6d 00 4b 31 	call 8002483c <tcp_rst>
      tcp_abandon(npcb, 0);
      return;
    }
    tcp_output(npcb);
  }
  return;
8001e5aa:	1d 00 49 01 	j 8001e83c <tcp_listen_input+0x368>
  } else if (flags & TCP_SYN) {
8001e5ae:	91 10 00 27 	movh.a %a2,28673
8001e5b2:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001e5b6:	14 22       	ld.bu %d2,[%a2]
8001e5b8:	8f 22 00 21 	and %d2,%d2,2
8001e5bc:	df 02 40 01 	jeq %d2,0,8001e83c <tcp_listen_input+0x368>
    npcb = tcp_alloc(pcb->prio);
8001e5c0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001e5c4:	39 22 18 00 	ld.bu %d2,[%a2]24
8001e5c8:	02 24       	mov %d4,%d2
8001e5ca:	6d ff f3 f1 	call 8001c9b0 <tcp_alloc>
8001e5ce:	b5 e2 fc ff 	st.a [%a14]-4,%a2
    if (npcb == NULL) {
8001e5d2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001e5d6:	df 02 2f 80 	jne %d2,0,8001e634 <tcp_listen_input+0x160>
      TCP_STATS_INC(tcp.memerr);
8001e5da:	91 10 00 27 	movh.a %a2,28673
8001e5de:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001e5e2:	b9 22 1c 20 	ld.hu %d2,[%a2]156 <7001009c <ram_heap+0x5008>>
8001e5e6:	c2 12       	add %d2,1
8001e5e8:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e5ec:	91 10 00 27 	movh.a %a2,28673
8001e5f0:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8001e5f4:	f9 22 1c 20 	st.h [%a2]156 <7001009c <ram_heap+0x5008>>,%d2
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
8001e5f8:	99 e2 ec ff 	ld.a %a2,[%a14]-20 <7001009c <ram_heap+0x5008>>
8001e5fc:	d9 22 1c 00 	lea %a2,[%a2]28 <7001009c <ram_heap+0x5008>>
8001e600:	54 22       	ld.w %d2,[%a2]
8001e602:	df 02 14 00 	jeq %d2,0,8001e62a <tcp_listen_input+0x156>
8001e606:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001e60a:	d9 22 1c 00 	lea %a2,[%a2]28
8001e60e:	d4 22       	ld.a %a2,[%a2]
8001e610:	99 e3 ec ff 	ld.a %a3,[%a14]-20
8001e614:	d9 33 10 00 	lea %a3,[%a3]16
8001e618:	54 32       	ld.w %d2,[%a3]
8001e61a:	82 f4       	mov %d4,-1
8001e61c:	a0 05       	mov.a %a5,0
8001e61e:	60 24       	mov.a %a4,%d2
8001e620:	2d 02 00 00 	calli %a2
8001e624:	e9 e2 f6 ff 	st.b [%a14]-10,%d2
      return;
8001e628:	00 90       	ret 
      TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
8001e62a:	3b 00 ff 2f 	mov %d2,-16
8001e62e:	e9 e2 f6 ff 	st.b [%a14]-10,%d2
      return;
8001e632:	00 90       	ret 
    ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
8001e634:	91 10 00 27 	movh.a %a2,28673
8001e638:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001e63c:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
8001e640:	54 22       	ld.w %d2,[%a2]
8001e642:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <70010014 <ram_heap+0x4f80>>
8001e646:	74 22       	st.w [%a2],%d2
    ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
8001e648:	91 10 00 27 	movh.a %a2,28673
8001e64c:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8001e650:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
8001e654:	54 22       	ld.w %d2,[%a2]
8001e656:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <70010010 <ram_heap+0x4f7c>>
8001e65a:	b0 42       	add.a %a2,4
8001e65c:	74 22       	st.w [%a2],%d2
    npcb->local_port = pcb->local_port;
8001e65e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001e662:	b9 22 1a 00 	ld.hu %d2,[%a2]26
8001e666:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e66a:	f9 22 1a 00 	st.h [%a2]26,%d2
    npcb->remote_port = tcphdr->src;
8001e66e:	91 10 00 27 	movh.a %a2,28673
8001e672:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e676:	d4 22       	ld.a %a2,[%a2]
8001e678:	14 23       	ld.bu %d3,[%a2]
8001e67a:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001e67e:	8f 82 00 20 	sh %d2,%d2,8
8001e682:	a6 32       	or %d2,%d3
8001e684:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e688:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e68c:	f9 22 1c 00 	st.h [%a2]28,%d2
    npcb->state = SYN_RCVD;
8001e690:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e694:	82 32       	mov %d2,3
8001e696:	d9 22 14 00 	lea %a2,[%a2]20
8001e69a:	74 22       	st.w [%a2],%d2
    npcb->rcv_nxt = seqno + 1;
8001e69c:	91 10 00 27 	movh.a %a2,28673
8001e6a0:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001e6a4:	54 22       	ld.w %d2,[%a2]
8001e6a6:	c2 12       	add %d2,1
8001e6a8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e6ac:	d9 22 28 00 	lea %a2,[%a2]40
8001e6b0:	74 22       	st.w [%a2],%d2
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
8001e6b2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e6b6:	d9 22 28 00 	lea %a2,[%a2]40
8001e6ba:	54 22       	ld.w %d2,[%a2]
8001e6bc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e6c0:	d9 22 30 00 	lea %a2,[%a2]48
8001e6c4:	74 22       	st.w [%a2],%d2
    iss = tcp_next_iss(npcb);
8001e6c6:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001e6ca:	6d ff 0b f5 	call 8001d0e0 <tcp_next_iss>
8001e6ce:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    npcb->snd_wl2 = iss;
8001e6d2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e6d6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001e6da:	d9 22 1c 10 	lea %a2,[%a2]92
8001e6de:	74 22       	st.w [%a2],%d2
    npcb->snd_nxt = iss;
8001e6e0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e6e4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001e6e8:	d9 22 14 10 	lea %a2,[%a2]84
8001e6ec:	74 22       	st.w [%a2],%d2
    npcb->lastack = iss;
8001e6ee:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e6f2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001e6f6:	d9 22 08 10 	lea %a2,[%a2]72
8001e6fa:	74 22       	st.w [%a2],%d2
    npcb->snd_lbb = iss;
8001e6fc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e700:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001e704:	d9 22 20 10 	lea %a2,[%a2]96
8001e708:	74 22       	st.w [%a2],%d2
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
8001e70a:	91 10 00 27 	movh.a %a2,28673
8001e70e:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001e712:	54 22       	ld.w %d2,[%a2]
8001e714:	c2 f2       	add %d2,-1
8001e716:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e71a:	d9 22 18 10 	lea %a2,[%a2]88
8001e71e:	74 22       	st.w [%a2],%d2
    npcb->callback_arg = pcb->callback_arg;
8001e720:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001e724:	d9 22 10 00 	lea %a2,[%a2]16
8001e728:	54 22       	ld.w %d2,[%a2]
8001e72a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e72e:	d9 22 10 00 	lea %a2,[%a2]16
8001e732:	74 22       	st.w [%a2],%d2
    npcb->listener = pcb;
8001e734:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e738:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001e73c:	d9 22 00 20 	lea %a2,[%a2]128
8001e740:	74 22       	st.w [%a2],%d2
    npcb->so_options = pcb->so_options & SOF_INHERITED;
8001e742:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001e746:	39 22 09 00 	ld.bu %d2,[%a2]9
8001e74a:	8f c2 00 21 	and %d2,%d2,12
8001e74e:	8f f2 0f 21 	and %d2,%d2,255
8001e752:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e756:	e9 22 09 00 	st.b [%a2]9,%d2
    npcb->netif_idx = pcb->netif_idx;
8001e75a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001e75e:	39 22 08 00 	ld.bu %d2,[%a2]8
8001e762:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e766:	e9 22 08 00 	st.b [%a2]8,%d2
    TCP_REG_ACTIVE(npcb);
8001e76a:	91 10 00 27 	movh.a %a2,28673
8001e76e:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001e772:	54 22       	ld.w %d2,[%a2]
8001e774:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145bc <tcp_active_pcbs>>
8001e778:	d9 22 0c 00 	lea %a2,[%a2]12 <700145bc <tcp_active_pcbs>>
8001e77c:	74 22       	st.w [%a2],%d2
8001e77e:	91 10 00 27 	movh.a %a2,28673
8001e782:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001e786:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <700145bc <tcp_active_pcbs>>
8001e78a:	74 22       	st.w [%a2],%d2
8001e78c:	6d 00 1e 33 	call 80024dc8 <tcp_timer_needed>
8001e790:	91 10 00 27 	movh.a %a2,28673
8001e794:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001e798:	82 12       	mov %d2,1
8001e79a:	34 22       	st.b [%a2],%d2
    tcp_parseopt(npcb);
8001e79c:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001e7a0:	6d 00 1a 18 	call 800217d4 <tcp_parseopt>
    npcb->snd_wnd = tcphdr->wnd;
8001e7a4:	91 10 00 27 	movh.a %a2,28673
8001e7a8:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e7ac:	d4 22       	ld.a %a2,[%a2]
8001e7ae:	39 23 0e 00 	ld.bu %d3,[%a2]14 <700145dc <tcphdr>>
8001e7b2:	39 22 0f 00 	ld.bu %d2,[%a2]15 <700145dc <tcphdr>>
8001e7b6:	8f 82 00 20 	sh %d2,%d2,8
8001e7ba:	a6 32       	or %d2,%d3
8001e7bc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e7c0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e7c4:	f9 22 24 10 	st.h [%a2]100,%d2
    npcb->snd_wnd_max = npcb->snd_wnd;
8001e7c8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e7cc:	b9 22 24 10 	ld.hu %d2,[%a2]100
8001e7d0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e7d4:	f9 22 26 10 	st.h [%a2]102,%d2
    npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
8001e7d8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e7dc:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001e7e0:	02 28       	mov %d8,%d2
8001e7e2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001e7e6:	c2 42       	add %d2,4
8001e7e8:	60 24       	mov.a %a4,%d2
8001e7ea:	6d ff 6c b3 	call 80014ec2 <ip4_route>
8001e7ee:	80 22       	mov.d %d2,%a2
8001e7f0:	19 e3 fc ff 	ld.w %d3,[%a14]-4
8001e7f4:	c2 43       	add %d3,4
8001e7f6:	60 35       	mov.a %a5,%d3
8001e7f8:	60 24       	mov.a %a4,%d2
8001e7fa:	02 84       	mov %d4,%d8
8001e7fc:	6d ff a5 f4 	call 8001d146 <tcp_eff_send_mss_netif>
8001e800:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e804:	f9 22 36 00 	st.h [%a2]54,%d2
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
8001e808:	3b 20 01 40 	mov %d4,18
8001e80c:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001e810:	6d 00 22 24 	call 80023054 <tcp_enqueue_flags>
8001e814:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
    if (rc != ERR_OK) {
8001e818:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
8001e81c:	df 02 08 00 	jeq %d2,0,8001e82c <tcp_listen_input+0x358>
      tcp_abandon(npcb, 0);
8001e820:	82 04       	mov %d4,0
8001e822:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001e826:	6d ff 2c e3 	call 8001ae7e <tcp_abandon>
      return;
8001e82a:	00 90       	ret 
    tcp_output(npcb);
8001e82c:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001e830:	6d 00 b2 25 	call 80023394 <tcp_output>
  return;
8001e834:	1d 00 04 00 	j 8001e83c <tcp_listen_input+0x368>
    return;
8001e838:	00 00       	nop 
8001e83a:	00 90       	ret 
  return;
8001e83c:	00 00       	nop 
}
8001e83e:	00 90       	ret 

8001e840 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static void
tcp_timewait_input(struct tcp_pcb *pcb)
{
8001e840:	40 ae       	mov.aa %a14,%sp
8001e842:	20 18       	sub.a %sp,24
8001e844:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST) {
8001e848:	91 10 00 27 	movh.a %a2,28673
8001e84c:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001e850:	14 22       	ld.bu %d2,[%a2]
8001e852:	8f 42 00 21 	and %d2,%d2,4
8001e856:	df 02 af 80 	jne %d2,0,8001e9b4 <tcp_timewait_input+0x174>
    return;
  }

  LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
8001e85a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8001e85e:	df 02 17 80 	jne %d2,0,8001e88c <tcp_timewait_input+0x4c>
8001e862:	91 00 00 28 	movh.a %a2,32768
8001e866:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001e86a:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001e86e:	3b e0 2e 20 	mov %d2,750
8001e872:	59 a2 04 00 	st.w [%sp]4,%d2
8001e876:	91 00 00 28 	movh.a %a2,32768
8001e87a:	d9 22 6a e2 	lea %a2,[%a2]10154 <800027aa <IfxCpu_Trap_vectorTable0_end+0x25b6>>
8001e87e:	f4 a2       	st.a [%sp],%a2
8001e880:	91 00 00 28 	movh.a %a2,32768
8001e884:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001e888:	6d ff 57 35 	call 80005336 <Ifx_Lwip_printf>

  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
8001e88c:	91 10 00 27 	movh.a %a2,28673
8001e890:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001e894:	14 22       	ld.bu %d2,[%a2]
8001e896:	8f 22 00 21 	and %d2,%d2,2
8001e89a:	df 02 60 00 	jeq %d2,0,8001e95a <tcp_timewait_input+0x11a>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
8001e89e:	91 10 00 27 	movh.a %a2,28673
8001e8a2:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001e8a6:	54 23       	ld.w %d3,[%a2]
8001e8a8:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145ec <seqno>>
8001e8ac:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
8001e8b0:	54 22       	ld.w %d2,[%a2]
8001e8b2:	0b 23 80 20 	sub %d2,%d3,%d2
8001e8b6:	bf 02 65 00 	jlt %d2,0,8001e980 <tcp_timewait_input+0x140>
8001e8ba:	91 10 00 27 	movh.a %a2,28673
8001e8be:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001e8c2:	54 23       	ld.w %d3,[%a2]
8001e8c4:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145ec <seqno>>
8001e8c8:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
8001e8cc:	54 24       	ld.w %d4,[%a2]
8001e8ce:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145ec <seqno>>
8001e8d2:	b9 22 2c 00 	ld.hu %d2,[%a2]44 <700145ec <seqno>>
8001e8d6:	42 42       	add %d2,%d4
8001e8d8:	0b 23 80 20 	sub %d2,%d3,%d2
8001e8dc:	ff 12 52 00 	jge %d2,1,8001e980 <tcp_timewait_input+0x140>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e8e0:	91 10 00 27 	movh.a %a2,28673
8001e8e4:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001e8e8:	54 24       	ld.w %d4,[%a2]
8001e8ea:	91 10 00 27 	movh.a %a2,28673
8001e8ee:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001e8f2:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001e8f6:	02 23       	mov %d3,%d2
8001e8f8:	91 10 00 27 	movh.a %a2,28673
8001e8fc:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001e900:	54 22       	ld.w %d2,[%a2]
8001e902:	0b 23 00 50 	add %d5,%d3,%d2
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001e906:	91 10 00 27 	movh.a %a2,28673
8001e90a:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e90e:	d4 22       	ld.a %a2,[%a2]
8001e910:	39 23 02 00 	ld.bu %d3,[%a2]2 <700145dc <tcphdr>>
8001e914:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001e918:	8f 82 00 20 	sh %d2,%d2,8
8001e91c:	a6 32       	or %d2,%d3
8001e91e:	37 02 70 20 	extr.u %d2,%d2,0,16
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e922:	02 26       	mov %d6,%d2
              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001e924:	91 10 00 27 	movh.a %a2,28673
8001e928:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001e92c:	d4 22       	ld.a %a2,[%a2]
8001e92e:	14 23       	ld.bu %d3,[%a2]
8001e930:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001e934:	8f 82 00 20 	sh %d2,%d2,8
8001e938:	a6 32       	or %d2,%d3
8001e93a:	37 02 70 20 	extr.u %d2,%d2,0,16
      tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001e93e:	02 27       	mov %d7,%d2
8001e940:	91 10 00 27 	movh.a %a2,28673
8001e944:	d9 26 0c 2b 	lea %a6,[%a2]-20340 <7000b08c <ip_data+0x10>>
8001e948:	91 10 00 27 	movh.a %a2,28673
8001e94c:	d9 25 10 2b 	lea %a5,[%a2]-20336 <7000b090 <ip_data+0x14>>
8001e950:	99 e4 fc ff 	ld.a %a4,[%a14]-4 <7000b090 <ip_data+0x14>>
8001e954:	6d 00 74 2f 	call 8002483c <tcp_rst>
      return;
8001e958:	00 90       	ret 
    }
  } else if (flags & TCP_FIN) {
8001e95a:	91 10 00 27 	movh.a %a2,28673
8001e95e:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001e962:	14 22       	ld.bu %d2,[%a2]
8001e964:	8f 12 00 21 	and %d2,%d2,1
8001e968:	df 02 0c 00 	jeq %d2,0,8001e980 <tcp_timewait_input+0x140>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
8001e96c:	91 10 00 27 	movh.a %a2,28673
8001e970:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001e974:	54 22       	ld.w %d2,[%a2]
8001e976:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <700145b0 <tcp_ticks>>
8001e97a:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001e97e:	74 22       	st.w [%a2],%d2
  }

  if ((tcplen > 0)) {
8001e980:	91 10 00 27 	movh.a %a2,28673
8001e984:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001e988:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001e98c:	df 02 16 00 	jeq %d2,0,8001e9b8 <tcp_timewait_input+0x178>
    /* Acknowledge data, FIN or out-of-window SYN */
    tcp_ack_now(pcb);
8001e990:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e994:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001e998:	8f 22 40 21 	or %d2,%d2,2
8001e99c:	37 02 70 20 	extr.u %d2,%d2,0,16
8001e9a0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001e9a4:	f9 22 1e 00 	st.h [%a2]30,%d2
    tcp_output(pcb);
8001e9a8:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001e9ac:	6d 00 f4 24 	call 80023394 <tcp_output>
  }
  return;
8001e9b0:	1d 00 04 00 	j 8001e9b8 <tcp_timewait_input+0x178>
    return;
8001e9b4:	00 00       	nop 
8001e9b6:	00 90       	ret 
  return;
8001e9b8:	00 00       	nop 
}
8001e9ba:	00 90       	ret 

8001e9bc <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
8001e9bc:	40 ae       	mov.aa %a14,%sp
8001e9be:	20 30       	sub.a %sp,48
8001e9c0:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
8001e9c4:	82 02       	mov %d2,0
8001e9c6:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  err_t err;

  err = ERR_OK;
8001e9ca:	82 02       	mov %d2,0
8001e9cc:	e9 e2 fe ff 	st.b [%a14]-2,%d2

  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
8001e9d0:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8001e9d4:	df 02 17 80 	jne %d2,0,8001ea02 <tcp_process+0x46>
8001e9d8:	91 00 00 28 	movh.a %a2,32768
8001e9dc:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001e9e0:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001e9e4:	3b c0 31 20 	mov %d2,796
8001e9e8:	59 a2 04 00 	st.w [%sp]4,%d2
8001e9ec:	91 00 00 28 	movh.a %a2,32768
8001e9f0:	d9 22 4a f2 	lea %a2,[%a2]10186 <800027ca <IfxCpu_Trap_vectorTable0_end+0x25d6>>
8001e9f4:	f4 a2       	st.a [%sp],%a2
8001e9f6:	91 00 00 28 	movh.a %a2,32768
8001e9fa:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001e9fe:	6d ff 9c 34 	call 80005336 <Ifx_Lwip_printf>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
8001ea02:	91 10 00 27 	movh.a %a2,28673
8001ea06:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001ea0a:	14 22       	ld.bu %d2,[%a2]
8001ea0c:	8f 42 00 21 	and %d2,%d2,4
8001ea10:	df 02 97 00 	jeq %d2,0,8001eb3e <tcp_process+0x182>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
8001ea14:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ea18:	d9 22 14 00 	lea %a2,[%a2]20
8001ea1c:	54 22       	ld.w %d2,[%a2]
8001ea1e:	df 22 13 80 	jne %d2,2,8001ea44 <tcp_process+0x88>
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
8001ea22:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ea26:	d9 22 14 10 	lea %a2,[%a2]84
8001ea2a:	54 23       	ld.w %d3,[%a2]
8001ea2c:	91 10 00 27 	movh.a %a2,28673
8001ea30:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001ea34:	54 22       	ld.w %d2,[%a2]
8001ea36:	5f 23 45 80 	jne %d3,%d2,8001eac0 <tcp_process+0x104>
        acceptable = 1;
8001ea3a:	82 12       	mov %d2,1
8001ea3c:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8001ea40:	1d 00 40 00 	j 8001eac0 <tcp_process+0x104>
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
8001ea44:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ea48:	d9 22 28 00 	lea %a2,[%a2]40
8001ea4c:	54 23       	ld.w %d3,[%a2]
8001ea4e:	91 10 00 27 	movh.a %a2,28673
8001ea52:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001ea56:	54 22       	ld.w %d2,[%a2]
8001ea58:	5f 23 07 80 	jne %d3,%d2,8001ea66 <tcp_process+0xaa>
        acceptable = 1;
8001ea5c:	82 12       	mov %d2,1
8001ea5e:	e9 e2 ff ff 	st.b [%a14]-1,%d2
8001ea62:	1d 00 2f 00 	j 8001eac0 <tcp_process+0x104>
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
8001ea66:	91 10 00 27 	movh.a %a2,28673
8001ea6a:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001ea6e:	54 23       	ld.w %d3,[%a2]
8001ea70:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145ec <seqno>>
8001ea74:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
8001ea78:	54 22       	ld.w %d2,[%a2]
8001ea7a:	0b 23 80 20 	sub %d2,%d3,%d2
8001ea7e:	bf 02 21 00 	jlt %d2,0,8001eac0 <tcp_process+0x104>
8001ea82:	91 10 00 27 	movh.a %a2,28673
8001ea86:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001ea8a:	54 23       	ld.w %d3,[%a2]
8001ea8c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145ec <seqno>>
8001ea90:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
8001ea94:	54 24       	ld.w %d4,[%a2]
8001ea96:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145ec <seqno>>
8001ea9a:	b9 22 2c 00 	ld.hu %d2,[%a2]44 <700145ec <seqno>>
8001ea9e:	42 42       	add %d2,%d4
8001eaa0:	0b 23 80 20 	sub %d2,%d3,%d2
8001eaa4:	ff 12 0e 00 	jge %d2,1,8001eac0 <tcp_process+0x104>
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we send a challenge ACK
           and wait for a re-send with matching sequence number.
           This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
           (RST spoofing attack), which is present in RFC 793 RST handling. */
        tcp_ack_now(pcb);
8001eaa8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eaac:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001eab0:	8f 22 40 21 	or %d2,%d2,2
8001eab4:	37 02 70 20 	extr.u %d2,%d2,0,16
8001eab8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eabc:	f9 22 1e 00 	st.h [%a2]30,%d2
      }
    }

    if (acceptable) {
8001eac0:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8001eac4:	df 02 3b 00 	jeq %d2,0,8001eb3a <tcp_process+0x17e>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
8001eac8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eacc:	d9 22 14 00 	lea %a2,[%a2]20
8001ead0:	54 22       	ld.w %d2,[%a2]
8001ead2:	df 02 17 80 	jne %d2,0,8001eb00 <tcp_process+0x144>
8001ead6:	91 00 00 28 	movh.a %a2,32768
8001eada:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001eade:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001eae2:	3b 80 33 20 	mov %d2,824
8001eae6:	59 a2 04 00 	st.w [%sp]4,%d2
8001eaea:	91 00 00 28 	movh.a %a2,32768
8001eaee:	d9 22 63 f2 	lea %a2,[%a2]10211 <800027e3 <IfxCpu_Trap_vectorTable0_end+0x25ef>>
8001eaf2:	f4 a2       	st.a [%sp],%a2
8001eaf4:	91 00 00 28 	movh.a %a2,32768
8001eaf8:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001eafc:	6d ff 1d 34 	call 80005336 <Ifx_Lwip_printf>
      recv_flags |= TF_RESET;
8001eb00:	91 10 00 27 	movh.a %a2,28673
8001eb04:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001eb08:	14 22       	ld.bu %d2,[%a2]
8001eb0a:	8f 82 40 21 	or %d2,%d2,8
8001eb0e:	8f f2 0f 21 	and %d2,%d2,255
8001eb12:	91 10 00 27 	movh.a %a2,28673
8001eb16:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001eb1a:	34 22       	st.b [%a2],%d2
      tcp_clear_flags(pcb, TF_ACK_DELAY);
8001eb1c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145f9 <recv_flags>>
8001eb20:	b9 22 1e 00 	ld.hu %d2,[%a2]30 <700145f9 <recv_flags>>
8001eb24:	8f 12 c0 21 	andn %d2,%d2,1
8001eb28:	37 02 70 20 	extr.u %d2,%d2,0,16
8001eb2c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eb30:	f9 22 1e 00 	st.h [%a2]30,%d2
      return ERR_RST;
8001eb34:	3b 20 ff 2f 	mov %d2,-14
8001eb38:	00 90       	ret 
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                                    seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                              seqno, pcb->rcv_nxt));
      return ERR_OK;
8001eb3a:	82 02       	mov %d2,0
8001eb3c:	00 90       	ret 
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
8001eb3e:	91 10 00 27 	movh.a %a2,28673
8001eb42:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001eb46:	14 22       	ld.bu %d2,[%a2]
8001eb48:	8f 22 00 21 	and %d2,%d2,2
8001eb4c:	df 02 1e 00 	jeq %d2,0,8001eb88 <tcp_process+0x1cc>
8001eb50:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eb54:	d9 22 14 00 	lea %a2,[%a2]20
8001eb58:	54 22       	ld.w %d2,[%a2]
8001eb5a:	df 22 17 00 	jeq %d2,2,8001eb88 <tcp_process+0x1cc>
8001eb5e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eb62:	d9 22 14 00 	lea %a2,[%a2]20
8001eb66:	54 22       	ld.w %d2,[%a2]
8001eb68:	df 32 10 00 	jeq %d2,3,8001eb88 <tcp_process+0x1cc>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
8001eb6c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eb70:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001eb74:	8f 22 40 21 	or %d2,%d2,2
8001eb78:	37 02 70 20 	extr.u %d2,%d2,0,16
8001eb7c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eb80:	f9 22 1e 00 	st.h [%a2]30,%d2
    return ERR_OK;
8001eb84:	82 02       	mov %d2,0
8001eb86:	00 90       	ret 
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
8001eb88:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eb8c:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001eb90:	8f 02 01 21 	and %d2,%d2,16
8001eb94:	df 02 0c 80 	jne %d2,0,8001ebac <tcp_process+0x1f0>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
8001eb98:	91 10 00 27 	movh.a %a2,28673
8001eb9c:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
8001eba0:	54 22       	ld.w %d2,[%a2]
8001eba2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145b0 <tcp_ticks>>
8001eba6:	d9 22 24 00 	lea %a2,[%a2]36 <700145b0 <tcp_ticks>>
8001ebaa:	74 22       	st.w [%a2],%d2
  }
  pcb->keep_cnt_sent = 0;
8001ebac:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145b0 <tcp_ticks>>
8001ebb0:	82 02       	mov %d2,0
8001ebb2:	e9 22 1f 20 	st.b [%a2]159,%d2
  pcb->persist_probe = 0;
8001ebb6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ebba:	82 02       	mov %d2,0
8001ebbc:	e9 22 1e 20 	st.b [%a2]158,%d2

  tcp_parseopt(pcb);
8001ebc0:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001ebc4:	6d 00 08 16 	call 800217d4 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
8001ebc8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ebcc:	d9 22 14 00 	lea %a2,[%a2]20
8001ebd0:	54 22       	ld.w %d2,[%a2]
8001ebd2:	91 20 00 28 	movh.a %a2,32770
8001ebd6:	d9 22 a8 fe 	lea %a2,[%a2]-5144 <8001ebe8 <tcp_process+0x22c>>
8001ebda:	c2 e2       	add %d2,-2
8001ebdc:	ff 82 66 85 	jge.u %d2,8,8001f6a8 <tcp_process+0xcec>
8001ebe0:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
8001ebe4:	dc 02       	ji %a2
8001ebe6:	00 00       	nop 
8001ebe8:	1d 00 10 00 	j 8001ec08 <tcp_process+0x24c>
8001ebec:	1d 00 cc 01 	j 8001ef84 <tcp_process+0x5c8>
8001ebf0:	1d 00 1d 03 	j 8001f22a <tcp_process+0x86e>
8001ebf4:	1d 00 3c 03 	j 8001f26c <tcp_process+0x8b0>
8001ebf8:	1d 00 15 04 	j 8001f422 <tcp_process+0xa66>
8001ebfc:	1d 00 17 03 	j 8001f22a <tcp_process+0x86e>
8001ec00:	1d 00 97 04 	j 8001f52e <tcp_process+0xb72>
8001ec04:	1d 00 22 05 	j 8001f648 <tcp_process+0xc8c>
    case SYN_SENT:
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
                                    pcb->snd_nxt, lwip_ntohl(pcb->unacked->tcphdr->seqno)));
      /* received SYN ACK with expected sequence number? */
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
8001ec08:	91 10 00 27 	movh.a %a2,28673
8001ec0c:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001ec10:	14 22       	ld.bu %d2,[%a2]
8001ec12:	8f 02 01 21 	and %d2,%d2,16
8001ec16:	df 02 61 01 	jeq %d2,0,8001eed8 <tcp_process+0x51c>
8001ec1a:	91 10 00 27 	movh.a %a2,28673
8001ec1e:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001ec22:	14 22       	ld.bu %d2,[%a2]
8001ec24:	8f 22 00 21 	and %d2,%d2,2
8001ec28:	df 02 58 01 	jeq %d2,0,8001eed8 <tcp_process+0x51c>
          && (ackno == pcb->lastack + 1)) {
8001ec2c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ec30:	d9 22 08 10 	lea %a2,[%a2]72
8001ec34:	54 22       	ld.w %d2,[%a2]
8001ec36:	1b 12 00 30 	addi %d3,%d2,1
8001ec3a:	91 10 00 27 	movh.a %a2,28673
8001ec3e:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001ec42:	54 22       	ld.w %d2,[%a2]
8001ec44:	5f 23 4a 81 	jne %d3,%d2,8001eed8 <tcp_process+0x51c>
        pcb->rcv_nxt = seqno + 1;
8001ec48:	91 10 00 27 	movh.a %a2,28673
8001ec4c:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001ec50:	54 22       	ld.w %d2,[%a2]
8001ec52:	c2 12       	add %d2,1
8001ec54:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ec58:	d9 22 28 00 	lea %a2,[%a2]40
8001ec5c:	74 22       	st.w [%a2],%d2
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
8001ec5e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ec62:	d9 22 28 00 	lea %a2,[%a2]40
8001ec66:	54 22       	ld.w %d2,[%a2]
8001ec68:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ec6c:	d9 22 30 00 	lea %a2,[%a2]48
8001ec70:	74 22       	st.w [%a2],%d2
        pcb->lastack = ackno;
8001ec72:	91 10 00 27 	movh.a %a2,28673
8001ec76:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001ec7a:	54 22       	ld.w %d2,[%a2]
8001ec7c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145f0 <ackno>>
8001ec80:	d9 22 08 10 	lea %a2,[%a2]72 <700145f0 <ackno>>
8001ec84:	74 22       	st.w [%a2],%d2
        pcb->snd_wnd = tcphdr->wnd;
8001ec86:	91 10 00 27 	movh.a %a2,28673
8001ec8a:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001ec8e:	d4 22       	ld.a %a2,[%a2]
8001ec90:	39 23 0e 00 	ld.bu %d3,[%a2]14 <700145dc <tcphdr>>
8001ec94:	39 22 0f 00 	ld.bu %d2,[%a2]15 <700145dc <tcphdr>>
8001ec98:	8f 82 00 20 	sh %d2,%d2,8
8001ec9c:	a6 32       	or %d2,%d3
8001ec9e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001eca2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eca6:	f9 22 24 10 	st.h [%a2]100,%d2
        pcb->snd_wnd_max = pcb->snd_wnd;
8001ecaa:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ecae:	b9 22 24 10 	ld.hu %d2,[%a2]100
8001ecb2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ecb6:	f9 22 26 10 	st.h [%a2]102,%d2
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
8001ecba:	91 10 00 27 	movh.a %a2,28673
8001ecbe:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001ecc2:	54 22       	ld.w %d2,[%a2]
8001ecc4:	c2 f2       	add %d2,-1
8001ecc6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ecca:	d9 22 18 10 	lea %a2,[%a2]88
8001ecce:	74 22       	st.w [%a2],%d2
        pcb->state = ESTABLISHED;
8001ecd0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ecd4:	82 42       	mov %d2,4
8001ecd6:	d9 22 14 00 	lea %a2,[%a2]20
8001ecda:	74 22       	st.w [%a2],%d2

#if TCP_CALCULATE_EFF_SEND_MSS
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
8001ecdc:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ece0:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001ece4:	02 28       	mov %d8,%d2
8001ece6:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8001ecea:	c2 42       	add %d2,4
8001ecec:	60 24       	mov.a %a4,%d2
8001ecee:	6d ff ea b0 	call 80014ec2 <ip4_route>
8001ecf2:	80 22       	mov.d %d2,%a2
8001ecf4:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8001ecf8:	c2 43       	add %d3,4
8001ecfa:	60 35       	mov.a %a5,%d3
8001ecfc:	60 24       	mov.a %a4,%d2
8001ecfe:	02 84       	mov %d4,%d8
8001ed00:	6d ff 23 f2 	call 8001d146 <tcp_eff_send_mss_netif>
8001ed04:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ed08:	f9 22 36 00 	st.h [%a2]54,%d2
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
8001ed0c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ed10:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001ed14:	8f 22 00 30 	sh %d3,%d2,2
8001ed18:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ed1c:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001ed20:	06 12       	sh %d2,1
8001ed22:	3b c0 11 41 	mov %d4,4380
8001ed26:	0b 42 b0 21 	max.u %d2,%d2,%d4
8001ed2a:	7f 23 0b 80 	jge.u %d3,%d2,8001ed40 <tcp_process+0x384>
8001ed2e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ed32:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001ed36:	06 22       	sh %d2,2
8001ed38:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ed3c:	1d 00 16 00 	j 8001ed68 <tcp_process+0x3ac>
8001ed40:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ed44:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001ed48:	06 12       	sh %d2,1
8001ed4a:	3b d0 11 31 	mov %d3,4381
8001ed4e:	3f 32 0b 80 	jlt.u %d2,%d3,8001ed64 <tcp_process+0x3a8>
8001ed52:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ed56:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001ed5a:	06 12       	sh %d2,1
8001ed5c:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ed60:	1d 00 04 00 	j 8001ed68 <tcp_process+0x3ac>
8001ed64:	3b c0 11 21 	mov %d2,4380
8001ed68:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ed6c:	f9 22 0c 10 	st.h [%a2]76,%d2
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
8001ed70:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ed74:	b9 22 2a 10 	ld.hu %d2,[%a2]106
8001ed78:	df 02 17 80 	jne %d2,0,8001eda6 <tcp_process+0x3ea>
8001ed7c:	91 00 00 28 	movh.a %a2,32768
8001ed80:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001ed84:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001ed88:	3b c0 36 20 	mov %d2,876
8001ed8c:	59 a2 04 00 	st.w [%sp]4,%d2
8001ed90:	91 00 00 28 	movh.a %a2,32768
8001ed94:	d9 22 83 02 	lea %a2,[%a2]10243 <80002803 <IfxCpu_Trap_vectorTable0_end+0x260f>>
8001ed98:	f4 a2       	st.a [%sp],%a2
8001ed9a:	91 00 00 28 	movh.a %a2,32768
8001ed9e:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001eda2:	6d ff ca 32 	call 80005336 <Ifx_Lwip_printf>
        --pcb->snd_queuelen;
8001eda6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001edaa:	b9 22 2a 10 	ld.hu %d2,[%a2]106
8001edae:	c2 f2       	add %d2,-1
8001edb0:	37 02 70 20 	extr.u %d2,%d2,0,16
8001edb4:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001edb8:	f9 22 2a 10 	st.h [%a2]106,%d2
        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
        rseg = pcb->unacked;
8001edbc:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001edc0:	d9 22 34 10 	lea %a2,[%a2]116
8001edc4:	54 22       	ld.w %d2,[%a2]
8001edc6:	59 e2 f4 ff 	st.w [%a14]-12,%d2
        if (rseg == NULL) {
8001edca:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001edce:	df 02 2c 80 	jne %d2,0,8001ee26 <tcp_process+0x46a>
          /* might happen if tcp_output fails in tcp_rexmit_rto()
             in which case the segment is on the unsent list */
          rseg = pcb->unsent;
8001edd2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001edd6:	d9 22 30 10 	lea %a2,[%a2]112
8001edda:	54 22       	ld.w %d2,[%a2]
8001eddc:	59 e2 f4 ff 	st.w [%a14]-12,%d2
          LWIP_ASSERT("no segment to free", rseg != NULL);
8001ede0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001ede4:	df 02 17 80 	jne %d2,0,8001ee12 <tcp_process+0x456>
8001ede8:	91 00 00 28 	movh.a %a2,32768
8001edec:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001edf0:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001edf4:	3b 40 37 20 	mov %d2,884
8001edf8:	59 a2 04 00 	st.w [%sp]4,%d2
8001edfc:	91 00 00 28 	movh.a %a2,32768
8001ee00:	d9 22 99 02 	lea %a2,[%a2]10265 <80002819 <IfxCpu_Trap_vectorTable0_end+0x2625>>
8001ee04:	f4 a2       	st.a [%sp],%a2
8001ee06:	91 00 00 28 	movh.a %a2,32768
8001ee0a:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001ee0e:	6d ff 94 32 	call 80005336 <Ifx_Lwip_printf>
          pcb->unsent = rseg->next;
8001ee12:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ee16:	54 22       	ld.w %d2,[%a2]
8001ee18:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ee1c:	d9 22 30 10 	lea %a2,[%a2]112
8001ee20:	74 22       	st.w [%a2],%d2
8001ee22:	1d 00 0a 00 	j 8001ee36 <tcp_process+0x47a>
        } else {
          pcb->unacked = rseg->next;
8001ee26:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001ee2a:	54 22       	ld.w %d2,[%a2]
8001ee2c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ee30:	d9 22 34 10 	lea %a2,[%a2]116
8001ee34:	74 22       	st.w [%a2],%d2
        }
        tcp_seg_free(rseg);
8001ee36:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8001ee3a:	6d ff b9 eb 	call 8001c5ac <tcp_seg_free>

        /* If there's nothing left to acknowledge, stop the retransmit
           timer, otherwise reset it to start again */
        if (pcb->unacked == NULL) {
8001ee3e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ee42:	d9 22 34 10 	lea %a2,[%a2]116
8001ee46:	54 22       	ld.w %d2,[%a2]
8001ee48:	df 02 09 80 	jne %d2,0,8001ee5a <tcp_process+0x49e>
          pcb->rtime = -1;
8001ee4c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ee50:	82 f2       	mov %d2,-1
8001ee52:	f9 22 34 00 	st.h [%a2]52,%d2
8001ee56:	1d 00 0c 00 	j 8001ee6e <tcp_process+0x4b2>
        } else {
          pcb->rtime = 0;
8001ee5a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ee5e:	82 02       	mov %d2,0
8001ee60:	f9 22 34 00 	st.h [%a2]52,%d2
          pcb->nrtx = 0;
8001ee64:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ee68:	82 02       	mov %d2,0
8001ee6a:	e9 22 06 10 	st.b [%a2]70,%d2
        }

        /* Call the user specified function to call when successfully
         * connected. */
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
8001ee6e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ee72:	d9 22 0c 20 	lea %a2,[%a2]140
8001ee76:	54 22       	ld.w %d2,[%a2]
8001ee78:	df 02 16 00 	jeq %d2,0,8001eea4 <tcp_process+0x4e8>
8001ee7c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ee80:	d9 22 0c 20 	lea %a2,[%a2]140
8001ee84:	d4 22       	ld.a %a2,[%a2]
8001ee86:	99 e3 e4 ff 	ld.a %a3,[%a14]-28
8001ee8a:	d9 33 10 00 	lea %a3,[%a3]16
8001ee8e:	54 32       	ld.w %d2,[%a3]
8001ee90:	82 04       	mov %d4,0
8001ee92:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
8001ee96:	60 24       	mov.a %a4,%d2
8001ee98:	2d 02 00 00 	calli %a2
8001ee9c:	e9 e2 fe ff 	st.b [%a14]-2,%d2
8001eea0:	1d 00 05 00 	j 8001eeaa <tcp_process+0x4ee>
8001eea4:	82 02       	mov %d2,0
8001eea6:	e9 e2 fe ff 	st.b [%a14]-2,%d2
        if (err == ERR_ABRT) {
8001eeaa:	79 e2 fe ff 	ld.b %d2,[%a14]-2
8001eeae:	8b 32 3f 22 	ne %d2,%d2,-13
8001eeb2:	df 02 05 80 	jne %d2,0,8001eebc <tcp_process+0x500>
          return ERR_ABRT;
8001eeb6:	3b 30 ff 2f 	mov %d2,-13
8001eeba:	00 90       	ret 
        }
        tcp_ack_now(pcb);
8001eebc:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eec0:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001eec4:	8f 22 40 21 	or %d2,%d2,2
8001eec8:	37 02 70 20 	extr.u %d2,%d2,0,16
8001eecc:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eed0:	f9 22 1e 00 	st.h [%a2]30,%d2
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
8001eed4:	1d 00 ed 03 	j 8001f6ae <tcp_process+0xcf2>
      else if (flags & TCP_ACK) {
8001eed8:	91 10 00 27 	movh.a %a2,28673
8001eedc:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001eee0:	14 22       	ld.bu %d2,[%a2]
8001eee2:	8f 02 01 21 	and %d2,%d2,16
8001eee6:	df 02 e4 03 	jeq %d2,0,8001f6ae <tcp_process+0xcf2>
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001eeea:	91 10 00 27 	movh.a %a2,28673
8001eeee:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001eef2:	54 24       	ld.w %d4,[%a2]
8001eef4:	91 10 00 27 	movh.a %a2,28673
8001eef8:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001eefc:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001ef00:	02 23       	mov %d3,%d2
8001ef02:	91 10 00 27 	movh.a %a2,28673
8001ef06:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001ef0a:	54 22       	ld.w %d2,[%a2]
8001ef0c:	0b 23 00 50 	add %d5,%d3,%d2
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001ef10:	91 10 00 27 	movh.a %a2,28673
8001ef14:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001ef18:	d4 22       	ld.a %a2,[%a2]
8001ef1a:	39 23 02 00 	ld.bu %d3,[%a2]2 <700145dc <tcphdr>>
8001ef1e:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001ef22:	8f 82 00 20 	sh %d2,%d2,8
8001ef26:	a6 32       	or %d2,%d3
8001ef28:	37 02 70 20 	extr.u %d2,%d2,0,16
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001ef2c:	02 26       	mov %d6,%d2
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001ef2e:	91 10 00 27 	movh.a %a2,28673
8001ef32:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001ef36:	d4 22       	ld.a %a2,[%a2]
8001ef38:	14 23       	ld.bu %d3,[%a2]
8001ef3a:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001ef3e:	8f 82 00 20 	sh %d2,%d2,8
8001ef42:	a6 32       	or %d2,%d3
8001ef44:	37 02 70 20 	extr.u %d2,%d2,0,16
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001ef48:	02 27       	mov %d7,%d2
8001ef4a:	91 10 00 27 	movh.a %a2,28673
8001ef4e:	d9 26 0c 2b 	lea %a6,[%a2]-20340 <7000b08c <ip_data+0x10>>
8001ef52:	91 10 00 27 	movh.a %a2,28673
8001ef56:	d9 25 10 2b 	lea %a5,[%a2]-20336 <7000b090 <ip_data+0x14>>
8001ef5a:	99 e4 e4 ff 	ld.a %a4,[%a14]-28 <7000b090 <ip_data+0x14>>
8001ef5e:	6d 00 6f 2c 	call 8002483c <tcp_rst>
        if (pcb->nrtx < TCP_SYNMAXRTX) {
8001ef62:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ef66:	39 22 06 10 	ld.bu %d2,[%a2]70
8001ef6a:	ff 62 a2 83 	jge.u %d2,6,8001f6ae <tcp_process+0xcf2>
          pcb->rtime = 0;
8001ef6e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001ef72:	82 02       	mov %d2,0
8001ef74:	f9 22 34 00 	st.h [%a2]52,%d2
          tcp_rexmit_rto(pcb);
8001ef78:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001ef7c:	6d 00 86 28 	call 80024088 <tcp_rexmit_rto>
      break;
8001ef80:	1d 00 97 03 	j 8001f6ae <tcp_process+0xcf2>
    case SYN_RCVD:
      if (flags & TCP_ACK) {
8001ef84:	91 10 00 27 	movh.a %a2,28673
8001ef88:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001ef8c:	14 22       	ld.bu %d2,[%a2]
8001ef8e:	8f 02 01 21 	and %d2,%d2,16
8001ef92:	df 02 2d 01 	jeq %d2,0,8001f1ec <tcp_process+0x830>
        /* expected ACK number? */
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
8001ef96:	91 10 00 27 	movh.a %a2,28673
8001ef9a:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001ef9e:	54 23       	ld.w %d3,[%a2]
8001efa0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145f0 <ackno>>
8001efa4:	d9 22 08 10 	lea %a2,[%a2]72 <700145f0 <ackno>>
8001efa8:	54 22       	ld.w %d2,[%a2]
8001efaa:	0b 23 80 20 	sub %d2,%d3,%d2
8001efae:	c2 f2       	add %d2,-1
8001efb0:	bf 02 e0 00 	jlt %d2,0,8001f170 <tcp_process+0x7b4>
8001efb4:	91 10 00 27 	movh.a %a2,28673
8001efb8:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001efbc:	54 23       	ld.w %d3,[%a2]
8001efbe:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145f0 <ackno>>
8001efc2:	d9 22 14 10 	lea %a2,[%a2]84 <700145f0 <ackno>>
8001efc6:	54 22       	ld.w %d2,[%a2]
8001efc8:	0b 23 80 20 	sub %d2,%d3,%d2
8001efcc:	ff 12 d2 00 	jge %d2,1,8001f170 <tcp_process+0x7b4>
          pcb->state = ESTABLISHED;
8001efd0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001efd4:	82 42       	mov %d2,4
8001efd6:	d9 22 14 00 	lea %a2,[%a2]20
8001efda:	74 22       	st.w [%a2],%d2
          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
          if (pcb->listener == NULL) {
8001efdc:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001efe0:	d9 22 00 20 	lea %a2,[%a2]128
8001efe4:	54 22       	ld.w %d2,[%a2]
8001efe6:	df 02 07 80 	jne %d2,0,8001eff4 <tcp_process+0x638>
            /* listen pcb might be closed by now */
            err = ERR_VAL;
8001efea:	82 a2       	mov %d2,-6
8001efec:	e9 e2 fe ff 	st.b [%a14]-2,%d2
8001eff0:	1d 00 46 00 	j 8001f07c <tcp_process+0x6c0>
          } else
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
          {
#if LWIP_CALLBACK_API
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
8001eff4:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001eff8:	d9 22 00 20 	lea %a2,[%a2]128
8001effc:	d4 22       	ld.a %a2,[%a2]
8001effe:	d9 22 1c 00 	lea %a2,[%a2]28
8001f002:	54 22       	ld.w %d2,[%a2]
8001f004:	df 02 17 80 	jne %d2,0,8001f032 <tcp_process+0x676>
8001f008:	91 00 00 28 	movh.a %a2,32768
8001f00c:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001f010:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001f014:	3b 80 3a 20 	mov %d2,936
8001f018:	59 a2 04 00 	st.w [%sp]4,%d2
8001f01c:	91 00 00 28 	movh.a %a2,32768
8001f020:	d9 22 ac 02 	lea %a2,[%a2]10284 <8000282c <IfxCpu_Trap_vectorTable0_end+0x2638>>
8001f024:	f4 a2       	st.a [%sp],%a2
8001f026:	91 00 00 28 	movh.a %a2,32768
8001f02a:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001f02e:	6d ff 84 31 	call 80005336 <Ifx_Lwip_printf>
#endif
            tcp_backlog_accepted(pcb);
            /* Call the accept function. */
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
8001f032:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f036:	d9 22 00 20 	lea %a2,[%a2]128
8001f03a:	d4 22       	ld.a %a2,[%a2]
8001f03c:	d9 22 1c 00 	lea %a2,[%a2]28
8001f040:	54 22       	ld.w %d2,[%a2]
8001f042:	df 02 19 00 	jeq %d2,0,8001f074 <tcp_process+0x6b8>
8001f046:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f04a:	d9 22 00 20 	lea %a2,[%a2]128
8001f04e:	d4 22       	ld.a %a2,[%a2]
8001f050:	d9 22 1c 00 	lea %a2,[%a2]28
8001f054:	d4 22       	ld.a %a2,[%a2]
8001f056:	99 e3 e4 ff 	ld.a %a3,[%a14]-28
8001f05a:	d9 33 10 00 	lea %a3,[%a3]16
8001f05e:	54 32       	ld.w %d2,[%a3]
8001f060:	82 04       	mov %d4,0
8001f062:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
8001f066:	60 24       	mov.a %a4,%d2
8001f068:	2d 02 00 00 	calli %a2
8001f06c:	e9 e2 fe ff 	st.b [%a14]-2,%d2
8001f070:	1d 00 06 00 	j 8001f07c <tcp_process+0x6c0>
8001f074:	3b 00 ff 2f 	mov %d2,-16
8001f078:	e9 e2 fe ff 	st.b [%a14]-2,%d2
          }
          if (err != ERR_OK) {
8001f07c:	79 e2 fe ff 	ld.b %d2,[%a14]-2
8001f080:	df 02 0f 00 	jeq %d2,0,8001f09e <tcp_process+0x6e2>
            /* If the accept function returns with an error, we abort
             * the connection. */
            /* Already aborted? */
            if (err != ERR_ABRT) {
8001f084:	79 e2 fe ff 	ld.b %d2,[%a14]-2
8001f088:	8b 32 1f 22 	eq %d2,%d2,-13
8001f08c:	df 02 06 80 	jne %d2,0,8001f098 <tcp_process+0x6dc>
              tcp_abort(pcb);
8001f090:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f094:	6d ff 38 e0 	call 8001b104 <tcp_abort>
            }
            return ERR_ABRT;
8001f098:	3b 30 ff 2f 	mov %d2,-13
8001f09c:	00 90       	ret 
          }
          /* If there was any data contained within this ACK,
           * we'd better pass it on to the application as well. */
          tcp_receive(pcb);
8001f09e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f0a2:	6d 00 08 05 	call 8001fab2 <tcp_receive>

          /* Prevent ACK for SYN to generate a sent event */
          if (recv_acked != 0) {
8001f0a6:	91 10 00 27 	movh.a %a2,28673
8001f0aa:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001f0ae:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001f0b2:	df 02 10 00 	jeq %d2,0,8001f0d2 <tcp_process+0x716>
            recv_acked--;
8001f0b6:	91 10 00 27 	movh.a %a2,28673
8001f0ba:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001f0be:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001f0c2:	c2 f2       	add %d2,-1
8001f0c4:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f0c8:	91 10 00 27 	movh.a %a2,28673
8001f0cc:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001f0d0:	b4 22       	st.h [%a2],%d2
          }

          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
8001f0d2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145f4 <recv_acked>>
8001f0d6:	b9 22 36 00 	ld.hu %d2,[%a2]54 <700145f4 <recv_acked>>
8001f0da:	8f 22 00 30 	sh %d3,%d2,2
8001f0de:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f0e2:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001f0e6:	06 12       	sh %d2,1
8001f0e8:	3b c0 11 41 	mov %d4,4380
8001f0ec:	0b 42 b0 21 	max.u %d2,%d2,%d4
8001f0f0:	7f 23 0b 80 	jge.u %d3,%d2,8001f106 <tcp_process+0x74a>
8001f0f4:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f0f8:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001f0fc:	06 22       	sh %d2,2
8001f0fe:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f102:	1d 00 16 00 	j 8001f12e <tcp_process+0x772>
8001f106:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f10a:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001f10e:	06 12       	sh %d2,1
8001f110:	3b d0 11 31 	mov %d3,4381
8001f114:	3f 32 0b 80 	jlt.u %d2,%d3,8001f12a <tcp_process+0x76e>
8001f118:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f11c:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001f120:	06 12       	sh %d2,1
8001f122:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f126:	1d 00 04 00 	j 8001f12e <tcp_process+0x772>
8001f12a:	3b c0 11 21 	mov %d2,4380
8001f12e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f132:	f9 22 0c 10 	st.h [%a2]76,%d2
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
8001f136:	91 10 00 27 	movh.a %a2,28673
8001f13a:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001f13e:	14 22       	ld.bu %d2,[%a2]
8001f140:	8f 02 02 21 	and %d2,%d2,32
8001f144:	df 02 71 00 	jeq %d2,0,8001f226 <tcp_process+0x86a>
            tcp_ack_now(pcb);
8001f148:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f14c:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001f150:	8f 22 40 21 	or %d2,%d2,2
8001f154:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f158:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f15c:	f9 22 1e 00 	st.h [%a2]30,%d2
            pcb->state = CLOSE_WAIT;
8001f160:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f164:	82 72       	mov %d2,7
8001f166:	d9 22 14 00 	lea %a2,[%a2]20
8001f16a:	74 22       	st.w [%a2],%d2
          if (recv_flags & TF_GOT_FIN) {
8001f16c:	1d 00 5d 00 	j 8001f226 <tcp_process+0x86a>
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001f170:	91 10 00 27 	movh.a %a2,28673
8001f174:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001f178:	54 24       	ld.w %d4,[%a2]
8001f17a:	91 10 00 27 	movh.a %a2,28673
8001f17e:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001f182:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001f186:	02 23       	mov %d3,%d2
8001f188:	91 10 00 27 	movh.a %a2,28673
8001f18c:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001f190:	54 22       	ld.w %d2,[%a2]
8001f192:	0b 23 00 50 	add %d5,%d3,%d2
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001f196:	91 10 00 27 	movh.a %a2,28673
8001f19a:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001f19e:	d4 22       	ld.a %a2,[%a2]
8001f1a0:	39 23 02 00 	ld.bu %d3,[%a2]2 <700145dc <tcphdr>>
8001f1a4:	39 22 03 00 	ld.bu %d2,[%a2]3 <700145dc <tcphdr>>
8001f1a8:	8f 82 00 20 	sh %d2,%d2,8
8001f1ac:	a6 32       	or %d2,%d3
8001f1ae:	37 02 70 20 	extr.u %d2,%d2,0,16
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001f1b2:	02 26       	mov %d6,%d2
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
8001f1b4:	91 10 00 27 	movh.a %a2,28673
8001f1b8:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001f1bc:	d4 22       	ld.a %a2,[%a2]
8001f1be:	14 23       	ld.bu %d3,[%a2]
8001f1c0:	39 22 01 00 	ld.bu %d2,[%a2]1 <700145dc <tcphdr>>
8001f1c4:	8f 82 00 20 	sh %d2,%d2,8
8001f1c8:	a6 32       	or %d2,%d3
8001f1ca:	37 02 70 20 	extr.u %d2,%d2,0,16
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
8001f1ce:	02 27       	mov %d7,%d2
8001f1d0:	91 10 00 27 	movh.a %a2,28673
8001f1d4:	d9 26 0c 2b 	lea %a6,[%a2]-20340 <7000b08c <ip_data+0x10>>
8001f1d8:	91 10 00 27 	movh.a %a2,28673
8001f1dc:	d9 25 10 2b 	lea %a5,[%a2]-20336 <7000b090 <ip_data+0x14>>
8001f1e0:	99 e4 e4 ff 	ld.a %a4,[%a14]-28 <7000b090 <ip_data+0x14>>
8001f1e4:	6d 00 2c 2b 	call 8002483c <tcp_rst>
        }
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
        /* Looks like another copy of the SYN - retransmit our SYN-ACK */
        tcp_rexmit(pcb);
      }
      break;
8001f1e8:	1d 00 66 02 	j 8001f6b4 <tcp_process+0xcf8>
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
8001f1ec:	91 10 00 27 	movh.a %a2,28673
8001f1f0:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001f1f4:	14 22       	ld.bu %d2,[%a2]
8001f1f6:	8f 22 00 21 	and %d2,%d2,2
8001f1fa:	df 02 5d 02 	jeq %d2,0,8001f6b4 <tcp_process+0xcf8>
8001f1fe:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f202:	d9 22 28 00 	lea %a2,[%a2]40
8001f206:	54 22       	ld.w %d2,[%a2]
8001f208:	1b f2 ff 3f 	addi %d3,%d2,-1
8001f20c:	91 10 00 27 	movh.a %a2,28673
8001f210:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001f214:	54 22       	ld.w %d2,[%a2]
8001f216:	5f 23 4f 82 	jne %d3,%d2,8001f6b4 <tcp_process+0xcf8>
        tcp_rexmit(pcb);
8001f21a:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f21e:	6d 00 5e 27 	call 800240da <tcp_rexmit>
      break;
8001f222:	1d 00 49 02 	j 8001f6b4 <tcp_process+0xcf8>
8001f226:	1d 00 47 02 	j 8001f6b4 <tcp_process+0xcf8>
    case CLOSE_WAIT:
    /* FALLTHROUGH */
    case ESTABLISHED:
      tcp_receive(pcb);
8001f22a:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f22e:	6d 00 42 04 	call 8001fab2 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) { /* passive close */
8001f232:	91 10 00 27 	movh.a %a2,28673
8001f236:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001f23a:	14 22       	ld.bu %d2,[%a2]
8001f23c:	8f 02 02 21 	and %d2,%d2,32
8001f240:	df 02 3d 02 	jeq %d2,0,8001f6ba <tcp_process+0xcfe>
        tcp_ack_now(pcb);
8001f244:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f248:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001f24c:	8f 22 40 21 	or %d2,%d2,2
8001f250:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f254:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f258:	f9 22 1e 00 	st.h [%a2]30,%d2
        pcb->state = CLOSE_WAIT;
8001f25c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f260:	82 72       	mov %d2,7
8001f262:	d9 22 14 00 	lea %a2,[%a2]20
8001f266:	74 22       	st.w [%a2],%d2
      }
      break;
8001f268:	1d 00 29 02 	j 8001f6ba <tcp_process+0xcfe>
    case FIN_WAIT_1:
      tcp_receive(pcb);
8001f26c:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f270:	6d 00 21 04 	call 8001fab2 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
8001f274:	91 10 00 27 	movh.a %a2,28673
8001f278:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001f27c:	14 22       	ld.bu %d2,[%a2]
8001f27e:	8f 02 02 21 	and %d2,%d2,32
8001f282:	df 02 ac 00 	jeq %d2,0,8001f3da <tcp_process+0xa1e>
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
8001f286:	91 10 00 27 	movh.a %a2,28673
8001f28a:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001f28e:	14 22       	ld.bu %d2,[%a2]
8001f290:	8f 02 01 21 	and %d2,%d2,16
8001f294:	df 02 8e 00 	jeq %d2,0,8001f3b0 <tcp_process+0x9f4>
8001f298:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f29c:	d9 22 14 10 	lea %a2,[%a2]84
8001f2a0:	54 23       	ld.w %d3,[%a2]
8001f2a2:	91 10 00 27 	movh.a %a2,28673
8001f2a6:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001f2aa:	54 22       	ld.w %d2,[%a2]
8001f2ac:	5f 23 82 80 	jne %d3,%d2,8001f3b0 <tcp_process+0x9f4>
            pcb->unsent == NULL) {
8001f2b0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f2b4:	d9 22 30 10 	lea %a2,[%a2]112
8001f2b8:	54 22       	ld.w %d2,[%a2]
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
8001f2ba:	df 02 7b 80 	jne %d2,0,8001f3b0 <tcp_process+0x9f4>
          LWIP_DEBUGF(TCP_DEBUG,
                      ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
          tcp_ack_now(pcb);
8001f2be:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f2c2:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001f2c6:	8f 22 40 21 	or %d2,%d2,2
8001f2ca:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f2ce:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f2d2:	f9 22 1e 00 	st.h [%a2]30,%d2
          tcp_pcb_purge(pcb);
8001f2d6:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f2da:	6d ff 78 ed 	call 8001cdca <tcp_pcb_purge>
          TCP_RMV_ACTIVE(pcb);
8001f2de:	91 10 00 27 	movh.a %a2,28673
8001f2e2:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f2e6:	54 22       	ld.w %d2,[%a2]
8001f2e8:	19 e3 e4 ff 	ld.w %d3,[%a14]-28 <700145bc <tcp_active_pcbs>>
8001f2ec:	5f 23 11 80 	jne %d3,%d2,8001f30e <tcp_process+0x952>
8001f2f0:	91 10 00 27 	movh.a %a2,28673
8001f2f4:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f2f8:	d4 22       	ld.a %a2,[%a2]
8001f2fa:	d9 22 0c 00 	lea %a2,[%a2]12 <700145bc <tcp_active_pcbs>>
8001f2fe:	54 22       	ld.w %d2,[%a2]
8001f300:	91 10 00 27 	movh.a %a2,28673
8001f304:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f308:	74 22       	st.w [%a2],%d2
8001f30a:	1d 00 2b 00 	j 8001f360 <tcp_process+0x9a4>
8001f30e:	91 10 00 27 	movh.a %a2,28673
8001f312:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f316:	54 22       	ld.w %d2,[%a2]
8001f318:	59 e2 f0 ff 	st.w [%a14]-16 <700145bc <tcp_active_pcbs>>,%d2
8001f31c:	1d 00 1e 00 	j 8001f358 <tcp_process+0x99c>
8001f320:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f324:	d9 22 0c 00 	lea %a2,[%a2]12
8001f328:	54 22       	ld.w %d2,[%a2]
8001f32a:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8001f32e:	5f 23 0e 80 	jne %d3,%d2,8001f34a <tcp_process+0x98e>
8001f332:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f336:	d9 22 0c 00 	lea %a2,[%a2]12
8001f33a:	54 22       	ld.w %d2,[%a2]
8001f33c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f340:	d9 22 0c 00 	lea %a2,[%a2]12
8001f344:	74 22       	st.w [%a2],%d2
8001f346:	1d 00 0d 00 	j 8001f360 <tcp_process+0x9a4>
8001f34a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f34e:	d9 22 0c 00 	lea %a2,[%a2]12
8001f352:	54 22       	ld.w %d2,[%a2]
8001f354:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8001f358:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001f35c:	df 02 e2 ff 	jne %d2,0,8001f320 <tcp_process+0x964>
8001f360:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f364:	82 02       	mov %d2,0
8001f366:	d9 22 0c 00 	lea %a2,[%a2]12
8001f36a:	74 22       	st.w [%a2],%d2
8001f36c:	91 10 00 27 	movh.a %a2,28673
8001f370:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001f374:	82 12       	mov %d2,1
8001f376:	34 22       	st.b [%a2],%d2
          pcb->state = TIME_WAIT;
8001f378:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f37c:	3b a0 00 20 	mov %d2,10
8001f380:	d9 22 14 00 	lea %a2,[%a2]20
8001f384:	74 22       	st.w [%a2],%d2
          TCP_REG(&tcp_tw_pcbs, pcb);
8001f386:	91 10 00 27 	movh.a %a2,28673
8001f38a:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001f38e:	54 22       	ld.w %d2,[%a2]
8001f390:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145c0 <tcp_tw_pcbs>>
8001f394:	d9 22 0c 00 	lea %a2,[%a2]12 <700145c0 <tcp_tw_pcbs>>
8001f398:	74 22       	st.w [%a2],%d2
8001f39a:	91 10 00 27 	movh.a %a2,28673
8001f39e:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001f3a2:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <700145c0 <tcp_tw_pcbs>>
8001f3a6:	74 22       	st.w [%a2],%d2
8001f3a8:	6d 00 10 2d 	call 80024dc8 <tcp_timer_needed>
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
8001f3ac:	1d 00 8a 01 	j 8001f6c0 <tcp_process+0xd04>
          tcp_ack_now(pcb);
8001f3b0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f3b4:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001f3b8:	8f 22 40 21 	or %d2,%d2,2
8001f3bc:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f3c0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f3c4:	f9 22 1e 00 	st.h [%a2]30,%d2
          pcb->state = CLOSING;
8001f3c8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f3cc:	3b 80 00 20 	mov %d2,8
8001f3d0:	d9 22 14 00 	lea %a2,[%a2]20
8001f3d4:	74 22       	st.w [%a2],%d2
      break;
8001f3d6:	1d 00 75 01 	j 8001f6c0 <tcp_process+0xd04>
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
8001f3da:	91 10 00 27 	movh.a %a2,28673
8001f3de:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001f3e2:	14 22       	ld.bu %d2,[%a2]
8001f3e4:	8f 02 01 21 	and %d2,%d2,16
8001f3e8:	df 02 6c 01 	jeq %d2,0,8001f6c0 <tcp_process+0xd04>
8001f3ec:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f3f0:	d9 22 14 10 	lea %a2,[%a2]84
8001f3f4:	54 23       	ld.w %d3,[%a2]
8001f3f6:	91 10 00 27 	movh.a %a2,28673
8001f3fa:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001f3fe:	54 22       	ld.w %d2,[%a2]
8001f400:	5f 23 60 81 	jne %d3,%d2,8001f6c0 <tcp_process+0xd04>
                 pcb->unsent == NULL) {
8001f404:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f408:	d9 22 30 10 	lea %a2,[%a2]112
8001f40c:	54 22       	ld.w %d2,[%a2]
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
8001f40e:	df 02 59 81 	jne %d2,0,8001f6c0 <tcp_process+0xd04>
        pcb->state = FIN_WAIT_2;
8001f412:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f416:	82 62       	mov %d2,6
8001f418:	d9 22 14 00 	lea %a2,[%a2]20
8001f41c:	74 22       	st.w [%a2],%d2
      break;
8001f41e:	1d 00 51 01 	j 8001f6c0 <tcp_process+0xd04>
    case FIN_WAIT_2:
      tcp_receive(pcb);
8001f422:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f426:	6d 00 46 03 	call 8001fab2 <tcp_receive>
      if (recv_flags & TF_GOT_FIN) {
8001f42a:	91 10 00 27 	movh.a %a2,28673
8001f42e:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001f432:	14 22       	ld.bu %d2,[%a2]
8001f434:	8f 02 02 21 	and %d2,%d2,32
8001f438:	df 02 47 01 	jeq %d2,0,8001f6c6 <tcp_process+0xd0a>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
8001f43c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f440:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001f444:	8f 22 40 21 	or %d2,%d2,2
8001f448:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f44c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f450:	f9 22 1e 00 	st.h [%a2]30,%d2
        tcp_pcb_purge(pcb);
8001f454:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f458:	6d ff b9 ec 	call 8001cdca <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
8001f45c:	91 10 00 27 	movh.a %a2,28673
8001f460:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f464:	54 22       	ld.w %d2,[%a2]
8001f466:	19 e3 e4 ff 	ld.w %d3,[%a14]-28 <700145bc <tcp_active_pcbs>>
8001f46a:	5f 23 11 80 	jne %d3,%d2,8001f48c <tcp_process+0xad0>
8001f46e:	91 10 00 27 	movh.a %a2,28673
8001f472:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f476:	d4 22       	ld.a %a2,[%a2]
8001f478:	d9 22 0c 00 	lea %a2,[%a2]12 <700145bc <tcp_active_pcbs>>
8001f47c:	54 22       	ld.w %d2,[%a2]
8001f47e:	91 10 00 27 	movh.a %a2,28673
8001f482:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f486:	74 22       	st.w [%a2],%d2
8001f488:	1d 00 2b 00 	j 8001f4de <tcp_process+0xb22>
8001f48c:	91 10 00 27 	movh.a %a2,28673
8001f490:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f494:	54 22       	ld.w %d2,[%a2]
8001f496:	59 e2 ec ff 	st.w [%a14]-20 <700145bc <tcp_active_pcbs>>,%d2
8001f49a:	1d 00 1e 00 	j 8001f4d6 <tcp_process+0xb1a>
8001f49e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001f4a2:	d9 22 0c 00 	lea %a2,[%a2]12
8001f4a6:	54 22       	ld.w %d2,[%a2]
8001f4a8:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8001f4ac:	5f 23 0e 80 	jne %d3,%d2,8001f4c8 <tcp_process+0xb0c>
8001f4b0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f4b4:	d9 22 0c 00 	lea %a2,[%a2]12
8001f4b8:	54 22       	ld.w %d2,[%a2]
8001f4ba:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001f4be:	d9 22 0c 00 	lea %a2,[%a2]12
8001f4c2:	74 22       	st.w [%a2],%d2
8001f4c4:	1d 00 0d 00 	j 8001f4de <tcp_process+0xb22>
8001f4c8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8001f4cc:	d9 22 0c 00 	lea %a2,[%a2]12
8001f4d0:	54 22       	ld.w %d2,[%a2]
8001f4d2:	59 e2 ec ff 	st.w [%a14]-20,%d2
8001f4d6:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8001f4da:	df 02 e2 ff 	jne %d2,0,8001f49e <tcp_process+0xae2>
8001f4de:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f4e2:	82 02       	mov %d2,0
8001f4e4:	d9 22 0c 00 	lea %a2,[%a2]12
8001f4e8:	74 22       	st.w [%a2],%d2
8001f4ea:	91 10 00 27 	movh.a %a2,28673
8001f4ee:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001f4f2:	82 12       	mov %d2,1
8001f4f4:	34 22       	st.b [%a2],%d2
        pcb->state = TIME_WAIT;
8001f4f6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f4fa:	3b a0 00 20 	mov %d2,10
8001f4fe:	d9 22 14 00 	lea %a2,[%a2]20
8001f502:	74 22       	st.w [%a2],%d2
        TCP_REG(&tcp_tw_pcbs, pcb);
8001f504:	91 10 00 27 	movh.a %a2,28673
8001f508:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001f50c:	54 22       	ld.w %d2,[%a2]
8001f50e:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145c0 <tcp_tw_pcbs>>
8001f512:	d9 22 0c 00 	lea %a2,[%a2]12 <700145c0 <tcp_tw_pcbs>>
8001f516:	74 22       	st.w [%a2],%d2
8001f518:	91 10 00 27 	movh.a %a2,28673
8001f51c:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001f520:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <700145c0 <tcp_tw_pcbs>>
8001f524:	74 22       	st.w [%a2],%d2
8001f526:	6d 00 51 2c 	call 80024dc8 <tcp_timer_needed>
      }
      break;
8001f52a:	1d 00 ce 00 	j 8001f6c6 <tcp_process+0xd0a>
    case CLOSING:
      tcp_receive(pcb);
8001f52e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f532:	6d 00 c0 02 	call 8001fab2 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
8001f536:	91 10 00 27 	movh.a %a2,28673
8001f53a:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001f53e:	14 22       	ld.bu %d2,[%a2]
8001f540:	8f 02 01 21 	and %d2,%d2,16
8001f544:	df 02 c4 00 	jeq %d2,0,8001f6cc <tcp_process+0xd10>
8001f548:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f54c:	d9 22 14 10 	lea %a2,[%a2]84
8001f550:	54 23       	ld.w %d3,[%a2]
8001f552:	91 10 00 27 	movh.a %a2,28673
8001f556:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001f55a:	54 22       	ld.w %d2,[%a2]
8001f55c:	5f 23 b8 80 	jne %d3,%d2,8001f6cc <tcp_process+0xd10>
8001f560:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f564:	d9 22 30 10 	lea %a2,[%a2]112
8001f568:	54 22       	ld.w %d2,[%a2]
8001f56a:	df 02 b1 80 	jne %d2,0,8001f6cc <tcp_process+0xd10>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_pcb_purge(pcb);
8001f56e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f572:	6d ff 2c ec 	call 8001cdca <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
8001f576:	91 10 00 27 	movh.a %a2,28673
8001f57a:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f57e:	54 22       	ld.w %d2,[%a2]
8001f580:	19 e3 e4 ff 	ld.w %d3,[%a14]-28 <700145bc <tcp_active_pcbs>>
8001f584:	5f 23 11 80 	jne %d3,%d2,8001f5a6 <tcp_process+0xbea>
8001f588:	91 10 00 27 	movh.a %a2,28673
8001f58c:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f590:	d4 22       	ld.a %a2,[%a2]
8001f592:	d9 22 0c 00 	lea %a2,[%a2]12 <700145bc <tcp_active_pcbs>>
8001f596:	54 22       	ld.w %d2,[%a2]
8001f598:	91 10 00 27 	movh.a %a2,28673
8001f59c:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f5a0:	74 22       	st.w [%a2],%d2
8001f5a2:	1d 00 2b 00 	j 8001f5f8 <tcp_process+0xc3c>
8001f5a6:	91 10 00 27 	movh.a %a2,28673
8001f5aa:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
8001f5ae:	54 22       	ld.w %d2,[%a2]
8001f5b0:	59 e2 f8 ff 	st.w [%a14]-8 <700145bc <tcp_active_pcbs>>,%d2
8001f5b4:	1d 00 1e 00 	j 8001f5f0 <tcp_process+0xc34>
8001f5b8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001f5bc:	d9 22 0c 00 	lea %a2,[%a2]12
8001f5c0:	54 22       	ld.w %d2,[%a2]
8001f5c2:	19 e3 e4 ff 	ld.w %d3,[%a14]-28
8001f5c6:	5f 23 0e 80 	jne %d3,%d2,8001f5e2 <tcp_process+0xc26>
8001f5ca:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f5ce:	d9 22 0c 00 	lea %a2,[%a2]12
8001f5d2:	54 22       	ld.w %d2,[%a2]
8001f5d4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001f5d8:	d9 22 0c 00 	lea %a2,[%a2]12
8001f5dc:	74 22       	st.w [%a2],%d2
8001f5de:	1d 00 0d 00 	j 8001f5f8 <tcp_process+0xc3c>
8001f5e2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8001f5e6:	d9 22 0c 00 	lea %a2,[%a2]12
8001f5ea:	54 22       	ld.w %d2,[%a2]
8001f5ec:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8001f5f0:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001f5f4:	df 02 e2 ff 	jne %d2,0,8001f5b8 <tcp_process+0xbfc>
8001f5f8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f5fc:	82 02       	mov %d2,0
8001f5fe:	d9 22 0c 00 	lea %a2,[%a2]12
8001f602:	74 22       	st.w [%a2],%d2
8001f604:	91 10 00 27 	movh.a %a2,28673
8001f608:	d9 22 44 74 	lea %a2,[%a2]17860 <700145c4 <tcp_active_pcbs_changed>>
8001f60c:	82 12       	mov %d2,1
8001f60e:	34 22       	st.b [%a2],%d2
        pcb->state = TIME_WAIT;
8001f610:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f614:	3b a0 00 20 	mov %d2,10
8001f618:	d9 22 14 00 	lea %a2,[%a2]20
8001f61c:	74 22       	st.w [%a2],%d2
        TCP_REG(&tcp_tw_pcbs, pcb);
8001f61e:	91 10 00 27 	movh.a %a2,28673
8001f622:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001f626:	54 22       	ld.w %d2,[%a2]
8001f628:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145c0 <tcp_tw_pcbs>>
8001f62c:	d9 22 0c 00 	lea %a2,[%a2]12 <700145c0 <tcp_tw_pcbs>>
8001f630:	74 22       	st.w [%a2],%d2
8001f632:	91 10 00 27 	movh.a %a2,28673
8001f636:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
8001f63a:	19 e2 e4 ff 	ld.w %d2,[%a14]-28 <700145c0 <tcp_tw_pcbs>>
8001f63e:	74 22       	st.w [%a2],%d2
8001f640:	6d 00 c4 2b 	call 80024dc8 <tcp_timer_needed>
      }
      break;
8001f644:	1d 00 44 00 	j 8001f6cc <tcp_process+0xd10>
    case LAST_ACK:
      tcp_receive(pcb);
8001f648:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
8001f64c:	6d 00 33 02 	call 8001fab2 <tcp_receive>
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
8001f650:	91 10 00 27 	movh.a %a2,28673
8001f654:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001f658:	14 22       	ld.bu %d2,[%a2]
8001f65a:	8f 02 01 21 	and %d2,%d2,16
8001f65e:	df 02 3a 00 	jeq %d2,0,8001f6d2 <tcp_process+0xd16>
8001f662:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f666:	d9 22 14 10 	lea %a2,[%a2]84
8001f66a:	54 23       	ld.w %d3,[%a2]
8001f66c:	91 10 00 27 	movh.a %a2,28673
8001f670:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001f674:	54 22       	ld.w %d2,[%a2]
8001f676:	5f 23 2e 80 	jne %d3,%d2,8001f6d2 <tcp_process+0xd16>
8001f67a:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
8001f67e:	d9 22 30 10 	lea %a2,[%a2]112
8001f682:	54 22       	ld.w %d2,[%a2]
8001f684:	df 02 27 80 	jne %d2,0,8001f6d2 <tcp_process+0xd16>
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
8001f688:	91 10 00 27 	movh.a %a2,28673
8001f68c:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001f690:	14 22       	ld.bu %d2,[%a2]
8001f692:	8f 02 41 21 	or %d2,%d2,16
8001f696:	8f f2 0f 21 	and %d2,%d2,255
8001f69a:	91 10 00 27 	movh.a %a2,28673
8001f69e:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
8001f6a2:	34 22       	st.b [%a2],%d2
      }
      break;
8001f6a4:	1d 00 17 00 	j 8001f6d2 <tcp_process+0xd16>
    default:
      break;
8001f6a8:	00 00       	nop 
8001f6aa:	1d 00 15 00 	j 8001f6d4 <tcp_process+0xd18>
      break;
8001f6ae:	00 00       	nop 
8001f6b0:	1d 00 12 00 	j 8001f6d4 <tcp_process+0xd18>
      break;
8001f6b4:	00 00       	nop 
8001f6b6:	1d 00 0f 00 	j 8001f6d4 <tcp_process+0xd18>
      break;
8001f6ba:	00 00       	nop 
8001f6bc:	1d 00 0c 00 	j 8001f6d4 <tcp_process+0xd18>
      break;
8001f6c0:	00 00       	nop 
8001f6c2:	1d 00 09 00 	j 8001f6d4 <tcp_process+0xd18>
      break;
8001f6c6:	00 00       	nop 
8001f6c8:	1d 00 06 00 	j 8001f6d4 <tcp_process+0xd18>
      break;
8001f6cc:	00 00       	nop 
8001f6ce:	1d 00 03 00 	j 8001f6d4 <tcp_process+0xd18>
      break;
8001f6d2:	00 00       	nop 
  }
  return ERR_OK;
8001f6d4:	82 02       	mov %d2,0
}
8001f6d6:	00 90       	ret 

8001f6d8 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
8001f6d8:	40 ae       	mov.aa %a14,%sp
8001f6da:	20 20       	sub.a %sp,32
8001f6dc:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001f6e0:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct tcp_seg *old_seg;

  LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
8001f6e4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8001f6e8:	df 02 17 80 	jne %d2,0,8001f716 <tcp_oos_insert_segment+0x3e>
8001f6ec:	91 00 00 28 	movh.a %a2,32768
8001f6f0:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001f6f4:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001f6f8:	3b f0 41 20 	mov %d2,1055
8001f6fc:	59 a2 04 00 	st.w [%sp]4,%d2
8001f700:	91 00 00 28 	movh.a %a2,32768
8001f704:	d9 22 8a 12 	lea %a2,[%a2]10314 <8000284a <IfxCpu_Trap_vectorTable0_end+0x2656>>
8001f708:	f4 a2       	st.a [%sp],%a2
8001f70a:	91 00 00 28 	movh.a %a2,32768
8001f70e:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001f712:	6d ff 12 2e 	call 80005336 <Ifx_Lwip_printf>

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
8001f716:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f71a:	d9 22 10 00 	lea %a2,[%a2]16
8001f71e:	d4 22       	ld.a %a2,[%a2]
8001f720:	39 23 0c 00 	ld.bu %d3,[%a2]12
8001f724:	39 22 0d 00 	ld.bu %d2,[%a2]13
8001f728:	8f 82 00 20 	sh %d2,%d2,8
8001f72c:	a6 32       	or %d2,%d3
8001f72e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f732:	02 24       	mov %d4,%d2
8001f734:	6d ff 10 bf 	call 80017554 <lwip_htons>
8001f738:	8f f2 0f 21 	and %d2,%d2,255
8001f73c:	8f 12 00 21 	and %d2,%d2,1
8001f740:	df 02 55 00 	jeq %d2,0,8001f7ea <tcp_oos_insert_segment+0x112>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
8001f744:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
8001f748:	6d ff 18 e7 	call 8001c578 <tcp_segs_free>
    next = NULL;
8001f74c:	82 02       	mov %d2,0
8001f74e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
8001f752:	1d 00 d9 00 	j 8001f904 <tcp_oos_insert_segment+0x22c>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                       (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
8001f756:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f75a:	d9 22 10 00 	lea %a2,[%a2]16
8001f75e:	d4 22       	ld.a %a2,[%a2]
8001f760:	39 23 0c 00 	ld.bu %d3,[%a2]12
8001f764:	39 22 0d 00 	ld.bu %d2,[%a2]13
8001f768:	8f 82 00 20 	sh %d2,%d2,8
8001f76c:	a6 32       	or %d2,%d3
8001f76e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f772:	02 24       	mov %d4,%d2
8001f774:	6d ff f0 be 	call 80017554 <lwip_htons>
8001f778:	8f f2 0f 21 	and %d2,%d2,255
8001f77c:	8f 12 00 21 	and %d2,%d2,1
8001f780:	df 02 28 00 	jeq %d2,0,8001f7d0 <tcp_oos_insert_segment+0xf8>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
8001f784:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f788:	d9 22 10 00 	lea %a2,[%a2]16
8001f78c:	d4 22       	ld.a %a2,[%a2]
8001f78e:	39 23 0c 00 	ld.bu %d3,[%a2]12
8001f792:	39 22 0d 00 	ld.bu %d2,[%a2]13
8001f796:	8f 82 00 20 	sh %d2,%d2,8
8001f79a:	a6 32       	or %d2,%d3
8001f79c:	37 02 70 80 	extr.u %d8,%d2,0,16
8001f7a0:	82 14       	mov %d4,1
8001f7a2:	6d ff d9 be 	call 80017554 <lwip_htons>
8001f7a6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f7aa:	d9 22 10 00 	lea %a2,[%a2]16
8001f7ae:	d4 22       	ld.a %a2,[%a2]
8001f7b0:	a6 82       	or %d2,%d8
8001f7b2:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f7b6:	8f f2 0f 31 	and %d3,%d2,255
8001f7ba:	82 04       	mov %d4,0
8001f7bc:	a6 43       	or %d3,%d4
8001f7be:	e9 23 0c 00 	st.b [%a2]12,%d3
8001f7c2:	06 82       	sh %d2,-8
8001f7c4:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f7c8:	82 03       	mov %d3,0
8001f7ca:	a6 32       	or %d2,%d3
8001f7cc:	e9 22 0d 00 	st.b [%a2]13,%d2
      }
      old_seg = next;
8001f7d0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001f7d4:	59 e2 fc ff 	st.w [%a14]-4,%d2
      next = next->next;
8001f7d8:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f7dc:	54 22       	ld.w %d2,[%a2]
8001f7de:	59 e2 f0 ff 	st.w [%a14]-16,%d2
      tcp_seg_free(old_seg);
8001f7e2:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8001f7e6:	6d ff e3 e6 	call 8001c5ac <tcp_seg_free>
    while (next &&
8001f7ea:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001f7ee:	df 02 2e 00 	jeq %d2,0,8001f84a <tcp_oos_insert_segment+0x172>
           TCP_SEQ_GEQ((seqno + cseg->len),
8001f7f2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f7f6:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001f7fa:	02 23       	mov %d3,%d2
8001f7fc:	91 10 00 27 	movh.a %a2,28673
8001f800:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001f804:	54 22       	ld.w %d2,[%a2]
8001f806:	0b 23 00 40 	add %d4,%d3,%d2
8001f80a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f80e:	d9 22 10 00 	lea %a2,[%a2]16
8001f812:	d4 22       	ld.a %a2,[%a2]
8001f814:	39 23 04 00 	ld.bu %d3,[%a2]4
8001f818:	39 22 05 00 	ld.bu %d2,[%a2]5
8001f81c:	8f 82 00 20 	sh %d2,%d2,8
8001f820:	a6 32       	or %d2,%d3
8001f822:	39 23 06 00 	ld.bu %d3,[%a2]6
8001f826:	8f 03 01 30 	sh %d3,%d3,16
8001f82a:	a6 32       	or %d2,%d3
8001f82c:	39 23 07 00 	ld.bu %d3,[%a2]7
8001f830:	8f 83 01 30 	sh %d3,%d3,24
8001f834:	a6 32       	or %d2,%d3
8001f836:	02 23       	mov %d3,%d2
8001f838:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f83c:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001f840:	42 32       	add %d2,%d3
8001f842:	0b 24 80 20 	sub %d2,%d4,%d2
    while (next &&
8001f846:	ff 02 88 7f 	jge %d2,0,8001f756 <tcp_oos_insert_segment+0x7e>
    }
    if (next &&
8001f84a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001f84e:	df 02 5b 00 	jeq %d2,0,8001f904 <tcp_oos_insert_segment+0x22c>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
8001f852:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f856:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001f85a:	02 23       	mov %d3,%d2
8001f85c:	91 10 00 27 	movh.a %a2,28673
8001f860:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001f864:	54 22       	ld.w %d2,[%a2]
8001f866:	0b 23 00 40 	add %d4,%d3,%d2
8001f86a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f86e:	d9 22 10 00 	lea %a2,[%a2]16
8001f872:	d4 22       	ld.a %a2,[%a2]
8001f874:	39 23 04 00 	ld.bu %d3,[%a2]4
8001f878:	39 22 05 00 	ld.bu %d2,[%a2]5
8001f87c:	8f 82 00 20 	sh %d2,%d2,8
8001f880:	a6 32       	or %d2,%d3
8001f882:	39 23 06 00 	ld.bu %d3,[%a2]6
8001f886:	8f 03 01 30 	sh %d3,%d3,16
8001f88a:	a6 32       	or %d2,%d3
8001f88c:	39 23 07 00 	ld.bu %d3,[%a2]7
8001f890:	8f 83 01 30 	sh %d3,%d3,24
8001f894:	a6 32       	or %d2,%d3
8001f896:	0b 24 80 20 	sub %d2,%d4,%d2
    if (next &&
8001f89a:	bf 12 35 00 	jlt %d2,1,8001f904 <tcp_oos_insert_segment+0x22c>
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
8001f89e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f8a2:	d9 22 10 00 	lea %a2,[%a2]16
8001f8a6:	d4 22       	ld.a %a2,[%a2]
8001f8a8:	39 23 04 00 	ld.bu %d3,[%a2]4
8001f8ac:	39 22 05 00 	ld.bu %d2,[%a2]5
8001f8b0:	8f 82 00 20 	sh %d2,%d2,8
8001f8b4:	a6 32       	or %d2,%d3
8001f8b6:	39 23 06 00 	ld.bu %d3,[%a2]6
8001f8ba:	8f 03 01 30 	sh %d3,%d3,16
8001f8be:	a6 32       	or %d2,%d3
8001f8c0:	39 23 07 00 	ld.bu %d3,[%a2]7
8001f8c4:	8f 83 01 30 	sh %d3,%d3,24
8001f8c8:	a6 32       	or %d2,%d3
8001f8ca:	37 02 70 30 	extr.u %d3,%d2,0,16
8001f8ce:	91 10 00 27 	movh.a %a2,28673
8001f8d2:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001f8d6:	54 22       	ld.w %d2,[%a2]
8001f8d8:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f8dc:	0b 23 80 20 	sub %d2,%d3,%d2
8001f8e0:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f8e4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f8e8:	f9 22 08 00 	st.h [%a2]8,%d2
      pbuf_realloc(cseg->p, cseg->len);
8001f8ec:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f8f0:	b0 42       	add.a %a2,4
8001f8f2:	54 22       	ld.w %d2,[%a2]
8001f8f4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f8f8:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001f8fc:	02 34       	mov %d4,%d3
8001f8fe:	60 24       	mov.a %a4,%d2
8001f900:	6d ff fd d0 	call 80019afa <pbuf_realloc>
    }
  }
  cseg->next = next;
8001f904:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f908:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001f90c:	74 22       	st.w [%a2],%d2
}
8001f90e:	00 00       	nop 
8001f910:	00 90       	ret 

8001f912 <tcp_free_acked_segments>:

/** Remove segments from a list if the incoming ACK acknowledges them */
static struct tcp_seg *
tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
                        struct tcp_seg *dbg_other_seg_list)
{
8001f912:	40 ae       	mov.aa %a14,%sp
8001f914:	20 28       	sub.a %sp,40
8001f916:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8001f91a:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
8001f91e:	b5 e6 ec ff 	st.a [%a14]-20,%a6
8001f922:	b5 e7 e8 ff 	st.a [%a14]-24,%a7
  u16_t clen;

  LWIP_UNUSED_ARG(dbg_list_name);
  LWIP_UNUSED_ARG(dbg_other_seg_list);

  while (seg_list != NULL &&
8001f926:	1d 00 78 00 	j 8001fa16 <tcp_free_acked_segments+0x104>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
                                  lwip_ntohl(seg_list->tcphdr->seqno),
                                  lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
                                  dbg_list_name));

    next = seg_list;
8001f92a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001f92e:	59 e2 fc ff 	st.w [%a14]-4,%d2
    seg_list = seg_list->next;
8001f932:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001f936:	54 22       	ld.w %d2,[%a2]
8001f938:	59 e2 f0 ff 	st.w [%a14]-16,%d2

    clen = pbuf_clen(next->p);
8001f93c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001f940:	b0 42       	add.a %a2,4
8001f942:	54 22       	ld.w %d2,[%a2]
8001f944:	60 24       	mov.a %a4,%d2
8001f946:	6d ff 0c d4 	call 8001a15e <pbuf_clen>
8001f94a:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
                                 (tcpwnd_size_t)pcb->snd_queuelen));
    LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
8001f94e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f952:	b9 23 2a 10 	ld.hu %d3,[%a2]106
8001f956:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8001f95a:	7f 23 17 80 	jge.u %d3,%d2,8001f988 <tcp_free_acked_segments+0x76>
8001f95e:	91 00 00 28 	movh.a %a2,32768
8001f962:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001f966:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001f96a:	3b 70 45 20 	mov %d2,1111
8001f96e:	59 a2 04 00 	st.w [%sp]4,%d2
8001f972:	91 00 00 28 	movh.a %a2,32768
8001f976:	d9 22 af 12 	lea %a2,[%a2]10351 <8000286f <IfxCpu_Trap_vectorTable0_end+0x267b>>
8001f97a:	f4 a2       	st.a [%sp],%a2
8001f97c:	91 00 00 28 	movh.a %a2,32768
8001f980:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001f984:	6d ff d9 2c 	call 80005336 <Ifx_Lwip_printf>

    pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
8001f988:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f98c:	b9 23 2a 10 	ld.hu %d3,[%a2]106
8001f990:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
8001f994:	0b 23 80 20 	sub %d2,%d3,%d2
8001f998:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f99c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f9a0:	f9 22 2a 10 	st.h [%a2]106,%d2
    recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
8001f9a4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8001f9a8:	b9 23 08 00 	ld.hu %d3,[%a2]8
8001f9ac:	91 10 00 27 	movh.a %a2,28673
8001f9b0:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001f9b4:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001f9b8:	42 32       	add %d2,%d3
8001f9ba:	37 02 70 20 	extr.u %d2,%d2,0,16
8001f9be:	91 10 00 27 	movh.a %a2,28673
8001f9c2:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
8001f9c6:	b4 22       	st.h [%a2],%d2
    tcp_seg_free(next);
8001f9c8:	99 e4 fc ff 	ld.a %a4,[%a14]-4 <700145f4 <recv_acked>>
8001f9cc:	6d ff f0 e5 	call 8001c5ac <tcp_seg_free>

    LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing %s)\n",
                                 (tcpwnd_size_t)pcb->snd_queuelen,
                                 dbg_list_name));
    if (pcb->snd_queuelen != 0) {
8001f9d0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8001f9d4:	b9 22 2a 10 	ld.hu %d2,[%a2]106
8001f9d8:	df 02 1f 00 	jeq %d2,0,8001fa16 <tcp_free_acked_segments+0x104>
      LWIP_ASSERT("tcp_receive: valid queue length",
8001f9dc:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001f9e0:	df 02 1b 80 	jne %d2,0,8001fa16 <tcp_free_acked_segments+0x104>
8001f9e4:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8001f9e8:	df 02 17 80 	jne %d2,0,8001fa16 <tcp_free_acked_segments+0x104>
8001f9ec:	91 00 00 28 	movh.a %a2,32768
8001f9f0:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001f9f4:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001f9f8:	3b 10 46 20 	mov %d2,1121
8001f9fc:	59 a2 04 00 	st.w [%sp]4,%d2
8001fa00:	91 00 00 28 	movh.a %a2,32768
8001fa04:	d9 22 97 22 	lea %a2,[%a2]10391 <80002897 <IfxCpu_Trap_vectorTable0_end+0x26a3>>
8001fa08:	f4 a2       	st.a [%sp],%a2
8001fa0a:	91 00 00 28 	movh.a %a2,32768
8001fa0e:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001fa12:	6d ff 92 2c 	call 80005336 <Ifx_Lwip_printf>
  while (seg_list != NULL &&
8001fa16:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8001fa1a:	df 02 48 00 	jeq %d2,0,8001faaa <tcp_free_acked_segments+0x198>
         TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
8001fa1e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001fa22:	d9 22 10 00 	lea %a2,[%a2]16
8001fa26:	d4 22       	ld.a %a2,[%a2]
8001fa28:	39 23 04 00 	ld.bu %d3,[%a2]4
8001fa2c:	39 22 05 00 	ld.bu %d2,[%a2]5
8001fa30:	8f 82 00 20 	sh %d2,%d2,8
8001fa34:	a6 32       	or %d2,%d3
8001fa36:	39 23 06 00 	ld.bu %d3,[%a2]6
8001fa3a:	8f 03 01 30 	sh %d3,%d3,16
8001fa3e:	a6 32       	or %d2,%d3
8001fa40:	39 23 07 00 	ld.bu %d3,[%a2]7
8001fa44:	8f 83 01 30 	sh %d3,%d3,24
8001fa48:	a6 32       	or %d2,%d3
8001fa4a:	02 24       	mov %d4,%d2
8001fa4c:	6d ff 9c bd 	call 80017584 <lwip_htonl>
8001fa50:	02 28       	mov %d8,%d2
8001fa52:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001fa56:	b9 22 08 00 	ld.hu %d2,[%a2]8
8001fa5a:	02 29       	mov %d9,%d2
8001fa5c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8001fa60:	d9 22 10 00 	lea %a2,[%a2]16
8001fa64:	d4 22       	ld.a %a2,[%a2]
8001fa66:	39 23 0c 00 	ld.bu %d3,[%a2]12
8001fa6a:	39 22 0d 00 	ld.bu %d2,[%a2]13
8001fa6e:	8f 82 00 20 	sh %d2,%d2,8
8001fa72:	a6 32       	or %d2,%d3
8001fa74:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fa78:	02 24       	mov %d4,%d2
8001fa7a:	6d ff 6d bd 	call 80017554 <lwip_htons>
8001fa7e:	8f f2 0f 21 	and %d2,%d2,255
8001fa82:	8f 32 00 21 	and %d2,%d2,3
8001fa86:	df 02 05 00 	jeq %d2,0,8001fa90 <tcp_free_acked_segments+0x17e>
8001fa8a:	82 12       	mov %d2,1
8001fa8c:	1d 00 03 00 	j 8001fa92 <tcp_free_acked_segments+0x180>
8001fa90:	82 02       	mov %d2,0
8001fa92:	42 92       	add %d2,%d9
8001fa94:	0b 28 00 30 	add %d3,%d8,%d2
8001fa98:	91 10 00 27 	movh.a %a2,28673
8001fa9c:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001faa0:	54 22       	ld.w %d2,[%a2]
8001faa2:	0b 23 80 20 	sub %d2,%d3,%d2
  while (seg_list != NULL &&
8001faa6:	bf 12 42 7f 	jlt %d2,1,8001f92a <tcp_free_acked_segments+0x18>
                  seg_list != NULL || dbg_other_seg_list != NULL);
    }
  }
  return seg_list;
8001faaa:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
}
8001faae:	60 22       	mov.a %a2,%d2
8001fab0:	00 90       	ret 

8001fab2 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
8001fab2:	40 ae       	mov.aa %a14,%sp
8001fab4:	20 60       	sub.a %sp,96
8001fab6:	b5 e4 f4 ef 	st.a [%a14]-76,%a4
  s16_t m;
  u32_t right_wnd_edge;
  int found_dupack = 0;
8001faba:	82 02       	mov %d2,0
8001fabc:	59 e2 f8 ff 	st.w [%a14]-8,%d2

  LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
8001fac0:	19 e2 f4 ef 	ld.w %d2,[%a14]-76
8001fac4:	df 02 17 80 	jne %d2,0,8001faf2 <tcp_receive+0x40>
8001fac8:	91 00 00 28 	movh.a %a2,32768
8001facc:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001fad0:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001fad4:	3b b0 47 20 	mov %d2,1147
8001fad8:	59 a2 04 00 	st.w [%sp]4,%d2
8001fadc:	91 00 00 28 	movh.a %a2,32768
8001fae0:	d9 22 b7 22 	lea %a2,[%a2]10423 <800028b7 <IfxCpu_Trap_vectorTable0_end+0x26c3>>
8001fae4:	f4 a2       	st.a [%sp],%a2
8001fae6:	91 00 00 28 	movh.a %a2,32768
8001faea:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001faee:	6d ff 24 2c 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
8001faf2:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001faf6:	d9 22 14 00 	lea %a2,[%a2]20
8001fafa:	54 22       	ld.w %d2,[%a2]
8001fafc:	ff 42 17 80 	jge.u %d2,4,8001fb2a <tcp_receive+0x78>
8001fb00:	91 00 00 28 	movh.a %a2,32768
8001fb04:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8001fb08:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8001fb0c:	3b c0 47 20 	mov %d2,1148
8001fb10:	59 a2 04 00 	st.w [%sp]4,%d2
8001fb14:	91 00 00 28 	movh.a %a2,32768
8001fb18:	d9 22 90 32 	lea %a2,[%a2]10448 <800028d0 <IfxCpu_Trap_vectorTable0_end+0x26dc>>
8001fb1c:	f4 a2       	st.a [%sp],%a2
8001fb1e:	91 00 00 28 	movh.a %a2,32768
8001fb22:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8001fb26:	6d ff 08 2c 	call 80005336 <Ifx_Lwip_printf>

  if (flags & TCP_ACK) {
8001fb2a:	91 10 00 27 	movh.a %a2,28673
8001fb2e:	d9 22 78 74 	lea %a2,[%a2]17912 <700145f8 <flags>>
8001fb32:	14 22       	ld.bu %d2,[%a2]
8001fb34:	8f 02 01 21 	and %d2,%d2,16
8001fb38:	df 02 da 03 	jeq %d2,0,800202ec <tcp_receive+0x83a>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
8001fb3c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fb40:	b9 22 24 10 	ld.hu %d2,[%a2]100
8001fb44:	02 23       	mov %d3,%d2
8001fb46:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fb4a:	d9 22 1c 10 	lea %a2,[%a2]92
8001fb4e:	54 22       	ld.w %d2,[%a2]
8001fb50:	42 32       	add %d2,%d3
8001fb52:	59 e2 e0 ff 	st.w [%a14]-32,%d2

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
8001fb56:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fb5a:	d9 22 18 10 	lea %a2,[%a2]88
8001fb5e:	54 23       	ld.w %d3,[%a2]
8001fb60:	91 10 00 27 	movh.a %a2,28673
8001fb64:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001fb68:	54 22       	ld.w %d2,[%a2]
8001fb6a:	0b 23 80 20 	sub %d2,%d3,%d2
8001fb6e:	bf 02 3c 00 	jlt %d2,0,8001fbe6 <tcp_receive+0x134>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
8001fb72:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fb76:	d9 22 18 10 	lea %a2,[%a2]88
8001fb7a:	54 23       	ld.w %d3,[%a2]
8001fb7c:	91 10 00 27 	movh.a %a2,28673
8001fb80:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001fb84:	54 22       	ld.w %d2,[%a2]
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
8001fb86:	5f 23 10 80 	jne %d3,%d2,8001fba6 <tcp_receive+0xf4>
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
8001fb8a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fb8e:	d9 22 1c 10 	lea %a2,[%a2]92
8001fb92:	54 23       	ld.w %d3,[%a2]
8001fb94:	91 10 00 27 	movh.a %a2,28673
8001fb98:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fb9c:	54 22       	ld.w %d2,[%a2]
8001fb9e:	0b 23 80 20 	sub %d2,%d3,%d2
8001fba2:	bf 02 22 00 	jlt %d2,0,8001fbe6 <tcp_receive+0x134>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
8001fba6:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fbaa:	d9 22 1c 10 	lea %a2,[%a2]92
8001fbae:	54 23       	ld.w %d3,[%a2]
8001fbb0:	91 10 00 27 	movh.a %a2,28673
8001fbb4:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fbb8:	54 22       	ld.w %d2,[%a2]
        (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
8001fbba:	5f 23 4e 80 	jne %d3,%d2,8001fc56 <tcp_receive+0x1a4>
        (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
8001fbbe:	91 10 00 27 	movh.a %a2,28673
8001fbc2:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001fbc6:	d4 22       	ld.a %a2,[%a2]
8001fbc8:	39 23 0e 00 	ld.bu %d3,[%a2]14 <700145dc <tcphdr>>
8001fbcc:	39 22 0f 00 	ld.bu %d2,[%a2]15 <700145dc <tcphdr>>
8001fbd0:	8f 82 00 20 	sh %d2,%d2,8
8001fbd4:	a6 32       	or %d2,%d3
8001fbd6:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fbda:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fbde:	b9 23 24 10 	ld.hu %d3,[%a2]100
8001fbe2:	7f 23 3a 80 	jge.u %d3,%d2,8001fc56 <tcp_receive+0x1a4>
      pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
8001fbe6:	91 10 00 27 	movh.a %a2,28673
8001fbea:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
8001fbee:	d4 22       	ld.a %a2,[%a2]
8001fbf0:	39 23 0e 00 	ld.bu %d3,[%a2]14 <700145dc <tcphdr>>
8001fbf4:	39 22 0f 00 	ld.bu %d2,[%a2]15 <700145dc <tcphdr>>
8001fbf8:	8f 82 00 20 	sh %d2,%d2,8
8001fbfc:	a6 32       	or %d2,%d3
8001fbfe:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fc02:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fc06:	f9 22 24 10 	st.h [%a2]100,%d2
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < pcb->snd_wnd) {
8001fc0a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fc0e:	b9 23 26 10 	ld.hu %d3,[%a2]102
8001fc12:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fc16:	b9 22 24 10 	ld.hu %d2,[%a2]100
8001fc1a:	7f 23 0a 80 	jge.u %d3,%d2,8001fc2e <tcp_receive+0x17c>
        pcb->snd_wnd_max = pcb->snd_wnd;
8001fc1e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fc22:	b9 22 24 10 	ld.hu %d2,[%a2]100
8001fc26:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fc2a:	f9 22 26 10 	st.h [%a2]102,%d2
      }
      pcb->snd_wl1 = seqno;
8001fc2e:	91 10 00 27 	movh.a %a2,28673
8001fc32:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8001fc36:	54 22       	ld.w %d2,[%a2]
8001fc38:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145ec <seqno>>
8001fc3c:	d9 22 18 10 	lea %a2,[%a2]88 <700145ec <seqno>>
8001fc40:	74 22       	st.w [%a2],%d2
      pcb->snd_wl2 = ackno;
8001fc42:	91 10 00 27 	movh.a %a2,28673
8001fc46:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fc4a:	54 22       	ld.w %d2,[%a2]
8001fc4c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145f0 <ackno>>
8001fc50:	d9 22 1c 10 	lea %a2,[%a2]92 <700145f0 <ackno>>
8001fc54:	74 22       	st.w [%a2],%d2
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
8001fc56:	91 10 00 27 	movh.a %a2,28673
8001fc5a:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fc5e:	54 23       	ld.w %d3,[%a2]
8001fc60:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145f0 <ackno>>
8001fc64:	d9 22 08 10 	lea %a2,[%a2]72 <700145f0 <ackno>>
8001fc68:	54 22       	ld.w %d2,[%a2]
8001fc6a:	0b 23 80 20 	sub %d2,%d3,%d2
8001fc6e:	ff 12 82 00 	jge %d2,1,8001fd72 <tcp_receive+0x2c0>
      /* Clause 2 */
      if (tcplen == 0) {
8001fc72:	91 10 00 27 	movh.a %a2,28673
8001fc76:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8001fc7a:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8001fc7e:	df 02 6f 80 	jne %d2,0,8001fd5c <tcp_receive+0x2aa>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
8001fc82:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fc86:	d9 22 1c 10 	lea %a2,[%a2]92
8001fc8a:	54 23       	ld.w %d3,[%a2]
8001fc8c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fc90:	b9 22 24 10 	ld.hu %d2,[%a2]100
8001fc94:	42 32       	add %d2,%d3
8001fc96:	19 e3 e0 ff 	ld.w %d3,[%a14]-32
8001fc9a:	5f 23 61 80 	jne %d3,%d2,8001fd5c <tcp_receive+0x2aa>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
8001fc9e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fca2:	c9 22 34 00 	ld.h %d2,[%a2]52
8001fca6:	bf 02 5b 00 	jlt %d2,0,8001fd5c <tcp_receive+0x2aa>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
8001fcaa:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fcae:	d9 22 08 10 	lea %a2,[%a2]72
8001fcb2:	54 23       	ld.w %d3,[%a2]
8001fcb4:	91 10 00 27 	movh.a %a2,28673
8001fcb8:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fcbc:	54 22       	ld.w %d2,[%a2]
8001fcbe:	5f 23 4f 80 	jne %d3,%d2,8001fd5c <tcp_receive+0x2aa>
              found_dupack = 1;
8001fcc2:	82 12       	mov %d2,1
8001fcc4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
8001fcc8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fccc:	39 22 07 10 	ld.bu %d2,[%a2]71
8001fcd0:	8b f2 0f 22 	eq %d2,%d2,255
8001fcd4:	df 02 0d 80 	jne %d2,0,8001fcee <tcp_receive+0x23c>
                ++pcb->dupacks;
8001fcd8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fcdc:	39 22 07 10 	ld.bu %d2,[%a2]71
8001fce0:	c2 12       	add %d2,1
8001fce2:	8f f2 0f 21 	and %d2,%d2,255
8001fce6:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fcea:	e9 22 07 10 	st.b [%a2]71,%d2
              }
              if (pcb->dupacks > 3) {
8001fcee:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fcf2:	39 22 07 10 	ld.bu %d2,[%a2]71
8001fcf6:	bf 42 29 80 	jlt.u %d2,4,8001fd48 <tcp_receive+0x296>
                /* Inflate the congestion window */
                TCP_WND_INC(pcb->cwnd, pcb->mss);
8001fcfa:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fcfe:	b9 23 0c 10 	ld.hu %d3,[%a2]76
8001fd02:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fd06:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001fd0a:	42 32       	add %d2,%d3
8001fd0c:	37 02 70 30 	extr.u %d3,%d2,0,16
8001fd10:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fd14:	b9 22 0c 10 	ld.hu %d2,[%a2]76
8001fd18:	3f 23 13 80 	jlt.u %d3,%d2,8001fd3e <tcp_receive+0x28c>
8001fd1c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fd20:	b9 23 0c 10 	ld.hu %d3,[%a2]76
8001fd24:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fd28:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001fd2c:	42 32       	add %d2,%d3
8001fd2e:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fd32:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fd36:	f9 22 0c 10 	st.h [%a2]76,%d2
8001fd3a:	1d 00 07 00 	j 8001fd48 <tcp_receive+0x296>
8001fd3e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fd42:	82 f2       	mov %d2,-1
8001fd44:	f9 22 0c 10 	st.h [%a2]76,%d2
              }
              if (pcb->dupacks >= 3) {
8001fd48:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fd4c:	39 22 07 10 	ld.bu %d2,[%a2]71
8001fd50:	bf 32 06 80 	jlt.u %d2,3,8001fd5c <tcp_receive+0x2aa>
                /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
                tcp_rexmit_fast(pcb);
8001fd54:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
8001fd58:	6d 00 78 22 	call 80024248 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
8001fd5c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8001fd60:	df 02 30 82 	jne %d2,0,800201c0 <tcp_receive+0x70e>
        pcb->dupacks = 0;
8001fd64:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fd68:	82 02       	mov %d2,0
8001fd6a:	e9 22 07 10 	st.b [%a2]71,%d2
8001fd6e:	1d 00 29 02 	j 800201c0 <tcp_receive+0x70e>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
8001fd72:	91 10 00 27 	movh.a %a2,28673
8001fd76:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fd7a:	54 23       	ld.w %d3,[%a2]
8001fd7c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145f0 <ackno>>
8001fd80:	d9 22 08 10 	lea %a2,[%a2]72 <700145f0 <ackno>>
8001fd84:	54 22       	ld.w %d2,[%a2]
8001fd86:	0b 23 80 20 	sub %d2,%d3,%d2
8001fd8a:	c2 f2       	add %d2,-1
8001fd8c:	bf 02 13 02 	jlt %d2,0,800201b2 <tcp_receive+0x700>
8001fd90:	91 10 00 27 	movh.a %a2,28673
8001fd94:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fd98:	54 23       	ld.w %d3,[%a2]
8001fd9a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145f0 <ackno>>
8001fd9e:	d9 22 14 10 	lea %a2,[%a2]84 <700145f0 <ackno>>
8001fda2:	54 22       	ld.w %d2,[%a2]
8001fda4:	0b 23 80 20 	sub %d2,%d3,%d2
8001fda8:	ff 12 05 02 	jge %d2,1,800201b2 <tcp_receive+0x700>
      tcpwnd_size_t acked;

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
8001fdac:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fdb0:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001fdb4:	8f 42 00 21 	and %d2,%d2,4
8001fdb8:	df 02 1b 00 	jeq %d2,0,8001fdee <tcp_receive+0x33c>
        tcp_clear_flags(pcb, TF_INFR);
8001fdbc:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fdc0:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001fdc4:	8f 42 c0 21 	andn %d2,%d2,4
8001fdc8:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fdcc:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fdd0:	f9 22 1e 00 	st.h [%a2]30,%d2
        pcb->cwnd = pcb->ssthresh;
8001fdd4:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fdd8:	b9 22 0e 10 	ld.hu %d2,[%a2]78
8001fddc:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fde0:	f9 22 0c 10 	st.h [%a2]76,%d2
        pcb->bytes_acked = 0;
8001fde4:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fde8:	82 02       	mov %d2,0
8001fdea:	f9 22 2e 10 	st.h [%a2]110,%d2
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
8001fdee:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fdf2:	82 02       	mov %d2,0
8001fdf4:	e9 22 06 10 	st.b [%a2]70,%d2

      /* Reset the retransmission time-out. */
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
8001fdf8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fdfc:	c9 22 00 10 	ld.h %d2,[%a2]64
8001fe00:	86 d2       	sha %d2,-3
8001fe02:	37 02 50 20 	extr %d2,%d2,0,16
8001fe06:	37 02 70 30 	extr.u %d3,%d2,0,16
8001fe0a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fe0e:	c9 22 02 10 	ld.h %d2,[%a2]66
8001fe12:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fe16:	42 32       	add %d2,%d3
8001fe18:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fe1c:	37 02 50 20 	extr %d2,%d2,0,16
8001fe20:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fe24:	f9 22 04 10 	st.h [%a2]68,%d2

      /* Record how much data this ACK acks */
      acked = (tcpwnd_size_t)(ackno - pcb->lastack);
8001fe28:	91 10 00 27 	movh.a %a2,28673
8001fe2c:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fe30:	54 22       	ld.w %d2,[%a2]
8001fe32:	37 02 70 30 	extr.u %d3,%d2,0,16
8001fe36:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fe3a:	d9 22 08 10 	lea %a2,[%a2]72
8001fe3e:	54 22       	ld.w %d2,[%a2]
8001fe40:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fe44:	0b 23 80 20 	sub %d2,%d3,%d2
8001fe48:	f9 e2 de ff 	st.h [%a14]-34,%d2

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
8001fe4c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fe50:	82 02       	mov %d2,0
8001fe52:	e9 22 07 10 	st.b [%a2]71,%d2
      pcb->lastack = ackno;
8001fe56:	91 10 00 27 	movh.a %a2,28673
8001fe5a:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
8001fe5e:	54 22       	ld.w %d2,[%a2]
8001fe60:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145f0 <ackno>>
8001fe64:	d9 22 08 10 	lea %a2,[%a2]72 <700145f0 <ackno>>
8001fe68:	74 22       	st.w [%a2],%d2

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
8001fe6a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145f0 <ackno>>
8001fe6e:	d9 22 14 00 	lea %a2,[%a2]20 <700145f0 <ackno>>
8001fe72:	54 22       	ld.w %d2,[%a2]
8001fe74:	bf 42 b6 80 	jlt.u %d2,4,8001ffe0 <tcp_receive+0x52e>
        if (pcb->cwnd < pcb->ssthresh) {
8001fe78:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fe7c:	b9 23 0c 10 	ld.hu %d3,[%a2]76
8001fe80:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fe84:	b9 22 0e 10 	ld.hu %d2,[%a2]78
8001fe88:	7f 23 48 80 	jge.u %d3,%d2,8001ff18 <tcp_receive+0x466>
          tcpwnd_size_t increase;
          /* limit to 1 SMSS segment during period following RTO */
          u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
8001fe8c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fe90:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8001fe94:	02 23       	mov %d3,%d2
8001fe96:	3b 00 80 20 	mov %d2,2048
8001fe9a:	26 32       	and %d2,%d3
8001fe9c:	df 02 05 00 	jeq %d2,0,8001fea6 <tcp_receive+0x3f4>
8001fea0:	82 12       	mov %d2,1
8001fea2:	1d 00 03 00 	j 8001fea8 <tcp_receive+0x3f6>
8001fea6:	82 22       	mov %d2,2
8001fea8:	e9 e2 dd ff 	st.b [%a14]-35,%d2
          /* RFC 3465, section 2.2 Slow Start */
          increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
8001feac:	39 e2 dd ff 	ld.bu %d2,[%a14]-35
8001feb0:	37 02 70 30 	extr.u %d3,%d2,0,16
8001feb4:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001feb8:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001febc:	e2 32       	mul %d2,%d3
8001febe:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fec2:	b9 e3 de ff 	ld.hu %d3,[%a14]-34
8001fec6:	0b 23 90 21 	min.u %d2,%d3,%d2
8001feca:	f9 e2 da ff 	st.h [%a14]-38,%d2
          TCP_WND_INC(pcb->cwnd, increase);
8001fece:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fed2:	b9 23 0c 10 	ld.hu %d3,[%a2]76
8001fed6:	c9 e2 da ff 	ld.h %d2,[%a14]-38
8001feda:	42 32       	add %d2,%d3
8001fedc:	37 02 70 30 	extr.u %d3,%d2,0,16
8001fee0:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fee4:	b9 22 0c 10 	ld.hu %d2,[%a2]76
8001fee8:	3f 23 11 80 	jlt.u %d3,%d2,8001ff0a <tcp_receive+0x458>
8001feec:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001fef0:	b9 23 0c 10 	ld.hu %d3,[%a2]76
8001fef4:	c9 e2 da ff 	ld.h %d2,[%a14]-38
8001fef8:	42 32       	add %d2,%d3
8001fefa:	37 02 70 20 	extr.u %d2,%d2,0,16
8001fefe:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff02:	f9 22 0c 10 	st.h [%a2]76,%d2
8001ff06:	1d 00 6d 00 	j 8001ffe0 <tcp_receive+0x52e>
8001ff0a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff0e:	82 f2       	mov %d2,-1
8001ff10:	f9 22 0c 10 	st.h [%a2]76,%d2
8001ff14:	1d 00 66 00 	j 8001ffe0 <tcp_receive+0x52e>
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
        } else {
          /* RFC 3465, section 2.1 Congestion Avoidance */
          TCP_WND_INC(pcb->bytes_acked, acked);
8001ff18:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff1c:	b9 23 2e 10 	ld.hu %d3,[%a2]110
8001ff20:	c9 e2 de ff 	ld.h %d2,[%a14]-34
8001ff24:	42 32       	add %d2,%d3
8001ff26:	37 02 70 30 	extr.u %d3,%d2,0,16
8001ff2a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff2e:	b9 22 2e 10 	ld.hu %d2,[%a2]110
8001ff32:	3f 23 11 80 	jlt.u %d3,%d2,8001ff54 <tcp_receive+0x4a2>
8001ff36:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff3a:	b9 23 2e 10 	ld.hu %d3,[%a2]110
8001ff3e:	c9 e2 de ff 	ld.h %d2,[%a14]-34
8001ff42:	42 32       	add %d2,%d3
8001ff44:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ff48:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff4c:	f9 22 2e 10 	st.h [%a2]110,%d2
8001ff50:	1d 00 07 00 	j 8001ff5e <tcp_receive+0x4ac>
8001ff54:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff58:	82 f2       	mov %d2,-1
8001ff5a:	f9 22 2e 10 	st.h [%a2]110,%d2
          if (pcb->bytes_acked >= pcb->cwnd) {
8001ff5e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff62:	b9 23 2e 10 	ld.hu %d3,[%a2]110
8001ff66:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff6a:	b9 22 0c 10 	ld.hu %d2,[%a2]76
8001ff6e:	3f 23 39 80 	jlt.u %d3,%d2,8001ffe0 <tcp_receive+0x52e>
            pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
8001ff72:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff76:	b9 23 2e 10 	ld.hu %d3,[%a2]110
8001ff7a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff7e:	b9 22 0c 10 	ld.hu %d2,[%a2]76
8001ff82:	0b 23 80 20 	sub %d2,%d3,%d2
8001ff86:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ff8a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff8e:	f9 22 2e 10 	st.h [%a2]110,%d2
            TCP_WND_INC(pcb->cwnd, pcb->mss);
8001ff92:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff96:	b9 23 0c 10 	ld.hu %d3,[%a2]76
8001ff9a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ff9e:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001ffa2:	42 32       	add %d2,%d3
8001ffa4:	37 02 70 30 	extr.u %d3,%d2,0,16
8001ffa8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ffac:	b9 22 0c 10 	ld.hu %d2,[%a2]76
8001ffb0:	3f 23 13 80 	jlt.u %d3,%d2,8001ffd6 <tcp_receive+0x524>
8001ffb4:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ffb8:	b9 23 0c 10 	ld.hu %d3,[%a2]76
8001ffbc:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ffc0:	b9 22 36 00 	ld.hu %d2,[%a2]54
8001ffc4:	42 32       	add %d2,%d3
8001ffc6:	37 02 70 20 	extr.u %d2,%d2,0,16
8001ffca:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ffce:	f9 22 0c 10 	st.h [%a2]76,%d2
8001ffd2:	1d 00 07 00 	j 8001ffe0 <tcp_receive+0x52e>
8001ffd6:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ffda:	82 f2       	mov %d2,-1
8001ffdc:	f9 22 0c 10 	st.h [%a2]76,%d2
                                    pcb->unacked != NULL ?
                                    lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked) : 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowledges them. */
      pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
8001ffe0:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ffe4:	d9 22 34 10 	lea %a2,[%a2]116
8001ffe8:	54 22       	ld.w %d2,[%a2]
8001ffea:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8001ffee:	d9 22 30 10 	lea %a2,[%a2]112
8001fff2:	54 23       	ld.w %d3,[%a2]
8001fff4:	60 37       	mov.a %a7,%d3
8001fff6:	91 00 00 28 	movh.a %a2,32768
8001fffa:	d9 26 a9 32 	lea %a6,[%a2]10473 <800028e9 <IfxCpu_Trap_vectorTable0_end+0x26f5>>
8001fffe:	60 25       	mov.a %a5,%d2
80020000:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
80020004:	6d ff 87 fc 	call 8001f912 <tcp_free_acked_segments>
80020008:	80 22       	mov.d %d2,%a2
8002000a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002000e:	d9 22 34 10 	lea %a2,[%a2]116
80020012:	74 22       	st.w [%a2],%d2
         on the list are acknowledged by the ACK. This may seem
         strange since an "unsent" segment shouldn't be acked. The
         rationale is that lwIP puts all outstanding segments on the
         ->unsent list after a retransmission, so these segments may
         in fact have been sent once. */
      pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
80020014:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020018:	d9 22 30 10 	lea %a2,[%a2]112
8002001c:	54 22       	ld.w %d2,[%a2]
8002001e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020022:	d9 22 34 10 	lea %a2,[%a2]116
80020026:	54 23       	ld.w %d3,[%a2]
80020028:	60 37       	mov.a %a7,%d3
8002002a:	91 00 00 28 	movh.a %a2,32768
8002002e:	d9 26 b1 32 	lea %a6,[%a2]10481 <800028f1 <IfxCpu_Trap_vectorTable0_end+0x26fd>>
80020032:	60 25       	mov.a %a5,%d2
80020034:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
80020038:	6d ff 6d fc 	call 8001f912 <tcp_free_acked_segments>
8002003c:	80 22       	mov.d %d2,%a2
8002003e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020042:	d9 22 30 10 	lea %a2,[%a2]112
80020046:	74 22       	st.w [%a2],%d2

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if (pcb->unacked == NULL) {
80020048:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002004c:	d9 22 34 10 	lea %a2,[%a2]116
80020050:	54 22       	ld.w %d2,[%a2]
80020052:	df 02 09 80 	jne %d2,0,80020064 <tcp_receive+0x5b2>
        pcb->rtime = -1;
80020056:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002005a:	82 f2       	mov %d2,-1
8002005c:	f9 22 34 00 	st.h [%a2]52,%d2
80020060:	1d 00 07 00 	j 8002006e <tcp_receive+0x5bc>
      } else {
        pcb->rtime = 0;
80020064:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020068:	82 02       	mov %d2,0
8002006a:	f9 22 34 00 	st.h [%a2]52,%d2
      }

      pcb->polltmr = 0;
8002006e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020072:	82 02       	mov %d2,0
80020074:	e9 22 20 00 	st.b [%a2]32,%d2

#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
80020078:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002007c:	d9 22 30 10 	lea %a2,[%a2]112
80020080:	54 22       	ld.w %d2,[%a2]
80020082:	df 02 07 80 	jne %d2,0,80020090 <tcp_receive+0x5de>
        pcb->unsent_oversize = 0;
80020086:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002008a:	82 02       	mov %d2,0
8002008c:	f9 22 2c 10 	st.h [%a2]108,%d2
        /* Inform neighbor reachability of forward progress. */
        nd6_reachability_hint(ip6_current_src_addr());
      }
#endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/

      pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
80020090:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020094:	b9 23 28 10 	ld.hu %d3,[%a2]104
80020098:	91 10 00 27 	movh.a %a2,28673
8002009c:	d9 22 74 74 	lea %a2,[%a2]17908 <700145f4 <recv_acked>>
800200a0:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
800200a4:	42 32       	add %d2,%d3
800200a6:	37 02 70 20 	extr.u %d2,%d2,0,16
800200aa:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800200ae:	f9 22 28 10 	st.h [%a2]104,%d2
      /* check if this ACK ends our retransmission of in-flight data */
      if (pcb->flags & TF_RTO) {
800200b2:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800200b6:	b9 22 1e 00 	ld.hu %d2,[%a2]30
800200ba:	02 23       	mov %d3,%d2
800200bc:	3b 00 80 20 	mov %d2,2048
800200c0:	26 32       	and %d2,%d3
800200c2:	df 02 7e 00 	jeq %d2,0,800201be <tcp_receive+0x70c>
        /* RTO is done if
            1) both queues are empty or
            2) unacked is empty and unsent head contains data not part of RTO or
            3) unacked head contains data not part of RTO */
        if (pcb->unacked == NULL) {
800200c6:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800200ca:	d9 22 34 10 	lea %a2,[%a2]116
800200ce:	54 22       	ld.w %d2,[%a2]
800200d0:	df 02 3d 80 	jne %d2,0,8002014a <tcp_receive+0x698>
          if ((pcb->unsent == NULL) ||
800200d4:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800200d8:	d9 22 30 10 	lea %a2,[%a2]112
800200dc:	54 22       	ld.w %d2,[%a2]
800200de:	df 02 27 00 	jeq %d2,0,8002012c <tcp_receive+0x67a>
              (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
800200e2:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800200e6:	d9 22 10 10 	lea %a2,[%a2]80
800200ea:	54 28       	ld.w %d8,[%a2]
800200ec:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800200f0:	d9 22 30 10 	lea %a2,[%a2]112
800200f4:	d4 22       	ld.a %a2,[%a2]
800200f6:	d9 22 10 00 	lea %a2,[%a2]16
800200fa:	d4 22       	ld.a %a2,[%a2]
800200fc:	39 23 04 00 	ld.bu %d3,[%a2]4
80020100:	39 22 05 00 	ld.bu %d2,[%a2]5
80020104:	8f 82 00 20 	sh %d2,%d2,8
80020108:	a6 32       	or %d2,%d3
8002010a:	39 23 06 00 	ld.bu %d3,[%a2]6
8002010e:	8f 03 01 30 	sh %d3,%d3,16
80020112:	a6 32       	or %d2,%d3
80020114:	39 23 07 00 	ld.bu %d3,[%a2]7
80020118:	8f 83 01 30 	sh %d3,%d3,24
8002011c:	a6 32       	or %d2,%d3
8002011e:	02 24       	mov %d4,%d2
80020120:	6d ff 32 ba 	call 80017584 <lwip_htonl>
80020124:	0b 28 80 20 	sub %d2,%d8,%d2
          if ((pcb->unsent == NULL) ||
80020128:	ff 12 4b 00 	jge %d2,1,800201be <tcp_receive+0x70c>
            tcp_clear_flags(pcb, TF_RTO);
8002012c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020130:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80020134:	3b f0 7f 3f 	mov %d3,-2049
80020138:	26 32       	and %d2,%d3
8002013a:	37 02 70 20 	extr.u %d2,%d2,0,16
8002013e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020142:	f9 22 1e 00 	st.h [%a2]30,%d2
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
80020146:	1d 00 3c 00 	j 800201be <tcp_receive+0x70c>
          }
        } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
8002014a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002014e:	d9 22 10 10 	lea %a2,[%a2]80
80020152:	54 28       	ld.w %d8,[%a2]
80020154:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020158:	d9 22 34 10 	lea %a2,[%a2]116
8002015c:	d4 22       	ld.a %a2,[%a2]
8002015e:	d9 22 10 00 	lea %a2,[%a2]16
80020162:	d4 22       	ld.a %a2,[%a2]
80020164:	39 23 04 00 	ld.bu %d3,[%a2]4
80020168:	39 22 05 00 	ld.bu %d2,[%a2]5
8002016c:	8f 82 00 20 	sh %d2,%d2,8
80020170:	a6 32       	or %d2,%d3
80020172:	39 23 06 00 	ld.bu %d3,[%a2]6
80020176:	8f 03 01 30 	sh %d3,%d3,16
8002017a:	a6 32       	or %d2,%d3
8002017c:	39 23 07 00 	ld.bu %d3,[%a2]7
80020180:	8f 83 01 30 	sh %d3,%d3,24
80020184:	a6 32       	or %d2,%d3
80020186:	02 24       	mov %d4,%d2
80020188:	6d ff fe b9 	call 80017584 <lwip_htonl>
8002018c:	0b 28 80 20 	sub %d2,%d8,%d2
80020190:	ff 12 17 00 	jge %d2,1,800201be <tcp_receive+0x70c>
          tcp_clear_flags(pcb, TF_RTO);
80020194:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020198:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8002019c:	3b f0 7f 3f 	mov %d3,-2049
800201a0:	26 32       	and %d2,%d3
800201a2:	37 02 70 20 	extr.u %d2,%d2,0,16
800201a6:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800201aa:	f9 22 1e 00 	st.h [%a2]30,%d2
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
800201ae:	1d 00 08 00 	j 800201be <tcp_receive+0x70c>
        }
      }
      /* End of ACK for new data processing. */
    } else {
      /* Out of sequence ACK, didn't really ack anything */
      tcp_send_empty_ack(pcb);
800201b2:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
800201b6:	6d 00 c7 23 	call 80024944 <tcp_send_empty_ack>
800201ba:	1d 00 03 00 	j 800201c0 <tcp_receive+0x70e>
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
800201be:	00 00       	nop 
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
800201c0:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800201c4:	d9 22 38 00 	lea %a2,[%a2]56
800201c8:	54 22       	ld.w %d2,[%a2]
800201ca:	df 02 91 00 	jeq %d2,0,800202ec <tcp_receive+0x83a>
800201ce:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800201d2:	d9 22 3c 00 	lea %a2,[%a2]60
800201d6:	54 23       	ld.w %d3,[%a2]
800201d8:	91 10 00 27 	movh.a %a2,28673
800201dc:	d9 22 70 74 	lea %a2,[%a2]17904 <700145f0 <ackno>>
800201e0:	54 22       	ld.w %d2,[%a2]
800201e2:	0b 23 80 20 	sub %d2,%d3,%d2
800201e6:	ff 02 83 00 	jge %d2,0,800202ec <tcp_receive+0x83a>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
800201ea:	91 10 00 27 	movh.a %a2,28673
800201ee:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
800201f2:	54 22       	ld.w %d2,[%a2]
800201f4:	37 02 70 30 	extr.u %d3,%d2,0,16
800201f8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800201fc:	d9 22 38 00 	lea %a2,[%a2]56
80020200:	54 22       	ld.w %d2,[%a2]
80020202:	37 02 70 20 	extr.u %d2,%d2,0,16
80020206:	0b 23 80 20 	sub %d2,%d3,%d2
8002020a:	37 02 70 20 	extr.u %d2,%d2,0,16
8002020e:	f9 e2 fe ff 	st.h [%a14]-2,%d2

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, (u16_t)(m * TCP_SLOW_INTERVAL)));

      /* This is taken directly from VJs original code in his paper */
      m = (s16_t)(m - (pcb->sa >> 3));
80020212:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80020216:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002021a:	c9 22 00 10 	ld.h %d2,[%a2]64
8002021e:	86 d2       	sha %d2,-3
80020220:	37 02 50 20 	extr %d2,%d2,0,16
80020224:	37 02 70 20 	extr.u %d2,%d2,0,16
80020228:	0b 23 80 20 	sub %d2,%d3,%d2
8002022c:	37 02 70 20 	extr.u %d2,%d2,0,16
80020230:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      pcb->sa = (s16_t)(pcb->sa + m);
80020234:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020238:	c9 22 00 10 	ld.h %d2,[%a2]64
8002023c:	37 02 70 30 	extr.u %d3,%d2,0,16
80020240:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80020244:	42 32       	add %d2,%d3
80020246:	37 02 70 20 	extr.u %d2,%d2,0,16
8002024a:	37 02 50 20 	extr %d2,%d2,0,16
8002024e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020252:	f9 22 00 10 	st.h [%a2]64,%d2
      if (m < 0) {
80020256:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8002025a:	ff 02 09 00 	jge %d2,0,8002026c <tcp_receive+0x7ba>
        m = (s16_t) - m;
8002025e:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80020262:	32 52       	rsub %d2
80020264:	37 02 70 20 	extr.u %d2,%d2,0,16
80020268:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      }
      m = (s16_t)(m - (pcb->sv >> 2));
8002026c:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
80020270:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020274:	c9 22 02 10 	ld.h %d2,[%a2]66
80020278:	86 e2       	sha %d2,-2
8002027a:	37 02 50 20 	extr %d2,%d2,0,16
8002027e:	37 02 70 20 	extr.u %d2,%d2,0,16
80020282:	0b 23 80 20 	sub %d2,%d3,%d2
80020286:	37 02 70 20 	extr.u %d2,%d2,0,16
8002028a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
      pcb->sv = (s16_t)(pcb->sv + m);
8002028e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020292:	c9 22 02 10 	ld.h %d2,[%a2]66
80020296:	37 02 70 30 	extr.u %d3,%d2,0,16
8002029a:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8002029e:	42 32       	add %d2,%d3
800202a0:	37 02 70 20 	extr.u %d2,%d2,0,16
800202a4:	37 02 50 20 	extr %d2,%d2,0,16
800202a8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800202ac:	f9 22 02 10 	st.h [%a2]66,%d2
      pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
800202b0:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800202b4:	c9 22 00 10 	ld.h %d2,[%a2]64
800202b8:	86 d2       	sha %d2,-3
800202ba:	37 02 50 20 	extr %d2,%d2,0,16
800202be:	37 02 70 30 	extr.u %d3,%d2,0,16
800202c2:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800202c6:	c9 22 02 10 	ld.h %d2,[%a2]66
800202ca:	37 02 70 20 	extr.u %d2,%d2,0,16
800202ce:	42 32       	add %d2,%d3
800202d0:	37 02 70 20 	extr.u %d2,%d2,0,16
800202d4:	37 02 50 20 	extr %d2,%d2,0,16
800202d8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800202dc:	f9 22 04 10 	st.h [%a2]68,%d2

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));

      pcb->rttest = 0;
800202e0:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800202e4:	82 02       	mov %d2,0
800202e6:	d9 22 38 00 	lea %a2,[%a2]56
800202ea:	74 22       	st.w [%a2],%d2

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
800202ec:	91 10 00 27 	movh.a %a2,28673
800202f0:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
800202f4:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
800202f8:	df 02 ea 09 	jeq %d2,0,800216cc <tcp_receive+0x1c1a>
800202fc:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020300:	d9 22 14 00 	lea %a2,[%a2]20
80020304:	54 22       	ld.w %d2,[%a2]
80020306:	ff 72 e3 89 	jge.u %d2,7,800216cc <tcp_receive+0x1c1a>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
8002030a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002030e:	d9 22 28 00 	lea %a2,[%a2]40
80020312:	54 23       	ld.w %d3,[%a2]
80020314:	91 10 00 27 	movh.a %a2,28673
80020318:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8002031c:	54 22       	ld.w %d2,[%a2]
8002031e:	0b 23 80 20 	sub %d2,%d3,%d2
80020322:	c2 f2       	add %d2,-1
80020324:	bf 02 0b 01 	jlt %d2,0,8002053a <tcp_receive+0xa88>
80020328:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002032c:	d9 22 28 00 	lea %a2,[%a2]40
80020330:	54 23       	ld.w %d3,[%a2]
80020332:	91 10 00 27 	movh.a %a2,28673
80020336:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8002033a:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8002033e:	02 24       	mov %d4,%d2
80020340:	91 10 00 27 	movh.a %a2,28673
80020344:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020348:	54 22       	ld.w %d2,[%a2]
8002034a:	42 42       	add %d2,%d4
8002034c:	0b 23 80 20 	sub %d2,%d3,%d2
80020350:	c2 12       	add %d2,1
80020352:	ff 12 f4 00 	jge %d2,1,8002053a <tcp_receive+0xa88>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      struct pbuf *p = inseg.p;
80020356:	91 10 00 27 	movh.a %a2,28673
8002035a:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002035e:	b0 42       	add.a %a2,4
80020360:	54 22       	ld.w %d2,[%a2]
80020362:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      u32_t off32 = pcb->rcv_nxt - seqno;
80020366:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002036a:	d9 22 28 00 	lea %a2,[%a2]40
8002036e:	54 23       	ld.w %d3,[%a2]
80020370:	91 10 00 27 	movh.a %a2,28673
80020374:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020378:	54 22       	ld.w %d2,[%a2]
8002037a:	0b 23 80 20 	sub %d2,%d3,%d2
8002037e:	59 e2 d4 ff 	st.w [%a14]-44,%d2
      u16_t new_tot_len, off;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
80020382:	91 10 00 27 	movh.a %a2,28673
80020386:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002038a:	b0 42       	add.a %a2,4
8002038c:	54 22       	ld.w %d2,[%a2]
8002038e:	df 02 17 80 	jne %d2,0,800203bc <tcp_receive+0x90a>
80020392:	91 00 00 28 	movh.a %a2,32768
80020396:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8002039a:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8002039e:	3b 40 59 20 	mov %d2,1428
800203a2:	59 a2 04 00 	st.w [%sp]4,%d2
800203a6:	91 00 00 28 	movh.a %a2,32768
800203aa:	d9 22 b8 32 	lea %a2,[%a2]10488 <800028f8 <IfxCpu_Trap_vectorTable0_end+0x2704>>
800203ae:	f4 a2       	st.a [%sp],%a2
800203b0:	91 00 00 28 	movh.a %a2,32768
800203b4:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
800203b8:	6d ff bf 27 	call 80005336 <Ifx_Lwip_printf>
      LWIP_ASSERT("insane offset!", (off32 < 0xffff));
800203bc:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800203c0:	bb f0 ff 3f 	mov.u %d3,65535
800203c4:	3f 32 17 80 	jlt.u %d2,%d3,800203f2 <tcp_receive+0x940>
800203c8:	91 00 00 28 	movh.a %a2,32768
800203cc:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
800203d0:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
800203d4:	3b 50 59 20 	mov %d2,1429
800203d8:	59 a2 04 00 	st.w [%sp]4,%d2
800203dc:	91 00 00 28 	movh.a %a2,32768
800203e0:	d9 22 88 42 	lea %a2,[%a2]10504 <80002908 <IfxCpu_Trap_vectorTable0_end+0x2714>>
800203e4:	f4 a2       	st.a [%sp],%a2
800203e6:	91 00 00 28 	movh.a %a2,32768
800203ea:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
800203ee:	6d ff a4 27 	call 80005336 <Ifx_Lwip_printf>
      off = (u16_t)off32;
800203f2:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800203f6:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
      LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
800203fa:	91 10 00 27 	movh.a %a2,28673
800203fe:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020402:	b0 42       	add.a %a2,4
80020404:	d4 22       	ld.a %a2,[%a2]
80020406:	b9 23 08 00 	ld.hu %d3,[%a2]8
8002040a:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
8002040e:	7f 23 17 80 	jge.u %d3,%d2,8002043c <tcp_receive+0x98a>
80020412:	91 00 00 28 	movh.a %a2,32768
80020416:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
8002041a:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8002041e:	3b 70 59 20 	mov %d2,1431
80020422:	59 a2 04 00 	st.w [%sp]4,%d2
80020426:	91 00 00 28 	movh.a %a2,32768
8002042a:	d9 22 97 42 	lea %a2,[%a2]10519 <80002917 <IfxCpu_Trap_vectorTable0_end+0x2723>>
8002042e:	f4 a2       	st.a [%sp],%a2
80020430:	91 00 00 28 	movh.a %a2,32768
80020434:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
80020438:	6d ff 7f 27 	call 80005336 <Ifx_Lwip_printf>
      inseg.len -= off;
8002043c:	91 10 00 27 	movh.a %a2,28673
80020440:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020444:	b9 23 08 00 	ld.hu %d3,[%a2]8 <70010008 <ram_heap+0x4f74>>
80020448:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14 <70010008 <ram_heap+0x4f74>>
8002044c:	0b 23 80 20 	sub %d2,%d3,%d2
80020450:	37 02 70 20 	extr.u %d2,%d2,0,16
80020454:	91 10 00 27 	movh.a %a2,28673
80020458:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002045c:	f9 22 08 00 	st.h [%a2]8 <70010008 <ram_heap+0x4f74>>,%d2
      new_tot_len = (u16_t)(inseg.p->tot_len - off);
80020460:	91 10 00 27 	movh.a %a2,28673
80020464:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020468:	b0 42       	add.a %a2,4
8002046a:	d4 22       	ld.a %a2,[%a2]
8002046c:	b9 23 08 00 	ld.hu %d3,[%a2]8
80020470:	c9 e2 f2 ff 	ld.h %d2,[%a14]-14
80020474:	0b 23 80 20 	sub %d2,%d3,%d2
80020478:	f9 e2 d2 ff 	st.h [%a14]-46,%d2
      while (p->len < off) {
8002047c:	1d 00 1c 00 	j 800204b4 <tcp_receive+0xa02>
        off -= p->len;
80020480:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80020484:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80020488:	c9 e3 f2 ff 	ld.h %d3,[%a14]-14
8002048c:	0b 23 80 20 	sub %d2,%d3,%d2
80020490:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
        /* all pbufs up to and including this one have len==0, so tot_len is equal */
        p->tot_len = new_tot_len;
80020494:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80020498:	c9 e2 d2 ff 	ld.h %d2,[%a14]-46
8002049c:	f9 22 08 00 	st.h [%a2]8,%d2
        p->len = 0;
800204a0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800204a4:	82 02       	mov %d2,0
800204a6:	f9 22 0a 00 	st.h [%a2]10,%d2
        p = p->next;
800204aa:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800204ae:	54 22       	ld.w %d2,[%a2]
800204b0:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      while (p->len < off) {
800204b4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800204b8:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800204bc:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
800204c0:	3f 23 e0 ff 	jlt.u %d3,%d2,80020480 <tcp_receive+0x9ce>
      }
      /* cannot fail... */
      pbuf_remove_header(p, off);
800204c4:	b9 e2 f2 ff 	ld.hu %d2,[%a14]-14
800204c8:	02 24       	mov %d4,%d2
800204ca:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800204ce:	6d ff 9f cc 	call 80019e0c <pbuf_remove_header>
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
800204d2:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800204d6:	d9 22 28 00 	lea %a2,[%a2]40
800204da:	54 22       	ld.w %d2,[%a2]
800204dc:	91 10 00 27 	movh.a %a2,28673
800204e0:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800204e4:	74 22       	st.w [%a2],%d2
800204e6:	91 10 00 27 	movh.a %a2,28673
800204ea:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
800204ee:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
800204f2:	d4 22       	ld.a %a2,[%a2]
800204f4:	91 10 00 37 	movh.a %a3,28673
800204f8:	d9 33 6c 74 	lea %a3,[%a3]17900 <700145ec <seqno>>
800204fc:	54 32       	ld.w %d2,[%a3]
800204fe:	8f f2 0f 31 	and %d3,%d2,255
80020502:	82 04       	mov %d4,0
80020504:	a6 43       	or %d3,%d4
80020506:	e9 23 04 00 	st.b [%a2]4,%d3
8002050a:	8f 82 1f 30 	sh %d3,%d2,-8
8002050e:	8f f3 0f 31 	and %d3,%d3,255
80020512:	82 04       	mov %d4,0
80020514:	a6 43       	or %d3,%d4
80020516:	e9 23 05 00 	st.b [%a2]5,%d3
8002051a:	8f 02 1f 30 	sh %d3,%d2,-16
8002051e:	8f f3 0f 31 	and %d3,%d3,255
80020522:	82 04       	mov %d4,0
80020524:	a6 43       	or %d3,%d4
80020526:	e9 23 06 00 	st.b [%a2]6,%d3
8002052a:	8f 82 1e 20 	sh %d2,%d2,-24
8002052e:	82 03       	mov %d3,0
80020530:	a6 32       	or %d2,%d3
80020532:	e9 22 07 00 	st.b [%a2]7,%d2
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
80020536:	1d 00 1c 00 	j 8002056e <tcp_receive+0xabc>
    } else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
8002053a:	91 10 00 27 	movh.a %a2,28673
8002053e:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020542:	54 23       	ld.w %d3,[%a2]
80020544:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145ec <seqno>>
80020548:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
8002054c:	54 22       	ld.w %d2,[%a2]
8002054e:	0b 23 80 20 	sub %d2,%d3,%d2
80020552:	ff 02 0e 00 	jge %d2,0,8002056e <tcp_receive+0xabc>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
80020556:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002055a:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8002055e:	8f 22 40 21 	or %d2,%d2,2
80020562:	37 02 70 20 	extr.u %d2,%d2,0,16
80020566:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002056a:	f9 22 1e 00 	st.h [%a2]30,%d2
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
8002056e:	91 10 00 27 	movh.a %a2,28673
80020572:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020576:	54 23       	ld.w %d3,[%a2]
80020578:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145ec <seqno>>
8002057c:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
80020580:	54 22       	ld.w %d2,[%a2]
80020582:	0b 23 80 20 	sub %d2,%d3,%d2
80020586:	bf 02 9b 08 	jlt %d2,0,800216bc <tcp_receive+0x1c0a>
8002058a:	91 10 00 27 	movh.a %a2,28673
8002058e:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020592:	54 23       	ld.w %d3,[%a2]
80020594:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145ec <seqno>>
80020598:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
8002059c:	54 24       	ld.w %d4,[%a2]
8002059e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145ec <seqno>>
800205a2:	b9 22 2c 00 	ld.hu %d2,[%a2]44 <700145ec <seqno>>
800205a6:	42 42       	add %d2,%d4
800205a8:	0b 23 80 20 	sub %d2,%d3,%d2
800205ac:	c2 12       	add %d2,1
800205ae:	ff 12 87 08 	jge %d2,1,800216bc <tcp_receive+0x1c0a>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
      if (pcb->rcv_nxt == seqno) {
800205b2:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800205b6:	d9 22 28 00 	lea %a2,[%a2]40
800205ba:	54 23       	ld.w %d3,[%a2]
800205bc:	91 10 00 27 	movh.a %a2,28673
800205c0:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800205c4:	54 22       	ld.w %d2,[%a2]
800205c6:	5f 23 53 85 	jne %d3,%d2,8002106c <tcp_receive+0x15ba>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
800205ca:	91 10 00 27 	movh.a %a2,28673
800205ce:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
800205d2:	b9 28 08 00 	ld.hu %d8,[%a2]8 <70010008 <ram_heap+0x4f74>>
800205d6:	91 10 00 27 	movh.a %a2,28673
800205da:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
800205de:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
800205e2:	d4 22       	ld.a %a2,[%a2]
800205e4:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
800205e8:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
800205ec:	8f 82 00 20 	sh %d2,%d2,8
800205f0:	a6 32       	or %d2,%d3
800205f2:	37 02 70 20 	extr.u %d2,%d2,0,16
800205f6:	02 24       	mov %d4,%d2
800205f8:	6d ff ae b7 	call 80017554 <lwip_htons>
800205fc:	8f f2 0f 21 	and %d2,%d2,255
80020600:	8f 32 00 21 	and %d2,%d2,3
80020604:	df 02 05 00 	jeq %d2,0,8002060e <tcp_receive+0xb5c>
80020608:	82 12       	mov %d2,1
8002060a:	1d 00 03 00 	j 80020610 <tcp_receive+0xb5e>
8002060e:	82 02       	mov %d2,0
80020610:	42 82       	add %d2,%d8
80020612:	37 02 70 20 	extr.u %d2,%d2,0,16
80020616:	91 10 00 27 	movh.a %a2,28673
8002061a:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
8002061e:	b4 22       	st.h [%a2],%d2

        if (tcplen > pcb->rcv_wnd) {
80020620:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145f6 <tcplen>>
80020624:	b9 23 2c 00 	ld.hu %d3,[%a2]44 <700145f6 <tcplen>>
80020628:	91 10 00 27 	movh.a %a2,28673
8002062c:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80020630:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80020634:	7f 23 02 81 	jge.u %d3,%d2,80020838 <tcp_receive+0xd86>
          LWIP_DEBUGF(TCP_INPUT_DEBUG,
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
80020638:	91 10 00 27 	movh.a %a2,28673
8002063c:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020640:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020644:	d4 22       	ld.a %a2,[%a2]
80020646:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
8002064a:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
8002064e:	8f 82 00 20 	sh %d2,%d2,8
80020652:	a6 32       	or %d2,%d3
80020654:	37 02 70 20 	extr.u %d2,%d2,0,16
80020658:	02 24       	mov %d4,%d2
8002065a:	6d ff 7d b7 	call 80017554 <lwip_htons>
8002065e:	8f f2 0f 21 	and %d2,%d2,255
80020662:	8f 12 00 21 	and %d2,%d2,1
80020666:	df 02 4e 00 	jeq %d2,0,80020702 <tcp_receive+0xc50>
            /* Must remove the FIN from the header as we're trimming
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
8002066a:	91 10 00 27 	movh.a %a2,28673
8002066e:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020672:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020676:	d4 22       	ld.a %a2,[%a2]
80020678:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
8002067c:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
80020680:	8f 82 00 20 	sh %d2,%d2,8
80020684:	a6 32       	or %d2,%d3
80020686:	37 02 70 20 	extr.u %d2,%d2,0,16
8002068a:	37 02 50 20 	extr %d2,%d2,0,16
8002068e:	3b f0 0f 3c 	mov %d3,-16129
80020692:	26 32       	and %d2,%d3
80020694:	37 02 50 80 	extr %d8,%d2,0,16
80020698:	91 10 00 27 	movh.a %a2,28673
8002069c:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
800206a0:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
800206a4:	d4 22       	ld.a %a2,[%a2]
800206a6:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
800206aa:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
800206ae:	8f 82 00 20 	sh %d2,%d2,8
800206b2:	a6 32       	or %d2,%d3
800206b4:	37 02 70 20 	extr.u %d2,%d2,0,16
800206b8:	02 24       	mov %d4,%d2
800206ba:	6d ff 4d b7 	call 80017554 <lwip_htons>
800206be:	8f f2 0f 21 	and %d2,%d2,255
800206c2:	8f e2 03 21 	and %d2,%d2,62
800206c6:	02 24       	mov %d4,%d2
800206c8:	6d ff 46 b7 	call 80017554 <lwip_htons>
800206cc:	37 02 50 20 	extr %d2,%d2,0,16
800206d0:	a6 82       	or %d2,%d8
800206d2:	37 02 50 20 	extr %d2,%d2,0,16
800206d6:	91 10 00 27 	movh.a %a2,28673
800206da:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
800206de:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
800206e2:	d4 22       	ld.a %a2,[%a2]
800206e4:	37 02 70 20 	extr.u %d2,%d2,0,16
800206e8:	8f f2 0f 31 	and %d3,%d2,255
800206ec:	82 04       	mov %d4,0
800206ee:	a6 43       	or %d3,%d4
800206f0:	e9 23 0c 00 	st.b [%a2]12,%d3
800206f4:	06 82       	sh %d2,-8
800206f6:	37 02 70 20 	extr.u %d2,%d2,0,16
800206fa:	82 03       	mov %d3,0
800206fc:	a6 32       	or %d2,%d3
800206fe:	e9 22 0d 00 	st.b [%a2]13,%d2
          }
          /* Adjust length of segment to fit in the window. */
          TCPWND_CHECK16(pcb->rcv_wnd);
          inseg.len = (u16_t)pcb->rcv_wnd;
80020702:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020706:	b9 22 2c 00 	ld.hu %d2,[%a2]44
8002070a:	91 10 00 27 	movh.a %a2,28673
8002070e:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020712:	f9 22 08 00 	st.h [%a2]8 <70010008 <ram_heap+0x4f74>>,%d2
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
80020716:	91 10 00 27 	movh.a %a2,28673
8002071a:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002071e:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020722:	d4 22       	ld.a %a2,[%a2]
80020724:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
80020728:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
8002072c:	8f 82 00 20 	sh %d2,%d2,8
80020730:	a6 32       	or %d2,%d3
80020732:	37 02 70 20 	extr.u %d2,%d2,0,16
80020736:	02 24       	mov %d4,%d2
80020738:	6d ff 0e b7 	call 80017554 <lwip_htons>
8002073c:	8f f2 0f 21 	and %d2,%d2,255
80020740:	8f 22 00 21 	and %d2,%d2,2
80020744:	df 02 11 00 	jeq %d2,0,80020766 <tcp_receive+0xcb4>
            inseg.len -= 1;
80020748:	91 10 00 27 	movh.a %a2,28673
8002074c:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020750:	b9 22 08 00 	ld.hu %d2,[%a2]8 <70010008 <ram_heap+0x4f74>>
80020754:	c2 f2       	add %d2,-1
80020756:	37 02 70 20 	extr.u %d2,%d2,0,16
8002075a:	91 10 00 27 	movh.a %a2,28673
8002075e:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020762:	f9 22 08 00 	st.h [%a2]8 <70010008 <ram_heap+0x4f74>>,%d2
          }
          pbuf_realloc(inseg.p, inseg.len);
80020766:	91 10 00 27 	movh.a %a2,28673
8002076a:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002076e:	b0 42       	add.a %a2,4
80020770:	54 22       	ld.w %d2,[%a2]
80020772:	91 10 00 27 	movh.a %a2,28673
80020776:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002077a:	b9 23 08 00 	ld.hu %d3,[%a2]8 <70010008 <ram_heap+0x4f74>>
8002077e:	02 34       	mov %d4,%d3
80020780:	60 24       	mov.a %a4,%d2
80020782:	6d ff bc c9 	call 80019afa <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
80020786:	91 10 00 27 	movh.a %a2,28673
8002078a:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002078e:	b9 28 08 00 	ld.hu %d8,[%a2]8 <70010008 <ram_heap+0x4f74>>
80020792:	91 10 00 27 	movh.a %a2,28673
80020796:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002079a:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
8002079e:	d4 22       	ld.a %a2,[%a2]
800207a0:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
800207a4:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
800207a8:	8f 82 00 20 	sh %d2,%d2,8
800207ac:	a6 32       	or %d2,%d3
800207ae:	37 02 70 20 	extr.u %d2,%d2,0,16
800207b2:	02 24       	mov %d4,%d2
800207b4:	6d ff d0 b6 	call 80017554 <lwip_htons>
800207b8:	8f f2 0f 21 	and %d2,%d2,255
800207bc:	8f 32 00 21 	and %d2,%d2,3
800207c0:	df 02 05 00 	jeq %d2,0,800207ca <tcp_receive+0xd18>
800207c4:	82 12       	mov %d2,1
800207c6:	1d 00 03 00 	j 800207cc <tcp_receive+0xd1a>
800207ca:	82 02       	mov %d2,0
800207cc:	42 82       	add %d2,%d8
800207ce:	37 02 70 20 	extr.u %d2,%d2,0,16
800207d2:	91 10 00 27 	movh.a %a2,28673
800207d6:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
800207da:	b4 22       	st.h [%a2],%d2
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
800207dc:	91 10 00 27 	movh.a %a2,28673
800207e0:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
800207e4:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
800207e8:	02 23       	mov %d3,%d2
800207ea:	91 10 00 27 	movh.a %a2,28673
800207ee:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800207f2:	54 22       	ld.w %d2,[%a2]
800207f4:	42 23       	add %d3,%d2
800207f6:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800207fa:	d9 22 28 00 	lea %a2,[%a2]40
800207fe:	54 24       	ld.w %d4,[%a2]
80020800:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020804:	b9 22 2c 00 	ld.hu %d2,[%a2]44
80020808:	42 42       	add %d2,%d4
8002080a:	5f 23 17 00 	jeq %d3,%d2,80020838 <tcp_receive+0xd86>
8002080e:	91 00 00 28 	movh.a %a2,32768
80020812:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
80020816:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
8002081a:	3b b0 5c 20 	mov %d2,1483
8002081e:	59 a2 04 00 	st.w [%sp]4,%d2
80020822:	91 00 00 28 	movh.a %a2,32768
80020826:	d9 22 a7 42 	lea %a2,[%a2]10535 <80002927 <IfxCpu_Trap_vectorTable0_end+0x2733>>
8002082a:	f4 a2       	st.a [%sp],%a2
8002082c:	91 00 00 28 	movh.a %a2,32768
80020830:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
80020834:	6d ff 81 25 	call 80005336 <Ifx_Lwip_printf>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
80020838:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002083c:	d9 22 38 10 	lea %a2,[%a2]120
80020840:	54 22       	ld.w %d2,[%a2]
80020842:	df 02 03 02 	jeq %d2,0,80020c48 <tcp_receive+0x1196>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
80020846:	91 10 00 27 	movh.a %a2,28673
8002084a:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002084e:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020852:	d4 22       	ld.a %a2,[%a2]
80020854:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
80020858:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
8002085c:	8f 82 00 20 	sh %d2,%d2,8
80020860:	a6 32       	or %d2,%d3
80020862:	37 02 70 20 	extr.u %d2,%d2,0,16
80020866:	02 24       	mov %d4,%d2
80020868:	6d ff 76 b6 	call 80017554 <lwip_htons>
8002086c:	8f f2 0f 21 	and %d2,%d2,255
80020870:	8f 12 00 21 	and %d2,%d2,1
80020874:	df 02 23 00 	jeq %d2,0,800208ba <tcp_receive+0xe08>
            LWIP_DEBUGF(TCP_INPUT_DEBUG,
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
80020878:	1d 00 18 00 	j 800208a8 <tcp_receive+0xdf6>
              struct tcp_seg *old_ooseq = pcb->ooseq;
8002087c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020880:	d9 22 38 10 	lea %a2,[%a2]120
80020884:	54 22       	ld.w %d2,[%a2]
80020886:	59 e2 fc ef 	st.w [%a14]-68,%d2
              pcb->ooseq = pcb->ooseq->next;
8002088a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002088e:	d9 22 38 10 	lea %a2,[%a2]120
80020892:	d4 22       	ld.a %a2,[%a2]
80020894:	54 22       	ld.w %d2,[%a2]
80020896:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002089a:	d9 22 38 10 	lea %a2,[%a2]120
8002089e:	74 22       	st.w [%a2],%d2
              tcp_seg_free(old_ooseq);
800208a0:	99 e4 fc ef 	ld.a %a4,[%a14]-68
800208a4:	6d ff 84 de 	call 8001c5ac <tcp_seg_free>
            while (pcb->ooseq != NULL) {
800208a8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800208ac:	d9 22 38 10 	lea %a2,[%a2]120
800208b0:	54 22       	ld.w %d2,[%a2]
800208b2:	df 02 e5 ff 	jne %d2,0,8002087c <tcp_receive+0xdca>
800208b6:	1d 00 c9 01 	j 80020c48 <tcp_receive+0x1196>
            }
          } else {
            struct tcp_seg *next = pcb->ooseq;
800208ba:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800208be:	d9 22 38 10 	lea %a2,[%a2]120
800208c2:	54 22       	ld.w %d2,[%a2]
800208c4:	59 e2 ec ff 	st.w [%a14]-20,%d2
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
800208c8:	1d 00 94 00 	j 800209f0 <tcp_receive+0xf3e>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              struct tcp_seg *tmp;
              /* inseg cannot have FIN here (already processed above) */
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
800208cc:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800208d0:	d9 22 10 00 	lea %a2,[%a2]16
800208d4:	d4 22       	ld.a %a2,[%a2]
800208d6:	39 23 0c 00 	ld.bu %d3,[%a2]12
800208da:	39 22 0d 00 	ld.bu %d2,[%a2]13
800208de:	8f 82 00 20 	sh %d2,%d2,8
800208e2:	a6 32       	or %d2,%d3
800208e4:	37 02 70 20 	extr.u %d2,%d2,0,16
800208e8:	02 24       	mov %d4,%d2
800208ea:	6d ff 35 b6 	call 80017554 <lwip_htons>
800208ee:	8f f2 0f 21 	and %d2,%d2,255
800208f2:	8f 12 00 21 	and %d2,%d2,1
800208f6:	df 02 70 00 	jeq %d2,0,800209d6 <tcp_receive+0xf24>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
800208fa:	91 10 00 27 	movh.a %a2,28673
800208fe:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020902:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020906:	d4 22       	ld.a %a2,[%a2]
80020908:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
8002090c:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
80020910:	8f 82 00 20 	sh %d2,%d2,8
80020914:	a6 32       	or %d2,%d3
80020916:	37 02 70 20 	extr.u %d2,%d2,0,16
8002091a:	02 24       	mov %d4,%d2
8002091c:	6d ff 1c b6 	call 80017554 <lwip_htons>
80020920:	8f f2 0f 21 	and %d2,%d2,255
80020924:	8f 22 00 21 	and %d2,%d2,2
              if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
80020928:	df 02 57 80 	jne %d2,0,800209d6 <tcp_receive+0xf24>
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
8002092c:	91 10 00 27 	movh.a %a2,28673
80020930:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020934:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020938:	d4 22       	ld.a %a2,[%a2]
8002093a:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
8002093e:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
80020942:	8f 82 00 20 	sh %d2,%d2,8
80020946:	a6 32       	or %d2,%d3
80020948:	37 02 70 80 	extr.u %d8,%d2,0,16
8002094c:	82 14       	mov %d4,1
8002094e:	6d ff 03 b6 	call 80017554 <lwip_htons>
80020952:	91 10 00 27 	movh.a %a2,28673
80020956:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
8002095a:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
8002095e:	d4 22       	ld.a %a2,[%a2]
80020960:	a6 82       	or %d2,%d8
80020962:	37 02 70 20 	extr.u %d2,%d2,0,16
80020966:	8f f2 0f 31 	and %d3,%d2,255
8002096a:	82 04       	mov %d4,0
8002096c:	a6 43       	or %d3,%d4
8002096e:	e9 23 0c 00 	st.b [%a2]12,%d3
80020972:	06 82       	sh %d2,-8
80020974:	37 02 70 20 	extr.u %d2,%d2,0,16
80020978:	82 03       	mov %d3,0
8002097a:	a6 32       	or %d2,%d3
8002097c:	e9 22 0d 00 	st.b [%a2]13,%d2
                tcplen = TCP_TCPLEN(&inseg);
80020980:	91 10 00 27 	movh.a %a2,28673
80020984:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020988:	b9 28 08 00 	ld.hu %d8,[%a2]8 <70010008 <ram_heap+0x4f74>>
8002098c:	91 10 00 27 	movh.a %a2,28673
80020990:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020994:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020998:	d4 22       	ld.a %a2,[%a2]
8002099a:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
8002099e:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
800209a2:	8f 82 00 20 	sh %d2,%d2,8
800209a6:	a6 32       	or %d2,%d3
800209a8:	37 02 70 20 	extr.u %d2,%d2,0,16
800209ac:	02 24       	mov %d4,%d2
800209ae:	6d ff d3 b5 	call 80017554 <lwip_htons>
800209b2:	8f f2 0f 21 	and %d2,%d2,255
800209b6:	8f 32 00 21 	and %d2,%d2,3
800209ba:	df 02 05 00 	jeq %d2,0,800209c4 <tcp_receive+0xf12>
800209be:	82 12       	mov %d2,1
800209c0:	1d 00 03 00 	j 800209c6 <tcp_receive+0xf14>
800209c4:	82 02       	mov %d2,0
800209c6:	42 82       	add %d2,%d8
800209c8:	37 02 70 20 	extr.u %d2,%d2,0,16
800209cc:	91 10 00 27 	movh.a %a2,28673
800209d0:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
800209d4:	b4 22       	st.h [%a2],%d2
              }
              tmp = next;
800209d6:	19 e2 ec ff 	ld.w %d2,[%a14]-20 <700145f6 <tcplen>>
800209da:	59 e2 c0 ff 	st.w [%a14]-64 <700145f6 <tcplen>>,%d2
              next = next->next;
800209de:	99 e2 ec ff 	ld.a %a2,[%a14]-20 <700145f6 <tcplen>>
800209e2:	54 22       	ld.w %d2,[%a2]
800209e4:	59 e2 ec ff 	st.w [%a14]-20 <700145f6 <tcplen>>,%d2
              tcp_seg_free(tmp);
800209e8:	99 e4 c0 ff 	ld.a %a4,[%a14]-64 <700145f6 <tcplen>>
800209ec:	6d ff e0 dd 	call 8001c5ac <tcp_seg_free>
            while (next &&
800209f0:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800209f4:	df 02 30 00 	jeq %d2,0,80020a54 <tcp_receive+0xfa2>
                   TCP_SEQ_GEQ(seqno + tcplen,
800209f8:	91 10 00 27 	movh.a %a2,28673
800209fc:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80020a00:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80020a04:	02 23       	mov %d3,%d2
80020a06:	91 10 00 27 	movh.a %a2,28673
80020a0a:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020a0e:	54 22       	ld.w %d2,[%a2]
80020a10:	0b 23 00 40 	add %d4,%d3,%d2
80020a14:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80020a18:	d9 22 10 00 	lea %a2,[%a2]16
80020a1c:	d4 22       	ld.a %a2,[%a2]
80020a1e:	39 23 04 00 	ld.bu %d3,[%a2]4
80020a22:	39 22 05 00 	ld.bu %d2,[%a2]5
80020a26:	8f 82 00 20 	sh %d2,%d2,8
80020a2a:	a6 32       	or %d2,%d3
80020a2c:	39 23 06 00 	ld.bu %d3,[%a2]6
80020a30:	8f 03 01 30 	sh %d3,%d3,16
80020a34:	a6 32       	or %d2,%d3
80020a36:	39 23 07 00 	ld.bu %d3,[%a2]7
80020a3a:	8f 83 01 30 	sh %d3,%d3,24
80020a3e:	a6 32       	or %d2,%d3
80020a40:	02 23       	mov %d3,%d2
80020a42:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80020a46:	b9 22 08 00 	ld.hu %d2,[%a2]8
80020a4a:	42 32       	add %d2,%d3
80020a4c:	0b 24 80 20 	sub %d2,%d4,%d2
            while (next &&
80020a50:	ff 02 3e 7f 	jge %d2,0,800208cc <tcp_receive+0xe1a>
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
80020a54:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80020a58:	df 02 f1 00 	jeq %d2,0,80020c3a <tcp_receive+0x1188>
                TCP_SEQ_GT(seqno + tcplen,
80020a5c:	91 10 00 27 	movh.a %a2,28673
80020a60:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80020a64:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80020a68:	02 23       	mov %d3,%d2
80020a6a:	91 10 00 27 	movh.a %a2,28673
80020a6e:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020a72:	54 22       	ld.w %d2,[%a2]
80020a74:	0b 23 00 40 	add %d4,%d3,%d2
80020a78:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80020a7c:	d9 22 10 00 	lea %a2,[%a2]16
80020a80:	d4 22       	ld.a %a2,[%a2]
80020a82:	39 23 04 00 	ld.bu %d3,[%a2]4
80020a86:	39 22 05 00 	ld.bu %d2,[%a2]5
80020a8a:	8f 82 00 20 	sh %d2,%d2,8
80020a8e:	a6 32       	or %d2,%d3
80020a90:	39 23 06 00 	ld.bu %d3,[%a2]6
80020a94:	8f 03 01 30 	sh %d3,%d3,16
80020a98:	a6 32       	or %d2,%d3
80020a9a:	39 23 07 00 	ld.bu %d3,[%a2]7
80020a9e:	8f 83 01 30 	sh %d3,%d3,24
80020aa2:	a6 32       	or %d2,%d3
80020aa4:	0b 24 80 20 	sub %d2,%d4,%d2
            if (next &&
80020aa8:	bf 12 c9 00 	jlt %d2,1,80020c3a <tcp_receive+0x1188>
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
80020aac:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80020ab0:	d9 22 10 00 	lea %a2,[%a2]16
80020ab4:	d4 22       	ld.a %a2,[%a2]
80020ab6:	39 23 04 00 	ld.bu %d3,[%a2]4
80020aba:	39 22 05 00 	ld.bu %d2,[%a2]5
80020abe:	8f 82 00 20 	sh %d2,%d2,8
80020ac2:	a6 32       	or %d2,%d3
80020ac4:	39 23 06 00 	ld.bu %d3,[%a2]6
80020ac8:	8f 03 01 30 	sh %d3,%d3,16
80020acc:	a6 32       	or %d2,%d3
80020ace:	39 23 07 00 	ld.bu %d3,[%a2]7
80020ad2:	8f 83 01 30 	sh %d3,%d3,24
80020ad6:	a6 32       	or %d2,%d3
80020ad8:	37 02 70 30 	extr.u %d3,%d2,0,16
80020adc:	91 10 00 27 	movh.a %a2,28673
80020ae0:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020ae4:	54 22       	ld.w %d2,[%a2]
80020ae6:	37 02 70 20 	extr.u %d2,%d2,0,16
80020aea:	0b 23 80 20 	sub %d2,%d3,%d2
80020aee:	37 02 70 20 	extr.u %d2,%d2,0,16
80020af2:	91 10 00 27 	movh.a %a2,28673
80020af6:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020afa:	f9 22 08 00 	st.h [%a2]8 <70010008 <ram_heap+0x4f74>>,%d2
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
80020afe:	91 10 00 27 	movh.a %a2,28673
80020b02:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020b06:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020b0a:	d4 22       	ld.a %a2,[%a2]
80020b0c:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
80020b10:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
80020b14:	8f 82 00 20 	sh %d2,%d2,8
80020b18:	a6 32       	or %d2,%d3
80020b1a:	37 02 70 20 	extr.u %d2,%d2,0,16
80020b1e:	02 24       	mov %d4,%d2
80020b20:	6d ff 1a b5 	call 80017554 <lwip_htons>
80020b24:	8f f2 0f 21 	and %d2,%d2,255
80020b28:	8f 22 00 21 	and %d2,%d2,2
80020b2c:	df 02 11 00 	jeq %d2,0,80020b4e <tcp_receive+0x109c>
                inseg.len -= 1;
80020b30:	91 10 00 27 	movh.a %a2,28673
80020b34:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020b38:	b9 22 08 00 	ld.hu %d2,[%a2]8 <70010008 <ram_heap+0x4f74>>
80020b3c:	c2 f2       	add %d2,-1
80020b3e:	37 02 70 20 	extr.u %d2,%d2,0,16
80020b42:	91 10 00 27 	movh.a %a2,28673
80020b46:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020b4a:	f9 22 08 00 	st.h [%a2]8 <70010008 <ram_heap+0x4f74>>,%d2
              }
              pbuf_realloc(inseg.p, inseg.len);
80020b4e:	91 10 00 27 	movh.a %a2,28673
80020b52:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020b56:	b0 42       	add.a %a2,4
80020b58:	54 22       	ld.w %d2,[%a2]
80020b5a:	91 10 00 27 	movh.a %a2,28673
80020b5e:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020b62:	b9 23 08 00 	ld.hu %d3,[%a2]8 <70010008 <ram_heap+0x4f74>>
80020b66:	02 34       	mov %d4,%d3
80020b68:	60 24       	mov.a %a4,%d2
80020b6a:	6d ff c8 c7 	call 80019afa <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
80020b6e:	91 10 00 27 	movh.a %a2,28673
80020b72:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020b76:	b9 28 08 00 	ld.hu %d8,[%a2]8 <70010008 <ram_heap+0x4f74>>
80020b7a:	91 10 00 27 	movh.a %a2,28673
80020b7e:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020b82:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020b86:	d4 22       	ld.a %a2,[%a2]
80020b88:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
80020b8c:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
80020b90:	8f 82 00 20 	sh %d2,%d2,8
80020b94:	a6 32       	or %d2,%d3
80020b96:	37 02 70 20 	extr.u %d2,%d2,0,16
80020b9a:	02 24       	mov %d4,%d2
80020b9c:	6d ff dc b4 	call 80017554 <lwip_htons>
80020ba0:	8f f2 0f 21 	and %d2,%d2,255
80020ba4:	8f 32 00 21 	and %d2,%d2,3
80020ba8:	df 02 05 00 	jeq %d2,0,80020bb2 <tcp_receive+0x1100>
80020bac:	82 12       	mov %d2,1
80020bae:	1d 00 03 00 	j 80020bb4 <tcp_receive+0x1102>
80020bb2:	82 02       	mov %d2,0
80020bb4:	42 82       	add %d2,%d8
80020bb6:	37 02 70 20 	extr.u %d2,%d2,0,16
80020bba:	91 10 00 27 	movh.a %a2,28673
80020bbe:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80020bc2:	b4 22       	st.h [%a2],%d2
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
80020bc4:	91 10 00 27 	movh.a %a2,28673
80020bc8:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80020bcc:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80020bd0:	02 23       	mov %d3,%d2
80020bd2:	91 10 00 27 	movh.a %a2,28673
80020bd6:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020bda:	54 22       	ld.w %d2,[%a2]
80020bdc:	0b 23 00 40 	add %d4,%d3,%d2
80020be0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80020be4:	d9 22 10 00 	lea %a2,[%a2]16
80020be8:	d4 22       	ld.a %a2,[%a2]
80020bea:	39 23 04 00 	ld.bu %d3,[%a2]4
80020bee:	39 22 05 00 	ld.bu %d2,[%a2]5
80020bf2:	8f 82 00 20 	sh %d2,%d2,8
80020bf6:	a6 32       	or %d2,%d3
80020bf8:	39 23 06 00 	ld.bu %d3,[%a2]6
80020bfc:	8f 03 01 30 	sh %d3,%d3,16
80020c00:	a6 32       	or %d2,%d3
80020c02:	39 23 07 00 	ld.bu %d3,[%a2]7
80020c06:	8f 83 01 30 	sh %d3,%d3,24
80020c0a:	a6 32       	or %d2,%d3
80020c0c:	5f 24 17 00 	jeq %d4,%d2,80020c3a <tcp_receive+0x1188>
80020c10:	91 00 00 28 	movh.a %a2,32768
80020c14:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
80020c18:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
80020c1c:	3b c0 5f 20 	mov %d2,1532
80020c20:	59 a2 04 00 	st.w [%sp]4,%d2
80020c24:	91 00 00 28 	movh.a %a2,32768
80020c28:	d9 22 9e 52 	lea %a2,[%a2]10590 <8000295e <IfxCpu_Trap_vectorTable0_end+0x276a>>
80020c2c:	f4 a2       	st.a [%sp],%a2
80020c2e:	91 00 00 28 	movh.a %a2,32768
80020c32:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
80020c36:	6d ff 80 23 	call 80005336 <Ifx_Lwip_printf>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
80020c3a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020c3e:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80020c42:	d9 22 38 10 	lea %a2,[%a2]120
80020c46:	74 22       	st.w [%a2],%d2
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
80020c48:	91 10 00 27 	movh.a %a2,28673
80020c4c:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80020c50:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80020c54:	02 23       	mov %d3,%d2
80020c56:	91 10 00 27 	movh.a %a2,28673
80020c5a:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020c5e:	54 22       	ld.w %d2,[%a2]
80020c60:	42 32       	add %d2,%d3
80020c62:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020c66:	d9 22 28 00 	lea %a2,[%a2]40
80020c6a:	74 22       	st.w [%a2],%d2

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
80020c6c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020c70:	b9 23 2c 00 	ld.hu %d3,[%a2]44
80020c74:	91 10 00 27 	movh.a %a2,28673
80020c78:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80020c7c:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80020c80:	7f 23 17 80 	jge.u %d3,%d2,80020cae <tcp_receive+0x11fc>
80020c84:	91 00 00 28 	movh.a %a2,32768
80020c88:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
80020c8c:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
80020c90:	3b 70 60 20 	mov %d2,1543
80020c94:	59 a2 04 00 	st.w [%sp]4,%d2
80020c98:	91 00 00 28 	movh.a %a2,32768
80020c9c:	d9 22 99 62 	lea %a2,[%a2]10649 <80002999 <IfxCpu_Trap_vectorTable0_end+0x27a5>>
80020ca0:	f4 a2       	st.a [%sp],%a2
80020ca2:	91 00 00 28 	movh.a %a2,32768
80020ca6:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
80020caa:	6d ff 46 23 	call 80005336 <Ifx_Lwip_printf>
        pcb->rcv_wnd -= tcplen;
80020cae:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020cb2:	b9 23 2c 00 	ld.hu %d3,[%a2]44
80020cb6:	91 10 00 27 	movh.a %a2,28673
80020cba:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80020cbe:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80020cc2:	0b 23 80 20 	sub %d2,%d3,%d2
80020cc6:	37 02 70 20 	extr.u %d2,%d2,0,16
80020cca:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020cce:	f9 22 2c 00 	st.h [%a2]44,%d2

        tcp_update_rcv_ann_wnd(pcb);
80020cd2:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
80020cd6:	6d ff 66 d4 	call 8001b5a2 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
80020cda:	91 10 00 27 	movh.a %a2,28673
80020cde:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020ce2:	b0 42       	add.a %a2,4
80020ce4:	d4 22       	ld.a %a2,[%a2]
80020ce6:	b9 22 08 00 	ld.hu %d2,[%a2]8
80020cea:	df 02 14 00 	jeq %d2,0,80020d12 <tcp_receive+0x1260>
          recv_data = inseg.p;
80020cee:	91 10 00 27 	movh.a %a2,28673
80020cf2:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020cf6:	b0 42       	add.a %a2,4
80020cf8:	54 22       	ld.w %d2,[%a2]
80020cfa:	91 10 00 27 	movh.a %a2,28673
80020cfe:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
80020d02:	74 22       	st.w [%a2],%d2
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
80020d04:	91 10 00 27 	movh.a %a2,28673
80020d08:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020d0c:	82 02       	mov %d2,0
80020d0e:	b0 42       	add.a %a2,4
80020d10:	74 22       	st.w [%a2],%d2
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
80020d12:	91 10 00 27 	movh.a %a2,28673
80020d16:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
80020d1a:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
80020d1e:	d4 22       	ld.a %a2,[%a2]
80020d20:	39 23 0c 00 	ld.bu %d3,[%a2]12 <70010010 <ram_heap+0x4f7c>>
80020d24:	39 22 0d 00 	ld.bu %d2,[%a2]13 <70010010 <ram_heap+0x4f7c>>
80020d28:	8f 82 00 20 	sh %d2,%d2,8
80020d2c:	a6 32       	or %d2,%d3
80020d2e:	37 02 70 20 	extr.u %d2,%d2,0,16
80020d32:	02 24       	mov %d4,%d2
80020d34:	6d ff 10 b4 	call 80017554 <lwip_htons>
80020d38:	8f f2 0f 21 	and %d2,%d2,255
80020d3c:	8f 12 00 21 	and %d2,%d2,1
80020d40:	df 02 3e 01 	jeq %d2,0,80020fbc <tcp_receive+0x150a>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
80020d44:	91 10 00 27 	movh.a %a2,28673
80020d48:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
80020d4c:	14 22       	ld.bu %d2,[%a2]
80020d4e:	8f 02 42 21 	or %d2,%d2,32
80020d52:	8f f2 0f 21 	and %d2,%d2,255
80020d56:	91 10 00 27 	movh.a %a2,28673
80020d5a:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
80020d5e:	34 22       	st.b [%a2],%d2
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
80020d60:	1d 00 2e 01 	j 80020fbc <tcp_receive+0x150a>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          struct tcp_seg *cseg = pcb->ooseq;
80020d64:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020d68:	d9 22 38 10 	lea %a2,[%a2]120
80020d6c:	54 22       	ld.w %d2,[%a2]
80020d6e:	59 e2 f8 ef 	st.w [%a14]-72,%d2
          seqno = pcb->ooseq->tcphdr->seqno;
80020d72:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020d76:	d9 22 38 10 	lea %a2,[%a2]120
80020d7a:	d4 22       	ld.a %a2,[%a2]
80020d7c:	d9 22 10 00 	lea %a2,[%a2]16
80020d80:	d4 22       	ld.a %a2,[%a2]
80020d82:	39 23 04 00 	ld.bu %d3,[%a2]4
80020d86:	39 22 05 00 	ld.bu %d2,[%a2]5
80020d8a:	8f 82 00 20 	sh %d2,%d2,8
80020d8e:	a6 32       	or %d2,%d3
80020d90:	39 23 06 00 	ld.bu %d3,[%a2]6
80020d94:	8f 03 01 30 	sh %d3,%d3,16
80020d98:	a6 32       	or %d2,%d3
80020d9a:	39 23 07 00 	ld.bu %d3,[%a2]7
80020d9e:	8f 83 01 30 	sh %d3,%d3,24
80020da2:	a6 32       	or %d2,%d3
80020da4:	91 10 00 27 	movh.a %a2,28673
80020da8:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80020dac:	74 22       	st.w [%a2],%d2

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
80020dae:	99 e2 f8 ef 	ld.a %a2,[%a14]-72 <700145ec <seqno>>
80020db2:	b9 22 08 00 	ld.hu %d2,[%a2]8 <700145ec <seqno>>
80020db6:	02 28       	mov %d8,%d2
80020db8:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020dbc:	d9 22 10 00 	lea %a2,[%a2]16
80020dc0:	d4 22       	ld.a %a2,[%a2]
80020dc2:	39 23 0c 00 	ld.bu %d3,[%a2]12
80020dc6:	39 22 0d 00 	ld.bu %d2,[%a2]13
80020dca:	8f 82 00 20 	sh %d2,%d2,8
80020dce:	a6 32       	or %d2,%d3
80020dd0:	37 02 70 20 	extr.u %d2,%d2,0,16
80020dd4:	02 24       	mov %d4,%d2
80020dd6:	6d ff bf b3 	call 80017554 <lwip_htons>
80020dda:	8f f2 0f 21 	and %d2,%d2,255
80020dde:	8f 32 00 21 	and %d2,%d2,3
80020de2:	df 02 05 00 	jeq %d2,0,80020dec <tcp_receive+0x133a>
80020de6:	82 12       	mov %d2,1
80020de8:	1d 00 03 00 	j 80020dee <tcp_receive+0x133c>
80020dec:	82 02       	mov %d2,0
80020dee:	0b 82 00 30 	add %d3,%d2,%d8
80020df2:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020df6:	d9 22 28 00 	lea %a2,[%a2]40
80020dfa:	54 22       	ld.w %d2,[%a2]
80020dfc:	42 32       	add %d2,%d3
80020dfe:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020e02:	d9 22 28 00 	lea %a2,[%a2]40
80020e06:	74 22       	st.w [%a2],%d2
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
80020e08:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020e0c:	b9 22 2c 00 	ld.hu %d2,[%a2]44
80020e10:	02 28       	mov %d8,%d2
80020e12:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020e16:	b9 22 08 00 	ld.hu %d2,[%a2]8
80020e1a:	02 29       	mov %d9,%d2
80020e1c:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020e20:	d9 22 10 00 	lea %a2,[%a2]16
80020e24:	d4 22       	ld.a %a2,[%a2]
80020e26:	39 23 0c 00 	ld.bu %d3,[%a2]12
80020e2a:	39 22 0d 00 	ld.bu %d2,[%a2]13
80020e2e:	8f 82 00 20 	sh %d2,%d2,8
80020e32:	a6 32       	or %d2,%d3
80020e34:	37 02 70 20 	extr.u %d2,%d2,0,16
80020e38:	02 24       	mov %d4,%d2
80020e3a:	6d ff 8d b3 	call 80017554 <lwip_htons>
80020e3e:	8f f2 0f 21 	and %d2,%d2,255
80020e42:	8f 32 00 21 	and %d2,%d2,3
80020e46:	df 02 05 00 	jeq %d2,0,80020e50 <tcp_receive+0x139e>
80020e4a:	82 12       	mov %d2,1
80020e4c:	1d 00 03 00 	j 80020e52 <tcp_receive+0x13a0>
80020e50:	82 02       	mov %d2,0
80020e52:	42 92       	add %d2,%d9
80020e54:	7f 28 17 80 	jge.u %d8,%d2,80020e82 <tcp_receive+0x13d0>
80020e58:	91 00 00 28 	movh.a %a2,32768
80020e5c:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
80020e60:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
80020e64:	3b b0 62 20 	mov %d2,1579
80020e68:	59 a2 04 00 	st.w [%sp]4,%d2
80020e6c:	91 00 00 28 	movh.a %a2,32768
80020e70:	d9 22 b8 62 	lea %a2,[%a2]10680 <800029b8 <IfxCpu_Trap_vectorTable0_end+0x27c4>>
80020e74:	f4 a2       	st.a [%sp],%a2
80020e76:	91 00 00 28 	movh.a %a2,32768
80020e7a:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
80020e7e:	6d ff 5c 22 	call 80005336 <Ifx_Lwip_printf>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
80020e82:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020e86:	b9 22 08 00 	ld.hu %d2,[%a2]8
80020e8a:	02 28       	mov %d8,%d2
80020e8c:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020e90:	d9 22 10 00 	lea %a2,[%a2]16
80020e94:	d4 22       	ld.a %a2,[%a2]
80020e96:	39 23 0c 00 	ld.bu %d3,[%a2]12
80020e9a:	39 22 0d 00 	ld.bu %d2,[%a2]13
80020e9e:	8f 82 00 20 	sh %d2,%d2,8
80020ea2:	a6 32       	or %d2,%d3
80020ea4:	37 02 70 20 	extr.u %d2,%d2,0,16
80020ea8:	02 24       	mov %d4,%d2
80020eaa:	6d ff 55 b3 	call 80017554 <lwip_htons>
80020eae:	8f f2 0f 21 	and %d2,%d2,255
80020eb2:	8f 32 00 21 	and %d2,%d2,3
80020eb6:	df 02 05 00 	jeq %d2,0,80020ec0 <tcp_receive+0x140e>
80020eba:	82 12       	mov %d2,1
80020ebc:	1d 00 03 00 	j 80020ec2 <tcp_receive+0x1410>
80020ec0:	82 02       	mov %d2,0
80020ec2:	42 82       	add %d2,%d8
80020ec4:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020ec8:	b9 23 2c 00 	ld.hu %d3,[%a2]44
80020ecc:	37 02 70 20 	extr.u %d2,%d2,0,16
80020ed0:	0b 23 80 20 	sub %d2,%d3,%d2
80020ed4:	37 02 70 20 	extr.u %d2,%d2,0,16
80020ed8:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020edc:	f9 22 2c 00 	st.h [%a2]44,%d2

          tcp_update_rcv_ann_wnd(pcb);
80020ee0:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
80020ee4:	6d ff 5f d3 	call 8001b5a2 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
80020ee8:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020eec:	b0 42       	add.a %a2,4
80020eee:	d4 22       	ld.a %a2,[%a2]
80020ef0:	b9 22 08 00 	ld.hu %d2,[%a2]8
80020ef4:	df 02 26 00 	jeq %d2,0,80020f40 <tcp_receive+0x148e>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            /* With window scaling, this can overflow recv_data->tot_len, but
               that's not a problem since we explicitly fix that before passing
               recv_data to the application. */
            if (recv_data) {
80020ef8:	91 10 00 27 	movh.a %a2,28673
80020efc:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
80020f00:	54 22       	ld.w %d2,[%a2]
80020f02:	df 02 11 00 	jeq %d2,0,80020f24 <tcp_receive+0x1472>
              pbuf_cat(recv_data, cseg->p);
80020f06:	91 10 00 27 	movh.a %a2,28673
80020f0a:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
80020f0e:	54 22       	ld.w %d2,[%a2]
80020f10:	99 e2 f8 ef 	ld.a %a2,[%a14]-72 <700145fc <recv_data>>
80020f14:	b0 42       	add.a %a2,4
80020f16:	54 23       	ld.w %d3,[%a2]
80020f18:	60 35       	mov.a %a5,%d3
80020f1a:	60 24       	mov.a %a4,%d2
80020f1c:	6d ff 6b c9 	call 8001a1f2 <pbuf_cat>
80020f20:	1d 00 0b 00 	j 80020f36 <tcp_receive+0x1484>
            } else {
              recv_data = cseg->p;
80020f24:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020f28:	b0 42       	add.a %a2,4
80020f2a:	54 22       	ld.w %d2,[%a2]
80020f2c:	91 10 00 27 	movh.a %a2,28673
80020f30:	d9 22 7c 74 	lea %a2,[%a2]17916 <700145fc <recv_data>>
80020f34:	74 22       	st.w [%a2],%d2
            }
            cseg->p = NULL;
80020f36:	99 e2 f8 ef 	ld.a %a2,[%a14]-72 <700145fc <recv_data>>
80020f3a:	82 02       	mov %d2,0
80020f3c:	b0 42       	add.a %a2,4
80020f3e:	74 22       	st.w [%a2],%d2
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
80020f40:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020f44:	d9 22 10 00 	lea %a2,[%a2]16
80020f48:	d4 22       	ld.a %a2,[%a2]
80020f4a:	39 23 0c 00 	ld.bu %d3,[%a2]12
80020f4e:	39 22 0d 00 	ld.bu %d2,[%a2]13
80020f52:	8f 82 00 20 	sh %d2,%d2,8
80020f56:	a6 32       	or %d2,%d3
80020f58:	37 02 70 20 	extr.u %d2,%d2,0,16
80020f5c:	02 24       	mov %d4,%d2
80020f5e:	6d ff fb b2 	call 80017554 <lwip_htons>
80020f62:	8f f2 0f 21 	and %d2,%d2,255
80020f66:	8f 12 00 21 	and %d2,%d2,1
80020f6a:	df 02 1d 00 	jeq %d2,0,80020fa4 <tcp_receive+0x14f2>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
80020f6e:	91 10 00 27 	movh.a %a2,28673
80020f72:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
80020f76:	14 22       	ld.bu %d2,[%a2]
80020f78:	8f 02 42 21 	or %d2,%d2,32
80020f7c:	8f f2 0f 21 	and %d2,%d2,255
80020f80:	91 10 00 27 	movh.a %a2,28673
80020f84:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
80020f88:	34 22       	st.b [%a2],%d2
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
80020f8a:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145f9 <recv_flags>>
80020f8e:	d9 22 14 00 	lea %a2,[%a2]20 <700145f9 <recv_flags>>
80020f92:	54 22       	ld.w %d2,[%a2]
80020f94:	df 42 08 80 	jne %d2,4,80020fa4 <tcp_receive+0x14f2>
              pcb->state = CLOSE_WAIT;
80020f98:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020f9c:	82 72       	mov %d2,7
80020f9e:	d9 22 14 00 	lea %a2,[%a2]20
80020fa2:	74 22       	st.w [%a2],%d2
            }
          }

          pcb->ooseq = cseg->next;
80020fa4:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
80020fa8:	54 22       	ld.w %d2,[%a2]
80020faa:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020fae:	d9 22 38 10 	lea %a2,[%a2]120
80020fb2:	74 22       	st.w [%a2],%d2
          tcp_seg_free(cseg);
80020fb4:	99 e4 f8 ef 	ld.a %a4,[%a14]-72
80020fb8:	6d ff fa da 	call 8001c5ac <tcp_seg_free>
        while (pcb->ooseq != NULL &&
80020fbc:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020fc0:	d9 22 38 10 	lea %a2,[%a2]120
80020fc4:	54 22       	ld.w %d2,[%a2]
80020fc6:	df 02 23 00 	jeq %d2,0,8002100c <tcp_receive+0x155a>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
80020fca:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80020fce:	d9 22 38 10 	lea %a2,[%a2]120
80020fd2:	d4 22       	ld.a %a2,[%a2]
80020fd4:	d9 22 10 00 	lea %a2,[%a2]16
80020fd8:	d4 22       	ld.a %a2,[%a2]
80020fda:	39 23 04 00 	ld.bu %d3,[%a2]4
80020fde:	39 22 05 00 	ld.bu %d2,[%a2]5
80020fe2:	8f 82 00 20 	sh %d2,%d2,8
80020fe6:	a6 32       	or %d2,%d3
80020fe8:	39 23 06 00 	ld.bu %d3,[%a2]6
80020fec:	8f 03 01 30 	sh %d3,%d3,16
80020ff0:	a6 32       	or %d2,%d3
80020ff2:	39 23 07 00 	ld.bu %d3,[%a2]7
80020ff6:	8f 83 01 30 	sh %d3,%d3,24
80020ffa:	a6 32       	or %d2,%d3
80020ffc:	02 23       	mov %d3,%d2
80020ffe:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021002:	d9 22 28 00 	lea %a2,[%a2]40
80021006:	54 22       	ld.w %d2,[%a2]
        while (pcb->ooseq != NULL &&
80021008:	5f 23 ae 7e 	jeq %d3,%d2,80020d64 <tcp_receive+0x12b2>
#endif /* LWIP_TCP_SACK_OUT */
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
8002100c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021010:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80021014:	8f 12 00 21 	and %d2,%d2,1
80021018:	df 02 1c 00 	jeq %d2,0,80021050 <tcp_receive+0x159e>
8002101c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021020:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80021024:	8f 12 c0 21 	andn %d2,%d2,1
80021028:	37 02 70 20 	extr.u %d2,%d2,0,16
8002102c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021030:	f9 22 1e 00 	st.h [%a2]30,%d2
80021034:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021038:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8002103c:	8f 22 40 21 	or %d2,%d2,2
80021040:	37 02 70 20 	extr.u %d2,%d2,0,16
80021044:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021048:	f9 22 1e 00 	st.h [%a2]30,%d2
      if (pcb->rcv_nxt == seqno) {
8002104c:	1d 00 3e 03 	j 800216c8 <tcp_receive+0x1c16>
        tcp_ack(pcb);
80021050:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021054:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80021058:	8f 12 40 21 	or %d2,%d2,1
8002105c:	37 02 70 20 	extr.u %d2,%d2,0,16
80021060:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021064:	f9 22 1e 00 	st.h [%a2]30,%d2
      if (pcb->rcv_nxt == seqno) {
80021068:	1d 00 30 03 	j 800216c8 <tcp_receive+0x1c16>
      } else {
        /* We get here if the incoming segment is out-of-sequence. */

#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
8002106c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021070:	d9 22 38 10 	lea %a2,[%a2]120
80021074:	54 22       	ld.w %d2,[%a2]
80021076:	df 02 10 80 	jne %d2,0,80021096 <tcp_receive+0x15e4>
          pcb->ooseq = tcp_seg_copy(&inseg);
8002107a:	91 10 00 27 	movh.a %a2,28673
8002107e:	d9 24 48 74 	lea %a4,[%a2]17864 <700145c8 <inseg>>
80021082:	6d ff b1 da 	call 8001c5e4 <tcp_seg_copy>
80021086:	80 22       	mov.d %d2,%a2
80021088:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
8002108c:	d9 22 38 10 	lea %a2,[%a2]120
80021090:	74 22       	st.w [%a2],%d2
80021092:	1d 00 0f 03 	j 800216b0 <tcp_receive+0x1bfe>
#if LWIP_TCP_SACK_OUT
          /* This is the left edge of the lowest possible SACK range.
             It may start before the newly received segment (possibly adjusted below). */
          u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
#endif /* LWIP_TCP_SACK_OUT */
          struct tcp_seg *next, *prev = NULL;
80021096:	82 02       	mov %d2,0
80021098:	59 e2 e4 ff 	st.w [%a14]-28,%d2
          for (next = pcb->ooseq; next != NULL; next = next->next) {
8002109c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800210a0:	d9 22 38 10 	lea %a2,[%a2]120
800210a4:	54 22       	ld.w %d2,[%a2]
800210a6:	59 e2 e8 ff 	st.w [%a14]-24,%d2
800210aa:	1d 00 ed 02 	j 80021684 <tcp_receive+0x1bd2>
            if (seqno == next->tcphdr->seqno) {
800210ae:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800210b2:	d9 22 10 00 	lea %a2,[%a2]16
800210b6:	d4 22       	ld.a %a2,[%a2]
800210b8:	39 23 04 00 	ld.bu %d3,[%a2]4
800210bc:	39 22 05 00 	ld.bu %d2,[%a2]5
800210c0:	8f 82 00 20 	sh %d2,%d2,8
800210c4:	a6 32       	or %d2,%d3
800210c6:	39 23 06 00 	ld.bu %d3,[%a2]6
800210ca:	8f 03 01 30 	sh %d3,%d3,16
800210ce:	a6 32       	or %d2,%d3
800210d0:	39 23 07 00 	ld.bu %d3,[%a2]7
800210d4:	8f 83 01 30 	sh %d3,%d3,24
800210d8:	a6 32       	or %d2,%d3
800210da:	02 23       	mov %d3,%d2
800210dc:	91 10 00 27 	movh.a %a2,28673
800210e0:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800210e4:	54 22       	ld.w %d2,[%a2]
800210e6:	5f 23 34 80 	jne %d3,%d2,8002114e <tcp_receive+0x169c>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
800210ea:	91 10 00 27 	movh.a %a2,28673
800210ee:	d9 22 48 74 	lea %a2,[%a2]17864 <700145c8 <inseg>>
800210f2:	b9 22 08 00 	ld.hu %d2,[%a2]8 <70010008 <ram_heap+0x4f74>>
800210f6:	99 e2 e8 ff 	ld.a %a2,[%a14]-24 <70010008 <ram_heap+0x4f74>>
800210fa:	b9 23 08 00 	ld.hu %d3,[%a2]8 <70010008 <ram_heap+0x4f74>>
800210fe:	7f 23 c9 82 	jge.u %d3,%d2,80021690 <tcp_receive+0x1bde>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                struct tcp_seg *cseg = tcp_seg_copy(&inseg);
80021102:	91 10 00 27 	movh.a %a2,28673
80021106:	d9 24 48 74 	lea %a4,[%a2]17864 <700145c8 <inseg>>
8002110a:	6d ff 6d da 	call 8001c5e4 <tcp_seg_copy>
8002110e:	b5 e2 c4 ff 	st.a [%a14]-60,%a2
                if (cseg != NULL) {
80021112:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80021116:	df 02 c0 02 	jeq %d2,0,80021696 <tcp_receive+0x1be4>
                  if (prev != NULL) {
8002111a:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8002111e:	df 02 09 00 	jeq %d2,0,80021130 <tcp_receive+0x167e>
                    prev->next = cseg;
80021122:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80021126:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
8002112a:	74 22       	st.w [%a2],%d2
8002112c:	1d 00 09 00 	j 8002113e <tcp_receive+0x168c>
                  } else {
                    pcb->ooseq = cseg;
80021130:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021134:	19 e2 c4 ff 	ld.w %d2,[%a14]-60
80021138:	d9 22 38 10 	lea %a2,[%a2]120
8002113c:	74 22       	st.w [%a2],%d2
                  }
                  tcp_oos_insert_segment(cseg, next);
8002113e:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
80021142:	99 e4 c4 ff 	ld.a %a4,[%a14]-60
80021146:	6d ff c9 f2 	call 8001f6d8 <tcp_oos_insert_segment>
                }
                break;
8002114a:	1d 00 a6 02 	j 80021696 <tcp_receive+0x1be4>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
8002114e:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80021152:	df 02 3c 80 	jne %d2,0,800211ca <tcp_receive+0x1718>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
80021156:	91 10 00 27 	movh.a %a2,28673
8002115a:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8002115e:	54 24       	ld.w %d4,[%a2]
80021160:	99 e2 e8 ff 	ld.a %a2,[%a14]-24 <700145ec <seqno>>
80021164:	d9 22 10 00 	lea %a2,[%a2]16 <700145ec <seqno>>
80021168:	d4 22       	ld.a %a2,[%a2]
8002116a:	39 23 04 00 	ld.bu %d3,[%a2]4 <700145ec <seqno>>
8002116e:	39 22 05 00 	ld.bu %d2,[%a2]5 <700145ec <seqno>>
80021172:	8f 82 00 20 	sh %d2,%d2,8
80021176:	a6 32       	or %d2,%d3
80021178:	39 23 06 00 	ld.bu %d3,[%a2]6
8002117c:	8f 03 01 30 	sh %d3,%d3,16
80021180:	a6 32       	or %d2,%d3
80021182:	39 23 07 00 	ld.bu %d3,[%a2]7
80021186:	8f 83 01 30 	sh %d3,%d3,24
8002118a:	a6 32       	or %d2,%d3
8002118c:	0b 24 80 20 	sub %d2,%d4,%d2
80021190:	ff 02 ce 00 	jge %d2,0,8002132c <tcp_receive+0x187a>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
80021194:	91 10 00 27 	movh.a %a2,28673
80021198:	d9 24 48 74 	lea %a4,[%a2]17864 <700145c8 <inseg>>
8002119c:	6d ff 24 da 	call 8001c5e4 <tcp_seg_copy>
800211a0:	b5 e2 c8 ff 	st.a [%a14]-56,%a2
                  if (cseg != NULL) {
800211a4:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
800211a8:	df 02 7a 02 	jeq %d2,0,8002169c <tcp_receive+0x1bea>
                    pcb->ooseq = cseg;
800211ac:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800211b0:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
800211b4:	d9 22 38 10 	lea %a2,[%a2]120
800211b8:	74 22       	st.w [%a2],%d2
                    tcp_oos_insert_segment(cseg, next);
800211ba:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
800211be:	99 e4 c8 ff 	ld.a %a4,[%a14]-56
800211c2:	6d ff 8b f2 	call 8001f6d8 <tcp_oos_insert_segment>
                  }
                  break;
800211c6:	1d 00 6b 02 	j 8002169c <tcp_receive+0x1bea>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
800211ca:	91 10 00 27 	movh.a %a2,28673
800211ce:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800211d2:	54 24       	ld.w %d4,[%a2]
800211d4:	99 e2 e4 ff 	ld.a %a2,[%a14]-28 <700145ec <seqno>>
800211d8:	d9 22 10 00 	lea %a2,[%a2]16 <700145ec <seqno>>
800211dc:	d4 22       	ld.a %a2,[%a2]
800211de:	39 23 04 00 	ld.bu %d3,[%a2]4 <700145ec <seqno>>
800211e2:	39 22 05 00 	ld.bu %d2,[%a2]5 <700145ec <seqno>>
800211e6:	8f 82 00 20 	sh %d2,%d2,8
800211ea:	a6 32       	or %d2,%d3
800211ec:	39 23 06 00 	ld.bu %d3,[%a2]6
800211f0:	8f 03 01 30 	sh %d3,%d3,16
800211f4:	a6 32       	or %d2,%d3
800211f6:	39 23 07 00 	ld.bu %d3,[%a2]7
800211fa:	8f 83 01 30 	sh %d3,%d3,24
800211fe:	a6 32       	or %d2,%d3
80021200:	0b 24 80 20 	sub %d2,%d4,%d2
80021204:	c2 f2       	add %d2,-1
80021206:	bf 02 93 00 	jlt %d2,0,8002132c <tcp_receive+0x187a>
8002120a:	91 10 00 27 	movh.a %a2,28673
8002120e:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80021212:	54 24       	ld.w %d4,[%a2]
80021214:	99 e2 e8 ff 	ld.a %a2,[%a14]-24 <700145ec <seqno>>
80021218:	d9 22 10 00 	lea %a2,[%a2]16 <700145ec <seqno>>
8002121c:	d4 22       	ld.a %a2,[%a2]
8002121e:	39 23 04 00 	ld.bu %d3,[%a2]4 <700145ec <seqno>>
80021222:	39 22 05 00 	ld.bu %d2,[%a2]5 <700145ec <seqno>>
80021226:	8f 82 00 20 	sh %d2,%d2,8
8002122a:	a6 32       	or %d2,%d3
8002122c:	39 23 06 00 	ld.bu %d3,[%a2]6
80021230:	8f 03 01 30 	sh %d3,%d3,16
80021234:	a6 32       	or %d2,%d3
80021236:	39 23 07 00 	ld.bu %d3,[%a2]7
8002123a:	8f 83 01 30 	sh %d3,%d3,24
8002123e:	a6 32       	or %d2,%d3
80021240:	0b 24 80 20 	sub %d2,%d4,%d2
80021244:	c2 12       	add %d2,1
80021246:	ff 12 73 00 	jge %d2,1,8002132c <tcp_receive+0x187a>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  struct tcp_seg *cseg = tcp_seg_copy(&inseg);
8002124a:	91 10 00 27 	movh.a %a2,28673
8002124e:	d9 24 48 74 	lea %a4,[%a2]17864 <700145c8 <inseg>>
80021252:	6d ff c9 d9 	call 8001c5e4 <tcp_seg_copy>
80021256:	b5 e2 cc ff 	st.a [%a14]-52,%a2
                  if (cseg != NULL) {
8002125a:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8002125e:	df 02 22 02 	jeq %d2,0,800216a2 <tcp_receive+0x1bf0>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
80021262:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80021266:	d9 22 10 00 	lea %a2,[%a2]16
8002126a:	d4 22       	ld.a %a2,[%a2]
8002126c:	39 23 04 00 	ld.bu %d3,[%a2]4
80021270:	39 22 05 00 	ld.bu %d2,[%a2]5
80021274:	8f 82 00 20 	sh %d2,%d2,8
80021278:	a6 32       	or %d2,%d3
8002127a:	39 23 06 00 	ld.bu %d3,[%a2]6
8002127e:	8f 03 01 30 	sh %d3,%d3,16
80021282:	a6 32       	or %d2,%d3
80021284:	39 23 07 00 	ld.bu %d3,[%a2]7
80021288:	8f 83 01 30 	sh %d3,%d3,24
8002128c:	a6 32       	or %d2,%d3
8002128e:	02 23       	mov %d3,%d2
80021290:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80021294:	b9 22 08 00 	ld.hu %d2,[%a2]8
80021298:	42 23       	add %d3,%d2
8002129a:	91 10 00 27 	movh.a %a2,28673
8002129e:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800212a2:	54 22       	ld.w %d2,[%a2]
800212a4:	0b 23 80 20 	sub %d2,%d3,%d2
800212a8:	bf 12 35 00 	jlt %d2,1,80021312 <tcp_receive+0x1860>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
800212ac:	91 10 00 27 	movh.a %a2,28673
800212b0:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800212b4:	54 22       	ld.w %d2,[%a2]
800212b6:	37 02 70 40 	extr.u %d4,%d2,0,16
800212ba:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800212be:	d9 22 10 00 	lea %a2,[%a2]16
800212c2:	d4 22       	ld.a %a2,[%a2]
800212c4:	39 23 04 00 	ld.bu %d3,[%a2]4
800212c8:	39 22 05 00 	ld.bu %d2,[%a2]5
800212cc:	8f 82 00 20 	sh %d2,%d2,8
800212d0:	a6 32       	or %d2,%d3
800212d2:	39 23 06 00 	ld.bu %d3,[%a2]6
800212d6:	8f 03 01 30 	sh %d3,%d3,16
800212da:	a6 32       	or %d2,%d3
800212dc:	39 23 07 00 	ld.bu %d3,[%a2]7
800212e0:	8f 83 01 30 	sh %d3,%d3,24
800212e4:	a6 32       	or %d2,%d3
800212e6:	37 02 70 20 	extr.u %d2,%d2,0,16
800212ea:	0b 24 80 20 	sub %d2,%d4,%d2
800212ee:	37 02 70 20 	extr.u %d2,%d2,0,16
800212f2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800212f6:	f9 22 08 00 	st.h [%a2]8,%d2
                      pbuf_realloc(prev->p, prev->len);
800212fa:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
800212fe:	b0 42       	add.a %a2,4
80021300:	54 22       	ld.w %d2,[%a2]
80021302:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80021306:	b9 23 08 00 	ld.hu %d3,[%a2]8
8002130a:	02 34       	mov %d4,%d3
8002130c:	60 24       	mov.a %a4,%d2
8002130e:	6d ff f6 c3 	call 80019afa <pbuf_realloc>
                    }
                    prev->next = cseg;
80021312:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80021316:	19 e2 cc ff 	ld.w %d2,[%a14]-52
8002131a:	74 22       	st.w [%a2],%d2
                    tcp_oos_insert_segment(cseg, next);
8002131c:	99 e5 e8 ff 	ld.a %a5,[%a14]-24
80021320:	99 e4 cc ff 	ld.a %a4,[%a14]-52
80021324:	6d ff da f1 	call 8001f6d8 <tcp_oos_insert_segment>
                  }
                  break;
80021328:	1d 00 bd 01 	j 800216a2 <tcp_receive+0x1bf0>
#endif /* LWIP_TCP_SACK_OUT */

              /* We don't use 'prev' below, so let's set it to current 'next'.
                 This way even if we break the loop below, 'prev' will be pointing
                 at the segment right in front of the newly added one. */
              prev = next;
8002132c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80021330:	59 e2 e4 ff 	st.w [%a14]-28,%d2

              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
80021334:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80021338:	54 22       	ld.w %d2,[%a2]
8002133a:	df 02 a0 81 	jne %d2,0,8002167a <tcp_receive+0x1bc8>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
8002133e:	91 10 00 27 	movh.a %a2,28673
80021342:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80021346:	54 24       	ld.w %d4,[%a2]
80021348:	99 e2 e8 ff 	ld.a %a2,[%a14]-24 <700145ec <seqno>>
8002134c:	d9 22 10 00 	lea %a2,[%a2]16 <700145ec <seqno>>
80021350:	d4 22       	ld.a %a2,[%a2]
80021352:	39 23 04 00 	ld.bu %d3,[%a2]4 <700145ec <seqno>>
80021356:	39 22 05 00 	ld.bu %d2,[%a2]5 <700145ec <seqno>>
8002135a:	8f 82 00 20 	sh %d2,%d2,8
8002135e:	a6 32       	or %d2,%d3
80021360:	39 23 06 00 	ld.bu %d3,[%a2]6
80021364:	8f 03 01 30 	sh %d3,%d3,16
80021368:	a6 32       	or %d2,%d3
8002136a:	39 23 07 00 	ld.bu %d3,[%a2]7
8002136e:	8f 83 01 30 	sh %d3,%d3,24
80021372:	a6 32       	or %d2,%d3
80021374:	0b 24 80 20 	sub %d2,%d4,%d2
              if (next->next == NULL &&
80021378:	bf 12 81 01 	jlt %d2,1,8002167a <tcp_receive+0x1bc8>
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
8002137c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80021380:	d9 22 10 00 	lea %a2,[%a2]16
80021384:	d4 22       	ld.a %a2,[%a2]
80021386:	39 23 0c 00 	ld.bu %d3,[%a2]12
8002138a:	39 22 0d 00 	ld.bu %d2,[%a2]13
8002138e:	8f 82 00 20 	sh %d2,%d2,8
80021392:	a6 32       	or %d2,%d3
80021394:	37 02 70 20 	extr.u %d2,%d2,0,16
80021398:	02 24       	mov %d4,%d2
8002139a:	6d ff dd b0 	call 80017554 <lwip_htons>
8002139e:	8f f2 0f 21 	and %d2,%d2,255
800213a2:	8f 12 00 21 	and %d2,%d2,1
800213a6:	df 02 81 81 	jne %d2,0,800216a8 <tcp_receive+0x1bf6>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
800213aa:	91 10 00 27 	movh.a %a2,28673
800213ae:	d9 24 48 74 	lea %a4,[%a2]17864 <700145c8 <inseg>>
800213b2:	6d ff 19 d9 	call 8001c5e4 <tcp_seg_copy>
800213b6:	80 22       	mov.d %d2,%a2
800213b8:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800213bc:	74 22       	st.w [%a2],%d2
                if (next->next != NULL) {
800213be:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800213c2:	54 22       	ld.w %d2,[%a2]
800213c4:	df 02 75 01 	jeq %d2,0,800216ae <tcp_receive+0x1bfc>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
800213c8:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800213cc:	d9 22 10 00 	lea %a2,[%a2]16
800213d0:	d4 22       	ld.a %a2,[%a2]
800213d2:	39 23 04 00 	ld.bu %d3,[%a2]4
800213d6:	39 22 05 00 	ld.bu %d2,[%a2]5
800213da:	8f 82 00 20 	sh %d2,%d2,8
800213de:	a6 32       	or %d2,%d3
800213e0:	39 23 06 00 	ld.bu %d3,[%a2]6
800213e4:	8f 03 01 30 	sh %d3,%d3,16
800213e8:	a6 32       	or %d2,%d3
800213ea:	39 23 07 00 	ld.bu %d3,[%a2]7
800213ee:	8f 83 01 30 	sh %d3,%d3,24
800213f2:	a6 32       	or %d2,%d3
800213f4:	02 23       	mov %d3,%d2
800213f6:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800213fa:	b9 22 08 00 	ld.hu %d2,[%a2]8
800213fe:	42 23       	add %d3,%d2
80021400:	91 10 00 27 	movh.a %a2,28673
80021404:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80021408:	54 22       	ld.w %d2,[%a2]
8002140a:	0b 23 80 20 	sub %d2,%d3,%d2
8002140e:	bf 12 35 00 	jlt %d2,1,80021478 <tcp_receive+0x19c6>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
80021412:	91 10 00 27 	movh.a %a2,28673
80021416:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8002141a:	54 22       	ld.w %d2,[%a2]
8002141c:	37 02 70 40 	extr.u %d4,%d2,0,16
80021420:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80021424:	d9 22 10 00 	lea %a2,[%a2]16
80021428:	d4 22       	ld.a %a2,[%a2]
8002142a:	39 23 04 00 	ld.bu %d3,[%a2]4
8002142e:	39 22 05 00 	ld.bu %d2,[%a2]5
80021432:	8f 82 00 20 	sh %d2,%d2,8
80021436:	a6 32       	or %d2,%d3
80021438:	39 23 06 00 	ld.bu %d3,[%a2]6
8002143c:	8f 03 01 30 	sh %d3,%d3,16
80021440:	a6 32       	or %d2,%d3
80021442:	39 23 07 00 	ld.bu %d3,[%a2]7
80021446:	8f 83 01 30 	sh %d3,%d3,24
8002144a:	a6 32       	or %d2,%d3
8002144c:	37 02 70 20 	extr.u %d2,%d2,0,16
80021450:	0b 24 80 20 	sub %d2,%d4,%d2
80021454:	37 02 70 20 	extr.u %d2,%d2,0,16
80021458:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8002145c:	f9 22 08 00 	st.h [%a2]8,%d2
                    pbuf_realloc(next->p, next->len);
80021460:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80021464:	b0 42       	add.a %a2,4
80021466:	54 22       	ld.w %d2,[%a2]
80021468:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8002146c:	b9 23 08 00 	ld.hu %d3,[%a2]8
80021470:	02 34       	mov %d4,%d3
80021472:	60 24       	mov.a %a4,%d2
80021474:	6d ff 43 c3 	call 80019afa <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
80021478:	91 10 00 27 	movh.a %a2,28673
8002147c:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80021480:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80021484:	02 23       	mov %d3,%d2
80021486:	91 10 00 27 	movh.a %a2,28673
8002148a:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
8002148e:	54 22       	ld.w %d2,[%a2]
80021490:	42 23       	add %d3,%d2
80021492:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021496:	d9 22 28 00 	lea %a2,[%a2]40
8002149a:	54 24       	ld.w %d4,[%a2]
8002149c:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
800214a0:	b9 22 2c 00 	ld.hu %d2,[%a2]44
800214a4:	42 42       	add %d2,%d4
800214a6:	0b 23 80 20 	sub %d2,%d3,%d2
800214aa:	bf 12 02 01 	jlt %d2,1,800216ae <tcp_receive+0x1bfc>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG,
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
800214ae:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800214b2:	d4 22       	ld.a %a2,[%a2]
800214b4:	d9 22 10 00 	lea %a2,[%a2]16
800214b8:	d4 22       	ld.a %a2,[%a2]
800214ba:	39 23 0c 00 	ld.bu %d3,[%a2]12
800214be:	39 22 0d 00 	ld.bu %d2,[%a2]13
800214c2:	8f 82 00 20 	sh %d2,%d2,8
800214c6:	a6 32       	or %d2,%d3
800214c8:	37 02 70 20 	extr.u %d2,%d2,0,16
800214cc:	02 24       	mov %d4,%d2
800214ce:	6d ff 43 b0 	call 80017554 <lwip_htons>
800214d2:	8f f2 0f 21 	and %d2,%d2,255
800214d6:	8f 12 00 21 	and %d2,%d2,1
800214da:	df 02 4b 00 	jeq %d2,0,80021570 <tcp_receive+0x1abe>
                      /* Must remove the FIN from the header as we're trimming
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
800214de:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800214e2:	d4 22       	ld.a %a2,[%a2]
800214e4:	d9 22 10 00 	lea %a2,[%a2]16
800214e8:	d4 22       	ld.a %a2,[%a2]
800214ea:	39 23 0c 00 	ld.bu %d3,[%a2]12
800214ee:	39 22 0d 00 	ld.bu %d2,[%a2]13
800214f2:	8f 82 00 20 	sh %d2,%d2,8
800214f6:	a6 32       	or %d2,%d3
800214f8:	37 02 70 20 	extr.u %d2,%d2,0,16
800214fc:	37 02 50 20 	extr %d2,%d2,0,16
80021500:	3b f0 0f 3c 	mov %d3,-16129
80021504:	26 32       	and %d2,%d3
80021506:	37 02 50 80 	extr %d8,%d2,0,16
8002150a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8002150e:	d4 22       	ld.a %a2,[%a2]
80021510:	d9 22 10 00 	lea %a2,[%a2]16
80021514:	d4 22       	ld.a %a2,[%a2]
80021516:	39 23 0c 00 	ld.bu %d3,[%a2]12
8002151a:	39 22 0d 00 	ld.bu %d2,[%a2]13
8002151e:	8f 82 00 20 	sh %d2,%d2,8
80021522:	a6 32       	or %d2,%d3
80021524:	37 02 70 20 	extr.u %d2,%d2,0,16
80021528:	02 24       	mov %d4,%d2
8002152a:	6d ff 15 b0 	call 80017554 <lwip_htons>
8002152e:	8f f2 0f 21 	and %d2,%d2,255
80021532:	8f e2 03 21 	and %d2,%d2,62
80021536:	02 24       	mov %d4,%d2
80021538:	6d ff 0e b0 	call 80017554 <lwip_htons>
8002153c:	37 02 50 20 	extr %d2,%d2,0,16
80021540:	a6 82       	or %d2,%d8
80021542:	37 02 50 20 	extr %d2,%d2,0,16
80021546:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8002154a:	d4 22       	ld.a %a2,[%a2]
8002154c:	d9 22 10 00 	lea %a2,[%a2]16
80021550:	d4 22       	ld.a %a2,[%a2]
80021552:	37 02 70 20 	extr.u %d2,%d2,0,16
80021556:	8f f2 0f 31 	and %d3,%d2,255
8002155a:	82 04       	mov %d4,0
8002155c:	a6 43       	or %d3,%d4
8002155e:	e9 23 0c 00 	st.b [%a2]12,%d3
80021562:	06 82       	sh %d2,-8
80021564:	37 02 70 20 	extr.u %d2,%d2,0,16
80021568:	82 03       	mov %d3,0
8002156a:	a6 32       	or %d2,%d3
8002156c:	e9 22 0d 00 	st.b [%a2]13,%d2
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
80021570:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021574:	d9 22 28 00 	lea %a2,[%a2]40
80021578:	54 22       	ld.w %d2,[%a2]
8002157a:	37 02 70 30 	extr.u %d3,%d2,0,16
8002157e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021582:	b9 22 2c 00 	ld.hu %d2,[%a2]44
80021586:	42 32       	add %d2,%d3
80021588:	37 02 70 30 	extr.u %d3,%d2,0,16
8002158c:	91 10 00 27 	movh.a %a2,28673
80021590:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80021594:	54 22       	ld.w %d2,[%a2]
80021596:	37 02 70 20 	extr.u %d2,%d2,0,16
8002159a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8002159e:	d4 22       	ld.a %a2,[%a2]
800215a0:	0b 23 80 20 	sub %d2,%d3,%d2
800215a4:	37 02 70 20 	extr.u %d2,%d2,0,16
800215a8:	f9 22 08 00 	st.h [%a2]8,%d2
                    pbuf_realloc(next->next->p, next->next->len);
800215ac:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800215b0:	d4 22       	ld.a %a2,[%a2]
800215b2:	b0 42       	add.a %a2,4
800215b4:	54 22       	ld.w %d2,[%a2]
800215b6:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800215ba:	d4 22       	ld.a %a2,[%a2]
800215bc:	b9 23 08 00 	ld.hu %d3,[%a2]8
800215c0:	02 34       	mov %d4,%d3
800215c2:	60 24       	mov.a %a4,%d2
800215c4:	6d ff 9b c2 	call 80019afa <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
800215c8:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800215cc:	d4 22       	ld.a %a2,[%a2]
800215ce:	b9 28 08 00 	ld.hu %d8,[%a2]8
800215d2:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800215d6:	d4 22       	ld.a %a2,[%a2]
800215d8:	d9 22 10 00 	lea %a2,[%a2]16
800215dc:	d4 22       	ld.a %a2,[%a2]
800215de:	39 23 0c 00 	ld.bu %d3,[%a2]12
800215e2:	39 22 0d 00 	ld.bu %d2,[%a2]13
800215e6:	8f 82 00 20 	sh %d2,%d2,8
800215ea:	a6 32       	or %d2,%d3
800215ec:	37 02 70 20 	extr.u %d2,%d2,0,16
800215f0:	02 24       	mov %d4,%d2
800215f2:	6d ff b1 af 	call 80017554 <lwip_htons>
800215f6:	8f f2 0f 21 	and %d2,%d2,255
800215fa:	8f 32 00 21 	and %d2,%d2,3
800215fe:	df 02 05 00 	jeq %d2,0,80021608 <tcp_receive+0x1b56>
80021602:	82 12       	mov %d2,1
80021604:	1d 00 03 00 	j 8002160a <tcp_receive+0x1b58>
80021608:	82 02       	mov %d2,0
8002160a:	42 82       	add %d2,%d8
8002160c:	37 02 70 20 	extr.u %d2,%d2,0,16
80021610:	91 10 00 27 	movh.a %a2,28673
80021614:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80021618:	b4 22       	st.h [%a2],%d2
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
8002161a:	91 10 00 27 	movh.a %a2,28673
8002161e:	d9 22 76 74 	lea %a2,[%a2]17910 <700145f6 <tcplen>>
80021622:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80021626:	02 23       	mov %d3,%d2
80021628:	91 10 00 27 	movh.a %a2,28673
8002162c:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
80021630:	54 22       	ld.w %d2,[%a2]
80021632:	42 23       	add %d3,%d2
80021634:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021638:	d9 22 28 00 	lea %a2,[%a2]40
8002163c:	54 24       	ld.w %d4,[%a2]
8002163e:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021642:	b9 22 2c 00 	ld.hu %d2,[%a2]44
80021646:	42 42       	add %d2,%d4
80021648:	5f 23 33 00 	jeq %d3,%d2,800216ae <tcp_receive+0x1bfc>
8002164c:	91 00 00 28 	movh.a %a2,32768
80021650:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
80021654:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
80021658:	3b 80 6f 20 	mov %d2,1784
8002165c:	59 a2 04 00 	st.w [%sp]4,%d2
80021660:	91 00 00 28 	movh.a %a2,32768
80021664:	d9 22 a7 42 	lea %a2,[%a2]10535 <80002927 <IfxCpu_Trap_vectorTable0_end+0x2733>>
80021668:	f4 a2       	st.a [%sp],%a2
8002166a:	91 00 00 28 	movh.a %a2,32768
8002166e:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
80021672:	6d ff 62 1e 	call 80005336 <Ifx_Lwip_printf>
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
80021676:	1d 00 1c 00 	j 800216ae <tcp_receive+0x1bfc>
          for (next = pcb->ooseq; next != NULL; next = next->next) {
8002167a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
8002167e:	54 22       	ld.w %d2,[%a2]
80021680:	59 e2 e8 ff 	st.w [%a14]-24,%d2
80021684:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80021688:	df 02 13 fd 	jne %d2,0,800210ae <tcp_receive+0x15fc>
8002168c:	1d 00 12 00 	j 800216b0 <tcp_receive+0x1bfe>
                break;
80021690:	00 00       	nop 
80021692:	1d 00 0f 00 	j 800216b0 <tcp_receive+0x1bfe>
                break;
80021696:	00 00       	nop 
80021698:	1d 00 0c 00 	j 800216b0 <tcp_receive+0x1bfe>
                  break;
8002169c:	00 00       	nop 
8002169e:	1d 00 09 00 	j 800216b0 <tcp_receive+0x1bfe>
                  break;
800216a2:	00 00       	nop 
800216a4:	1d 00 06 00 	j 800216b0 <tcp_receive+0x1bfe>
                  break;
800216a8:	00 00       	nop 
800216aa:	1d 00 03 00 	j 800216b0 <tcp_receive+0x1bfe>
                break;
800216ae:	00 00       	nop 
#endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
#endif /* TCP_QUEUE_OOSEQ */

        /* We send the ACK packet after we've (potentially) dealt with SACKs,
           so they can be included in the acknowledgment. */
        tcp_send_empty_ack(pcb);
800216b0:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
800216b4:	6d 00 48 19 	call 80024944 <tcp_send_empty_ack>
      if (pcb->rcv_nxt == seqno) {
800216b8:	1d 00 08 00 	j 800216c8 <tcp_receive+0x1c16>
      }
    } else {
      /* The incoming segment is not within the window. */
      tcp_send_empty_ack(pcb);
800216bc:	99 e4 f4 ef 	ld.a %a4,[%a14]-76
800216c0:	6d 00 42 19 	call 80024944 <tcp_send_empty_ack>
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
800216c4:	1d 00 34 00 	j 8002172c <tcp_receive+0x1c7a>
800216c8:	1d 00 32 00 	j 8002172c <tcp_receive+0x1c7a>
    }
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
800216cc:	91 10 00 27 	movh.a %a2,28673
800216d0:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800216d4:	54 23       	ld.w %d3,[%a2]
800216d6:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145ec <seqno>>
800216da:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
800216de:	54 22       	ld.w %d2,[%a2]
800216e0:	0b 23 80 20 	sub %d2,%d3,%d2
800216e4:	bf 02 16 00 	jlt %d2,0,80021710 <tcp_receive+0x1c5e>
800216e8:	91 10 00 27 	movh.a %a2,28673
800216ec:	d9 22 6c 74 	lea %a2,[%a2]17900 <700145ec <seqno>>
800216f0:	54 23       	ld.w %d3,[%a2]
800216f2:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145ec <seqno>>
800216f6:	d9 22 28 00 	lea %a2,[%a2]40 <700145ec <seqno>>
800216fa:	54 24       	ld.w %d4,[%a2]
800216fc:	99 e2 f4 ef 	ld.a %a2,[%a14]-76 <700145ec <seqno>>
80021700:	b9 22 2c 00 	ld.hu %d2,[%a2]44 <700145ec <seqno>>
80021704:	42 42       	add %d2,%d4
80021706:	0b 23 80 20 	sub %d2,%d3,%d2
8002170a:	c2 12       	add %d2,1
8002170c:	bf 12 10 00 	jlt %d2,1,8002172c <tcp_receive+0x1c7a>
      tcp_ack_now(pcb);
80021710:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021714:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80021718:	8f 22 40 21 	or %d2,%d2,2
8002171c:	37 02 70 20 	extr.u %d2,%d2,0,16
80021720:	99 e2 f4 ef 	ld.a %a2,[%a14]-76
80021724:	f9 22 1e 00 	st.h [%a2]30,%d2
    }
  }
}
80021728:	1d 00 02 00 	j 8002172c <tcp_receive+0x1c7a>
8002172c:	00 00       	nop 
8002172e:	00 90       	ret 

80021730 <tcp_get_next_optbyte>:

static u8_t
tcp_get_next_optbyte(void)
{
80021730:	40 ae       	mov.aa %a14,%sp
80021732:	20 08       	sub.a %sp,8
  u16_t optidx = tcp_optidx++;
80021734:	91 10 00 27 	movh.a %a2,28673
80021738:	d9 22 68 74 	lea %a2,[%a2]17896 <700145e8 <tcp_optidx>>
8002173c:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80021740:	1b 12 00 30 	addi %d3,%d2,1
80021744:	37 03 70 30 	extr.u %d3,%d3,0,16
80021748:	91 10 00 27 	movh.a %a2,28673
8002174c:	d9 22 68 74 	lea %a2,[%a2]17896 <700145e8 <tcp_optidx>>
80021750:	b4 23       	st.h [%a2],%d3
80021752:	f9 e2 fe ff 	st.h [%a14]-2 <700145e8 <tcp_optidx>>,%d2
  if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
80021756:	91 10 00 27 	movh.a %a2,28673
8002175a:	d9 22 64 74 	lea %a2,[%a2]17892 <700145e4 <tcphdr_opt2>>
8002175e:	54 22       	ld.w %d2,[%a2]
80021760:	df 02 0c 00 	jeq %d2,0,80021778 <tcp_get_next_optbyte+0x48>
80021764:	91 10 00 27 	movh.a %a2,28673
80021768:	d9 22 62 74 	lea %a2,[%a2]17890 <700145e2 <tcphdr_opt1len>>
8002176c:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80021770:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2 <70010000 <ram_heap+0x4f6c>>
80021774:	7f 23 14 80 	jge.u %d3,%d2,8002179c <tcp_get_next_optbyte+0x6c>
    u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
80021778:	91 10 00 27 	movh.a %a2,28673
8002177c:	d9 22 5c 74 	lea %a2,[%a2]17884 <700145dc <tcphdr>>
80021780:	54 22       	ld.w %d2,[%a2]
80021782:	1b 42 01 20 	addi %d2,%d2,20
80021786:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    return opts[optidx];
8002178a:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8002178e:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80021792:	60 32       	mov.a %a2,%d3
80021794:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80021798:	14 22       	ld.bu %d2,[%a2]
8002179a:	00 90       	ret 
  } else {
    u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
8002179c:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
800217a0:	8f f2 0f 31 	and %d3,%d2,255
800217a4:	91 10 00 27 	movh.a %a2,28673
800217a8:	d9 22 62 74 	lea %a2,[%a2]17890 <700145e2 <tcphdr_opt1len>>
800217ac:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
800217b0:	8f f2 0f 21 	and %d2,%d2,255
800217b4:	0b 23 80 20 	sub %d2,%d3,%d2
800217b8:	e9 e2 fd ff 	st.b [%a14]-3,%d2
    return tcphdr_opt2[idx];
800217bc:	91 10 00 27 	movh.a %a2,28673
800217c0:	d9 22 64 74 	lea %a2,[%a2]17892 <700145e4 <tcphdr_opt2>>
800217c4:	54 23       	ld.w %d3,[%a2]
800217c6:	39 e2 fd ff 	ld.bu %d2,[%a14]-3 <700145e4 <tcphdr_opt2>>
800217ca:	60 32       	mov.a %a2,%d3
800217cc:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800217d0:	14 22       	ld.bu %d2,[%a2]
  }
}
800217d2:	00 90       	ret 

800217d4 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
800217d4:	40 ae       	mov.aa %a14,%sp
800217d6:	20 20       	sub.a %sp,32
800217d8:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  u16_t mss;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
800217dc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800217e0:	df 02 17 80 	jne %d2,0,8002180e <tcp_parseopt+0x3a>
800217e4:	91 00 00 28 	movh.a %a2,32768
800217e8:	d9 22 53 72 	lea %a2,[%a2]9683 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>
800217ec:	b5 a2 08 00 	st.a [%sp]8 <800025d3 <IfxCpu_Trap_vectorTable0_end+0x23df>>,%a2
800217f0:	3b d0 77 20 	mov %d2,1917
800217f4:	59 a2 04 00 	st.w [%sp]4,%d2
800217f8:	91 00 00 28 	movh.a %a2,32768
800217fc:	d9 22 9d 72 	lea %a2,[%a2]10717 <800029dd <IfxCpu_Trap_vectorTable0_end+0x27e9>>
80021800:	f4 a2       	st.a [%sp],%a2
80021802:	91 00 00 28 	movh.a %a2,32768
80021806:	d9 24 6b 62 	lea %a4,[%a2]9643 <800025ab <IfxCpu_Trap_vectorTable0_end+0x23b7>>
8002180a:	6d ff 96 1d 	call 80005336 <Ifx_Lwip_printf>

  /* Parse the TCP MSS option, if present. */
  if (tcphdr_optlen != 0) {
8002180e:	91 10 00 27 	movh.a %a2,28673
80021812:	d9 22 60 74 	lea %a2,[%a2]17888 <700145e0 <tcphdr_optlen>>
80021816:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
8002181a:	df 02 85 00 	jeq %d2,0,80021924 <tcp_parseopt+0x150>
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
8002181e:	91 10 00 27 	movh.a %a2,28673
80021822:	d9 22 68 74 	lea %a2,[%a2]17896 <700145e8 <tcp_optidx>>
80021826:	82 02       	mov %d2,0
80021828:	b4 22       	st.h [%a2],%d2
8002182a:	1d 00 69 00 	j 800218fc <tcp_parseopt+0x128>
      u8_t opt = tcp_get_next_optbyte();
8002182e:	6d ff 81 ff 	call 80021730 <tcp_get_next_optbyte>
80021832:	e9 e2 ff ff 	st.b [%a14]-1,%d2
      switch (opt) {
80021836:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8002183a:	df 22 0a 00 	jeq %d2,2,8002184e <tcp_parseopt+0x7a>
8002183e:	ff 32 42 00 	jge %d2,3,800218c2 <tcp_parseopt+0xee>
80021842:	df 02 6c 00 	jeq %d2,0,8002191a <tcp_parseopt+0x146>
80021846:	df 12 3e 80 	jne %d2,1,800218c2 <tcp_parseopt+0xee>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
          return;
        case LWIP_TCP_OPT_NOP:
          /* NOP option. */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
          break;
8002184a:	1d 00 59 00 	j 800218fc <tcp_parseopt+0x128>
        case LWIP_TCP_OPT_MSS:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
          if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
8002184e:	6d ff 71 ff 	call 80021730 <tcp_get_next_optbyte>
80021852:	df 42 66 80 	jne %d2,4,8002191e <tcp_parseopt+0x14a>
80021856:	91 10 00 27 	movh.a %a2,28673
8002185a:	d9 22 68 74 	lea %a2,[%a2]17896 <700145e8 <tcp_optidx>>
8002185e:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80021862:	c2 12       	add %d2,1
80021864:	91 10 00 27 	movh.a %a2,28673
80021868:	d9 22 60 74 	lea %a2,[%a2]17888 <700145e0 <tcphdr_optlen>>
8002186c:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80021870:	7f 32 57 00 	jge %d2,%d3,8002191e <tcp_parseopt+0x14a>
            /* Bad length */
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
            return;
          }
          /* An MSS option with the right option length. */
          mss = (u16_t)(tcp_get_next_optbyte() << 8);
80021874:	6d ff 5e ff 	call 80021730 <tcp_get_next_optbyte>
80021878:	37 02 70 20 	extr.u %d2,%d2,0,16
8002187c:	8f 82 00 20 	sh %d2,%d2,8
80021880:	f9 e2 fc ff 	st.h [%a14]-4,%d2
          mss |= tcp_get_next_optbyte();
80021884:	6d ff 56 ff 	call 80021730 <tcp_get_next_optbyte>
80021888:	37 02 70 30 	extr.u %d3,%d2,0,16
8002188c:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80021890:	a6 32       	or %d2,%d3
80021892:	f9 e2 fc ff 	st.h [%a14]-4,%d2
          /* Limit the mss to the configured TCP_MSS and prevent division by zero */
          pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
80021896:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
8002189a:	3b 90 21 30 	mov %d3,537
8002189e:	7f 32 0a 80 	jge.u %d2,%d3,800218b2 <tcp_parseopt+0xde>
800218a2:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800218a6:	df 02 06 00 	jeq %d2,0,800218b2 <tcp_parseopt+0xde>
800218aa:	b9 e2 fc ff 	ld.hu %d2,[%a14]-4
800218ae:	1d 00 04 00 	j 800218b6 <tcp_parseopt+0xe2>
800218b2:	3b 80 21 20 	mov %d2,536
800218b6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800218ba:	f9 22 36 00 	st.h [%a2]54,%d2
          break;
800218be:	1d 00 1f 00 	j 800218fc <tcp_parseopt+0x128>
          }
          break;
#endif /* LWIP_TCP_SACK_OUT */
        default:
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
          data = tcp_get_next_optbyte();
800218c2:	6d ff 37 ff 	call 80021730 <tcp_get_next_optbyte>
800218c6:	e9 e2 fb ff 	st.b [%a14]-5,%d2
          if (data < 2) {
800218ca:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
800218ce:	bf 22 2a 80 	jlt.u %d2,2,80021922 <tcp_parseopt+0x14e>
               and we don't process them further. */
            return;
          }
          /* All other options have a length field, so that we easily
             can skip past them. */
          tcp_optidx += data - 2;
800218d2:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
800218d6:	37 02 70 30 	extr.u %d3,%d2,0,16
800218da:	91 10 00 27 	movh.a %a2,28673
800218de:	d9 22 68 74 	lea %a2,[%a2]17896 <700145e8 <tcp_optidx>>
800218e2:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
800218e6:	42 32       	add %d2,%d3
800218e8:	37 02 70 20 	extr.u %d2,%d2,0,16
800218ec:	c2 e2       	add %d2,-2
800218ee:	37 02 70 20 	extr.u %d2,%d2,0,16
800218f2:	91 10 00 27 	movh.a %a2,28673
800218f6:	d9 22 68 74 	lea %a2,[%a2]17896 <700145e8 <tcp_optidx>>
800218fa:	b4 22       	st.h [%a2],%d2
    for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
800218fc:	91 10 00 27 	movh.a %a2,28673
80021900:	d9 22 68 74 	lea %a2,[%a2]17896 <700145e8 <tcp_optidx>>
80021904:	b9 23 00 00 	ld.hu %d3,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80021908:	91 10 00 27 	movh.a %a2,28673
8002190c:	d9 22 60 74 	lea %a2,[%a2]17888 <700145e0 <tcphdr_optlen>>
80021910:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80021914:	3f 23 8d ff 	jlt.u %d3,%d2,8002182e <tcp_parseopt+0x5a>
80021918:	00 90       	ret 
          return;
8002191a:	00 00       	nop 
8002191c:	00 90       	ret 
            return;
8002191e:	00 00       	nop 
80021920:	00 90       	ret 
            return;
80021922:	00 00       	nop 
      }
    }
  }
}
80021924:	00 90       	ret 

80021926 <tcp_trigger_input_pcb_close>:

void
tcp_trigger_input_pcb_close(void)
{
80021926:	40 ae       	mov.aa %a14,%sp
  recv_flags |= TF_CLOSED;
80021928:	91 10 00 27 	movh.a %a2,28673
8002192c:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
80021930:	14 22       	ld.bu %d2,[%a2]
80021932:	8f 02 41 21 	or %d2,%d2,16
80021936:	8f f2 0f 21 	and %d2,%d2,255
8002193a:	91 10 00 27 	movh.a %a2,28673
8002193e:	d9 22 79 74 	lea %a2,[%a2]17913 <700145f9 <recv_flags>>
80021942:	34 22       	st.b [%a2],%d2
}
80021944:	00 00       	nop 
80021946:	00 90       	ret 

80021948 <tcp_route>:
static err_t tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif);

/* tcp_route: common code that returns a fixed bound netif or calls ip_route */
static struct netif *
tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
{
80021948:	40 ae       	mov.aa %a14,%sp
8002194a:	20 10       	sub.a %sp,16
8002194c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80021950:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
80021954:	b5 e6 f4 ff 	st.a [%a14]-12,%a6
  LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */

  if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
80021958:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002195c:	df 02 12 00 	jeq %d2,0,80021980 <tcp_route+0x38>
80021960:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021964:	39 22 08 00 	ld.bu %d2,[%a2]8
80021968:	df 02 0c 00 	jeq %d2,0,80021980 <tcp_route+0x38>
    return netif_get_by_index(pcb->netif_idx);
8002196c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021970:	39 22 08 00 	ld.bu %d2,[%a2]8
80021974:	02 24       	mov %d4,%d2
80021976:	6d ff ab bd 	call 800194cc <netif_get_by_index>
8002197a:	80 22       	mov.d %d2,%a2
8002197c:	1d 00 07 00 	j 8002198a <tcp_route+0x42>
  } else {
    return ip_route(src, dst);
80021980:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80021984:	6d ff 9f 9a 	call 80014ec2 <ip4_route>
80021988:	80 22       	mov.d %d2,%a2
  }
}
8002198a:	60 22       	mov.a %a2,%d2
8002198c:	00 90       	ret 

8002198e <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optflags)
{
8002198e:	40 ae       	mov.aa %a14,%sp
80021990:	20 30       	sub.a %sp,48
80021992:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80021996:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
8002199a:	02 42       	mov %d2,%d4
8002199c:	59 e5 e8 ff 	st.w [%a14]-24,%d5
800219a0:	02 63       	mov %d3,%d6
800219a2:	e9 e2 ec ff 	st.b [%a14]-20,%d2
800219a6:	02 32       	mov %d2,%d3
800219a8:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
  struct tcp_seg *seg;
  u8_t optlen;

  LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
800219ac:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800219b0:	df 02 17 80 	jne %d2,0,800219de <tcp_create_segment+0x50>
800219b4:	91 00 00 28 	movh.a %a2,32768
800219b8:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800219bc:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800219c0:	3b 30 0a 20 	mov %d2,163
800219c4:	59 a2 04 00 	st.w [%sp]4,%d2
800219c8:	91 00 00 28 	movh.a %a2,32768
800219cc:	d9 22 8d 92 	lea %a2,[%a2]10829 <80002a4d <IfxCpu_Trap_vectorTable0_end+0x2859>>
800219d0:	f4 a2       	st.a [%sp],%a2
800219d2:	91 00 00 28 	movh.a %a2,32768
800219d6:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800219da:	6d ff ae 1c 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
800219de:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800219e2:	df 02 17 80 	jne %d2,0,80021a10 <tcp_create_segment+0x82>
800219e6:	91 00 00 28 	movh.a %a2,32768
800219ea:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800219ee:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800219f2:	3b 40 0a 20 	mov %d2,164
800219f6:	59 a2 04 00 	st.w [%sp]4,%d2
800219fa:	91 00 00 28 	movh.a %a2,32768
800219fe:	d9 22 ad 92 	lea %a2,[%a2]10861 <80002a6d <IfxCpu_Trap_vectorTable0_end+0x2879>>
80021a02:	f4 a2       	st.a [%sp],%a2
80021a04:	91 00 00 28 	movh.a %a2,32768
80021a08:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021a0c:	6d ff 95 1c 	call 80005336 <Ifx_Lwip_printf>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
80021a10:	39 e2 e4 ff 	ld.bu %d2,[%a14]-28
80021a14:	06 22       	sh %d2,2
80021a16:	8f f2 0f 21 	and %d2,%d2,255
80021a1a:	8f 42 00 21 	and %d2,%d2,4
80021a1e:	e9 e2 ff ff 	st.b [%a14]-1,%d2

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
80021a22:	82 34       	mov %d4,3
80021a24:	6d ff d3 b7 	call 800189ca <memp_malloc>
80021a28:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
80021a2c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80021a30:	df 02 09 80 	jne %d2,0,80021a42 <tcp_create_segment+0xb4>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
80021a34:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80021a38:	6d ff b0 c2 	call 80019f98 <pbuf_free>
    return NULL;
80021a3c:	82 02       	mov %d2,0
80021a3e:	1d 00 fc 00 	j 80021c36 <tcp_create_segment+0x2a8>
  }
  seg->flags = optflags;
80021a42:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021a46:	79 e2 e4 ff 	ld.b %d2,[%a14]-28
80021a4a:	e9 22 0c 00 	st.b [%a2]12,%d2
  seg->next = NULL;
80021a4e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021a52:	82 02       	mov %d2,0
80021a54:	74 22       	st.w [%a2],%d2
  seg->p = p;
80021a56:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021a5a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80021a5e:	b0 42       	add.a %a2,4
80021a60:	74 22       	st.w [%a2],%d2
  LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
80021a62:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80021a66:	b9 23 08 00 	ld.hu %d3,[%a2]8
80021a6a:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80021a6e:	37 02 70 20 	extr.u %d2,%d2,0,16
80021a72:	7f 23 17 80 	jge.u %d3,%d2,80021aa0 <tcp_create_segment+0x112>
80021a76:	91 00 00 28 	movh.a %a2,32768
80021a7a:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80021a7e:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80021a82:	3b 00 0b 20 	mov %d2,176
80021a86:	59 a2 04 00 	st.w [%sp]4,%d2
80021a8a:	91 00 00 28 	movh.a %a2,32768
80021a8e:	d9 22 8e a2 	lea %a2,[%a2]10894 <80002a8e <IfxCpu_Trap_vectorTable0_end+0x289a>>
80021a92:	f4 a2       	st.a [%sp],%a2
80021a94:	91 00 00 28 	movh.a %a2,32768
80021a98:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021a9c:	6d ff 4d 1c 	call 80005336 <Ifx_Lwip_printf>
  seg->len = p->tot_len - optlen;
80021aa0:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80021aa4:	b9 23 08 00 	ld.hu %d3,[%a2]8
80021aa8:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80021aac:	37 02 70 20 	extr.u %d2,%d2,0,16
80021ab0:	0b 23 80 20 	sub %d2,%d3,%d2
80021ab4:	37 02 70 20 	extr.u %d2,%d2,0,16
80021ab8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021abc:	f9 22 08 00 	st.h [%a2]8,%d2
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
80021ac0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021ac4:	82 02       	mov %d2,0
80021ac6:	f9 22 0a 00 	st.h [%a2]10,%d2
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_add_header(p, TCP_HLEN)) {
80021aca:	3b 40 01 40 	mov %d4,20
80021ace:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80021ad2:	6d ff 8f c1 	call 80019df0 <pbuf_add_header>
80021ad6:	df 02 18 00 	jeq %d2,0,80021b06 <tcp_create_segment+0x178>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
80021ada:	91 10 00 27 	movh.a %a2,28673
80021ade:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80021ae2:	b9 22 24 20 	ld.hu %d2,[%a2]164 <700100a4 <ram_heap+0x5010>>
80021ae6:	c2 12       	add %d2,1
80021ae8:	37 02 70 20 	extr.u %d2,%d2,0,16
80021aec:	91 10 00 27 	movh.a %a2,28673
80021af0:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80021af4:	f9 22 24 20 	st.h [%a2]164 <700100a4 <ram_heap+0x5010>>,%d2
    tcp_seg_free(seg);
80021af8:	99 e4 f8 ff 	ld.a %a4,[%a14]-8 <700100a4 <ram_heap+0x5010>>
80021afc:	6d ff 58 d5 	call 8001c5ac <tcp_seg_free>
    return NULL;
80021b00:	82 02       	mov %d2,0
80021b02:	1d 00 9a 00 	j 80021c36 <tcp_create_segment+0x2a8>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
80021b06:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021b0a:	b0 42       	add.a %a2,4
80021b0c:	d4 22       	ld.a %a2,[%a2]
80021b0e:	b0 42       	add.a %a2,4
80021b10:	54 22       	ld.w %d2,[%a2]
80021b12:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021b16:	d9 22 10 00 	lea %a2,[%a2]16
80021b1a:	74 22       	st.w [%a2],%d2
  seg->tcphdr->src = lwip_htons(pcb->local_port);
80021b1c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80021b20:	b9 22 1a 00 	ld.hu %d2,[%a2]26
80021b24:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021b28:	d9 22 10 00 	lea %a2,[%a2]16
80021b2c:	d4 2c       	ld.a %a12,[%a2]
80021b2e:	02 24       	mov %d4,%d2
80021b30:	6d ff 12 ad 	call 80017554 <lwip_htons>
80021b34:	8f f2 0f 31 	and %d3,%d2,255
80021b38:	82 04       	mov %d4,0
80021b3a:	a6 43       	or %d3,%d4
80021b3c:	34 c3       	st.b [%a12],%d3
80021b3e:	06 82       	sh %d2,-8
80021b40:	37 02 70 20 	extr.u %d2,%d2,0,16
80021b44:	82 03       	mov %d3,0
80021b46:	a6 32       	or %d2,%d3
80021b48:	e9 c2 01 00 	st.b [%a12]1,%d2
  seg->tcphdr->dest = lwip_htons(pcb->remote_port);
80021b4c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80021b50:	b9 22 1c 00 	ld.hu %d2,[%a2]28
80021b54:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021b58:	d9 22 10 00 	lea %a2,[%a2]16
80021b5c:	d4 2c       	ld.a %a12,[%a2]
80021b5e:	02 24       	mov %d4,%d2
80021b60:	6d ff fa ac 	call 80017554 <lwip_htons>
80021b64:	8f f2 0f 31 	and %d3,%d2,255
80021b68:	82 04       	mov %d4,0
80021b6a:	a6 43       	or %d3,%d4
80021b6c:	e9 c3 02 00 	st.b [%a12]2,%d3
80021b70:	06 82       	sh %d2,-8
80021b72:	37 02 70 20 	extr.u %d2,%d2,0,16
80021b76:	82 03       	mov %d3,0
80021b78:	a6 32       	or %d2,%d3
80021b7a:	e9 c2 03 00 	st.b [%a12]3,%d2
  seg->tcphdr->seqno = lwip_htonl(seqno);
80021b7e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021b82:	d9 22 10 00 	lea %a2,[%a2]16
80021b86:	d4 2c       	ld.a %a12,[%a2]
80021b88:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
80021b8c:	6d ff fc ac 	call 80017584 <lwip_htonl>
80021b90:	8f f2 0f 31 	and %d3,%d2,255
80021b94:	82 04       	mov %d4,0
80021b96:	a6 43       	or %d3,%d4
80021b98:	e9 c3 04 00 	st.b [%a12]4,%d3
80021b9c:	8f 82 1f 30 	sh %d3,%d2,-8
80021ba0:	8f f3 0f 31 	and %d3,%d3,255
80021ba4:	82 04       	mov %d4,0
80021ba6:	a6 43       	or %d3,%d4
80021ba8:	e9 c3 05 00 	st.b [%a12]5,%d3
80021bac:	8f 02 1f 30 	sh %d3,%d2,-16
80021bb0:	8f f3 0f 31 	and %d3,%d3,255
80021bb4:	82 04       	mov %d4,0
80021bb6:	a6 43       	or %d3,%d4
80021bb8:	e9 c3 06 00 	st.b [%a12]6,%d3
80021bbc:	8f 82 1e 20 	sh %d2,%d2,-24
80021bc0:	82 03       	mov %d3,0
80021bc2:	a6 32       	or %d2,%d3
80021bc4:	e9 c2 07 00 	st.b [%a12]7,%d2
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
80021bc8:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80021bcc:	06 e2       	sh %d2,-2
80021bce:	8f f2 0f 21 	and %d2,%d2,255
80021bd2:	37 02 70 20 	extr.u %d2,%d2,0,16
80021bd6:	c2 52       	add %d2,5
80021bd8:	37 02 70 20 	extr.u %d2,%d2,0,16
80021bdc:	8f c2 00 20 	sh %d2,%d2,12
80021be0:	37 02 70 30 	extr.u %d3,%d2,0,16
80021be4:	39 e2 ec ff 	ld.bu %d2,[%a14]-20
80021be8:	37 02 70 20 	extr.u %d2,%d2,0,16
80021bec:	a6 32       	or %d2,%d3
80021bee:	37 02 70 20 	extr.u %d2,%d2,0,16
80021bf2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021bf6:	d9 22 10 00 	lea %a2,[%a2]16
80021bfa:	d4 2c       	ld.a %a12,[%a2]
80021bfc:	02 24       	mov %d4,%d2
80021bfe:	6d ff ab ac 	call 80017554 <lwip_htons>
80021c02:	8f f2 0f 31 	and %d3,%d2,255
80021c06:	82 04       	mov %d4,0
80021c08:	a6 43       	or %d3,%d4
80021c0a:	e9 c3 0c 00 	st.b [%a12]12,%d3
80021c0e:	06 82       	sh %d2,-8
80021c10:	37 02 70 20 	extr.u %d2,%d2,0,16
80021c14:	82 03       	mov %d3,0
80021c16:	a6 32       	or %d2,%d3
80021c18:	e9 c2 0d 00 	st.b [%a12]13,%d2
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
80021c1c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021c20:	d9 22 10 00 	lea %a2,[%a2]16
80021c24:	d4 22       	ld.a %a2,[%a2]
80021c26:	82 02       	mov %d2,0
80021c28:	e9 22 12 00 	st.b [%a2]18,%d2
80021c2c:	82 02       	mov %d2,0
80021c2e:	e9 22 13 00 	st.b [%a2]19,%d2
  return seg;
80021c32:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
}
80021c36:	60 22       	mov.a %a2,%d2
80021c38:	00 90       	ret 

80021c3a <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, const struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
80021c3a:	40 ae       	mov.aa %a14,%sp
80021c3c:	20 38       	sub.a %sp,56
80021c3e:	59 e4 f4 ff 	st.w [%a14]-12,%d4
80021c42:	02 52       	mov %d2,%d5
80021c44:	02 64       	mov %d4,%d6
80021c46:	b5 e4 e8 ff 	st.a [%a14]-24,%a4
80021c4a:	b5 e5 e4 ff 	st.a [%a14]-28,%a5
80021c4e:	02 73       	mov %d3,%d7
80021c50:	54 e5       	ld.w %d5,[%a14]
80021c52:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
80021c56:	02 42       	mov %d2,%d4
80021c58:	f9 e2 ec ff 	st.h [%a14]-20,%d2
80021c5c:	02 32       	mov %d2,%d3
80021c5e:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
80021c62:	02 52       	mov %d2,%d5
80021c64:	e9 e2 dc ff 	st.b [%a14]-36,%d2
  struct pbuf *p;
  u16_t alloc = length;
80021c68:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
80021c6c:	f9 e2 fe ff 	st.h [%a14]-2,%d2

  LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
80021c70:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80021c74:	df 02 17 80 	jne %d2,0,80021ca2 <tcp_pbuf_prealloc+0x68>
80021c78:	91 00 00 28 	movh.a %a2,32768
80021c7c:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80021c80:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80021c84:	3b 80 0e 20 	mov %d2,232
80021c88:	59 a2 04 00 	st.w [%sp]4,%d2
80021c8c:	91 00 00 28 	movh.a %a2,32768
80021c90:	d9 22 a3 a2 	lea %a2,[%a2]10915 <80002aa3 <IfxCpu_Trap_vectorTable0_end+0x28af>>
80021c94:	f4 a2       	st.a [%sp],%a2
80021c96:	91 00 00 28 	movh.a %a2,32768
80021c9a:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021c9e:	6d ff 4c 1b 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
80021ca2:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80021ca6:	df 02 17 80 	jne %d2,0,80021cd4 <tcp_pbuf_prealloc+0x9a>
80021caa:	91 00 00 28 	movh.a %a2,32768
80021cae:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80021cb2:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80021cb6:	3b 90 0e 20 	mov %d2,233
80021cba:	59 a2 04 00 	st.w [%sp]4,%d2
80021cbe:	91 00 00 28 	movh.a %a2,32768
80021cc2:	d9 22 87 b2 	lea %a2,[%a2]10951 <80002ac7 <IfxCpu_Trap_vectorTable0_end+0x28d3>>
80021cc6:	f4 a2       	st.a [%sp],%a2
80021cc8:	91 00 00 28 	movh.a %a2,32768
80021ccc:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021cd0:	6d ff 33 1b 	call 80005336 <Ifx_Lwip_printf>
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
80021cd4:	b9 e3 f0 ff 	ld.hu %d3,[%a14]-16
80021cd8:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80021cdc:	7f 23 2e 80 	jge.u %d3,%d2,80021d38 <tcp_pbuf_prealloc+0xfe>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
80021ce0:	39 e2 e0 ff 	ld.bu %d2,[%a14]-32
80021ce4:	8f 22 00 21 	and %d2,%d2,2
80021ce8:	df 02 1c 80 	jne %d2,0,80021d20 <tcp_pbuf_prealloc+0xe6>
        (!(pcb->flags & TF_NODELAY) &&
80021cec:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80021cf0:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80021cf4:	8f 02 04 21 	and %d2,%d2,64
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
80021cf8:	df 02 20 80 	jne %d2,0,80021d38 <tcp_pbuf_prealloc+0xfe>
        (!(pcb->flags & TF_NODELAY) &&
80021cfc:	39 e2 dc ff 	ld.bu %d2,[%a14]-36
80021d00:	df 02 10 00 	jeq %d2,0,80021d20 <tcp_pbuf_prealloc+0xe6>
         (!first_seg ||
          pcb->unsent != NULL ||
80021d04:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80021d08:	d9 22 30 10 	lea %a2,[%a2]112
80021d0c:	54 22       	ld.w %d2,[%a2]
         (!first_seg ||
80021d0e:	df 02 09 80 	jne %d2,0,80021d20 <tcp_pbuf_prealloc+0xe6>
          pcb->unacked != NULL))) {
80021d12:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80021d16:	d9 22 34 10 	lea %a2,[%a2]116
80021d1a:	54 22       	ld.w %d2,[%a2]
          pcb->unsent != NULL ||
80021d1c:	df 02 0e 00 	jeq %d2,0,80021d38 <tcp_pbuf_prealloc+0xfe>
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
80021d20:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
80021d24:	1b b2 21 20 	addi %d2,%d2,539
80021d28:	8f 32 c0 31 	andn %d3,%d2,3
80021d2c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80021d30:	0b 23 90 21 	min.u %d2,%d3,%d2
80021d34:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
80021d38:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80021d3c:	3b 00 28 60 	mov %d6,640
80021d40:	02 25       	mov %d5,%d2
80021d42:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
80021d46:	6d ff cd bc 	call 800196e0 <pbuf_alloc>
80021d4a:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  if (p == NULL) {
80021d4e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80021d52:	df 02 05 80 	jne %d2,0,80021d5c <tcp_pbuf_prealloc+0x122>
    return NULL;
80021d56:	82 02       	mov %d2,0
80021d58:	1d 00 39 00 	j 80021dca <tcp_pbuf_prealloc+0x190>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
80021d5c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021d60:	54 22       	ld.w %d2,[%a2]
80021d62:	df 02 17 00 	jeq %d2,0,80021d90 <tcp_pbuf_prealloc+0x156>
80021d66:	91 00 00 28 	movh.a %a2,32768
80021d6a:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80021d6e:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80021d72:	3b b0 10 20 	mov %d2,267
80021d76:	59 a2 04 00 	st.w [%sp]4,%d2
80021d7a:	91 00 00 28 	movh.a %a2,32768
80021d7e:	d9 22 a6 b2 	lea %a2,[%a2]10982 <80002ae6 <IfxCpu_Trap_vectorTable0_end+0x28f2>>
80021d82:	f4 a2       	st.a [%sp],%a2
80021d84:	91 00 00 28 	movh.a %a2,32768
80021d88:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021d8c:	6d ff d5 1a 	call 80005336 <Ifx_Lwip_printf>
  *oversize = p->len - length;
80021d90:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021d94:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80021d98:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
80021d9c:	0b 23 80 20 	sub %d2,%d3,%d2
80021da0:	37 02 70 20 	extr.u %d2,%d2,0,16
80021da4:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80021da8:	b4 22       	st.h [%a2],%d2
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
80021daa:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021dae:	c9 e2 f0 ff 	ld.h %d2,[%a14]-16
80021db2:	f9 22 08 00 	st.h [%a2]8,%d2
80021db6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021dba:	b9 22 08 00 	ld.hu %d2,[%a2]8
80021dbe:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80021dc2:	f9 22 0a 00 	st.h [%a2]10,%d2
  return p;
80021dc6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
}
80021dca:	60 22       	mov.a %a2,%d2
80021dcc:	00 90       	ret 

80021dce <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
80021dce:	40 ae       	mov.aa %a14,%sp
80021dd0:	20 18       	sub.a %sp,24
80021dd2:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80021dd6:	02 42       	mov %d2,%d4
80021dd8:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
80021ddc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80021de0:	df 02 17 80 	jne %d2,0,80021e0e <tcp_write_checks+0x40>
80021de4:	91 00 00 28 	movh.a %a2,32768
80021de8:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80021dec:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80021df0:	3b 30 13 20 	mov %d2,307
80021df4:	59 a2 04 00 	st.w [%sp]4,%d2
80021df8:	91 00 00 28 	movh.a %a2,32768
80021dfc:	d9 22 ba b2 	lea %a2,[%a2]11002 <80002afa <IfxCpu_Trap_vectorTable0_end+0x2906>>
80021e00:	f4 a2       	st.a [%sp],%a2
80021e02:	91 00 00 28 	movh.a %a2,32768
80021e06:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021e0a:	6d ff 96 1a 	call 80005336 <Ifx_Lwip_printf>

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
80021e0e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021e12:	d9 22 14 00 	lea %a2,[%a2]20
80021e16:	54 22       	ld.w %d2,[%a2]
80021e18:	df 42 1a 00 	jeq %d2,4,80021e4c <tcp_write_checks+0x7e>
      (pcb->state != CLOSE_WAIT) &&
80021e1c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021e20:	d9 22 14 00 	lea %a2,[%a2]20
80021e24:	54 22       	ld.w %d2,[%a2]
  if ((pcb->state != ESTABLISHED) &&
80021e26:	df 72 13 00 	jeq %d2,7,80021e4c <tcp_write_checks+0x7e>
      (pcb->state != SYN_SENT) &&
80021e2a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021e2e:	d9 22 14 00 	lea %a2,[%a2]20
80021e32:	54 22       	ld.w %d2,[%a2]
      (pcb->state != CLOSE_WAIT) &&
80021e34:	df 22 0c 00 	jeq %d2,2,80021e4c <tcp_write_checks+0x7e>
      (pcb->state != SYN_RCVD)) {
80021e38:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021e3c:	d9 22 14 00 	lea %a2,[%a2]20
80021e40:	54 22       	ld.w %d2,[%a2]
      (pcb->state != SYN_SENT) &&
80021e42:	df 32 05 00 	jeq %d2,3,80021e4c <tcp_write_checks+0x7e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
80021e46:	3b 50 ff 2f 	mov %d2,-11
80021e4a:	00 90       	ret 
  } else if (len == 0) {
80021e4c:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80021e50:	df 02 04 80 	jne %d2,0,80021e58 <tcp_write_checks+0x8a>
    return ERR_OK;
80021e54:	82 02       	mov %d2,0
80021e56:	00 90       	ret 
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
80021e58:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021e5c:	b9 23 28 10 	ld.hu %d3,[%a2]104
80021e60:	b9 e2 f8 ff 	ld.hu %d2,[%a14]-8
80021e64:	7f 23 10 80 	jge.u %d3,%d2,80021e84 <tcp_write_checks+0xb6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
                len, pcb->snd_buf));
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
80021e68:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021e6c:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80021e70:	8f 02 48 21 	or %d2,%d2,128
80021e74:	37 02 70 20 	extr.u %d2,%d2,0,16
80021e78:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021e7c:	f9 22 1e 00 	st.h [%a2]30,%d2
    return ERR_MEM;
80021e80:	82 f2       	mov %d2,-1
80021e82:	00 90       	ret 
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
80021e84:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021e88:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80021e8c:	bf 82 1f 80 	jlt.u %d2,8,80021eca <tcp_write_checks+0xfc>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
                pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
80021e90:	91 10 00 27 	movh.a %a2,28673
80021e94:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80021e98:	b9 22 1c 20 	ld.hu %d2,[%a2]156 <7001009c <ram_heap+0x5008>>
80021e9c:	c2 12       	add %d2,1
80021e9e:	37 02 70 20 	extr.u %d2,%d2,0,16
80021ea2:	91 10 00 27 	movh.a %a2,28673
80021ea6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80021eaa:	f9 22 1c 20 	st.h [%a2]156 <7001009c <ram_heap+0x5008>>,%d2
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
80021eae:	99 e2 fc ff 	ld.a %a2,[%a14]-4 <7001009c <ram_heap+0x5008>>
80021eb2:	b9 22 1e 00 	ld.hu %d2,[%a2]30 <7001009c <ram_heap+0x5008>>
80021eb6:	8f 02 48 21 	or %d2,%d2,128
80021eba:	37 02 70 20 	extr.u %d2,%d2,0,16
80021ebe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021ec2:	f9 22 1e 00 	st.h [%a2]30,%d2
    return ERR_MEM;
80021ec6:	82 f2       	mov %d2,-1
80021ec8:	00 90       	ret 
  }
  if (pcb->snd_queuelen != 0) {
80021eca:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021ece:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80021ed2:	df 02 27 00 	jeq %d2,0,80021f20 <tcp_write_checks+0x152>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
80021ed6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021eda:	d9 22 34 10 	lea %a2,[%a2]116
80021ede:	54 22       	ld.w %d2,[%a2]
80021ee0:	df 02 43 80 	jne %d2,0,80021f66 <tcp_write_checks+0x198>
80021ee4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021ee8:	d9 22 30 10 	lea %a2,[%a2]112
80021eec:	54 22       	ld.w %d2,[%a2]
80021eee:	df 02 3c 80 	jne %d2,0,80021f66 <tcp_write_checks+0x198>
80021ef2:	91 00 00 28 	movh.a %a2,32768
80021ef6:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80021efa:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80021efe:	3b 50 15 20 	mov %d2,341
80021f02:	59 a2 04 00 	st.w [%sp]4,%d2
80021f06:	91 00 00 28 	movh.a %a2,32768
80021f0a:	d9 22 98 c2 	lea %a2,[%a2]11032 <80002b18 <IfxCpu_Trap_vectorTable0_end+0x2924>>
80021f0e:	f4 a2       	st.a [%sp],%a2
80021f10:	91 00 00 28 	movh.a %a2,32768
80021f14:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021f18:	6d ff 0f 1a 	call 80005336 <Ifx_Lwip_printf>
80021f1c:	1d 00 25 00 	j 80021f66 <tcp_write_checks+0x198>
                pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
80021f20:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021f24:	d9 22 34 10 	lea %a2,[%a2]116
80021f28:	54 22       	ld.w %d2,[%a2]
80021f2a:	df 02 09 80 	jne %d2,0,80021f3c <tcp_write_checks+0x16e>
80021f2e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80021f32:	d9 22 30 10 	lea %a2,[%a2]112
80021f36:	54 22       	ld.w %d2,[%a2]
80021f38:	df 02 17 00 	jeq %d2,0,80021f66 <tcp_write_checks+0x198>
80021f3c:	91 00 00 28 	movh.a %a2,32768
80021f40:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80021f44:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80021f48:	3b 80 15 20 	mov %d2,344
80021f4c:	59 a2 04 00 	st.w [%sp]4,%d2
80021f50:	91 00 00 28 	movh.a %a2,32768
80021f54:	d9 22 92 d2 	lea %a2,[%a2]11090 <80002b52 <IfxCpu_Trap_vectorTable0_end+0x295e>>
80021f58:	f4 a2       	st.a [%sp],%a2
80021f5a:	91 00 00 28 	movh.a %a2,32768
80021f5e:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021f62:	6d ff ea 19 	call 80005336 <Ifx_Lwip_printf>
                pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
80021f66:	82 02       	mov %d2,0
}
80021f68:	00 90       	ret 

80021f6a <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
80021f6a:	40 ae       	mov.aa %a14,%sp
80021f6c:	20 70       	sub.a %sp,112
80021f6e:	b5 e4 ec ef 	st.a [%a14]-84,%a4
80021f72:	b5 e5 e8 ef 	st.a [%a14]-88,%a5
80021f76:	02 42       	mov %d2,%d4
80021f78:	02 53       	mov %d3,%d5
80021f7a:	f9 e2 e4 ef 	st.h [%a14]-92,%d2
80021f7e:	02 32       	mov %d2,%d3
80021f80:	e9 e2 e0 ef 	st.b [%a14]-96,%d2
  struct pbuf *concat_p = NULL;
80021f84:	82 02       	mov %d2,0
80021f86:	59 e2 d8 ff 	st.w [%a14]-40,%d2
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
80021f8a:	82 02       	mov %d2,0
80021f8c:	59 e2 dc ff 	st.w [%a14]-36,%d2
80021f90:	82 02       	mov %d2,0
80021f92:	59 e2 f0 ff 	st.w [%a14]-16,%d2
80021f96:	82 02       	mov %d2,0
80021f98:	59 e2 ec ff 	st.w [%a14]-20,%d2
80021f9c:	82 02       	mov %d2,0
80021f9e:	59 e2 e8 ff 	st.w [%a14]-24,%d2
  u16_t pos = 0; /* position in 'arg' data */
80021fa2:	82 02       	mov %d2,0
80021fa4:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
  u16_t queuelen;
  u8_t optlen;
  u8_t optflags = 0;
80021fa8:	82 02       	mov %d2,0
80021faa:	e9 e2 cb ff 	st.b [%a14]-53,%d2
#if TCP_OVERSIZE
  u16_t oversize = 0;
80021fae:	82 02       	mov %d2,0
80021fb0:	f9 e2 f6 ef 	st.h [%a14]-74,%d2
  u16_t oversize_used = 0;
80021fb4:	82 02       	mov %d2,0
80021fb6:	f9 e2 e2 ff 	st.h [%a14]-30,%d2
#if TCP_OVERSIZE_DBGCHECK
  u16_t oversize_add = 0;
80021fba:	82 02       	mov %d2,0
80021fbc:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
#endif /* TCP_OVERSIZE_DBGCHECK*/
#endif /* TCP_OVERSIZE */
  u16_t extendlen = 0;
80021fc0:	82 02       	mov %d2,0
80021fc2:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  u16_t mss_local;

  LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
80021fc6:	19 e2 ec ef 	ld.w %d2,[%a14]-84
80021fca:	df 02 1a 80 	jne %d2,0,80021ffe <tcp_write+0x94>
80021fce:	91 00 00 28 	movh.a %a2,32768
80021fd2:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80021fd6:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80021fda:	3b e0 19 20 	mov %d2,414
80021fde:	59 a2 04 00 	st.w [%sp]4,%d2
80021fe2:	91 00 00 28 	movh.a %a2,32768
80021fe6:	d9 22 84 e2 	lea %a2,[%a2]11140 <80002b84 <IfxCpu_Trap_vectorTable0_end+0x2990>>
80021fea:	f4 a2       	st.a [%sp],%a2
80021fec:	91 00 00 28 	movh.a %a2,32768
80021ff0:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80021ff4:	6d ff a1 19 	call 80005336 <Ifx_Lwip_printf>
80021ff8:	3b 00 ff 2f 	mov %d2,-16
80021ffc:	00 90       	ret 

  /* don't allocate segments bigger than half the maximum window we ever received */
  mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
80021ffe:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022002:	b9 22 26 10 	ld.hu %d2,[%a2]102
80022006:	06 f2       	sh %d2,-1
80022008:	37 02 70 30 	extr.u %d3,%d2,0,16
8002200c:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022010:	b9 22 36 00 	ld.hu %d2,[%a2]54
80022014:	0b 23 90 21 	min.u %d2,%d3,%d2
80022018:	f9 e2 c8 ff 	st.h [%a14]-56,%d2
  mss_local = mss_local ? mss_local : pcb->mss;
8002201c:	b9 e2 c8 ff 	ld.hu %d2,[%a14]-56
80022020:	df 02 08 80 	jne %d2,0,80022030 <tcp_write+0xc6>
80022024:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022028:	b9 22 36 00 	ld.hu %d2,[%a2]54
8002202c:	1d 00 04 00 	j 80022034 <tcp_write+0xca>
80022030:	b9 e2 c8 ff 	ld.hu %d2,[%a14]-56
80022034:	f9 e2 c8 ff 	st.h [%a14]-56,%d2
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
                                 (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
80022038:	19 e2 e8 ef 	ld.w %d2,[%a14]-88
8002203c:	df 02 1a 80 	jne %d2,0,80022070 <tcp_write+0x106>
80022040:	91 00 00 28 	movh.a %a2,32768
80022044:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022048:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
8002204c:	3b d0 1a 20 	mov %d2,429
80022050:	59 a2 04 00 	st.w [%sp]4,%d2
80022054:	91 00 00 28 	movh.a %a2,32768
80022058:	d9 22 9b e2 	lea %a2,[%a2]11163 <80002b9b <IfxCpu_Trap_vectorTable0_end+0x29a7>>
8002205c:	f4 a2       	st.a [%sp],%a2
8002205e:	91 00 00 28 	movh.a %a2,32768
80022062:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022066:	6d ff 68 19 	call 80005336 <Ifx_Lwip_printf>
8002206a:	3b 00 ff 2f 	mov %d2,-16
8002206e:	00 90       	ret 
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
80022070:	b9 e2 e4 ef 	ld.hu %d2,[%a14]-92
80022074:	02 24       	mov %d4,%d2
80022076:	99 e4 ec ef 	ld.a %a4,[%a14]-84
8002207a:	6d ff aa fe 	call 80021dce <tcp_write_checks>
8002207e:	e9 e2 c7 ff 	st.b [%a14]-57,%d2
  if (err != ERR_OK) {
80022082:	79 e2 c7 ff 	ld.b %d2,[%a14]-57
80022086:	df 02 05 00 	jeq %d2,0,80022090 <tcp_write+0x126>
    return err;
8002208a:	79 e2 c7 ff 	ld.b %d2,[%a14]-57
8002208e:	00 90       	ret 
  }
  queuelen = pcb->snd_queuelen;
80022090:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022094:	c9 22 2a 10 	ld.h %d2,[%a2]106
80022098:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
    /* ensure that segments can hold at least one data byte... */
    mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
  } else
#endif /* LWIP_TCP_TIMESTAMPS */
  {
    optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
8002209c:	82 02       	mov %d2,0
8002209e:	e9 e2 c6 ff 	st.b [%a14]-58,%d2
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
800220a2:	99 e2 ec ef 	ld.a %a2,[%a14]-84
800220a6:	d9 22 30 10 	lea %a2,[%a2]112
800220aa:	54 22       	ld.w %d2,[%a2]
800220ac:	df 02 ac 01 	jeq %d2,0,80022404 <tcp_write+0x49a>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
800220b0:	99 e2 ec ef 	ld.a %a2,[%a14]-84
800220b4:	d9 22 30 10 	lea %a2,[%a2]112
800220b8:	54 22       	ld.w %d2,[%a2]
800220ba:	59 e2 dc ff 	st.w [%a14]-36,%d2
800220be:	1d 00 07 00 	j 800220cc <tcp_write+0x162>
         last_unsent = last_unsent->next);
800220c2:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800220c6:	54 22       	ld.w %d2,[%a2]
800220c8:	59 e2 dc ff 	st.w [%a14]-36,%d2
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
800220cc:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800220d0:	54 22       	ld.w %d2,[%a2]
800220d2:	df 02 f8 ff 	jne %d2,0,800220c2 <tcp_write+0x158>

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
800220d6:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800220da:	39 22 0c 00 	ld.bu %d2,[%a2]12
800220de:	06 22       	sh %d2,2
800220e0:	37 02 70 20 	extr.u %d2,%d2,0,16
800220e4:	8f 42 00 21 	and %d2,%d2,4
800220e8:	f9 e2 c4 ff 	st.h [%a14]-60,%d2
    LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
800220ec:	b9 e2 c8 ff 	ld.hu %d2,[%a14]-56
800220f0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800220f4:	b9 23 08 00 	ld.hu %d3,[%a2]8
800220f8:	02 34       	mov %d4,%d3
800220fa:	b9 e3 c4 ff 	ld.hu %d3,[%a14]-60
800220fe:	42 43       	add %d3,%d4
80022100:	7f 32 17 00 	jge %d2,%d3,8002212e <tcp_write+0x1c4>
80022104:	91 00 00 28 	movh.a %a2,32768
80022108:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
8002210c:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022110:	3b 60 1e 20 	mov %d2,486
80022114:	59 a2 04 00 	st.w [%sp]4,%d2
80022118:	91 00 00 28 	movh.a %a2,32768
8002211c:	d9 22 8c f2 	lea %a2,[%a2]11212 <80002bcc <IfxCpu_Trap_vectorTable0_end+0x29d8>>
80022120:	f4 a2       	st.a [%sp],%a2
80022122:	91 00 00 28 	movh.a %a2,32768
80022126:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002212a:	6d ff 06 19 	call 80005336 <Ifx_Lwip_printf>
    space = mss_local - (last_unsent->len + unsent_optlen);
8002212e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022132:	b9 23 08 00 	ld.hu %d3,[%a2]8
80022136:	c9 e2 c4 ff 	ld.h %d2,[%a14]-60
8002213a:	42 32       	add %d2,%d3
8002213c:	37 02 70 20 	extr.u %d2,%d2,0,16
80022140:	c9 e3 c8 ff 	ld.h %d3,[%a14]-56
80022144:	0b 23 80 20 	sub %d2,%d3,%d2
80022148:	f9 e2 fe ff 	st.h [%a14]-2,%d2
     * function.
     */
#if TCP_OVERSIZE
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
8002214c:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022150:	b9 23 2c 10 	ld.hu %d3,[%a2]108
80022154:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022158:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8002215c:	5f 23 17 00 	jeq %d3,%d2,8002218a <tcp_write+0x220>
80022160:	91 00 00 28 	movh.a %a2,32768
80022164:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022168:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
8002216c:	3b 30 1f 20 	mov %d2,499
80022170:	59 a2 04 00 	st.w [%sp]4,%d2
80022174:	91 00 00 28 	movh.a %a2,32768
80022178:	d9 22 a3 f2 	lea %a2,[%a2]11235 <80002be3 <IfxCpu_Trap_vectorTable0_end+0x29ef>>
8002217c:	f4 a2       	st.a [%sp],%a2
8002217e:	91 00 00 28 	movh.a %a2,32768
80022182:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022186:	6d ff d8 18 	call 80005336 <Ifx_Lwip_printf>
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
8002218a:	99 e2 ec ef 	ld.a %a2,[%a14]-84
8002218e:	b9 22 2c 10 	ld.hu %d2,[%a2]108
80022192:	f9 e2 f6 ef 	st.h [%a14]-74,%d2
    if (oversize > 0) {
80022196:	b9 e2 f6 ef 	ld.hu %d2,[%a14]-74
8002219a:	df 02 48 00 	jeq %d2,0,8002222a <tcp_write+0x2c0>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
8002219e:	b9 e2 f6 ef 	ld.hu %d2,[%a14]-74
800221a2:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
800221a6:	7f 23 17 80 	jge.u %d3,%d2,800221d4 <tcp_write+0x26a>
800221aa:	91 00 00 28 	movh.a %a2,32768
800221ae:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800221b2:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800221b6:	3b 80 1f 20 	mov %d2,504
800221ba:	59 a2 04 00 	st.w [%sp]4,%d2
800221be:	91 00 00 28 	movh.a %a2,32768
800221c2:	d9 22 d2 02 	lea %a2,[%a2]11282 <80002c12 <IfxCpu_Trap_vectorTable0_end+0x2a1e>>
800221c6:	f4 a2       	st.a [%sp],%a2
800221c8:	91 00 00 28 	movh.a %a2,32768
800221cc:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800221d0:	6d ff b3 18 	call 80005336 <Ifx_Lwip_printf>
      seg = last_unsent;
800221d4:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800221d8:	59 e2 f0 ff 	st.w [%a14]-16,%d2
      oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
800221dc:	b9 e2 f6 ef 	ld.hu %d2,[%a14]-74
800221e0:	b9 e3 e4 ef 	ld.hu %d3,[%a14]-92
800221e4:	0b 23 90 21 	min.u %d2,%d3,%d2
800221e8:	37 02 70 20 	extr.u %d2,%d2,0,16
800221ec:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
800221f0:	0b 23 90 21 	min.u %d2,%d3,%d2
800221f4:	f9 e2 e2 ff 	st.h [%a14]-30,%d2
      pos += oversize_used;
800221f8:	c9 e3 e6 ff 	ld.h %d3,[%a14]-26
800221fc:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
80022200:	42 32       	add %d2,%d3
80022202:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
      oversize -= oversize_used;
80022206:	b9 e3 f6 ef 	ld.hu %d3,[%a14]-74
8002220a:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
8002220e:	0b 23 80 20 	sub %d2,%d3,%d2
80022212:	37 02 70 20 	extr.u %d2,%d2,0,16
80022216:	f9 e2 f6 ef 	st.h [%a14]-74,%d2
      space -= oversize_used;
8002221a:	c9 e3 fe ff 	ld.h %d3,[%a14]-2
8002221e:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
80022222:	0b 23 80 20 	sub %d2,%d3,%d2
80022226:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
8002222a:	b9 e2 f6 ef 	ld.hu %d2,[%a14]-74
8002222e:	df 02 1d 00 	jeq %d2,0,80022268 <tcp_write+0x2fe>
80022232:	b9 e3 e6 ff 	ld.hu %d3,[%a14]-26
80022236:	b9 e2 e4 ef 	ld.hu %d2,[%a14]-92
8002223a:	5f 23 17 00 	jeq %d3,%d2,80022268 <tcp_write+0x2fe>
8002223e:	91 00 00 28 	movh.a %a2,32768
80022242:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022246:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
8002224a:	3b 00 20 20 	mov %d2,512
8002224e:	59 a2 04 00 	st.w [%sp]4,%d2
80022252:	91 00 00 28 	movh.a %a2,32768
80022256:	d9 22 f2 02 	lea %a2,[%a2]11314 <80002c32 <IfxCpu_Trap_vectorTable0_end+0x2a3e>>
8002225a:	f4 a2       	st.a [%sp],%a2
8002225c:	91 00 00 28 	movh.a %a2,32768
80022260:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022264:	6d ff 69 18 	call 80005336 <Ifx_Lwip_printf>
     *
     * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
     * it after rexmit puts a segment from unacked to unsent and at this point,
     * oversize info is lost.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
80022268:	b9 e3 e6 ff 	ld.hu %d3,[%a14]-26
8002226c:	b9 e2 e4 ef 	ld.hu %d2,[%a14]-92
80022270:	7f 23 11 82 	jge.u %d3,%d2,80022692 <tcp_write+0x728>
80022274:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80022278:	df 02 0d 02 	jeq %d2,0,80022692 <tcp_write+0x728>
8002227c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022280:	b9 22 08 00 	ld.hu %d2,[%a2]8
80022284:	df 02 07 02 	jeq %d2,0,80022692 <tcp_write+0x728>
      u16_t seglen = LWIP_MIN(space, len - pos);
80022288:	b9 e3 e4 ef 	ld.hu %d3,[%a14]-92
8002228c:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
80022290:	a2 23       	sub %d3,%d2
80022292:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80022296:	0b 23 80 21 	min %d2,%d3,%d2
8002229a:	f9 e2 c2 ff 	st.h [%a14]-62,%d2
      seg = last_unsent;
8002229e:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800222a2:	59 e2 f0 ff 	st.w [%a14]-16,%d2

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
800222a6:	39 e2 e0 ef 	ld.bu %d2,[%a14]-96
800222aa:	8f 12 00 21 	and %d2,%d2,1
800222ae:	df 02 3c 00 	jeq %d2,0,80022326 <tcp_write+0x3bc>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
800222b2:	b9 e2 c2 ff 	ld.hu %d2,[%a14]-62
800222b6:	b9 e3 fe ff 	ld.hu %d3,[%a14]-2
800222ba:	39 e4 e0 ef 	ld.bu %d4,[%a14]-96
800222be:	d9 e2 f6 ef 	lea %a2,[%a14]-74
800222c2:	82 15       	mov %d5,1
800222c4:	74 a5       	st.w [%sp],%d5
800222c6:	02 47       	mov %d7,%d4
800222c8:	99 e5 ec ef 	ld.a %a5,[%a14]-84
800222cc:	40 24       	mov.aa %a4,%a2
800222ce:	02 36       	mov %d6,%d3
800222d0:	02 25       	mov %d5,%d2
800222d2:	82 04       	mov %d4,0
800222d4:	6d ff b3 fc 	call 80021c3a <tcp_pbuf_prealloc>
800222d8:	b5 e2 d8 ff 	st.a [%a14]-40,%a2
800222dc:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
800222e0:	df 02 ad 03 	jeq %d2,0,80022a3a <tcp_write+0xad0>
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        oversize_add = oversize;
800222e4:	c9 e2 f6 ef 	ld.h %d2,[%a14]-74
800222e8:	f9 e2 f4 ff 	st.h [%a14]-12,%d2
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
800222ec:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
800222f0:	b0 42       	add.a %a2,4
800222f2:	54 23       	ld.w %d3,[%a2]
800222f4:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
800222f8:	19 e4 e8 ef 	ld.w %d4,[%a14]-88
800222fc:	0b 24 00 50 	add %d5,%d4,%d2
80022300:	b9 e2 c2 ff 	ld.hu %d2,[%a14]-62
80022304:	02 24       	mov %d4,%d2
80022306:	60 55       	mov.a %a5,%d5
80022308:	60 34       	mov.a %a4,%d3
8002230a:	6d 00 89 27 	call 8002721c <memcpy>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        queuelen += pbuf_clen(concat_p);
8002230e:	99 e4 d8 ff 	ld.a %a4,[%a14]-40
80022312:	6d ff 26 bf 	call 8001a15e <pbuf_clen>
80022316:	02 23       	mov %d3,%d2
80022318:	c9 e2 e4 ff 	ld.h %d2,[%a14]-28
8002231c:	42 32       	add %d2,%d3
8002231e:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
80022322:	1d 00 68 00 	j 800223f2 <tcp_write+0x488>
      } else {
        /* Data is not copied */
        /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
        struct pbuf *p;
        for (p = last_unsent->p; p->next != NULL; p = p->next);
80022326:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002232a:	b0 42       	add.a %a2,4
8002232c:	54 22       	ld.w %d2,[%a2]
8002232e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80022332:	1d 00 07 00 	j 80022340 <tcp_write+0x3d6>
80022336:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002233a:	54 22       	ld.w %d2,[%a2]
8002233c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80022340:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80022344:	54 22       	ld.w %d2,[%a2]
80022346:	df 02 f8 ff 	jne %d2,0,80022336 <tcp_write+0x3cc>
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
8002234a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002234e:	39 22 0c 00 	ld.bu %d2,[%a2]12
80022352:	8f 02 0c 21 	and %d2,%d2,192
80022356:	df 02 2e 80 	jne %d2,0,800223b2 <tcp_write+0x448>
            (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
8002235a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002235e:	b0 42       	add.a %a2,4
80022360:	54 23       	ld.w %d3,[%a2]
80022362:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80022366:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8002236a:	42 32       	add %d2,%d3
        if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
8002236c:	19 e3 e8 ef 	ld.w %d3,[%a14]-88
80022370:	5f 23 21 80 	jne %d3,%d2,800223b2 <tcp_write+0x448>
          LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
80022374:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
80022378:	df 02 17 00 	jeq %d2,0,800223a6 <tcp_write+0x43c>
8002237c:	91 00 00 28 	movh.a %a2,32768
80022380:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022384:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022388:	3b 10 23 20 	mov %d2,561
8002238c:	59 a2 04 00 	st.w [%sp]4,%d2
80022390:	91 00 00 28 	movh.a %a2,32768
80022394:	d9 22 d0 12 	lea %a2,[%a2]11344 <80002c50 <IfxCpu_Trap_vectorTable0_end+0x2a5c>>
80022398:	f4 a2       	st.a [%sp],%a2
8002239a:	91 00 00 28 	movh.a %a2,32768
8002239e:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800223a2:	6d ff ca 17 	call 80005336 <Ifx_Lwip_printf>
          extendlen = seglen;
800223a6:	c9 e2 c2 ff 	ld.h %d2,[%a14]-62
800223aa:	f9 e2 f6 ff 	st.h [%a14]-10,%d2
800223ae:	1d 00 22 00 	j 800223f2 <tcp_write+0x488>
        } else {
          if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
800223b2:	b9 e2 c2 ff 	ld.hu %d2,[%a14]-62
800223b6:	82 16       	mov %d6,1
800223b8:	02 25       	mov %d5,%d2
800223ba:	82 04       	mov %d4,0
800223bc:	6d ff 92 b9 	call 800196e0 <pbuf_alloc>
800223c0:	b5 e2 d8 ff 	st.a [%a14]-40,%a2
800223c4:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
800223c8:	df 02 39 03 	jeq %d2,0,80022a3a <tcp_write+0xad0>
            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                        ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
            goto memerr;
          }
          /* reference the non-volatile payload data */
          ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
800223cc:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
800223d0:	19 e3 e8 ef 	ld.w %d3,[%a14]-88
800223d4:	42 32       	add %d2,%d3
800223d6:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
800223da:	b0 42       	add.a %a2,4
800223dc:	74 22       	st.w [%a2],%d2
          queuelen += pbuf_clen(concat_p);
800223de:	99 e4 d8 ff 	ld.a %a4,[%a14]-40
800223e2:	6d ff be be 	call 8001a15e <pbuf_clen>
800223e6:	02 23       	mov %d3,%d2
800223e8:	c9 e2 e4 ff 	ld.h %d2,[%a14]-28
800223ec:	42 32       	add %d2,%d3
800223ee:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
                           &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      }

      pos += seglen;
800223f2:	c9 e3 e6 ff 	ld.h %d3,[%a14]-26
800223f6:	c9 e2 c2 ff 	ld.h %d2,[%a14]-62
800223fa:	42 32       	add %d2,%d3
800223fc:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
80022400:	1d 00 49 01 	j 80022692 <tcp_write+0x728>
    }
#endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
80022404:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022408:	b9 22 2c 10 	ld.hu %d2,[%a2]108
8002240c:	df 02 43 01 	jeq %d2,0,80022692 <tcp_write+0x728>
80022410:	91 00 00 28 	movh.a %a2,32768
80022414:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022418:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
8002241c:	3b a0 24 20 	mov %d2,586
80022420:	59 a2 04 00 	st.w [%sp]4,%d2
80022424:	91 00 00 28 	movh.a %a2,32768
80022428:	d9 22 f9 12 	lea %a2,[%a2]11385 <80002c79 <IfxCpu_Trap_vectorTable0_end+0x2a85>>
8002242c:	f4 a2       	st.a [%sp],%a2
8002242e:	91 00 00 28 	movh.a %a2,32768
80022432:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022436:	6d ff 80 17 	call 80005336 <Ifx_Lwip_printf>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
8002243a:	1d 00 2c 01 	j 80022692 <tcp_write+0x728>
    struct pbuf *p;
    u16_t left = len - pos;
8002243e:	c9 e3 e4 ef 	ld.h %d3,[%a14]-92
80022442:	c9 e2 e6 ff 	ld.h %d2,[%a14]-26
80022446:	0b 23 80 20 	sub %d2,%d3,%d2
8002244a:	f9 e2 c0 ff 	st.h [%a14]-64,%d2
    u16_t max_len = mss_local - optlen;
8002244e:	39 e2 c6 ff 	ld.bu %d2,[%a14]-58
80022452:	37 02 70 20 	extr.u %d2,%d2,0,16
80022456:	c9 e3 c8 ff 	ld.h %d3,[%a14]-56
8002245a:	0b 23 80 20 	sub %d2,%d3,%d2
8002245e:	f9 e2 fe ef 	st.h [%a14]-66,%d2
    u16_t seglen = LWIP_MIN(left, max_len);
80022462:	b9 e3 fe ef 	ld.hu %d3,[%a14]-66
80022466:	b9 e2 c0 ff 	ld.hu %d2,[%a14]-64
8002246a:	0b 23 90 21 	min.u %d2,%d3,%d2
8002246e:	f9 e2 fc ef 	st.h [%a14]-68,%d2
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
80022472:	39 e2 e0 ef 	ld.bu %d2,[%a14]-96
80022476:	8f 12 00 21 	and %d2,%d2,1
8002247a:	df 02 5b 00 	jeq %d2,0,80022530 <tcp_write+0x5c6>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
8002247e:	39 e2 c6 ff 	ld.bu %d2,[%a14]-58
80022482:	37 02 70 30 	extr.u %d3,%d2,0,16
80022486:	c9 e2 fc ef 	ld.h %d2,[%a14]-68
8002248a:	42 32       	add %d2,%d3
8002248c:	37 02 70 20 	extr.u %d2,%d2,0,16
80022490:	02 25       	mov %d5,%d2
80022492:	b9 e2 c8 ff 	ld.hu %d2,[%a14]-56
80022496:	39 e3 e0 ef 	ld.bu %d3,[%a14]-96
8002249a:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
8002249e:	8b 04 00 42 	eq %d4,%d4,0
800224a2:	8f f4 0f 41 	and %d4,%d4,255
800224a6:	d9 e2 f6 ef 	lea %a2,[%a14]-74
800224aa:	74 a4       	st.w [%sp],%d4
800224ac:	02 37       	mov %d7,%d3
800224ae:	99 e5 ec ef 	ld.a %a5,[%a14]-84
800224b2:	40 24       	mov.aa %a4,%a2
800224b4:	02 26       	mov %d6,%d2
800224b6:	3b 80 03 40 	mov %d4,56
800224ba:	6d ff c0 fb 	call 80021c3a <tcp_pbuf_prealloc>
800224be:	b5 e2 d4 ff 	st.a [%a14]-44,%a2
800224c2:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800224c6:	df 02 ba 02 	jeq %d2,0,80022a3a <tcp_write+0xad0>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
800224ca:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
800224ce:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800224d2:	b9 e2 fc ef 	ld.hu %d2,[%a14]-68
800224d6:	7f 23 17 80 	jge.u %d3,%d2,80022504 <tcp_write+0x59a>
800224da:	91 00 00 28 	movh.a %a2,32768
800224de:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800224e2:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800224e6:	3b 60 26 20 	mov %d2,614
800224ea:	59 a2 04 00 	st.w [%sp]4,%d2
800224ee:	91 00 00 28 	movh.a %a2,32768
800224f2:	d9 22 e8 22 	lea %a2,[%a2]11432 <80002ca8 <IfxCpu_Trap_vectorTable0_end+0x2ab4>>
800224f6:	f4 a2       	st.a [%sp],%a2
800224f8:	91 00 00 28 	movh.a %a2,32768
800224fc:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022500:	6d ff 1b 17 	call 80005336 <Ifx_Lwip_printf>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
80022504:	99 e2 d4 ff 	ld.a %a2,[%a14]-44
80022508:	b0 42       	add.a %a2,4
8002250a:	54 23       	ld.w %d3,[%a2]
8002250c:	39 e2 c6 ff 	ld.bu %d2,[%a14]-58
80022510:	42 23       	add %d3,%d2
80022512:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
80022516:	19 e4 e8 ef 	ld.w %d4,[%a14]-88
8002251a:	0b 24 00 50 	add %d5,%d4,%d2
8002251e:	b9 e2 fc ef 	ld.hu %d2,[%a14]-68
80022522:	02 24       	mov %d4,%d2
80022524:	60 55       	mov.a %a5,%d5
80022526:	60 34       	mov.a %a4,%d3
80022528:	6d 00 7a 26 	call 8002721c <memcpy>
8002252c:	1d 00 4d 00 	j 800225c6 <tcp_write+0x65c>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
80022530:	b9 e2 f6 ef 	ld.hu %d2,[%a14]-74
80022534:	df 02 17 00 	jeq %d2,0,80022562 <tcp_write+0x5f8>
80022538:	91 00 00 28 	movh.a %a2,32768
8002253c:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022540:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022544:	3b 10 27 20 	mov %d2,625
80022548:	59 a2 04 00 	st.w [%sp]4,%d2
8002254c:	91 00 00 28 	movh.a %a2,32768
80022550:	d9 22 e6 32 	lea %a2,[%a2]11494 <80002ce6 <IfxCpu_Trap_vectorTable0_end+0x2af2>>
80022554:	f4 a2       	st.a [%sp],%a2
80022556:	91 00 00 28 	movh.a %a2,32768
8002255a:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002255e:	6d ff ec 16 	call 80005336 <Ifx_Lwip_printf>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
80022562:	b9 e2 fc ef 	ld.hu %d2,[%a14]-68
80022566:	82 16       	mov %d6,1
80022568:	02 25       	mov %d5,%d2
8002256a:	3b 80 03 40 	mov %d4,56
8002256e:	6d ff b9 b8 	call 800196e0 <pbuf_alloc>
80022572:	b5 e2 f8 ef 	st.a [%a14]-72,%a2
80022576:	19 e2 f8 ef 	ld.w %d2,[%a14]-72
8002257a:	df 02 60 02 	jeq %d2,0,80022a3a <tcp_write+0xad0>
        chksum_swapped = 1;
        chksum = SWAP_BYTES_IN_WORD(chksum);
      }
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
8002257e:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
80022582:	19 e3 e8 ef 	ld.w %d3,[%a14]-88
80022586:	42 32       	add %d2,%d3
80022588:	99 e2 f8 ef 	ld.a %a2,[%a14]-72
8002258c:	b0 42       	add.a %a2,4
8002258e:	74 22       	st.w [%a2],%d2

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
80022590:	39 e2 c6 ff 	ld.bu %d2,[%a14]-58
80022594:	3b 00 28 60 	mov %d6,640
80022598:	02 25       	mov %d5,%d2
8002259a:	3b 80 03 40 	mov %d4,56
8002259e:	6d ff a1 b8 	call 800196e0 <pbuf_alloc>
800225a2:	b5 e2 d4 ff 	st.a [%a14]-44,%a2
800225a6:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800225aa:	df 02 08 80 	jne %d2,0,800225ba <tcp_write+0x650>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
800225ae:	99 e4 f8 ef 	ld.a %a4,[%a14]-72
800225b2:	6d ff f3 bc 	call 80019f98 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
800225b6:	1d 00 42 02 	j 80022a3a <tcp_write+0xad0>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
800225ba:	99 e5 f8 ef 	ld.a %a5,[%a14]-72
800225be:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
800225c2:	6d ff 18 be 	call 8001a1f2 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
800225c6:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
800225ca:	6d ff ca bd 	call 8001a15e <pbuf_clen>
800225ce:	02 23       	mov %d3,%d2
800225d0:	c9 e2 e4 ff 	ld.h %d2,[%a14]-28
800225d4:	42 32       	add %d2,%d3
800225d6:	f9 e2 e4 ff 	st.h [%a14]-28,%d2

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
800225da:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
800225de:	bf 92 08 80 	jlt.u %d2,9,800225ee <tcp_write+0x684>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
                  queuelen, (int)TCP_SND_QUEUELEN));
      pbuf_free(p);
800225e2:	99 e4 d4 ff 	ld.a %a4,[%a14]-44
800225e6:	6d ff d9 bc 	call 80019f98 <pbuf_free>
      goto memerr;
800225ea:	1d 00 28 02 	j 80022a3a <tcp_write+0xad0>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
800225ee:	99 e2 ec ef 	ld.a %a2,[%a14]-84
800225f2:	d9 22 20 10 	lea %a2,[%a2]96
800225f6:	54 23       	ld.w %d3,[%a2]
800225f8:	b9 e2 e6 ff 	ld.hu %d2,[%a14]-26
800225fc:	42 23       	add %d3,%d2
800225fe:	39 e2 cb ff 	ld.bu %d2,[%a14]-53
80022602:	02 26       	mov %d6,%d2
80022604:	02 35       	mov %d5,%d3
80022606:	82 04       	mov %d4,0
80022608:	99 e5 d4 ff 	ld.a %a5,[%a14]-44
8002260c:	99 e4 ec ef 	ld.a %a4,[%a14]-84
80022610:	6d ff bf f9 	call 8002198e <tcp_create_segment>
80022614:	b5 e2 f0 ff 	st.a [%a14]-16,%a2
80022618:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8002261c:	df 02 0f 02 	jeq %d2,0,80022a3a <tcp_write+0xad0>
      goto memerr;
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
80022620:	b9 e2 f6 ef 	ld.hu %d2,[%a14]-74
80022624:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80022628:	f9 22 0a 00 	st.h [%a2]10,%d2
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
8002262c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80022630:	df 02 08 80 	jne %d2,0,80022640 <tcp_write+0x6d6>
      queue = seg;
80022634:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80022638:	59 e2 e8 ff 	st.w [%a14]-24,%d2
8002263c:	1d 00 20 00 	j 8002267c <tcp_write+0x712>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
80022640:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80022644:	df 02 17 80 	jne %d2,0,80022672 <tcp_write+0x708>
80022648:	91 00 00 28 	movh.a %a2,32768
8002264c:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022650:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022654:	3b b0 2a 20 	mov %d2,683
80022658:	59 a2 04 00 	st.w [%sp]4,%d2
8002265c:	91 00 00 28 	movh.a %a2,32768
80022660:	d9 22 f4 32 	lea %a2,[%a2]11508 <80002cf4 <IfxCpu_Trap_vectorTable0_end+0x2b00>>
80022664:	f4 a2       	st.a [%sp],%a2
80022666:	91 00 00 28 	movh.a %a2,32768
8002266a:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002266e:	6d ff 64 16 	call 80005336 <Ifx_Lwip_printf>
      prev_seg->next = seg;
80022672:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80022676:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8002267a:	74 22       	st.w [%a2],%d2
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
8002267c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80022680:	59 e2 ec ff 	st.w [%a14]-20,%d2

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
                lwip_ntohl(seg->tcphdr->seqno),
                lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
80022684:	c9 e3 e6 ff 	ld.h %d3,[%a14]-26
80022688:	c9 e2 fc ef 	ld.h %d2,[%a14]-68
8002268c:	42 32       	add %d2,%d3
8002268e:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
  while (pos < len) {
80022692:	b9 e3 e6 ff 	ld.hu %d3,[%a14]-26
80022696:	b9 e2 e4 ef 	ld.hu %d2,[%a14]-92
8002269a:	3f 23 d2 fe 	jlt.u %d3,%d2,8002243e <tcp_write+0x4d4>
  /*
   * All three segmentation phases were successful. We can commit the
   * transaction.
   */
#if TCP_OVERSIZE_DBGCHECK
  if ((last_unsent != NULL) && (oversize_add != 0)) {
8002269e:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800226a2:	df 02 13 00 	jeq %d2,0,800226c8 <tcp_write+0x75e>
800226a6:	b9 e2 f4 ff 	ld.hu %d2,[%a14]-12
800226aa:	df 02 0f 00 	jeq %d2,0,800226c8 <tcp_write+0x75e>
    last_unsent->oversize_left += oversize_add;
800226ae:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800226b2:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800226b6:	c9 e2 f4 ff 	ld.h %d2,[%a14]-12
800226ba:	42 32       	add %d2,%d3
800226bc:	37 02 70 20 	extr.u %d2,%d2,0,16
800226c0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800226c4:	f9 22 0a 00 	st.h [%a2]10,%d2
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
800226c8:	b9 e2 e2 ff 	ld.hu %d2,[%a14]-30
800226cc:	df 02 7b 00 	jeq %d2,0,800227c2 <tcp_write+0x858>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
800226d0:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800226d4:	b0 42       	add.a %a2,4
800226d6:	54 22       	ld.w %d2,[%a2]
800226d8:	59 e2 d0 ff 	st.w [%a14]-48,%d2
800226dc:	1d 00 37 00 	j 8002274a <tcp_write+0x7e0>
      p->tot_len += oversize_used;
800226e0:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
800226e4:	b9 23 08 00 	ld.hu %d3,[%a2]8
800226e8:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
800226ec:	42 32       	add %d2,%d3
800226ee:	37 02 70 20 	extr.u %d2,%d2,0,16
800226f2:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
800226f6:	f9 22 08 00 	st.h [%a2]8,%d2
      if (p->next == NULL) {
800226fa:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
800226fe:	54 22       	ld.w %d2,[%a2]
80022700:	df 02 20 80 	jne %d2,0,80022740 <tcp_write+0x7d6>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
80022704:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
80022708:	b0 42       	add.a %a2,4
8002270a:	54 23       	ld.w %d3,[%a2]
8002270c:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
80022710:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80022714:	42 23       	add %d3,%d2
80022716:	b9 e2 e2 ff 	ld.hu %d2,[%a14]-30
8002271a:	02 24       	mov %d4,%d2
8002271c:	99 e5 e8 ef 	ld.a %a5,[%a14]-88
80022720:	60 34       	mov.a %a4,%d3
80022722:	6d 00 7d 25 	call 8002721c <memcpy>
        p->len += oversize_used;
80022726:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8002272a:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8002272e:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
80022732:	42 32       	add %d2,%d3
80022734:	37 02 70 20 	extr.u %d2,%d2,0,16
80022738:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
8002273c:	f9 22 0a 00 	st.h [%a2]10,%d2
    for (p = last_unsent->p; p; p = p->next) {
80022740:	99 e2 d0 ff 	ld.a %a2,[%a14]-48
80022744:	54 22       	ld.w %d2,[%a2]
80022746:	59 e2 d0 ff 	st.w [%a14]-48,%d2
8002274a:	19 e2 d0 ff 	ld.w %d2,[%a14]-48
8002274e:	df 02 c9 ff 	jne %d2,0,800226e0 <tcp_write+0x776>
      }
    }
    last_unsent->len += oversize_used;
80022752:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022756:	b9 23 08 00 	ld.hu %d3,[%a2]8
8002275a:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
8002275e:	42 32       	add %d2,%d3
80022760:	37 02 70 20 	extr.u %d2,%d2,0,16
80022764:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022768:	f9 22 08 00 	st.h [%a2]8,%d2
#if TCP_OVERSIZE_DBGCHECK
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
8002276c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022770:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80022774:	b9 e2 e2 ff 	ld.hu %d2,[%a14]-30
80022778:	7f 23 17 80 	jge.u %d3,%d2,800227a6 <tcp_write+0x83c>
8002277c:	91 00 00 28 	movh.a %a2,32768
80022780:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022784:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022788:	3b 30 2d 20 	mov %d2,723
8002278c:	59 a2 04 00 	st.w [%sp]4,%d2
80022790:	91 00 00 28 	movh.a %a2,32768
80022794:	d9 22 c5 42 	lea %a2,[%a2]11525 <80002d05 <IfxCpu_Trap_vectorTable0_end+0x2b11>>
80022798:	f4 a2       	st.a [%sp],%a2
8002279a:	91 00 00 28 	movh.a %a2,32768
8002279e:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800227a2:	6d ff ca 15 	call 80005336 <Ifx_Lwip_printf>
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
800227a6:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800227aa:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800227ae:	c9 e2 e2 ff 	ld.h %d2,[%a14]-30
800227b2:	0b 23 80 20 	sub %d2,%d3,%d2
800227b6:	37 02 70 20 	extr.u %d2,%d2,0,16
800227ba:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800227be:	f9 22 0a 00 	st.h [%a2]10,%d2
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
800227c2:	b9 e2 f6 ef 	ld.hu %d2,[%a14]-74
800227c6:	99 e2 ec ef 	ld.a %a2,[%a14]-84
800227ca:	f9 22 2c 10 	st.h [%a2]108,%d2

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
   * determined that the last ROM pbuf can be extended to include the new data.
   */
  if (concat_p != NULL) {
800227ce:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
800227d2:	df 02 35 00 	jeq %d2,0,8002283c <tcp_write+0x8d2>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
800227d6:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800227da:	df 02 17 80 	jne %d2,0,80022808 <tcp_write+0x89e>
800227de:	91 00 00 28 	movh.a %a2,32768
800227e2:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800227e6:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800227ea:	3b 00 2e 20 	mov %d2,736
800227ee:	59 a2 04 00 	st.w [%sp]4,%d2
800227f2:	91 00 00 28 	movh.a %a2,32768
800227f6:	d9 22 f1 42 	lea %a2,[%a2]11569 <80002d31 <IfxCpu_Trap_vectorTable0_end+0x2b3d>>
800227fa:	f4 a2       	st.a [%sp],%a2
800227fc:	91 00 00 28 	movh.a %a2,32768
80022800:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022804:	6d ff 99 15 	call 80005336 <Ifx_Lwip_printf>
                (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
80022808:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002280c:	b0 42       	add.a %a2,4
8002280e:	54 22       	ld.w %d2,[%a2]
80022810:	99 e5 d8 ff 	ld.a %a5,[%a14]-40
80022814:	60 24       	mov.a %a4,%d2
80022816:	6d ff ee bc 	call 8001a1f2 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
8002281a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002281e:	b9 23 08 00 	ld.hu %d3,[%a2]8
80022822:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80022826:	b9 22 08 00 	ld.hu %d2,[%a2]8
8002282a:	42 32       	add %d2,%d3
8002282c:	37 02 70 20 	extr.u %d2,%d2,0,16
80022830:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022834:	f9 22 08 00 	st.h [%a2]8,%d2
80022838:	1d 00 6b 00 	j 8002290e <tcp_write+0x9a4>
  } else if (extendlen > 0) {
8002283c:	b9 e2 f6 ff 	ld.hu %d2,[%a14]-10
80022840:	df 02 67 00 	jeq %d2,0,8002290e <tcp_write+0x9a4>
    struct pbuf *p;
    LWIP_ASSERT("tcp_write: extension of reference requires reference",
80022844:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80022848:	df 02 08 00 	jeq %d2,0,80022858 <tcp_write+0x8ee>
8002284c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022850:	b0 42       	add.a %a2,4
80022852:	54 22       	ld.w %d2,[%a2]
80022854:	df 02 17 80 	jne %d2,0,80022882 <tcp_write+0x918>
80022858:	91 00 00 28 	movh.a %a2,32768
8002285c:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022860:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022864:	3b 60 2e 20 	mov %d2,742
80022868:	59 a2 04 00 	st.w [%sp]4,%d2
8002286c:	91 00 00 28 	movh.a %a2,32768
80022870:	d9 22 e9 52 	lea %a2,[%a2]11625 <80002d69 <IfxCpu_Trap_vectorTable0_end+0x2b75>>
80022874:	f4 a2       	st.a [%sp],%a2
80022876:	91 00 00 28 	movh.a %a2,32768
8002287a:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002287e:	6d ff 5c 15 	call 80005336 <Ifx_Lwip_printf>
                last_unsent != NULL && last_unsent->p != NULL);
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
80022882:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80022886:	b0 42       	add.a %a2,4
80022888:	54 22       	ld.w %d2,[%a2]
8002288a:	59 e2 cc ff 	st.w [%a14]-52,%d2
8002288e:	1d 00 14 00 	j 800228b6 <tcp_write+0x94c>
      p->tot_len += extendlen;
80022892:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80022896:	b9 23 08 00 	ld.hu %d3,[%a2]8
8002289a:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
8002289e:	42 32       	add %d2,%d3
800228a0:	37 02 70 20 	extr.u %d2,%d2,0,16
800228a4:	99 e2 cc ff 	ld.a %a2,[%a14]-52
800228a8:	f9 22 08 00 	st.h [%a2]8,%d2
    for (p = last_unsent->p; p->next != NULL; p = p->next) {
800228ac:	99 e2 cc ff 	ld.a %a2,[%a14]-52
800228b0:	54 22       	ld.w %d2,[%a2]
800228b2:	59 e2 cc ff 	st.w [%a14]-52,%d2
800228b6:	99 e2 cc ff 	ld.a %a2,[%a14]-52
800228ba:	54 22       	ld.w %d2,[%a2]
800228bc:	df 02 eb ff 	jne %d2,0,80022892 <tcp_write+0x928>
    }
    p->tot_len += extendlen;
800228c0:	99 e2 cc ff 	ld.a %a2,[%a14]-52
800228c4:	b9 23 08 00 	ld.hu %d3,[%a2]8
800228c8:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
800228cc:	42 32       	add %d2,%d3
800228ce:	37 02 70 20 	extr.u %d2,%d2,0,16
800228d2:	99 e2 cc ff 	ld.a %a2,[%a14]-52
800228d6:	f9 22 08 00 	st.h [%a2]8,%d2
    p->len += extendlen;
800228da:	99 e2 cc ff 	ld.a %a2,[%a14]-52
800228de:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800228e2:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
800228e6:	42 32       	add %d2,%d3
800228e8:	37 02 70 20 	extr.u %d2,%d2,0,16
800228ec:	99 e2 cc ff 	ld.a %a2,[%a14]-52
800228f0:	f9 22 0a 00 	st.h [%a2]10,%d2
    last_unsent->len += extendlen;
800228f4:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800228f8:	b9 23 08 00 	ld.hu %d3,[%a2]8
800228fc:	c9 e2 f6 ff 	ld.h %d2,[%a14]-10
80022900:	42 32       	add %d2,%d3
80022902:	37 02 70 20 	extr.u %d2,%d2,0,16
80022906:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002290a:	f9 22 08 00 	st.h [%a2]8,%d2

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
8002290e:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80022912:	df 02 0b 80 	jne %d2,0,80022928 <tcp_write+0x9be>
    pcb->unsent = queue;
80022916:	99 e2 ec ef 	ld.a %a2,[%a14]-84
8002291a:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
8002291e:	d9 22 30 10 	lea %a2,[%a2]112
80022922:	74 22       	st.w [%a2],%d2
80022924:	1d 00 07 00 	j 80022932 <tcp_write+0x9c8>
  } else {
    last_unsent->next = queue;
80022928:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002292c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80022930:	74 22       	st.w [%a2],%d2
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
80022932:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022936:	d9 22 20 10 	lea %a2,[%a2]96
8002293a:	54 23       	ld.w %d3,[%a2]
8002293c:	b9 e2 e4 ef 	ld.hu %d2,[%a14]-92
80022940:	42 32       	add %d2,%d3
80022942:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022946:	d9 22 20 10 	lea %a2,[%a2]96
8002294a:	74 22       	st.w [%a2],%d2
  pcb->snd_buf -= len;
8002294c:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022950:	b9 23 28 10 	ld.hu %d3,[%a2]104
80022954:	c9 e2 e4 ef 	ld.h %d2,[%a14]-92
80022958:	0b 23 80 20 	sub %d2,%d3,%d2
8002295c:	37 02 70 20 	extr.u %d2,%d2,0,16
80022960:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022964:	f9 22 28 10 	st.h [%a2]104,%d2
  pcb->snd_queuelen = queuelen;
80022968:	99 e2 ec ef 	ld.a %a2,[%a14]-84
8002296c:	c9 e2 e4 ff 	ld.h %d2,[%a14]-28
80022970:	f9 22 2a 10 	st.h [%a2]106,%d2

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
                               pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
80022974:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022978:	b9 22 2a 10 	ld.hu %d2,[%a2]106
8002297c:	df 02 25 00 	jeq %d2,0,800229c6 <tcp_write+0xa5c>
    LWIP_ASSERT("tcp_write: valid queue length",
80022980:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022984:	d9 22 34 10 	lea %a2,[%a2]116
80022988:	54 22       	ld.w %d2,[%a2]
8002298a:	df 02 1e 80 	jne %d2,0,800229c6 <tcp_write+0xa5c>
8002298e:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022992:	d9 22 30 10 	lea %a2,[%a2]112
80022996:	54 22       	ld.w %d2,[%a2]
80022998:	df 02 17 80 	jne %d2,0,800229c6 <tcp_write+0xa5c>
8002299c:	91 00 00 28 	movh.a %a2,32768
800229a0:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800229a4:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800229a8:	3b 20 31 20 	mov %d2,786
800229ac:	59 a2 04 00 	st.w [%sp]4,%d2
800229b0:	91 00 00 28 	movh.a %a2,32768
800229b4:	d9 22 de 62 	lea %a2,[%a2]11678 <80002d9e <IfxCpu_Trap_vectorTable0_end+0x2baa>>
800229b8:	f4 a2       	st.a [%sp],%a2
800229ba:	91 00 00 28 	movh.a %a2,32768
800229be:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800229c2:	6d ff ba 14 	call 80005336 <Ifx_Lwip_printf>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
800229c6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800229ca:	df 02 36 00 	jeq %d2,0,80022a36 <tcp_write+0xacc>
800229ce:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800229d2:	d9 22 10 00 	lea %a2,[%a2]16
800229d6:	54 22       	ld.w %d2,[%a2]
800229d8:	df 02 2f 00 	jeq %d2,0,80022a36 <tcp_write+0xacc>
800229dc:	39 e2 e0 ef 	ld.bu %d2,[%a14]-96
800229e0:	8f 22 00 21 	and %d2,%d2,2
800229e4:	df 02 29 80 	jne %d2,0,80022a36 <tcp_write+0xacc>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
800229e8:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800229ec:	d9 22 10 00 	lea %a2,[%a2]16
800229f0:	d4 22       	ld.a %a2,[%a2]
800229f2:	39 23 0c 00 	ld.bu %d3,[%a2]12
800229f6:	39 22 0d 00 	ld.bu %d2,[%a2]13
800229fa:	8f 82 00 20 	sh %d2,%d2,8
800229fe:	a6 32       	or %d2,%d3
80022a00:	37 02 70 80 	extr.u %d8,%d2,0,16
80022a04:	3b 80 00 40 	mov %d4,8
80022a08:	6d ff a6 a5 	call 80017554 <lwip_htons>
80022a0c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80022a10:	d9 22 10 00 	lea %a2,[%a2]16
80022a14:	d4 22       	ld.a %a2,[%a2]
80022a16:	a6 82       	or %d2,%d8
80022a18:	37 02 70 20 	extr.u %d2,%d2,0,16
80022a1c:	8f f2 0f 31 	and %d3,%d2,255
80022a20:	82 04       	mov %d4,0
80022a22:	a6 43       	or %d3,%d4
80022a24:	e9 23 0c 00 	st.b [%a2]12,%d3
80022a28:	06 82       	sh %d2,-8
80022a2a:	37 02 70 20 	extr.u %d2,%d2,0,16
80022a2e:	82 03       	mov %d3,0
80022a30:	a6 32       	or %d2,%d3
80022a32:	e9 22 0d 00 	st.b [%a2]13,%d2
  }

  return ERR_OK;
80022a36:	82 02       	mov %d2,0
80022a38:	00 90       	ret 
memerr:
  tcp_set_flags(pcb, TF_NAGLEMEMERR);
80022a3a:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022a3e:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80022a42:	8f 02 48 21 	or %d2,%d2,128
80022a46:	37 02 70 20 	extr.u %d2,%d2,0,16
80022a4a:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022a4e:	f9 22 1e 00 	st.h [%a2]30,%d2
  TCP_STATS_INC(tcp.memerr);
80022a52:	91 10 00 27 	movh.a %a2,28673
80022a56:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80022a5a:	b9 22 1c 20 	ld.hu %d2,[%a2]156 <7001009c <ram_heap+0x5008>>
80022a5e:	c2 12       	add %d2,1
80022a60:	37 02 70 20 	extr.u %d2,%d2,0,16
80022a64:	91 10 00 27 	movh.a %a2,28673
80022a68:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80022a6c:	f9 22 1c 20 	st.h [%a2]156 <7001009c <ram_heap+0x5008>>,%d2

  if (concat_p != NULL) {
80022a70:	19 e2 d8 ff 	ld.w %d2,[%a14]-40 <7001009c <ram_heap+0x5008>>
80022a74:	df 02 06 00 	jeq %d2,0,80022a80 <tcp_write+0xb16>
    pbuf_free(concat_p);
80022a78:	99 e4 d8 ff 	ld.a %a4,[%a14]-40
80022a7c:	6d ff 8e ba 	call 80019f98 <pbuf_free>
  }
  if (queue != NULL) {
80022a80:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80022a84:	df 02 06 00 	jeq %d2,0,80022a90 <tcp_write+0xb26>
    tcp_segs_free(queue);
80022a88:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80022a8c:	6d ff 76 cd 	call 8001c578 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
80022a90:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022a94:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80022a98:	df 02 25 00 	jeq %d2,0,80022ae2 <tcp_write+0xb78>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
80022a9c:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022aa0:	d9 22 34 10 	lea %a2,[%a2]116
80022aa4:	54 22       	ld.w %d2,[%a2]
80022aa6:	df 02 1e 80 	jne %d2,0,80022ae2 <tcp_write+0xb78>
80022aaa:	99 e2 ec ef 	ld.a %a2,[%a14]-84
80022aae:	d9 22 30 10 	lea %a2,[%a2]112
80022ab2:	54 22       	ld.w %d2,[%a2]
80022ab4:	df 02 17 80 	jne %d2,0,80022ae2 <tcp_write+0xb78>
80022ab8:	91 00 00 28 	movh.a %a2,32768
80022abc:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022ac0:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022ac4:	3b 70 32 20 	mov %d2,807
80022ac8:	59 a2 04 00 	st.w [%sp]4,%d2
80022acc:	91 00 00 28 	movh.a %a2,32768
80022ad0:	d9 22 de 62 	lea %a2,[%a2]11678 <80002d9e <IfxCpu_Trap_vectorTable0_end+0x2baa>>
80022ad4:	f4 a2       	st.a [%sp],%a2
80022ad6:	91 00 00 28 	movh.a %a2,32768
80022ada:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022ade:	6d ff 2c 14 	call 80005336 <Ifx_Lwip_printf>
                pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
80022ae2:	82 f2       	mov %d2,-1
}
80022ae4:	00 90       	ret 

80022ae6 <tcp_split_unsent_seg>:
 * @param pcb the tcp_pcb for which to split the unsent head
 * @param split the amount of payload to remain in the head
 */
err_t
tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
{
80022ae6:	40 ae       	mov.aa %a14,%sp
80022ae8:	20 30       	sub.a %sp,48
80022aea:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80022aee:	02 42       	mov %d2,%d4
80022af0:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
  struct tcp_seg *seg = NULL, *useg = NULL;
80022af4:	82 02       	mov %d2,0
80022af6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80022afa:	82 02       	mov %d2,0
80022afc:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  struct pbuf *p = NULL;
80022b00:	82 02       	mov %d2,0
80022b02:	59 e2 f0 ff 	st.w [%a14]-16,%d2
  u16_t chksum = 0;
  u8_t chksum_swapped = 0;
  struct pbuf *q;
#endif /* TCP_CHECKSUM_ON_COPY */

  LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
80022b06:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80022b0a:	df 02 17 80 	jne %d2,0,80022b38 <tcp_split_unsent_seg+0x52>
80022b0e:	91 00 00 28 	movh.a %a2,32768
80022b12:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022b16:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022b1a:	3b b0 34 20 	mov %d2,843
80022b1e:	59 a2 04 00 	st.w [%sp]4,%d2
80022b22:	91 00 00 28 	movh.a %a2,32768
80022b26:	d9 22 fc 62 	lea %a2,[%a2]11708 <80002dbc <IfxCpu_Trap_vectorTable0_end+0x2bc8>>
80022b2a:	f4 a2       	st.a [%sp],%a2
80022b2c:	91 00 00 28 	movh.a %a2,32768
80022b30:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022b34:	6d ff 01 14 	call 80005336 <Ifx_Lwip_printf>

  useg = pcb->unsent;
80022b38:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022b3c:	d9 22 30 10 	lea %a2,[%a2]112
80022b40:	54 22       	ld.w %d2,[%a2]
80022b42:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  if (useg == NULL) {
80022b46:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80022b4a:	df 02 04 80 	jne %d2,0,80022b52 <tcp_split_unsent_seg+0x6c>
    return ERR_MEM;
80022b4e:	82 f2       	mov %d2,-1
80022b50:	00 90       	ret 
  }

  if (split == 0) {
80022b52:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
80022b56:	df 02 19 80 	jne %d2,0,80022b88 <tcp_split_unsent_seg+0xa2>
    LWIP_ASSERT("Can't split segment into length 0", 0);
80022b5a:	91 00 00 28 	movh.a %a2,32768
80022b5e:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022b62:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022b66:	3b 30 35 20 	mov %d2,851
80022b6a:	59 a2 04 00 	st.w [%sp]4,%d2
80022b6e:	91 00 00 28 	movh.a %a2,32768
80022b72:	d9 22 de 72 	lea %a2,[%a2]11742 <80002dde <IfxCpu_Trap_vectorTable0_end+0x2bea>>
80022b76:	f4 a2       	st.a [%sp],%a2
80022b78:	91 00 00 28 	movh.a %a2,32768
80022b7c:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022b80:	6d ff db 13 	call 80005336 <Ifx_Lwip_printf>
    return ERR_VAL;
80022b84:	82 a2       	mov %d2,-6
80022b86:	00 90       	ret 
  }

  if (useg->len <= split) {
80022b88:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022b8c:	b9 22 08 00 	ld.hu %d2,[%a2]8
80022b90:	b9 e3 e0 ff 	ld.hu %d3,[%a14]-32
80022b94:	3f 23 04 80 	jlt.u %d3,%d2,80022b9c <tcp_split_unsent_seg+0xb6>
    return ERR_OK;
80022b98:	82 02       	mov %d2,0
80022b9a:	00 90       	ret 
  }

  LWIP_ASSERT("split <= mss", split <= pcb->mss);
80022b9c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022ba0:	b9 23 36 00 	ld.hu %d3,[%a2]54
80022ba4:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
80022ba8:	7f 23 17 80 	jge.u %d3,%d2,80022bd6 <tcp_split_unsent_seg+0xf0>
80022bac:	91 00 00 28 	movh.a %a2,32768
80022bb0:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022bb4:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022bb8:	3b b0 35 20 	mov %d2,859
80022bbc:	59 a2 04 00 	st.w [%sp]4,%d2
80022bc0:	91 00 00 28 	movh.a %a2,32768
80022bc4:	d9 22 c0 82 	lea %a2,[%a2]11776 <80002e00 <IfxCpu_Trap_vectorTable0_end+0x2c0c>>
80022bc8:	f4 a2       	st.a [%sp],%a2
80022bca:	91 00 00 28 	movh.a %a2,32768
80022bce:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022bd2:	6d ff b2 13 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("useg->len > 0", useg->len > 0);
80022bd6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022bda:	b9 22 08 00 	ld.hu %d2,[%a2]8
80022bde:	df 02 17 80 	jne %d2,0,80022c0c <tcp_split_unsent_seg+0x126>
80022be2:	91 00 00 28 	movh.a %a2,32768
80022be6:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022bea:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022bee:	3b c0 35 20 	mov %d2,860
80022bf2:	59 a2 04 00 	st.w [%sp]4,%d2
80022bf6:	91 00 00 28 	movh.a %a2,32768
80022bfa:	d9 22 cd 82 	lea %a2,[%a2]11789 <80002e0d <IfxCpu_Trap_vectorTable0_end+0x2c19>>
80022bfe:	f4 a2       	st.a [%sp],%a2
80022c00:	91 00 00 28 	movh.a %a2,32768
80022c04:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022c08:	6d ff 97 13 	call 80005336 <Ifx_Lwip_printf>
   * to split this packet so we may actually exceed the max value by
   * one!
   */
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuelen));

  optflags = useg->flags;
80022c0c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022c10:	79 22 0c 00 	ld.b %d2,[%a2]12
80022c14:	e9 e2 ef ff 	st.b [%a14]-17,%d2
#if TCP_CHECKSUM_ON_COPY
  /* Remove since checksum is not stored until after tcp_create_segment() */
  optflags &= ~TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
80022c18:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
80022c1c:	06 22       	sh %d2,2
80022c1e:	8f f2 0f 21 	and %d2,%d2,255
80022c22:	8f 42 00 21 	and %d2,%d2,4
80022c26:	e9 e2 ee ff 	st.b [%a14]-18,%d2
  remainder = useg->len - split;
80022c2a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022c2e:	b9 23 08 00 	ld.hu %d3,[%a2]8
80022c32:	c9 e2 e0 ff 	ld.h %d2,[%a14]-32
80022c36:	0b 23 80 20 	sub %d2,%d3,%d2
80022c3a:	f9 e2 ec ff 	st.h [%a14]-20,%d2

  /* Create new pbuf for the remainder of the split */
  p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
80022c3e:	39 e2 ee ff 	ld.bu %d2,[%a14]-18
80022c42:	37 02 70 30 	extr.u %d3,%d2,0,16
80022c46:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
80022c4a:	42 32       	add %d2,%d3
80022c4c:	37 02 70 20 	extr.u %d2,%d2,0,16
80022c50:	3b 00 28 60 	mov %d6,640
80022c54:	02 25       	mov %d5,%d2
80022c56:	3b 80 03 40 	mov %d4,56
80022c5a:	6d ff 43 b5 	call 800196e0 <pbuf_alloc>
80022c5e:	b5 e2 f0 ff 	st.a [%a14]-16,%a2
  if (p == NULL) {
80022c62:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80022c66:	df 02 3d 01 	jeq %d2,0,80022ee0 <tcp_split_unsent_seg+0x3fa>
                ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
    goto memerr;
  }

  /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
  offset = useg->p->tot_len - useg->len + split;
80022c6a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022c6e:	b0 42       	add.a %a2,4
80022c70:	d4 22       	ld.a %a2,[%a2]
80022c72:	b9 23 08 00 	ld.hu %d3,[%a2]8
80022c76:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022c7a:	b9 22 08 00 	ld.hu %d2,[%a2]8
80022c7e:	0b 23 80 20 	sub %d2,%d3,%d2
80022c82:	37 02 70 30 	extr.u %d3,%d2,0,16
80022c86:	c9 e2 e0 ff 	ld.h %d2,[%a14]-32
80022c8a:	42 32       	add %d2,%d3
80022c8c:	f9 e2 ea ff 	st.h [%a14]-22,%d2
  /* Copy remainder into new pbuf, headers and options will not be filled out */
  if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
80022c90:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022c94:	b0 42       	add.a %a2,4
80022c96:	54 26       	ld.w %d6,[%a2]
80022c98:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80022c9c:	b0 42       	add.a %a2,4
80022c9e:	54 23       	ld.w %d3,[%a2]
80022ca0:	39 e2 ee ff 	ld.bu %d2,[%a14]-18
80022ca4:	0b 23 00 70 	add %d7,%d3,%d2
80022ca8:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80022cac:	b9 e3 ea ff 	ld.hu %d3,[%a14]-22
80022cb0:	02 35       	mov %d5,%d3
80022cb2:	02 24       	mov %d4,%d2
80022cb4:	60 75       	mov.a %a5,%d7
80022cb6:	60 64       	mov.a %a4,%d6
80022cb8:	6d ff 9b bc 	call 8001a5ee <pbuf_copy_partial>
80022cbc:	02 23       	mov %d3,%d2
80022cbe:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80022cc2:	5f 32 0f 81 	jne %d2,%d3,80022ee0 <tcp_split_unsent_seg+0x3fa>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Options are created when calling tcp_output() */

  /* Migrate flags from original segment */
  split_flags = TCPH_FLAGS(useg->tcphdr);
80022cc6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022cca:	d9 22 10 00 	lea %a2,[%a2]16
80022cce:	d4 22       	ld.a %a2,[%a2]
80022cd0:	39 23 0c 00 	ld.bu %d3,[%a2]12
80022cd4:	39 22 0d 00 	ld.bu %d2,[%a2]13
80022cd8:	8f 82 00 20 	sh %d2,%d2,8
80022cdc:	a6 32       	or %d2,%d3
80022cde:	37 02 70 20 	extr.u %d2,%d2,0,16
80022ce2:	02 24       	mov %d4,%d2
80022ce4:	6d ff 38 a4 	call 80017554 <lwip_htons>
80022ce8:	8f f2 0f 21 	and %d2,%d2,255
80022cec:	8f f2 03 21 	and %d2,%d2,63
80022cf0:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  remainder_flags = 0; /* ACK added in tcp_output() */
80022cf4:	82 02       	mov %d2,0
80022cf6:	e9 e2 fe ff 	st.b [%a14]-2,%d2

  if (split_flags & TCP_PSH) {
80022cfa:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80022cfe:	8f 82 00 21 	and %d2,%d2,8
80022d02:	df 02 0e 00 	jeq %d2,0,80022d1e <tcp_split_unsent_seg+0x238>
    split_flags &= ~TCP_PSH;
80022d06:	79 e2 ff ff 	ld.b %d2,[%a14]-1
80022d0a:	8f 82 c0 21 	andn %d2,%d2,8
80022d0e:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    remainder_flags |= TCP_PSH;
80022d12:	79 e2 fe ff 	ld.b %d2,[%a14]-2
80022d16:	8f 82 40 21 	or %d2,%d2,8
80022d1a:	e9 e2 fe ff 	st.b [%a14]-2,%d2
  }
  if (split_flags & TCP_FIN) {
80022d1e:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80022d22:	8f 12 00 21 	and %d2,%d2,1
80022d26:	df 02 0e 00 	jeq %d2,0,80022d42 <tcp_split_unsent_seg+0x25c>
    split_flags &= ~TCP_FIN;
80022d2a:	79 e2 ff ff 	ld.b %d2,[%a14]-1
80022d2e:	8f 12 c0 21 	andn %d2,%d2,1
80022d32:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    remainder_flags |= TCP_FIN;
80022d36:	79 e2 fe ff 	ld.b %d2,[%a14]-2
80022d3a:	8f 12 40 21 	or %d2,%d2,1
80022d3e:	e9 e2 fe ff 	st.b [%a14]-2,%d2
  }
  /* SYN should be left on split, RST should not be present with data */

  seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
80022d42:	39 e8 fe ff 	ld.bu %d8,[%a14]-2
80022d46:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022d4a:	d9 22 10 00 	lea %a2,[%a2]16
80022d4e:	d4 22       	ld.a %a2,[%a2]
80022d50:	39 23 04 00 	ld.bu %d3,[%a2]4
80022d54:	39 22 05 00 	ld.bu %d2,[%a2]5
80022d58:	8f 82 00 20 	sh %d2,%d2,8
80022d5c:	a6 32       	or %d2,%d3
80022d5e:	39 23 06 00 	ld.bu %d3,[%a2]6
80022d62:	8f 03 01 30 	sh %d3,%d3,16
80022d66:	a6 32       	or %d2,%d3
80022d68:	39 23 07 00 	ld.bu %d3,[%a2]7
80022d6c:	8f 83 01 30 	sh %d3,%d3,24
80022d70:	a6 32       	or %d2,%d3
80022d72:	02 24       	mov %d4,%d2
80022d74:	6d ff 08 a4 	call 80017584 <lwip_htonl>
80022d78:	02 23       	mov %d3,%d2
80022d7a:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
80022d7e:	42 23       	add %d3,%d2
80022d80:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
80022d84:	02 26       	mov %d6,%d2
80022d86:	02 35       	mov %d5,%d3
80022d88:	02 84       	mov %d4,%d8
80022d8a:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
80022d8e:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80022d92:	6d ff fe f5 	call 8002198e <tcp_create_segment>
80022d96:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  if (seg == NULL) {
80022d9a:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80022d9e:	df 02 a1 00 	jeq %d2,0,80022ee0 <tcp_split_unsent_seg+0x3fa>
  seg->chksum_swapped = chksum_swapped;
  seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Remove this segment from the queue since trimming it may free pbufs */
  pcb->snd_queuelen -= pbuf_clen(useg->p);
80022da2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022da6:	b0 42       	add.a %a2,4
80022da8:	54 22       	ld.w %d2,[%a2]
80022daa:	60 24       	mov.a %a4,%d2
80022dac:	6d ff d9 b9 	call 8001a15e <pbuf_clen>
80022db0:	02 23       	mov %d3,%d2
80022db2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022db6:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80022dba:	a2 32       	sub %d2,%d3
80022dbc:	37 02 70 20 	extr.u %d2,%d2,0,16
80022dc0:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022dc4:	f9 22 2a 10 	st.h [%a2]106,%d2

  /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
  successfully because we are modifying the original segment */
  pbuf_realloc(useg->p, useg->p->tot_len - remainder);
80022dc8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022dcc:	b0 42       	add.a %a2,4
80022dce:	54 25       	ld.w %d5,[%a2]
80022dd0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022dd4:	b0 42       	add.a %a2,4
80022dd6:	d4 22       	ld.a %a2,[%a2]
80022dd8:	b9 23 08 00 	ld.hu %d3,[%a2]8
80022ddc:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
80022de0:	0b 23 80 20 	sub %d2,%d3,%d2
80022de4:	37 02 70 20 	extr.u %d2,%d2,0,16
80022de8:	02 24       	mov %d4,%d2
80022dea:	60 54       	mov.a %a4,%d5
80022dec:	6d ff 87 b6 	call 80019afa <pbuf_realloc>
  useg->len -= remainder;
80022df0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022df4:	b9 23 08 00 	ld.hu %d3,[%a2]8
80022df8:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
80022dfc:	0b 23 80 20 	sub %d2,%d3,%d2
80022e00:	37 02 70 20 	extr.u %d2,%d2,0,16
80022e04:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022e08:	f9 22 08 00 	st.h [%a2]8,%d2
  TCPH_SET_FLAG(useg->tcphdr, split_flags);
80022e0c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022e10:	d9 22 10 00 	lea %a2,[%a2]16
80022e14:	d4 22       	ld.a %a2,[%a2]
80022e16:	39 23 0c 00 	ld.bu %d3,[%a2]12
80022e1a:	39 22 0d 00 	ld.bu %d2,[%a2]13
80022e1e:	8f 82 00 20 	sh %d2,%d2,8
80022e22:	a6 32       	or %d2,%d3
80022e24:	37 02 70 80 	extr.u %d8,%d2,0,16
80022e28:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
80022e2c:	02 24       	mov %d4,%d2
80022e2e:	6d ff 93 a3 	call 80017554 <lwip_htons>
80022e32:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022e36:	d9 22 10 00 	lea %a2,[%a2]16
80022e3a:	d4 22       	ld.a %a2,[%a2]
80022e3c:	a6 82       	or %d2,%d8
80022e3e:	37 02 70 20 	extr.u %d2,%d2,0,16
80022e42:	8f f2 0f 31 	and %d3,%d2,255
80022e46:	82 04       	mov %d4,0
80022e48:	a6 43       	or %d3,%d4
80022e4a:	e9 23 0c 00 	st.b [%a2]12,%d3
80022e4e:	06 82       	sh %d2,-8
80022e50:	37 02 70 20 	extr.u %d2,%d2,0,16
80022e54:	82 03       	mov %d3,0
80022e56:	a6 32       	or %d2,%d3
80022e58:	e9 22 0d 00 	st.b [%a2]13,%d2
#if TCP_OVERSIZE_DBGCHECK
  /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
  useg->oversize_left = 0;
80022e5c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022e60:	82 02       	mov %d2,0
80022e62:	f9 22 0a 00 	st.h [%a2]10,%d2
#endif /* TCP_OVERSIZE_DBGCHECK */

  /* Add back to the queue with new trimmed pbuf */
  pcb->snd_queuelen += pbuf_clen(useg->p);
80022e66:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022e6a:	b0 42       	add.a %a2,4
80022e6c:	54 22       	ld.w %d2,[%a2]
80022e6e:	60 24       	mov.a %a4,%d2
80022e70:	6d ff 77 b9 	call 8001a15e <pbuf_clen>
80022e74:	02 23       	mov %d3,%d2
80022e76:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022e7a:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80022e7e:	42 32       	add %d2,%d3
80022e80:	37 02 70 20 	extr.u %d2,%d2,0,16
80022e84:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022e88:	f9 22 2a 10 	st.h [%a2]106,%d2
#endif /* TCP_CHECKSUM_ON_COPY */

  /* Update number of segments on the queues. Note that length now may
   * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
   * because the total amount of data is constant when packet is split */
  pcb->snd_queuelen += pbuf_clen(seg->p);
80022e8c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80022e90:	b0 42       	add.a %a2,4
80022e92:	54 22       	ld.w %d2,[%a2]
80022e94:	60 24       	mov.a %a4,%d2
80022e96:	6d ff 64 b9 	call 8001a15e <pbuf_clen>
80022e9a:	02 23       	mov %d3,%d2
80022e9c:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022ea0:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80022ea4:	42 32       	add %d2,%d3
80022ea6:	37 02 70 20 	extr.u %d2,%d2,0,16
80022eaa:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022eae:	f9 22 2a 10 	st.h [%a2]106,%d2

  /* Finally insert remainder into queue after split (which stays head) */
  seg->next = useg->next;
80022eb2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022eb6:	54 22       	ld.w %d2,[%a2]
80022eb8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80022ebc:	74 22       	st.w [%a2],%d2
  useg->next = seg;
80022ebe:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022ec2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80022ec6:	74 22       	st.w [%a2],%d2

#if TCP_OVERSIZE
  /* If remainder is last segment on the unsent, ensure we clear the oversize amount
   * because the remainder is always sized to the exact remaining amount */
  if (seg->next == NULL) {
80022ec8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80022ecc:	54 22       	ld.w %d2,[%a2]
80022ece:	df 02 07 80 	jne %d2,0,80022edc <tcp_split_unsent_seg+0x3f6>
    pcb->unsent_oversize = 0;
80022ed2:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80022ed6:	82 02       	mov %d2,0
80022ed8:	f9 22 2c 10 	st.h [%a2]108,%d2
  }
#endif /* TCP_OVERSIZE */

  return ERR_OK;
80022edc:	82 02       	mov %d2,0
80022ede:	00 90       	ret 
memerr:
  TCP_STATS_INC(tcp.memerr);
80022ee0:	91 10 00 27 	movh.a %a2,28673
80022ee4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80022ee8:	b9 22 1c 20 	ld.hu %d2,[%a2]156 <7001009c <ram_heap+0x5008>>
80022eec:	c2 12       	add %d2,1
80022eee:	37 02 70 20 	extr.u %d2,%d2,0,16
80022ef2:	91 10 00 27 	movh.a %a2,28673
80022ef6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80022efa:	f9 22 1c 20 	st.h [%a2]156 <7001009c <ram_heap+0x5008>>,%d2

  LWIP_ASSERT("seg == NULL", seg == NULL);
80022efe:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <7001009c <ram_heap+0x5008>>
80022f02:	df 02 17 00 	jeq %d2,0,80022f30 <tcp_split_unsent_seg+0x44a>
80022f06:	91 00 00 28 	movh.a %a2,32768
80022f0a:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022f0e:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022f12:	3b 80 3d 20 	mov %d2,984
80022f16:	59 a2 04 00 	st.w [%sp]4,%d2
80022f1a:	91 00 00 28 	movh.a %a2,32768
80022f1e:	d9 22 db 82 	lea %a2,[%a2]11803 <80002e1b <IfxCpu_Trap_vectorTable0_end+0x2c27>>
80022f22:	f4 a2       	st.a [%sp],%a2
80022f24:	91 00 00 28 	movh.a %a2,32768
80022f28:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022f2c:	6d ff 05 12 	call 80005336 <Ifx_Lwip_printf>
  if (p != NULL) {
80022f30:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80022f34:	df 02 06 00 	jeq %d2,0,80022f40 <tcp_split_unsent_seg+0x45a>
    pbuf_free(p);
80022f38:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80022f3c:	6d ff 2e b8 	call 80019f98 <pbuf_free>
  }

  return ERR_MEM;
80022f40:	82 f2       	mov %d2,-1
}
80022f42:	00 90       	ret 

80022f44 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
80022f44:	40 ae       	mov.aa %a14,%sp
80022f46:	20 20       	sub.a %sp,32
80022f48:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
80022f4c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80022f50:	df 02 17 80 	jne %d2,0,80022f7e <tcp_send_fin+0x3a>
80022f54:	91 00 00 28 	movh.a %a2,32768
80022f58:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80022f5c:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80022f60:	3b b0 3e 20 	mov %d2,1003
80022f64:	59 a2 04 00 	st.w [%sp]4,%d2
80022f68:	91 00 00 28 	movh.a %a2,32768
80022f6c:	d9 22 e7 82 	lea %a2,[%a2]11815 <80002e27 <IfxCpu_Trap_vectorTable0_end+0x2c33>>
80022f70:	f4 a2       	st.a [%sp],%a2
80022f72:	91 00 00 28 	movh.a %a2,32768
80022f76:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80022f7a:	6d ff de 11 	call 80005336 <Ifx_Lwip_printf>

  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
80022f7e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022f82:	d9 22 30 10 	lea %a2,[%a2]112
80022f86:	54 22       	ld.w %d2,[%a2]
80022f88:	df 02 60 00 	jeq %d2,0,80023048 <tcp_send_fin+0x104>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
80022f8c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80022f90:	d9 22 30 10 	lea %a2,[%a2]112
80022f94:	54 22       	ld.w %d2,[%a2]
80022f96:	59 e2 fc ff 	st.w [%a14]-4,%d2
80022f9a:	1d 00 07 00 	j 80022fa8 <tcp_send_fin+0x64>
         last_unsent = last_unsent->next);
80022f9e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80022fa2:	54 22       	ld.w %d2,[%a2]
80022fa4:	59 e2 fc ff 	st.w [%a14]-4,%d2
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
80022fa8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80022fac:	54 22       	ld.w %d2,[%a2]
80022fae:	df 02 f8 ff 	jne %d2,0,80022f9e <tcp_send_fin+0x5a>

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
80022fb2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80022fb6:	d9 22 10 00 	lea %a2,[%a2]16
80022fba:	d4 22       	ld.a %a2,[%a2]
80022fbc:	39 23 0c 00 	ld.bu %d3,[%a2]12
80022fc0:	39 22 0d 00 	ld.bu %d2,[%a2]13
80022fc4:	8f 82 00 20 	sh %d2,%d2,8
80022fc8:	a6 32       	or %d2,%d3
80022fca:	37 02 70 20 	extr.u %d2,%d2,0,16
80022fce:	02 24       	mov %d4,%d2
80022fd0:	6d ff c2 a2 	call 80017554 <lwip_htons>
80022fd4:	8f f2 0f 21 	and %d2,%d2,255
80022fd8:	8f 72 00 21 	and %d2,%d2,7
80022fdc:	df 02 36 80 	jne %d2,0,80023048 <tcp_send_fin+0x104>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
80022fe0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80022fe4:	d9 22 10 00 	lea %a2,[%a2]16
80022fe8:	d4 22       	ld.a %a2,[%a2]
80022fea:	39 23 0c 00 	ld.bu %d3,[%a2]12
80022fee:	39 22 0d 00 	ld.bu %d2,[%a2]13
80022ff2:	8f 82 00 20 	sh %d2,%d2,8
80022ff6:	a6 32       	or %d2,%d3
80022ff8:	37 02 70 80 	extr.u %d8,%d2,0,16
80022ffc:	82 14       	mov %d4,1
80022ffe:	6d ff ab a2 	call 80017554 <lwip_htons>
80023002:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023006:	d9 22 10 00 	lea %a2,[%a2]16
8002300a:	d4 22       	ld.a %a2,[%a2]
8002300c:	a6 82       	or %d2,%d8
8002300e:	37 02 70 20 	extr.u %d2,%d2,0,16
80023012:	8f f2 0f 31 	and %d3,%d2,255
80023016:	82 04       	mov %d4,0
80023018:	a6 43       	or %d3,%d4
8002301a:	e9 23 0c 00 	st.b [%a2]12,%d3
8002301e:	06 82       	sh %d2,-8
80023020:	37 02 70 20 	extr.u %d2,%d2,0,16
80023024:	82 03       	mov %d3,0
80023026:	a6 32       	or %d2,%d3
80023028:	e9 22 0d 00 	st.b [%a2]13,%d2
      tcp_set_flags(pcb, TF_FIN);
8002302c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023030:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023034:	8f 02 42 21 	or %d2,%d2,32
80023038:	37 02 70 20 	extr.u %d2,%d2,0,16
8002303c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023040:	f9 22 1e 00 	st.h [%a2]30,%d2
      return ERR_OK;
80023044:	82 02       	mov %d2,0
80023046:	00 90       	ret 
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
80023048:	82 14       	mov %d4,1
8002304a:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8002304e:	6d 00 03 00 	call 80023054 <tcp_enqueue_flags>
}
80023052:	00 90       	ret 

80023054 <tcp_enqueue_flags>:
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
80023054:	40 ae       	mov.aa %a14,%sp
80023056:	20 28       	sub.a %sp,40
80023058:	b5 e4 ec ff 	st.a [%a14]-20,%a4
8002305c:	02 42       	mov %d2,%d4
8002305e:	e9 e2 e8 ff 	st.b [%a14]-24,%d2
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
80023062:	82 02       	mov %d2,0
80023064:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  u8_t optlen = 0;
80023068:	82 02       	mov %d2,0
8002306a:	e9 e2 fe ff 	st.b [%a14]-2,%d2

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
8002306e:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
80023072:	8f 32 00 21 	and %d2,%d2,3
80023076:	df 02 17 80 	jne %d2,0,800230a4 <tcp_enqueue_flags+0x50>
8002307a:	91 00 00 28 	movh.a %a2,32768
8002307e:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80023082:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023086:	3b 10 41 20 	mov %d2,1041
8002308a:	59 a2 04 00 	st.w [%sp]4,%d2
8002308e:	91 00 00 28 	movh.a %a2,32768
80023092:	d9 22 c1 92 	lea %a2,[%a2]11841 <80002e41 <IfxCpu_Trap_vectorTable0_end+0x2c4d>>
80023096:	f4 a2       	st.a [%sp],%a2
80023098:	91 00 00 28 	movh.a %a2,32768
8002309c:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800230a0:	6d ff 4b 11 	call 80005336 <Ifx_Lwip_printf>
              (flags & (TCP_SYN | TCP_FIN)) != 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
800230a4:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800230a8:	df 02 17 80 	jne %d2,0,800230d6 <tcp_enqueue_flags+0x82>
800230ac:	91 00 00 28 	movh.a %a2,32768
800230b0:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800230b4:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800230b8:	3b 30 41 20 	mov %d2,1043
800230bc:	59 a2 04 00 	st.w [%sp]4,%d2
800230c0:	91 00 00 28 	movh.a %a2,32768
800230c4:	d9 22 d6 a2 	lea %a2,[%a2]11926 <80002e96 <IfxCpu_Trap_vectorTable0_end+0x2ca2>>
800230c8:	f4 a2       	st.a [%sp],%a2
800230ca:	91 00 00 28 	movh.a %a2,32768
800230ce:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800230d2:	6d ff 32 11 	call 80005336 <Ifx_Lwip_printf>

  /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */

  /* Get options for this segment. This is a special case since this is the
     only place where a SYN can be sent. */
  if (flags & TCP_SYN) {
800230d6:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
800230da:	8f 22 00 21 	and %d2,%d2,2
800230de:	df 02 05 00 	jeq %d2,0,800230e8 <tcp_enqueue_flags+0x94>
    optflags = TF_SEG_OPTS_MSS;
800230e2:	82 12       	mov %d2,1
800230e4:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    /* Make sure the timestamp option is only included in data segments if we
       agreed about it with the remote host (and in active open SYN segments). */
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
800230e8:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
800230ec:	06 22       	sh %d2,2
800230ee:	8f f2 0f 21 	and %d2,%d2,255
800230f2:	8f 42 00 21 	and %d2,%d2,4
800230f6:	e9 e2 fe ff 	st.b [%a14]-2,%d2

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
800230fa:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
800230fe:	3b 00 28 60 	mov %d6,640
80023102:	02 25       	mov %d5,%d2
80023104:	3b 80 03 40 	mov %d4,56
80023108:	6d ff ec b2 	call 800196e0 <pbuf_alloc>
8002310c:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
80023110:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80023114:	df 02 1f 80 	jne %d2,0,80023152 <tcp_enqueue_flags+0xfe>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
80023118:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8002311c:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023120:	8f 02 48 21 	or %d2,%d2,128
80023124:	37 02 70 20 	extr.u %d2,%d2,0,16
80023128:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8002312c:	f9 22 1e 00 	st.h [%a2]30,%d2
    TCP_STATS_INC(tcp.memerr);
80023130:	91 10 00 27 	movh.a %a2,28673
80023134:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80023138:	b9 22 1c 20 	ld.hu %d2,[%a2]156 <7001009c <ram_heap+0x5008>>
8002313c:	c2 12       	add %d2,1
8002313e:	37 02 70 20 	extr.u %d2,%d2,0,16
80023142:	91 10 00 27 	movh.a %a2,28673
80023146:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002314a:	f9 22 1c 20 	st.h [%a2]156 <7001009c <ram_heap+0x5008>>,%d2
    return ERR_MEM;
8002314e:	82 f2       	mov %d2,-1
80023150:	00 90       	ret 
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
80023152:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023156:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8002315a:	39 e2 fe ff 	ld.bu %d2,[%a14]-2
8002315e:	37 02 70 20 	extr.u %d2,%d2,0,16
80023162:	7f 23 17 80 	jge.u %d3,%d2,80023190 <tcp_enqueue_flags+0x13c>
80023166:	91 00 00 28 	movh.a %a2,32768
8002316a:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
8002316e:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023172:	3b 90 43 20 	mov %d2,1081
80023176:	59 a2 04 00 	st.w [%sp]4,%d2
8002317a:	91 00 00 28 	movh.a %a2,32768
8002317e:	d9 22 f5 a2 	lea %a2,[%a2]11957 <80002eb5 <IfxCpu_Trap_vectorTable0_end+0x2cc1>>
80023182:	f4 a2       	st.a [%sp],%a2
80023184:	91 00 00 28 	movh.a %a2,32768
80023188:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002318c:	6d ff d5 10 	call 80005336 <Ifx_Lwip_printf>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
80023190:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
80023194:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023198:	d9 22 20 10 	lea %a2,[%a2]96
8002319c:	54 24       	ld.w %d4,[%a2]
8002319e:	39 e3 ff ff 	ld.bu %d3,[%a14]-1
800231a2:	02 36       	mov %d6,%d3
800231a4:	02 45       	mov %d5,%d4
800231a6:	02 24       	mov %d4,%d2
800231a8:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
800231ac:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800231b0:	6d ff ef f3 	call 8002198e <tcp_create_segment>
800231b4:	b5 e2 f0 ff 	st.a [%a14]-16,%a2
800231b8:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800231bc:	df 02 1f 80 	jne %d2,0,800231fa <tcp_enqueue_flags+0x1a6>
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
800231c0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800231c4:	b9 22 1e 00 	ld.hu %d2,[%a2]30
800231c8:	8f 02 48 21 	or %d2,%d2,128
800231cc:	37 02 70 20 	extr.u %d2,%d2,0,16
800231d0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800231d4:	f9 22 1e 00 	st.h [%a2]30,%d2
    TCP_STATS_INC(tcp.memerr);
800231d8:	91 10 00 27 	movh.a %a2,28673
800231dc:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800231e0:	b9 22 1c 20 	ld.hu %d2,[%a2]156 <7001009c <ram_heap+0x5008>>
800231e4:	c2 12       	add %d2,1
800231e6:	37 02 70 20 	extr.u %d2,%d2,0,16
800231ea:	91 10 00 27 	movh.a %a2,28673
800231ee:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800231f2:	f9 22 1c 20 	st.h [%a2]156 <7001009c <ram_heap+0x5008>>,%d2
    return ERR_MEM;
800231f6:	82 f2       	mov %d2,-1
800231f8:	00 90       	ret 
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
800231fa:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800231fe:	d9 22 10 00 	lea %a2,[%a2]16
80023202:	54 22       	ld.w %d2,[%a2]
80023204:	8f 32 00 21 	and %d2,%d2,3
80023208:	df 02 17 00 	jeq %d2,0,80023236 <tcp_enqueue_flags+0x1e2>
8002320c:	91 00 00 28 	movh.a %a2,32768
80023210:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80023214:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023218:	3b 20 44 20 	mov %d2,1090
8002321c:	59 a2 04 00 	st.w [%sp]4,%d2
80023220:	91 00 00 28 	movh.a %a2,32768
80023224:	d9 22 ee b2 	lea %a2,[%a2]12014 <80002eee <IfxCpu_Trap_vectorTable0_end+0x2cfa>>
80023228:	f4 a2       	st.a [%sp],%a2
8002322a:	91 00 00 28 	movh.a %a2,32768
8002322e:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023232:	6d ff 82 10 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
80023236:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8002323a:	b9 22 08 00 	ld.hu %d2,[%a2]8
8002323e:	df 02 17 00 	jeq %d2,0,8002326c <tcp_enqueue_flags+0x218>
80023242:	91 00 00 28 	movh.a %a2,32768
80023246:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
8002324a:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
8002324e:	3b 30 44 20 	mov %d2,1091
80023252:	59 a2 04 00 	st.w [%sp]4,%d2
80023256:	91 00 00 28 	movh.a %a2,32768
8002325a:	d9 22 c6 c2 	lea %a2,[%a2]12038 <80002f06 <IfxCpu_Trap_vectorTable0_end+0x2d12>>
8002325e:	f4 a2       	st.a [%sp],%a2
80023260:	91 00 00 28 	movh.a %a2,32768
80023264:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023268:	6d ff 67 10 	call 80005336 <Ifx_Lwip_printf>
               lwip_ntohl(seg->tcphdr->seqno),
               lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
8002326c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023270:	d9 22 30 10 	lea %a2,[%a2]112
80023274:	54 22       	ld.w %d2,[%a2]
80023276:	df 02 0b 80 	jne %d2,0,8002328c <tcp_enqueue_flags+0x238>
    pcb->unsent = seg;
8002327a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8002327e:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80023282:	d9 22 30 10 	lea %a2,[%a2]112
80023286:	74 22       	st.w [%a2],%d2
80023288:	1d 00 1a 00 	j 800232bc <tcp_enqueue_flags+0x268>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
8002328c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023290:	d9 22 30 10 	lea %a2,[%a2]112
80023294:	54 22       	ld.w %d2,[%a2]
80023296:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8002329a:	1d 00 07 00 	j 800232a8 <tcp_enqueue_flags+0x254>
8002329e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800232a2:	54 22       	ld.w %d2,[%a2]
800232a4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800232a8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800232ac:	54 22       	ld.w %d2,[%a2]
800232ae:	df 02 f8 ff 	jne %d2,0,8002329e <tcp_enqueue_flags+0x24a>
    useg->next = seg;
800232b2:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800232b6:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800232ba:	74 22       	st.w [%a2],%d2
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
800232bc:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800232c0:	82 02       	mov %d2,0
800232c2:	f9 22 2c 10 	st.h [%a2]108,%d2
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
800232c6:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
800232ca:	8f 22 00 21 	and %d2,%d2,2
800232ce:	df 02 08 80 	jne %d2,0,800232de <tcp_enqueue_flags+0x28a>
800232d2:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
800232d6:	8f 12 00 21 	and %d2,%d2,1
800232da:	df 02 0d 00 	jeq %d2,0,800232f4 <tcp_enqueue_flags+0x2a0>
    pcb->snd_lbb++;
800232de:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800232e2:	d9 22 20 10 	lea %a2,[%a2]96
800232e6:	54 22       	ld.w %d2,[%a2]
800232e8:	c2 12       	add %d2,1
800232ea:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800232ee:	d9 22 20 10 	lea %a2,[%a2]96
800232f2:	74 22       	st.w [%a2],%d2
    /* optlen does not influence snd_buf */
  }
  if (flags & TCP_FIN) {
800232f4:	39 e2 e8 ff 	ld.bu %d2,[%a14]-24
800232f8:	8f 12 00 21 	and %d2,%d2,1
800232fc:	df 02 0e 00 	jeq %d2,0,80023318 <tcp_enqueue_flags+0x2c4>
    tcp_set_flags(pcb, TF_FIN);
80023300:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023304:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023308:	8f 02 42 21 	or %d2,%d2,32
8002330c:	37 02 70 20 	extr.u %d2,%d2,0,16
80023310:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023314:	f9 22 1e 00 	st.h [%a2]30,%d2
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
80023318:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8002331c:	b0 42       	add.a %a2,4
8002331e:	54 22       	ld.w %d2,[%a2]
80023320:	60 24       	mov.a %a4,%d2
80023322:	6d ff 1e b7 	call 8001a15e <pbuf_clen>
80023326:	02 23       	mov %d3,%d2
80023328:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8002332c:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80023330:	42 32       	add %d2,%d3
80023332:	37 02 70 20 	extr.u %d2,%d2,0,16
80023336:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8002333a:	f9 22 2a 10 	st.h [%a2]106,%d2
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
8002333e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023342:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80023346:	df 02 25 00 	jeq %d2,0,80023390 <tcp_enqueue_flags+0x33c>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
8002334a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8002334e:	d9 22 34 10 	lea %a2,[%a2]116
80023352:	54 22       	ld.w %d2,[%a2]
80023354:	df 02 1e 80 	jne %d2,0,80023390 <tcp_enqueue_flags+0x33c>
80023358:	99 e2 ec ff 	ld.a %a2,[%a14]-20
8002335c:	d9 22 30 10 	lea %a2,[%a2]112
80023360:	54 22       	ld.w %d2,[%a2]
80023362:	df 02 17 80 	jne %d2,0,80023390 <tcp_enqueue_flags+0x33c>
80023366:	91 00 00 28 	movh.a %a2,32768
8002336a:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
8002336e:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023372:	3b 50 46 20 	mov %d2,1125
80023376:	59 a2 04 00 	st.w [%sp]4,%d2
8002337a:	91 00 00 28 	movh.a %a2,32768
8002337e:	d9 22 f0 c2 	lea %a2,[%a2]12080 <80002f30 <IfxCpu_Trap_vectorTable0_end+0x2d3c>>
80023382:	f4 a2       	st.a [%sp],%a2
80023384:	91 00 00 28 	movh.a %a2,32768
80023388:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002338c:	6d ff d5 0f 	call 80005336 <Ifx_Lwip_printf>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
80023390:	82 02       	mov %d2,0
}
80023392:	00 90       	ret 

80023394 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
80023394:	40 ae       	mov.aa %a14,%sp
80023396:	20 38       	sub.a %sp,56
80023398:	b5 e4 dc ff 	st.a [%a14]-36,%a4
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
8002339c:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800233a0:	df 02 17 80 	jne %d2,0,800233ce <tcp_output+0x3a>
800233a4:	91 00 00 28 	movh.a %a2,32768
800233a8:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800233ac:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800233b0:	3b 10 4e 20 	mov %d2,1249
800233b4:	59 a2 04 00 	st.w [%sp]4,%d2
800233b8:	91 00 00 28 	movh.a %a2,32768
800233bc:	d9 22 d8 d2 	lea %a2,[%a2]12120 <80002f58 <IfxCpu_Trap_vectorTable0_end+0x2d64>>
800233c0:	f4 a2       	st.a [%sp],%a2
800233c2:	91 00 00 28 	movh.a %a2,32768
800233c6:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800233ca:	6d ff b6 0f 	call 80005336 <Ifx_Lwip_printf>
  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
800233ce:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800233d2:	d9 22 14 00 	lea %a2,[%a2]20
800233d6:	54 22       	ld.w %d2,[%a2]
800233d8:	df 12 17 80 	jne %d2,1,80023406 <tcp_output+0x72>
800233dc:	91 00 00 28 	movh.a %a2,32768
800233e0:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800233e4:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800233e8:	3b 30 4e 20 	mov %d2,1251
800233ec:	59 a2 04 00 	st.w [%sp]4,%d2
800233f0:	91 00 00 28 	movh.a %a2,32768
800233f4:	d9 22 f0 d2 	lea %a2,[%a2]12144 <80002f70 <IfxCpu_Trap_vectorTable0_end+0x2d7c>>
800233f8:	f4 a2       	st.a [%sp],%a2
800233fa:	91 00 00 28 	movh.a %a2,32768
800233fe:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023402:	6d ff 9a 0f 	call 80005336 <Ifx_Lwip_printf>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
80023406:	91 10 00 27 	movh.a %a2,28673
8002340a:	d9 22 40 84 	lea %a2,[%a2]17920 <70014600 <tcp_input_pcb>>
8002340e:	54 22       	ld.w %d2,[%a2]
80023410:	19 e3 dc ff 	ld.w %d3,[%a14]-36 <70014600 <tcp_input_pcb>>
80023414:	5f 23 04 80 	jne %d3,%d2,8002341c <tcp_output+0x88>
    return ERR_OK;
80023418:	82 02       	mov %d2,0
8002341a:	00 90       	ret 
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
8002341c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023420:	b9 23 0c 10 	ld.hu %d3,[%a2]76
80023424:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023428:	b9 22 24 10 	ld.hu %d2,[%a2]100
8002342c:	0b 23 90 21 	min.u %d2,%d3,%d2
80023430:	37 02 70 20 	extr.u %d2,%d2,0,16
80023434:	59 e2 f0 ff 	st.w [%a14]-16,%d2

  seg = pcb->unsent;
80023438:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002343c:	d9 22 30 10 	lea %a2,[%a2]112
80023440:	54 22       	ld.w %d2,[%a2]
80023442:	59 e2 fc ff 	st.w [%a14]-4,%d2

  if (seg == NULL) {
80023446:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002344a:	df 02 0f 80 	jne %d2,0,80023468 <tcp_output+0xd4>
                                 ", seg == NULL, ack %"U32_F"\n",
                                 pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));

    /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
     * an empty ACK segment and send it. */
    if (pcb->flags & TF_ACK_NOW) {
8002344e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023452:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023456:	8f 22 00 21 	and %d2,%d2,2
8002345a:	df 02 fe 02 	jeq %d2,0,80023a56 <tcp_output+0x6c2>
      return tcp_send_empty_ack(pcb);
8002345e:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80023462:	6d 00 71 0a 	call 80024944 <tcp_send_empty_ack>
80023466:	00 90       	ret 
                 pcb->snd_wnd, pcb->cwnd, wnd,
                 lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
  }

  netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
80023468:	19 e2 dc ff 	ld.w %d2,[%a14]-36
8002346c:	19 e3 dc ff 	ld.w %d3,[%a14]-36
80023470:	c2 43       	add %d3,4
80023472:	60 36       	mov.a %a6,%d3
80023474:	60 25       	mov.a %a5,%d2
80023476:	99 e4 dc ff 	ld.a %a4,[%a14]-36
8002347a:	6d ff 67 f2 	call 80021948 <tcp_route>
8002347e:	b5 e2 ec ff 	st.a [%a14]-20,%a2
  if (netif == NULL) {
80023482:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80023486:	df 02 04 80 	jne %d2,0,8002348e <tcp_output+0xfa>
    return ERR_RTE;
8002348a:	82 c2       	mov %d2,-4
8002348c:	00 90       	ret 
  }

  /* If we don't have a local IP address, we get one from netif */
  if (ip_addr_isany(&pcb->local_ip)) {
8002348e:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80023492:	df 02 07 00 	jeq %d2,0,800234a0 <tcp_output+0x10c>
80023496:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002349a:	54 22       	ld.w %d2,[%a2]
8002349c:	df 02 1a 80 	jne %d2,0,800234d0 <tcp_output+0x13c>
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
800234a0:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800234a4:	df 02 07 00 	jeq %d2,0,800234b2 <tcp_output+0x11e>
800234a8:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800234ac:	c2 42       	add %d2,4
800234ae:	1d 00 03 00 	j 800234b4 <tcp_output+0x120>
800234b2:	82 02       	mov %d2,0
800234b4:	59 e2 e8 ff 	st.w [%a14]-24,%d2
    if (local_ip == NULL) {
800234b8:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800234bc:	df 02 04 80 	jne %d2,0,800234c4 <tcp_output+0x130>
      return ERR_RTE;
800234c0:	82 c2       	mov %d2,-4
800234c2:	00 90       	ret 
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
800234c4:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800234c8:	54 22       	ld.w %d2,[%a2]
800234ca:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800234ce:	74 22       	st.w [%a2],%d2
  }

  /* Handle the current segment not fitting within the window */
  if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
800234d0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800234d4:	d9 22 10 00 	lea %a2,[%a2]16
800234d8:	d4 22       	ld.a %a2,[%a2]
800234da:	39 23 04 00 	ld.bu %d3,[%a2]4
800234de:	39 22 05 00 	ld.bu %d2,[%a2]5
800234e2:	8f 82 00 20 	sh %d2,%d2,8
800234e6:	a6 32       	or %d2,%d3
800234e8:	39 23 06 00 	ld.bu %d3,[%a2]6
800234ec:	8f 03 01 30 	sh %d3,%d3,16
800234f0:	a6 32       	or %d2,%d3
800234f2:	39 23 07 00 	ld.bu %d3,[%a2]7
800234f6:	8f 83 01 30 	sh %d3,%d3,24
800234fa:	a6 32       	or %d2,%d3
800234fc:	02 24       	mov %d4,%d2
800234fe:	6d ff 43 a0 	call 80017584 <lwip_htonl>
80023502:	02 23       	mov %d3,%d2
80023504:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023508:	d9 22 08 10 	lea %a2,[%a2]72
8002350c:	54 22       	ld.w %d2,[%a2]
8002350e:	a2 23       	sub %d3,%d2
80023510:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023514:	b9 22 08 00 	ld.hu %d2,[%a2]8
80023518:	42 32       	add %d2,%d3
8002351a:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8002351e:	7f 23 34 80 	jge.u %d3,%d2,80023586 <tcp_output+0x1f2>
     * within the remaining (could be 0) send window and RTO timer is not running (we
     * have no in-flight data). If window is still too small after persist timer fires,
     * then we split the segment. We don't consider the congestion window since a cwnd
     * smaller than 1 SMSS implies in-flight data
     */
    if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
80023522:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023526:	b9 22 24 10 	ld.hu %d2,[%a2]100
8002352a:	02 23       	mov %d3,%d2
8002352c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80023530:	5f 32 1e 80 	jne %d2,%d3,8002356c <tcp_output+0x1d8>
80023534:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023538:	d9 22 34 10 	lea %a2,[%a2]116
8002353c:	54 22       	ld.w %d2,[%a2]
8002353e:	df 02 17 80 	jne %d2,0,8002356c <tcp_output+0x1d8>
80023542:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023546:	39 22 1d 20 	ld.bu %d2,[%a2]157
8002354a:	df 02 11 80 	jne %d2,0,8002356c <tcp_output+0x1d8>
      pcb->persist_cnt = 0;
8002354e:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023552:	82 02       	mov %d2,0
80023554:	e9 22 1c 20 	st.b [%a2]156,%d2
      pcb->persist_backoff = 1;
80023558:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002355c:	82 12       	mov %d2,1
8002355e:	e9 22 1d 20 	st.b [%a2]157,%d2
      pcb->persist_probe = 0;
80023562:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023566:	82 02       	mov %d2,0
80023568:	e9 22 1e 20 	st.b [%a2]158,%d2
    }
    /* We need an ACK, but can't send data now, so send an empty ACK */
    if (pcb->flags & TF_ACK_NOW) {
8002356c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023570:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023574:	8f 22 00 21 	and %d2,%d2,2
80023578:	df 02 72 02 	jeq %d2,0,80023a5c <tcp_output+0x6c8>
      return tcp_send_empty_ack(pcb);
8002357c:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80023580:	6d 00 e2 09 	call 80024944 <tcp_send_empty_ack>
80023584:	00 90       	ret 
    }
    goto output_done;
  }
  /* Stop persist timer, above conditions are not active */
  pcb->persist_backoff = 0;
80023586:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002358a:	82 02       	mov %d2,0
8002358c:	e9 22 1d 20 	st.b [%a2]157,%d2

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
80023590:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023594:	d9 22 34 10 	lea %a2,[%a2]116
80023598:	54 22       	ld.w %d2,[%a2]
8002359a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  if (useg != NULL) {
8002359e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800235a2:	df 02 1c 02 	jeq %d2,0,800239da <tcp_output+0x646>
    for (; useg->next != NULL; useg = useg->next);
800235a6:	1d 00 07 00 	j 800235b4 <tcp_output+0x220>
800235aa:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800235ae:	54 22       	ld.w %d2,[%a2]
800235b0:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800235b4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800235b8:	54 22       	ld.w %d2,[%a2]
800235ba:	df 02 f8 ff 	jne %d2,0,800235aa <tcp_output+0x216>
  }
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
800235be:	1d 00 0e 02 	j 800239da <tcp_output+0x646>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!",
800235c2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800235c6:	d9 22 10 00 	lea %a2,[%a2]16
800235ca:	d4 22       	ld.a %a2,[%a2]
800235cc:	39 23 0c 00 	ld.bu %d3,[%a2]12
800235d0:	39 22 0d 00 	ld.bu %d2,[%a2]13
800235d4:	8f 82 00 20 	sh %d2,%d2,8
800235d8:	a6 32       	or %d2,%d3
800235da:	37 02 70 20 	extr.u %d2,%d2,0,16
800235de:	02 24       	mov %d4,%d2
800235e0:	6d ff ba 9f 	call 80017554 <lwip_htons>
800235e4:	8f f2 0f 21 	and %d2,%d2,255
800235e8:	8f 42 00 21 	and %d2,%d2,4
800235ec:	df 02 17 00 	jeq %d2,0,8002361a <tcp_output+0x286>
800235f0:	91 00 00 28 	movh.a %a2,32768
800235f4:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800235f8:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800235fc:	3b 60 53 20 	mov %d2,1334
80023600:	59 a2 04 00 	st.w [%sp]4,%d2
80023604:	91 00 00 28 	movh.a %a2,32768
80023608:	d9 22 d6 e2 	lea %a2,[%a2]12182 <80002f96 <IfxCpu_Trap_vectorTable0_end+0x2da2>>
8002360c:	f4 a2       	st.a [%sp],%a2
8002360e:	91 00 00 28 	movh.a %a2,32768
80023612:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023616:	6d ff 90 0e 	call 80005336 <Ifx_Lwip_printf>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if ((tcp_do_output_nagle(pcb) == 0) &&
8002361a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002361e:	d9 22 34 10 	lea %a2,[%a2]116
80023622:	54 22       	ld.w %d2,[%a2]
80023624:	df 02 32 00 	jeq %d2,0,80023688 <tcp_output+0x2f4>
80023628:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002362c:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023630:	8f 42 04 21 	and %d2,%d2,68
80023634:	df 02 2a 80 	jne %d2,0,80023688 <tcp_output+0x2f4>
80023638:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002363c:	d9 22 30 10 	lea %a2,[%a2]112
80023640:	54 22       	ld.w %d2,[%a2]
80023642:	df 02 17 00 	jeq %d2,0,80023670 <tcp_output+0x2dc>
80023646:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002364a:	d9 22 30 10 	lea %a2,[%a2]112
8002364e:	d4 22       	ld.a %a2,[%a2]
80023650:	54 22       	ld.w %d2,[%a2]
80023652:	df 02 1b 80 	jne %d2,0,80023688 <tcp_output+0x2f4>
80023656:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002365a:	d9 22 30 10 	lea %a2,[%a2]112
8002365e:	d4 22       	ld.a %a2,[%a2]
80023660:	b9 23 08 00 	ld.hu %d3,[%a2]8
80023664:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023668:	b9 22 36 00 	ld.hu %d2,[%a2]54
8002366c:	7f 23 0e 80 	jge.u %d3,%d2,80023688 <tcp_output+0x2f4>
80023670:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023674:	b9 22 28 10 	ld.hu %d2,[%a2]104
80023678:	df 02 08 00 	jeq %d2,0,80023688 <tcp_output+0x2f4>
8002367c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023680:	b9 22 2a 10 	ld.hu %d2,[%a2]106
80023684:	bf 82 05 80 	jlt.u %d2,8,8002368e <tcp_output+0x2fa>
80023688:	82 12       	mov %d2,1
8002368a:	1d 00 03 00 	j 80023690 <tcp_output+0x2fc>
8002368e:	82 02       	mov %d2,0
80023690:	df 02 0a 80 	jne %d2,0,800236a4 <tcp_output+0x310>
        ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
80023694:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023698:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8002369c:	8f 02 0a 21 	and %d2,%d2,160
    if ((tcp_do_output_nagle(pcb) == 0) &&
800236a0:	df 02 cc 01 	jeq %d2,0,80023a38 <tcp_output+0x6a4>
                                 pcb->lastack,
                                 lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    if (pcb->state != SYN_SENT) {
800236a4:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800236a8:	d9 22 14 00 	lea %a2,[%a2]20
800236ac:	54 22       	ld.w %d2,[%a2]
800236ae:	df 22 29 00 	jeq %d2,2,80023700 <tcp_output+0x36c>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
800236b2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800236b6:	d9 22 10 00 	lea %a2,[%a2]16
800236ba:	d4 22       	ld.a %a2,[%a2]
800236bc:	39 23 0c 00 	ld.bu %d3,[%a2]12
800236c0:	39 22 0d 00 	ld.bu %d2,[%a2]13
800236c4:	8f 82 00 20 	sh %d2,%d2,8
800236c8:	a6 32       	or %d2,%d3
800236ca:	37 02 70 80 	extr.u %d8,%d2,0,16
800236ce:	3b 00 01 40 	mov %d4,16
800236d2:	6d ff 41 9f 	call 80017554 <lwip_htons>
800236d6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800236da:	d9 22 10 00 	lea %a2,[%a2]16
800236de:	d4 22       	ld.a %a2,[%a2]
800236e0:	a6 82       	or %d2,%d8
800236e2:	37 02 70 20 	extr.u %d2,%d2,0,16
800236e6:	8f f2 0f 31 	and %d3,%d2,255
800236ea:	82 04       	mov %d4,0
800236ec:	a6 43       	or %d3,%d4
800236ee:	e9 23 0c 00 	st.b [%a2]12,%d3
800236f2:	06 82       	sh %d2,-8
800236f4:	37 02 70 20 	extr.u %d2,%d2,0,16
800236f8:	82 03       	mov %d3,0
800236fa:	a6 32       	or %d2,%d3
800236fc:	e9 22 0d 00 	st.b [%a2]13,%d2
    }

    err = tcp_output_segment(seg, pcb, netif);
80023700:	99 e6 ec ff 	ld.a %a6,[%a14]-20
80023704:	99 e5 dc ff 	ld.a %a5,[%a14]-36
80023708:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8002370c:	6d 00 e3 01 	call 80023ad2 <tcp_output_segment>
80023710:	e9 e2 e7 ff 	st.b [%a14]-25,%d2
    if (err != ERR_OK) {
80023714:	79 e2 e7 ff 	ld.b %d2,[%a14]-25
80023718:	df 02 11 00 	jeq %d2,0,8002373a <tcp_output+0x3a6>
      /* segment could not be sent, for whatever reason */
      tcp_set_flags(pcb, TF_NAGLEMEMERR);
8002371c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023720:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023724:	8f 02 48 21 	or %d2,%d2,128
80023728:	37 02 70 20 	extr.u %d2,%d2,0,16
8002372c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023730:	f9 22 1e 00 	st.h [%a2]30,%d2
      return err;
80023734:	79 e2 e7 ff 	ld.b %d2,[%a14]-25
80023738:	00 90       	ret 
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = 0;
8002373a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002373e:	82 02       	mov %d2,0
80023740:	f9 22 0a 00 	st.h [%a2]10,%d2
#endif /* TCP_OVERSIZE_DBGCHECK */
    pcb->unsent = seg->next;
80023744:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023748:	54 22       	ld.w %d2,[%a2]
8002374a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002374e:	d9 22 30 10 	lea %a2,[%a2]112
80023752:	74 22       	st.w [%a2],%d2
    if (pcb->state != SYN_SENT) {
80023754:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023758:	d9 22 14 00 	lea %a2,[%a2]20
8002375c:	54 22       	ld.w %d2,[%a2]
8002375e:	df 22 0e 00 	jeq %d2,2,8002377a <tcp_output+0x3e6>
      tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
80023762:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023766:	b9 22 1e 00 	ld.hu %d2,[%a2]30
8002376a:	8f 32 c0 21 	andn %d2,%d2,3
8002376e:	37 02 70 20 	extr.u %d2,%d2,0,16
80023772:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023776:	f9 22 1e 00 	st.h [%a2]30,%d2
    }
    snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
8002377a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002377e:	d9 22 10 00 	lea %a2,[%a2]16
80023782:	d4 22       	ld.a %a2,[%a2]
80023784:	39 23 04 00 	ld.bu %d3,[%a2]4
80023788:	39 22 05 00 	ld.bu %d2,[%a2]5
8002378c:	8f 82 00 20 	sh %d2,%d2,8
80023790:	a6 32       	or %d2,%d3
80023792:	39 23 06 00 	ld.bu %d3,[%a2]6
80023796:	8f 03 01 30 	sh %d3,%d3,16
8002379a:	a6 32       	or %d2,%d3
8002379c:	39 23 07 00 	ld.bu %d3,[%a2]7
800237a0:	8f 83 01 30 	sh %d3,%d3,24
800237a4:	a6 32       	or %d2,%d3
800237a6:	02 24       	mov %d4,%d2
800237a8:	6d ff ee 9e 	call 80017584 <lwip_htonl>
800237ac:	02 28       	mov %d8,%d2
800237ae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800237b2:	b9 22 08 00 	ld.hu %d2,[%a2]8
800237b6:	02 29       	mov %d9,%d2
800237b8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800237bc:	d9 22 10 00 	lea %a2,[%a2]16
800237c0:	d4 22       	ld.a %a2,[%a2]
800237c2:	39 23 0c 00 	ld.bu %d3,[%a2]12
800237c6:	39 22 0d 00 	ld.bu %d2,[%a2]13
800237ca:	8f 82 00 20 	sh %d2,%d2,8
800237ce:	a6 32       	or %d2,%d3
800237d0:	37 02 70 20 	extr.u %d2,%d2,0,16
800237d4:	02 24       	mov %d4,%d2
800237d6:	6d ff bf 9e 	call 80017554 <lwip_htons>
800237da:	8f f2 0f 21 	and %d2,%d2,255
800237de:	8f 32 00 21 	and %d2,%d2,3
800237e2:	df 02 05 00 	jeq %d2,0,800237ec <tcp_output+0x458>
800237e6:	82 12       	mov %d2,1
800237e8:	1d 00 03 00 	j 800237ee <tcp_output+0x45a>
800237ec:	82 02       	mov %d2,0
800237ee:	42 92       	add %d2,%d9
800237f0:	42 82       	add %d2,%d8
800237f2:	59 e2 e0 ff 	st.w [%a14]-32,%d2
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
800237f6:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800237fa:	d9 22 14 10 	lea %a2,[%a2]84
800237fe:	54 23       	ld.w %d3,[%a2]
80023800:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80023804:	0b 23 80 20 	sub %d2,%d3,%d2
80023808:	ff 02 09 00 	jge %d2,0,8002381a <tcp_output+0x486>
      pcb->snd_nxt = snd_nxt;
8002380c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023810:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80023814:	d9 22 14 10 	lea %a2,[%a2]84
80023818:	74 22       	st.w [%a2],%d2
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
8002381a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002381e:	b9 22 08 00 	ld.hu %d2,[%a2]8
80023822:	02 28       	mov %d8,%d2
80023824:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023828:	d9 22 10 00 	lea %a2,[%a2]16
8002382c:	d4 22       	ld.a %a2,[%a2]
8002382e:	39 23 0c 00 	ld.bu %d3,[%a2]12
80023832:	39 22 0d 00 	ld.bu %d2,[%a2]13
80023836:	8f 82 00 20 	sh %d2,%d2,8
8002383a:	a6 32       	or %d2,%d3
8002383c:	37 02 70 20 	extr.u %d2,%d2,0,16
80023840:	02 24       	mov %d4,%d2
80023842:	6d ff 89 9e 	call 80017554 <lwip_htons>
80023846:	8f f2 0f 21 	and %d2,%d2,255
8002384a:	8f 32 00 21 	and %d2,%d2,3
8002384e:	df 02 05 00 	jeq %d2,0,80023858 <tcp_output+0x4c4>
80023852:	82 12       	mov %d2,1
80023854:	1d 00 03 00 	j 8002385a <tcp_output+0x4c6>
80023858:	82 02       	mov %d2,0
8002385a:	42 82       	add %d2,%d8
8002385c:	df 02 b4 00 	jeq %d2,0,800239c4 <tcp_output+0x630>
      seg->next = NULL;
80023860:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023864:	82 02       	mov %d2,0
80023866:	74 22       	st.w [%a2],%d2
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
80023868:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002386c:	d9 22 34 10 	lea %a2,[%a2]116
80023870:	54 22       	ld.w %d2,[%a2]
80023872:	df 02 0f 80 	jne %d2,0,80023890 <tcp_output+0x4fc>
        pcb->unacked = seg;
80023876:	99 e2 dc ff 	ld.a %a2,[%a14]-36
8002387a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002387e:	d9 22 34 10 	lea %a2,[%a2]116
80023882:	74 22       	st.w [%a2],%d2
        useg = seg;
80023884:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80023888:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8002388c:	1d 00 a0 00 	j 800239cc <tcp_output+0x638>
        /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
80023890:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023894:	d9 22 10 00 	lea %a2,[%a2]16
80023898:	d4 22       	ld.a %a2,[%a2]
8002389a:	39 23 04 00 	ld.bu %d3,[%a2]4
8002389e:	39 22 05 00 	ld.bu %d2,[%a2]5
800238a2:	8f 82 00 20 	sh %d2,%d2,8
800238a6:	a6 32       	or %d2,%d3
800238a8:	39 23 06 00 	ld.bu %d3,[%a2]6
800238ac:	8f 03 01 30 	sh %d3,%d3,16
800238b0:	a6 32       	or %d2,%d3
800238b2:	39 23 07 00 	ld.bu %d3,[%a2]7
800238b6:	8f 83 01 30 	sh %d3,%d3,24
800238ba:	a6 32       	or %d2,%d3
800238bc:	02 24       	mov %d4,%d2
800238be:	6d ff 63 9e 	call 80017584 <lwip_htonl>
800238c2:	02 28       	mov %d8,%d2
800238c4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800238c8:	d9 22 10 00 	lea %a2,[%a2]16
800238cc:	d4 22       	ld.a %a2,[%a2]
800238ce:	39 23 04 00 	ld.bu %d3,[%a2]4
800238d2:	39 22 05 00 	ld.bu %d2,[%a2]5
800238d6:	8f 82 00 20 	sh %d2,%d2,8
800238da:	a6 32       	or %d2,%d3
800238dc:	39 23 06 00 	ld.bu %d3,[%a2]6
800238e0:	8f 03 01 30 	sh %d3,%d3,16
800238e4:	a6 32       	or %d2,%d3
800238e6:	39 23 07 00 	ld.bu %d3,[%a2]7
800238ea:	8f 83 01 30 	sh %d3,%d3,24
800238ee:	a6 32       	or %d2,%d3
800238f0:	02 24       	mov %d4,%d2
800238f2:	6d ff 49 9e 	call 80017584 <lwip_htonl>
800238f6:	0b 28 80 20 	sub %d2,%d8,%d2
800238fa:	ff 02 59 00 	jge %d2,0,800239ac <tcp_output+0x618>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
800238fe:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80023902:	1b 42 07 20 	addi %d2,%d2,116
80023906:	59 e2 f4 ff 	st.w [%a14]-12,%d2
          while (*cur_seg &&
8002390a:	1d 00 07 00 	j 80023918 <tcp_output+0x584>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
            cur_seg = &((*cur_seg)->next );
8002390e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023912:	54 22       	ld.w %d2,[%a2]
80023914:	59 e2 f4 ff 	st.w [%a14]-12,%d2
          while (*cur_seg &&
80023918:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002391c:	54 22       	ld.w %d2,[%a2]
8002391e:	df 02 3a 00 	jeq %d2,0,80023992 <tcp_output+0x5fe>
                 TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
80023922:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023926:	d4 22       	ld.a %a2,[%a2]
80023928:	d9 22 10 00 	lea %a2,[%a2]16
8002392c:	d4 22       	ld.a %a2,[%a2]
8002392e:	39 23 04 00 	ld.bu %d3,[%a2]4
80023932:	39 22 05 00 	ld.bu %d2,[%a2]5
80023936:	8f 82 00 20 	sh %d2,%d2,8
8002393a:	a6 32       	or %d2,%d3
8002393c:	39 23 06 00 	ld.bu %d3,[%a2]6
80023940:	8f 03 01 30 	sh %d3,%d3,16
80023944:	a6 32       	or %d2,%d3
80023946:	39 23 07 00 	ld.bu %d3,[%a2]7
8002394a:	8f 83 01 30 	sh %d3,%d3,24
8002394e:	a6 32       	or %d2,%d3
80023950:	02 24       	mov %d4,%d2
80023952:	6d ff 19 9e 	call 80017584 <lwip_htonl>
80023956:	02 28       	mov %d8,%d2
80023958:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002395c:	d9 22 10 00 	lea %a2,[%a2]16
80023960:	d4 22       	ld.a %a2,[%a2]
80023962:	39 23 04 00 	ld.bu %d3,[%a2]4
80023966:	39 22 05 00 	ld.bu %d2,[%a2]5
8002396a:	8f 82 00 20 	sh %d2,%d2,8
8002396e:	a6 32       	or %d2,%d3
80023970:	39 23 06 00 	ld.bu %d3,[%a2]6
80023974:	8f 03 01 30 	sh %d3,%d3,16
80023978:	a6 32       	or %d2,%d3
8002397a:	39 23 07 00 	ld.bu %d3,[%a2]7
8002397e:	8f 83 01 30 	sh %d3,%d3,24
80023982:	a6 32       	or %d2,%d3
80023984:	02 24       	mov %d4,%d2
80023986:	6d ff ff 9d 	call 80017584 <lwip_htonl>
8002398a:	0b 28 80 20 	sub %d2,%d8,%d2
          while (*cur_seg &&
8002398e:	bf 02 c0 7f 	jlt %d2,0,8002390e <tcp_output+0x57a>
          }
          seg->next = (*cur_seg);
80023992:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023996:	54 22       	ld.w %d2,[%a2]
80023998:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002399c:	74 22       	st.w [%a2],%d2
          (*cur_seg) = seg;
8002399e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800239a2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800239a6:	74 22       	st.w [%a2],%d2
800239a8:	1d 00 12 00 	j 800239cc <tcp_output+0x638>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
800239ac:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800239b0:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800239b4:	74 22       	st.w [%a2],%d2
          useg = useg->next;
800239b6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800239ba:	54 22       	ld.w %d2,[%a2]
800239bc:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800239c0:	1d 00 06 00 	j 800239cc <tcp_output+0x638>
        }
      }
      /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
800239c4:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800239c8:	6d ff f2 c5 	call 8001c5ac <tcp_seg_free>
    }
    seg = pcb->unsent;
800239cc:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800239d0:	d9 22 30 10 	lea %a2,[%a2]112
800239d4:	54 22       	ld.w %d2,[%a2]
800239d6:	59 e2 fc ff 	st.w [%a14]-4,%d2
  while (seg != NULL &&
800239da:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800239de:	df 02 2e 00 	jeq %d2,0,80023a3a <tcp_output+0x6a6>
         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
800239e2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800239e6:	d9 22 10 00 	lea %a2,[%a2]16
800239ea:	d4 22       	ld.a %a2,[%a2]
800239ec:	39 23 04 00 	ld.bu %d3,[%a2]4
800239f0:	39 22 05 00 	ld.bu %d2,[%a2]5
800239f4:	8f 82 00 20 	sh %d2,%d2,8
800239f8:	a6 32       	or %d2,%d3
800239fa:	39 23 06 00 	ld.bu %d3,[%a2]6
800239fe:	8f 03 01 30 	sh %d3,%d3,16
80023a02:	a6 32       	or %d2,%d3
80023a04:	39 23 07 00 	ld.bu %d3,[%a2]7
80023a08:	8f 83 01 30 	sh %d3,%d3,24
80023a0c:	a6 32       	or %d2,%d3
80023a0e:	02 24       	mov %d4,%d2
80023a10:	6d ff ba 9d 	call 80017584 <lwip_htonl>
80023a14:	02 23       	mov %d3,%d2
80023a16:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023a1a:	d9 22 08 10 	lea %a2,[%a2]72
80023a1e:	54 22       	ld.w %d2,[%a2]
80023a20:	a2 23       	sub %d3,%d2
80023a22:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023a26:	b9 22 08 00 	ld.hu %d2,[%a2]8
80023a2a:	42 32       	add %d2,%d3
  while (seg != NULL &&
80023a2c:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
80023a30:	7f 23 c9 fd 	jge.u %d3,%d2,800235c2 <tcp_output+0x22e>
80023a34:	1d 00 03 00 	j 80023a3a <tcp_output+0x6a6>
      break;
80023a38:	00 00       	nop 
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
80023a3a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023a3e:	d9 22 30 10 	lea %a2,[%a2]112
80023a42:	54 22       	ld.w %d2,[%a2]
80023a44:	df 02 0f 80 	jne %d2,0,80023a62 <tcp_output+0x6ce>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
80023a48:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023a4c:	82 02       	mov %d2,0
80023a4e:	f9 22 2c 10 	st.h [%a2]108,%d2
80023a52:	1d 00 09 00 	j 80023a64 <tcp_output+0x6d0>
    goto output_done;
80023a56:	00 00       	nop 
80023a58:	1d 00 06 00 	j 80023a64 <tcp_output+0x6d0>
    goto output_done;
80023a5c:	00 00       	nop 
80023a5e:	1d 00 03 00 	j 80023a64 <tcp_output+0x6d0>
  }
#endif /* TCP_OVERSIZE */

output_done:
80023a62:	00 00       	nop 
  tcp_clear_flags(pcb, TF_NAGLEMEMERR);
80023a64:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023a68:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023a6c:	8f 02 c8 21 	andn %d2,%d2,128
80023a70:	37 02 70 20 	extr.u %d2,%d2,0,16
80023a74:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80023a78:	f9 22 1e 00 	st.h [%a2]30,%d2
  return ERR_OK;
80023a7c:	82 02       	mov %d2,0
}
80023a7e:	00 90       	ret 

80023a80 <tcp_output_segment_busy>:
 * @arg seg the tcp segment to check
 * @return 1 if ref != 1, 0 if ref == 1
 */
static int
tcp_output_segment_busy(const struct tcp_seg *seg)
{
80023a80:	40 ae       	mov.aa %a14,%sp
80023a82:	20 18       	sub.a %sp,24
80023a84:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
80023a88:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80023a8c:	df 02 17 80 	jne %d2,0,80023aba <tcp_output_segment_busy+0x3a>
80023a90:	91 00 00 28 	movh.a %a2,32768
80023a94:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80023a98:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023a9c:	3b a0 59 20 	mov %d2,1434
80023aa0:	59 a2 04 00 	st.w [%sp]4,%d2
80023aa4:	91 00 00 28 	movh.a %a2,32768
80023aa8:	d9 22 ed e2 	lea %a2,[%a2]12205 <80002fad <IfxCpu_Trap_vectorTable0_end+0x2db9>>
80023aac:	f4 a2       	st.a [%sp],%a2
80023aae:	91 00 00 28 	movh.a %a2,32768
80023ab2:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023ab6:	6d ff 40 0c 	call 80005336 <Ifx_Lwip_printf>

  /* We only need to check the first pbuf here:
     If a pbuf is queued for transmission, a driver calls pbuf_ref(),
     which only changes the ref count of the first pbuf */
  if (seg->p->ref != 1) {
80023aba:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023abe:	b0 42       	add.a %a2,4
80023ac0:	d4 22       	ld.a %a2,[%a2]
80023ac2:	39 22 0e 00 	ld.bu %d2,[%a2]14
80023ac6:	df 12 04 00 	jeq %d2,1,80023ace <tcp_output_segment_busy+0x4e>
    /* other reference found */
    return 1;
80023aca:	82 12       	mov %d2,1
80023acc:	00 90       	ret 
  }
  /* no other references found */
  return 0;
80023ace:	82 02       	mov %d2,0
}
80023ad0:	00 90       	ret 

80023ad2 <tcp_output_segment>:
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 * @param netif the netif used to send the segment
 */
static err_t
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
{
80023ad2:	40 ae       	mov.aa %a14,%sp
80023ad4:	20 30       	sub.a %sp,48
80023ad6:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80023ada:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80023ade:	b5 e6 e4 ff 	st.a [%a14]-28,%a6
  u32_t *opts;
#if TCP_CHECKSUM_ON_COPY
  int seg_chksum_was_swapped = 0;
#endif

  LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
80023ae2:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80023ae6:	df 02 17 80 	jne %d2,0,80023b14 <tcp_output_segment+0x42>
80023aea:	91 00 00 28 	movh.a %a2,32768
80023aee:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80023af2:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023af6:	3b 80 5b 20 	mov %d2,1464
80023afa:	59 a2 04 00 	st.w [%sp]4,%d2
80023afe:	91 00 00 28 	movh.a %a2,32768
80023b02:	d9 22 d2 f2 	lea %a2,[%a2]12242 <80002fd2 <IfxCpu_Trap_vectorTable0_end+0x2dde>>
80023b06:	f4 a2       	st.a [%sp],%a2
80023b08:	91 00 00 28 	movh.a %a2,32768
80023b0c:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023b10:	6d ff 13 0c 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
80023b14:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80023b18:	df 02 17 80 	jne %d2,0,80023b46 <tcp_output_segment+0x74>
80023b1c:	91 00 00 28 	movh.a %a2,32768
80023b20:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80023b24:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023b28:	3b 90 5b 20 	mov %d2,1465
80023b2c:	59 a2 04 00 	st.w [%sp]4,%d2
80023b30:	91 00 00 28 	movh.a %a2,32768
80023b34:	d9 22 f2 f2 	lea %a2,[%a2]12274 <80002ff2 <IfxCpu_Trap_vectorTable0_end+0x2dfe>>
80023b38:	f4 a2       	st.a [%sp],%a2
80023b3a:	91 00 00 28 	movh.a %a2,32768
80023b3e:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023b42:	6d ff fa 0b 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
80023b46:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80023b4a:	df 02 17 80 	jne %d2,0,80023b78 <tcp_output_segment+0xa6>
80023b4e:	91 00 00 28 	movh.a %a2,32768
80023b52:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80023b56:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023b5a:	3b a0 5b 20 	mov %d2,1466
80023b5e:	59 a2 04 00 	st.w [%sp]4,%d2
80023b62:	91 00 00 28 	movh.a %a2,32768
80023b66:	d9 22 12 03 	lea %a2,[%a2]12306 <80003012 <IfxCpu_Trap_vectorTable0_end+0x2e1e>>
80023b6a:	f4 a2       	st.a [%sp],%a2
80023b6c:	91 00 00 28 	movh.a %a2,32768
80023b70:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023b74:	6d ff e1 0b 	call 80005336 <Ifx_Lwip_printf>

  if (tcp_output_segment_busy(seg)) {
80023b78:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80023b7c:	6d ff 82 ff 	call 80023a80 <tcp_output_segment_busy>
80023b80:	df 02 04 00 	jeq %d2,0,80023b88 <tcp_output_segment+0xb6>
    /* This should not happen: rexmit functions should have checked this.
       However, since this function modifies p->len, we must not continue in this case. */
    LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
    return ERR_OK;
80023b84:	82 02       	mov %d2,0
80023b86:	00 90       	ret 
  }

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
80023b88:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023b8c:	d9 22 28 00 	lea %a2,[%a2]40
80023b90:	54 22       	ld.w %d2,[%a2]
80023b92:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023b96:	d9 22 10 00 	lea %a2,[%a2]16
80023b9a:	d4 2c       	ld.a %a12,[%a2]
80023b9c:	02 24       	mov %d4,%d2
80023b9e:	6d ff f3 9c 	call 80017584 <lwip_htonl>
80023ba2:	8f f2 0f 31 	and %d3,%d2,255
80023ba6:	82 04       	mov %d4,0
80023ba8:	a6 43       	or %d3,%d4
80023baa:	e9 c3 08 00 	st.b [%a12]8,%d3
80023bae:	8f 82 1f 30 	sh %d3,%d2,-8
80023bb2:	8f f3 0f 31 	and %d3,%d3,255
80023bb6:	82 04       	mov %d4,0
80023bb8:	a6 43       	or %d3,%d4
80023bba:	e9 c3 09 00 	st.b [%a12]9,%d3
80023bbe:	8f 02 1f 30 	sh %d3,%d2,-16
80023bc2:	8f f3 0f 31 	and %d3,%d3,255
80023bc6:	82 04       	mov %d4,0
80023bc8:	a6 43       	or %d3,%d4
80023bca:	e9 c3 0a 00 	st.b [%a12]10,%d3
80023bce:	8f 82 1e 20 	sh %d2,%d2,-24
80023bd2:	82 03       	mov %d3,0
80023bd4:	a6 32       	or %d2,%d3
80023bd6:	e9 c2 0b 00 	st.b [%a12]11,%d2
       the window scale option) is never scaled. */
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
  } else
#endif /* LWIP_WND_SCALE */
  {
    seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
80023bda:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023bde:	b9 22 2e 00 	ld.hu %d2,[%a2]46
80023be2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023be6:	d9 22 10 00 	lea %a2,[%a2]16
80023bea:	d4 2c       	ld.a %a12,[%a2]
80023bec:	02 24       	mov %d4,%d2
80023bee:	6d ff b3 9c 	call 80017554 <lwip_htons>
80023bf2:	8f f2 0f 31 	and %d3,%d2,255
80023bf6:	82 04       	mov %d4,0
80023bf8:	a6 43       	or %d3,%d4
80023bfa:	e9 c3 0e 00 	st.b [%a12]14,%d3
80023bfe:	06 82       	sh %d2,-8
80023c00:	37 02 70 20 	extr.u %d2,%d2,0,16
80023c04:	82 03       	mov %d3,0
80023c06:	a6 32       	or %d2,%d3
80023c08:	e9 c2 0f 00 	st.b [%a12]15,%d2
  }

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
80023c0c:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023c10:	d9 22 28 00 	lea %a2,[%a2]40
80023c14:	54 23       	ld.w %d3,[%a2]
80023c16:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023c1a:	b9 22 2e 00 	ld.hu %d2,[%a2]46
80023c1e:	42 32       	add %d2,%d3
80023c20:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023c24:	d9 22 30 00 	lea %a2,[%a2]48
80023c28:	74 22       	st.w [%a2],%d2

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  /* cast through void* to get rid of alignment warnings */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
80023c2a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023c2e:	d9 22 10 00 	lea %a2,[%a2]16
80023c32:	54 22       	ld.w %d2,[%a2]
80023c34:	1b 42 01 20 	addi %d2,%d2,20
80023c38:	59 e2 fc ff 	st.w [%a14]-4,%d2
  if (seg->flags & TF_SEG_OPTS_MSS) {
80023c3c:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023c40:	39 22 0c 00 	ld.bu %d2,[%a2]12
80023c44:	8f 12 00 21 	and %d2,%d2,1
80023c48:	df 02 1e 00 	jeq %d2,0,80023c84 <tcp_output_segment+0x1b2>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
80023c4c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80023c50:	c2 42       	add %d2,4
80023c52:	60 25       	mov.a %a5,%d2
80023c54:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80023c58:	3b 80 21 40 	mov %d4,536
80023c5c:	6d ff 75 ca 	call 8001d146 <tcp_eff_send_mss_netif>
80023c60:	f9 e2 fa ff 	st.h [%a14]-6,%d2
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
80023c64:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80023c68:	7b 40 20 30 	movh %d3,516
80023c6c:	a6 32       	or %d2,%d3
80023c6e:	02 24       	mov %d4,%d2
80023c70:	6d ff 8a 9c 	call 80017584 <lwip_htonl>
80023c74:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023c78:	74 22       	st.w [%a2],%d2
    opts += 1;
80023c7a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80023c7e:	c2 42       	add %d2,4
80023c80:	59 e2 fc ff 	st.w [%a14]-4,%d2
  }
#endif

  /* Set retransmission timer running if it is not currently enabled
     This must be set before checking the route. */
  if (pcb->rtime < 0) {
80023c84:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023c88:	c9 22 34 00 	ld.h %d2,[%a2]52
80023c8c:	ff 02 07 00 	jge %d2,0,80023c9a <tcp_output_segment+0x1c8>
    pcb->rtime = 0;
80023c90:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023c94:	82 02       	mov %d2,0
80023c96:	f9 22 34 00 	st.h [%a2]52,%d2
  }

  if (pcb->rttest == 0) {
80023c9a:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023c9e:	d9 22 38 00 	lea %a2,[%a2]56
80023ca2:	54 22       	ld.w %d2,[%a2]
80023ca4:	df 02 2a 80 	jne %d2,0,80023cf8 <tcp_output_segment+0x226>
    pcb->rttest = tcp_ticks;
80023ca8:	91 10 00 27 	movh.a %a2,28673
80023cac:	d9 22 70 64 	lea %a2,[%a2]17840 <700145b0 <tcp_ticks>>
80023cb0:	54 22       	ld.w %d2,[%a2]
80023cb2:	99 e2 e8 ff 	ld.a %a2,[%a14]-24 <700145b0 <tcp_ticks>>
80023cb6:	d9 22 38 00 	lea %a2,[%a2]56 <700145b0 <tcp_ticks>>
80023cba:	74 22       	st.w [%a2],%d2
    pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
80023cbc:	99 e2 ec ff 	ld.a %a2,[%a14]-20 <700145b0 <tcp_ticks>>
80023cc0:	d9 22 10 00 	lea %a2,[%a2]16 <700145b0 <tcp_ticks>>
80023cc4:	d4 22       	ld.a %a2,[%a2]
80023cc6:	39 23 04 00 	ld.bu %d3,[%a2]4 <700145b0 <tcp_ticks>>
80023cca:	39 22 05 00 	ld.bu %d2,[%a2]5 <700145b0 <tcp_ticks>>
80023cce:	8f 82 00 20 	sh %d2,%d2,8
80023cd2:	a6 32       	or %d2,%d3
80023cd4:	39 23 06 00 	ld.bu %d3,[%a2]6
80023cd8:	8f 03 01 30 	sh %d3,%d3,16
80023cdc:	a6 32       	or %d2,%d3
80023cde:	39 23 07 00 	ld.bu %d3,[%a2]7
80023ce2:	8f 83 01 30 	sh %d3,%d3,24
80023ce6:	a6 32       	or %d2,%d3
80023ce8:	02 24       	mov %d4,%d2
80023cea:	6d ff 4d 9c 	call 80017584 <lwip_htonl>
80023cee:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023cf2:	d9 22 3c 00 	lea %a2,[%a2]60
80023cf6:	74 22       	st.w [%a2],%d2
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
                                 lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
                                 seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
80023cf8:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023cfc:	d9 22 10 00 	lea %a2,[%a2]16
80023d00:	54 23       	ld.w %d3,[%a2]
80023d02:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d06:	b0 42       	add.a %a2,4
80023d08:	d4 22       	ld.a %a2,[%a2]
80023d0a:	b0 42       	add.a %a2,4
80023d0c:	54 22       	ld.w %d2,[%a2]
80023d0e:	0b 23 80 20 	sub %d2,%d3,%d2
80023d12:	f9 e2 f8 ff 	st.h [%a14]-8,%d2
  if (len == 0) {
    /** Exclude retransmitted segments from this count. */
    MIB2_STATS_INC(mib2.tcpoutsegs);
  }

  seg->p->len -= len;
80023d16:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d1a:	b0 42       	add.a %a2,4
80023d1c:	d4 22       	ld.a %a2,[%a2]
80023d1e:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80023d22:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d26:	b0 42       	add.a %a2,4
80023d28:	d4 22       	ld.a %a2,[%a2]
80023d2a:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
80023d2e:	0b 23 80 20 	sub %d2,%d3,%d2
80023d32:	37 02 70 20 	extr.u %d2,%d2,0,16
80023d36:	f9 22 0a 00 	st.h [%a2]10,%d2
  seg->p->tot_len -= len;
80023d3a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d3e:	b0 42       	add.a %a2,4
80023d40:	d4 22       	ld.a %a2,[%a2]
80023d42:	b9 23 08 00 	ld.hu %d3,[%a2]8
80023d46:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d4a:	b0 42       	add.a %a2,4
80023d4c:	d4 22       	ld.a %a2,[%a2]
80023d4e:	c9 e2 f8 ff 	ld.h %d2,[%a14]-8
80023d52:	0b 23 80 20 	sub %d2,%d3,%d2
80023d56:	37 02 70 20 	extr.u %d2,%d2,0,16
80023d5a:	f9 22 08 00 	st.h [%a2]8,%d2

  seg->p->payload = seg->tcphdr;
80023d5e:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d62:	b0 42       	add.a %a2,4
80023d64:	d4 22       	ld.a %a2,[%a2]
80023d66:	99 e3 ec ff 	ld.a %a3,[%a14]-20
80023d6a:	d9 33 10 00 	lea %a3,[%a3]16
80023d6e:	54 32       	ld.w %d2,[%a3]
80023d70:	b0 42       	add.a %a2,4
80023d72:	74 22       	st.w [%a2],%d2

  seg->tcphdr->chksum = 0;
80023d74:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d78:	d9 22 10 00 	lea %a2,[%a2]16
80023d7c:	d4 22       	ld.a %a2,[%a2]
80023d7e:	82 02       	mov %d2,0
80023d80:	e9 22 10 00 	st.b [%a2]16,%d2
80023d84:	82 02       	mov %d2,0
80023d86:	e9 22 11 00 	st.b [%a2]17,%d2

#ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);
#endif
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
80023d8a:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d8e:	d9 22 10 00 	lea %a2,[%a2]16
80023d92:	54 23       	ld.w %d3,[%a2]
80023d94:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023d98:	39 22 0c 00 	ld.bu %d2,[%a2]12
80023d9c:	8f 12 00 21 	and %d2,%d2,1
80023da0:	df 02 06 00 	jeq %d2,0,80023dac <tcp_output_segment+0x2da>
80023da4:	3b 80 01 20 	mov %d2,24
80023da8:	1d 00 04 00 	j 80023db0 <tcp_output_segment+0x2de>
80023dac:	3b 40 01 20 	mov %d2,20
80023db0:	42 32       	add %d2,%d3
80023db2:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80023db6:	5f 23 17 00 	jeq %d3,%d2,80023de4 <tcp_output_segment+0x312>
80023dba:	91 00 00 28 	movh.a %a2,32768
80023dbe:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80023dc2:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023dc6:	3b c0 61 20 	mov %d2,1564
80023dca:	59 a2 04 00 	st.w [%sp]4,%d2
80023dce:	91 00 00 28 	movh.a %a2,32768
80023dd2:	d9 22 34 03 	lea %a2,[%a2]12340 <80003034 <IfxCpu_Trap_vectorTable0_end+0x2e40>>
80023dd6:	f4 a2       	st.a [%sp],%a2
80023dd8:	91 00 00 28 	movh.a %a2,32768
80023ddc:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023de0:	6d ff ab 0a 	call 80005336 <Ifx_Lwip_printf>
         seg->tcphdr->chksum, chksum_slow));
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
#else /* TCP_CHECKSUM_ON_COPY */
    seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
80023de4:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023de8:	b0 42       	add.a %a2,4
80023dea:	54 22       	ld.w %d2,[%a2]
                                           seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
80023dec:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023df0:	b0 42       	add.a %a2,4
80023df2:	d4 22       	ld.a %a2,[%a2]
80023df4:	b9 23 08 00 	ld.hu %d3,[%a2]8
    seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
80023df8:	02 35       	mov %d5,%d3
                                           seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
80023dfa:	19 e3 e8 ff 	ld.w %d3,[%a14]-24
80023dfe:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
80023e02:	c2 44       	add %d4,4
    seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
80023e04:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80023e08:	d9 22 10 00 	lea %a2,[%a2]16
80023e0c:	d4 2c       	ld.a %a12,[%a2]
80023e0e:	60 46       	mov.a %a6,%d4
80023e10:	60 35       	mov.a %a5,%d3
80023e12:	82 64       	mov %d4,6
80023e14:	60 24       	mov.a %a4,%d2
80023e16:	6d ff 69 9d 	call 800178e8 <ip_chksum_pseudo>
80023e1a:	8f f2 0f 31 	and %d3,%d2,255
80023e1e:	82 04       	mov %d4,0
80023e20:	a6 43       	or %d3,%d4
80023e22:	e9 c3 10 00 	st.b [%a12]16,%d3
80023e26:	06 82       	sh %d2,-8
80023e28:	37 02 70 20 	extr.u %d2,%d2,0,16
80023e2c:	82 03       	mov %d3,0
80023e2e:	a6 32       	or %d2,%d3
80023e30:	e9 c2 11 00 	st.b [%a12]17,%d2
#endif /* TCP_CHECKSUM_ON_COPY */
  }
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
80023e34:	91 10 00 27 	movh.a %a2,28673
80023e38:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80023e3c:	b9 22 10 20 	ld.hu %d2,[%a2]144 <70010090 <ram_heap+0x4ffc>>
80023e40:	c2 12       	add %d2,1
80023e42:	37 02 70 20 	extr.u %d2,%d2,0,16
80023e46:	91 10 00 27 	movh.a %a2,28673
80023e4a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80023e4e:	f9 22 10 20 	st.h [%a2]144 <70010090 <ram_heap+0x4ffc>>,%d2

  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
  err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
80023e52:	99 e2 ec ff 	ld.a %a2,[%a14]-20 <70010090 <ram_heap+0x4ffc>>
80023e56:	b0 42       	add.a %a2,4
80023e58:	54 22       	ld.w %d2,[%a2]
80023e5a:	19 e3 e8 ff 	ld.w %d3,[%a14]-24
80023e5e:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
80023e62:	1b 44 00 70 	addi %d7,%d4,4
80023e66:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023e6a:	39 24 0b 00 	ld.bu %d4,[%a2]11
80023e6e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80023e72:	39 25 0a 00 	ld.bu %d5,[%a2]10
80023e76:	99 e7 e4 ff 	ld.a %a7,[%a14]-28
80023e7a:	82 66       	mov %d6,6
80023e7c:	60 76       	mov.a %a6,%d7
80023e7e:	60 35       	mov.a %a5,%d3
80023e80:	60 24       	mov.a %a4,%d2
80023e82:	6d ff eb 8b 	call 80015658 <ip4_output_if>
80023e86:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
    seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
    seg->chksum_swapped = 1;
  }
#endif

  return err;
80023e8a:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
}
80023e8e:	00 90       	ret 

80023e90 <tcp_rexmit_rto_prepare>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
err_t
tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
{
80023e90:	40 ae       	mov.aa %a14,%sp
80023e92:	20 20       	sub.a %sp,32
80023e94:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct tcp_seg *seg;

  LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
80023e98:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80023e9c:	df 02 17 80 	jne %d2,0,80023eca <tcp_rexmit_rto_prepare+0x3a>
80023ea0:	91 00 00 28 	movh.a %a2,32768
80023ea4:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80023ea8:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80023eac:	3b 30 66 20 	mov %d2,1635
80023eb0:	59 a2 04 00 	st.w [%sp]4,%d2
80023eb4:	91 00 00 28 	movh.a %a2,32768
80023eb8:	d9 22 07 13 	lea %a2,[%a2]12359 <80003047 <IfxCpu_Trap_vectorTable0_end+0x2e53>>
80023ebc:	f4 a2       	st.a [%sp],%a2
80023ebe:	91 00 00 28 	movh.a %a2,32768
80023ec2:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80023ec6:	6d ff 38 0a 	call 80005336 <Ifx_Lwip_printf>

  if (pcb->unacked == NULL) {
80023eca:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023ece:	d9 22 34 10 	lea %a2,[%a2]116
80023ed2:	54 22       	ld.w %d2,[%a2]
80023ed4:	df 02 04 80 	jne %d2,0,80023edc <tcp_rexmit_rto_prepare+0x4c>
    return ERR_VAL;
80023ed8:	82 a2       	mov %d2,-6
80023eda:	00 90       	ret 

  /* Move all unacked segments to the head of the unsent queue.
     However, give up if any of the unsent pbufs are still referenced by the
     netif driver due to deferred transmission. No point loading the link further
     if it is struggling to flush its buffered writes. */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
80023edc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023ee0:	d9 22 34 10 	lea %a2,[%a2]116
80023ee4:	54 22       	ld.w %d2,[%a2]
80023ee6:	59 e2 fc ff 	st.w [%a14]-4,%d2
80023eea:	1d 00 0f 00 	j 80023f08 <tcp_rexmit_rto_prepare+0x78>
    if (tcp_output_segment_busy(seg)) {
80023eee:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80023ef2:	6d ff c7 fd 	call 80023a80 <tcp_output_segment_busy>
80023ef6:	df 02 04 00 	jeq %d2,0,80023efe <tcp_rexmit_rto_prepare+0x6e>
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
      return ERR_VAL;
80023efa:	82 a2       	mov %d2,-6
80023efc:	00 90       	ret 
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
80023efe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023f02:	54 22       	ld.w %d2,[%a2]
80023f04:	59 e2 fc ff 	st.w [%a14]-4,%d2
80023f08:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023f0c:	54 22       	ld.w %d2,[%a2]
80023f0e:	df 02 f0 ff 	jne %d2,0,80023eee <tcp_rexmit_rto_prepare+0x5e>
    }
  }
  if (tcp_output_segment_busy(seg)) {
80023f12:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80023f16:	6d ff b5 fd 	call 80023a80 <tcp_output_segment_busy>
80023f1a:	df 02 04 00 	jeq %d2,0,80023f22 <tcp_rexmit_rto_prepare+0x92>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
    return ERR_VAL;
80023f1e:	82 a2       	mov %d2,-6
80023f20:	00 90       	ret 
  }
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
80023f22:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023f26:	d9 22 30 10 	lea %a2,[%a2]112
80023f2a:	54 22       	ld.w %d2,[%a2]
80023f2c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023f30:	74 22       	st.w [%a2],%d2
#if TCP_OVERSIZE_DBGCHECK
  /* if last unsent changed, we need to update unsent_oversize */
  if (pcb->unsent == NULL) {
80023f32:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023f36:	d9 22 30 10 	lea %a2,[%a2]112
80023f3a:	54 22       	ld.w %d2,[%a2]
80023f3c:	df 02 0a 80 	jne %d2,0,80023f50 <tcp_rexmit_rto_prepare+0xc0>
    pcb->unsent_oversize = seg->oversize_left;
80023f40:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023f44:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80023f48:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023f4c:	f9 22 2c 10 	st.h [%a2]108,%d2
  }
#endif /* TCP_OVERSIZE_DBGCHECK */
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
80023f50:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023f54:	d9 22 34 10 	lea %a2,[%a2]116
80023f58:	54 22       	ld.w %d2,[%a2]
80023f5a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023f5e:	d9 22 30 10 	lea %a2,[%a2]112
80023f62:	74 22       	st.w [%a2],%d2
  /* unacked queue is now empty */
  pcb->unacked = NULL;
80023f64:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023f68:	82 02       	mov %d2,0
80023f6a:	d9 22 34 10 	lea %a2,[%a2]116
80023f6e:	74 22       	st.w [%a2],%d2

  /* Mark RTO in-progress */
  tcp_set_flags(pcb, TF_RTO);
80023f70:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023f74:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80023f78:	3b 00 80 30 	mov %d3,2048
80023f7c:	a6 32       	or %d2,%d3
80023f7e:	37 02 70 20 	extr.u %d2,%d2,0,16
80023f82:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80023f86:	f9 22 1e 00 	st.h [%a2]30,%d2
  /* Record the next byte following retransmit */
  pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
80023f8a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023f8e:	d9 22 10 00 	lea %a2,[%a2]16
80023f92:	d4 22       	ld.a %a2,[%a2]
80023f94:	39 23 04 00 	ld.bu %d3,[%a2]4
80023f98:	39 22 05 00 	ld.bu %d2,[%a2]5
80023f9c:	8f 82 00 20 	sh %d2,%d2,8
80023fa0:	a6 32       	or %d2,%d3
80023fa2:	39 23 06 00 	ld.bu %d3,[%a2]6
80023fa6:	8f 03 01 30 	sh %d3,%d3,16
80023faa:	a6 32       	or %d2,%d3
80023fac:	39 23 07 00 	ld.bu %d3,[%a2]7
80023fb0:	8f 83 01 30 	sh %d3,%d3,24
80023fb4:	a6 32       	or %d2,%d3
80023fb6:	02 24       	mov %d4,%d2
80023fb8:	6d ff e6 9a 	call 80017584 <lwip_htonl>
80023fbc:	02 28       	mov %d8,%d2
80023fbe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023fc2:	b9 22 08 00 	ld.hu %d2,[%a2]8
80023fc6:	02 29       	mov %d9,%d2
80023fc8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80023fcc:	d9 22 10 00 	lea %a2,[%a2]16
80023fd0:	d4 22       	ld.a %a2,[%a2]
80023fd2:	39 23 0c 00 	ld.bu %d3,[%a2]12
80023fd6:	39 22 0d 00 	ld.bu %d2,[%a2]13
80023fda:	8f 82 00 20 	sh %d2,%d2,8
80023fde:	a6 32       	or %d2,%d3
80023fe0:	37 02 70 20 	extr.u %d2,%d2,0,16
80023fe4:	02 24       	mov %d4,%d2
80023fe6:	6d ff b7 9a 	call 80017554 <lwip_htons>
80023fea:	8f f2 0f 21 	and %d2,%d2,255
80023fee:	8f 32 00 21 	and %d2,%d2,3
80023ff2:	df 02 05 00 	jeq %d2,0,80023ffc <tcp_rexmit_rto_prepare+0x16c>
80023ff6:	82 12       	mov %d2,1
80023ff8:	1d 00 03 00 	j 80023ffe <tcp_rexmit_rto_prepare+0x16e>
80023ffc:	82 02       	mov %d2,0
80023ffe:	42 92       	add %d2,%d9
80024000:	42 82       	add %d2,%d8
80024002:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024006:	d9 22 10 10 	lea %a2,[%a2]80
8002400a:	74 22       	st.w [%a2],%d2
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
8002400c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024010:	82 02       	mov %d2,0
80024012:	d9 22 38 00 	lea %a2,[%a2]56
80024016:	74 22       	st.w [%a2],%d2

  return ERR_OK;
80024018:	82 02       	mov %d2,0
}
8002401a:	00 90       	ret 

8002401c <tcp_rexmit_rto_commit>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
{
8002401c:	40 ae       	mov.aa %a14,%sp
8002401e:	20 18       	sub.a %sp,24
80024020:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
80024024:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80024028:	df 02 17 80 	jne %d2,0,80024056 <tcp_rexmit_rto_commit+0x3a>
8002402c:	91 00 00 28 	movh.a %a2,32768
80024030:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80024034:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80024038:	3b 80 69 20 	mov %d2,1688
8002403c:	59 a2 04 00 	st.w [%sp]4,%d2
80024040:	91 00 00 28 	movh.a %a2,32768
80024044:	d9 22 2b 13 	lea %a2,[%a2]12395 <8000306b <IfxCpu_Trap_vectorTable0_end+0x2e77>>
80024048:	f4 a2       	st.a [%sp],%a2
8002404a:	91 00 00 28 	movh.a %a2,32768
8002404e:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80024052:	6d ff 72 09 	call 80005336 <Ifx_Lwip_printf>

  /* increment number of retransmissions */
  if (pcb->nrtx < 0xFF) {
80024056:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002405a:	39 22 06 10 	ld.bu %d2,[%a2]70
8002405e:	8b f2 0f 22 	eq %d2,%d2,255
80024062:	df 02 0d 80 	jne %d2,0,8002407c <tcp_rexmit_rto_commit+0x60>
    ++pcb->nrtx;
80024066:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002406a:	39 22 06 10 	ld.bu %d2,[%a2]70
8002406e:	c2 12       	add %d2,1
80024070:	8f f2 0f 21 	and %d2,%d2,255
80024074:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024078:	e9 22 06 10 	st.b [%a2]70,%d2
  }
  /* Do the actual retransmission */
  tcp_output(pcb);
8002407c:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80024080:	6d ff 8a f9 	call 80023394 <tcp_output>
}
80024084:	00 00       	nop 
80024086:	00 90       	ret 

80024088 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
80024088:	40 ae       	mov.aa %a14,%sp
8002408a:	20 18       	sub.a %sp,24
8002408c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
80024090:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80024094:	df 02 17 80 	jne %d2,0,800240c2 <tcp_rexmit_rto+0x3a>
80024098:	91 00 00 28 	movh.a %a2,32768
8002409c:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800240a0:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800240a4:	3b d0 6a 20 	mov %d2,1709
800240a8:	59 a2 04 00 	st.w [%sp]4,%d2
800240ac:	91 00 00 28 	movh.a %a2,32768
800240b0:	d9 22 0e 23 	lea %a2,[%a2]12430 <8000308e <IfxCpu_Trap_vectorTable0_end+0x2e9a>>
800240b4:	f4 a2       	st.a [%sp],%a2
800240b6:	91 00 00 28 	movh.a %a2,32768
800240ba:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800240be:	6d ff 3c 09 	call 80005336 <Ifx_Lwip_printf>

  if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
800240c2:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800240c6:	6d ff e5 fe 	call 80023e90 <tcp_rexmit_rto_prepare>
800240ca:	df 02 06 80 	jne %d2,0,800240d6 <tcp_rexmit_rto+0x4e>
    tcp_rexmit_rto_commit(pcb);
800240ce:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800240d2:	6d ff a5 ff 	call 8002401c <tcp_rexmit_rto_commit>
  }
}
800240d6:	00 00       	nop 
800240d8:	00 90       	ret 

800240da <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
err_t
tcp_rexmit(struct tcp_pcb *pcb)
{
800240da:	40 ae       	mov.aa %a14,%sp
800240dc:	20 20       	sub.a %sp,32
800240de:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
800240e2:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800240e6:	df 02 17 80 	jne %d2,0,80024114 <tcp_rexmit+0x3a>
800240ea:	91 00 00 28 	movh.a %a2,32768
800240ee:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800240f2:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800240f6:	3b 10 6c 20 	mov %d2,1729
800240fa:	59 a2 04 00 	st.w [%sp]4,%d2
800240fe:	91 00 00 28 	movh.a %a2,32768
80024102:	d9 22 2a 23 	lea %a2,[%a2]12458 <800030aa <IfxCpu_Trap_vectorTable0_end+0x2eb6>>
80024106:	f4 a2       	st.a [%sp],%a2
80024108:	91 00 00 28 	movh.a %a2,32768
8002410c:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80024110:	6d ff 13 09 	call 80005336 <Ifx_Lwip_printf>

  if (pcb->unacked == NULL) {
80024114:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024118:	d9 22 34 10 	lea %a2,[%a2]116
8002411c:	54 22       	ld.w %d2,[%a2]
8002411e:	df 02 04 80 	jne %d2,0,80024126 <tcp_rexmit+0x4c>
    return ERR_VAL;
80024122:	82 a2       	mov %d2,-6
80024124:	00 90       	ret 
  }

  seg = pcb->unacked;
80024126:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002412a:	d9 22 34 10 	lea %a2,[%a2]116
8002412e:	54 22       	ld.w %d2,[%a2]
80024130:	59 e2 f8 ff 	st.w [%a14]-8,%d2

  /* Give up if the segment is still referenced by the netif driver
     due to deferred transmission. */
  if (tcp_output_segment_busy(seg)) {
80024134:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80024138:	6d ff a4 fc 	call 80023a80 <tcp_output_segment_busy>
8002413c:	df 02 04 00 	jeq %d2,0,80024144 <tcp_rexmit+0x6a>
    LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
    return ERR_VAL;
80024140:	82 a2       	mov %d2,-6
80024142:	00 90       	ret 
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  pcb->unacked = seg->next;
80024144:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024148:	54 22       	ld.w %d2,[%a2]
8002414a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002414e:	d9 22 34 10 	lea %a2,[%a2]116
80024152:	74 22       	st.w [%a2],%d2

  cur_seg = &(pcb->unsent);
80024154:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80024158:	1b 02 07 20 	addi %d2,%d2,112
8002415c:	59 e2 fc ff 	st.w [%a14]-4,%d2
  while (*cur_seg &&
80024160:	1d 00 07 00 	j 8002416e <tcp_rexmit+0x94>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
    cur_seg = &((*cur_seg)->next );
80024164:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024168:	54 22       	ld.w %d2,[%a2]
8002416a:	59 e2 fc ff 	st.w [%a14]-4,%d2
  while (*cur_seg &&
8002416e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024172:	54 22       	ld.w %d2,[%a2]
80024174:	df 02 3a 00 	jeq %d2,0,800241e8 <tcp_rexmit+0x10e>
         TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
80024178:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002417c:	d4 22       	ld.a %a2,[%a2]
8002417e:	d9 22 10 00 	lea %a2,[%a2]16
80024182:	d4 22       	ld.a %a2,[%a2]
80024184:	39 23 04 00 	ld.bu %d3,[%a2]4
80024188:	39 22 05 00 	ld.bu %d2,[%a2]5
8002418c:	8f 82 00 20 	sh %d2,%d2,8
80024190:	a6 32       	or %d2,%d3
80024192:	39 23 06 00 	ld.bu %d3,[%a2]6
80024196:	8f 03 01 30 	sh %d3,%d3,16
8002419a:	a6 32       	or %d2,%d3
8002419c:	39 23 07 00 	ld.bu %d3,[%a2]7
800241a0:	8f 83 01 30 	sh %d3,%d3,24
800241a4:	a6 32       	or %d2,%d3
800241a6:	02 24       	mov %d4,%d2
800241a8:	6d ff ee 99 	call 80017584 <lwip_htonl>
800241ac:	02 28       	mov %d8,%d2
800241ae:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800241b2:	d9 22 10 00 	lea %a2,[%a2]16
800241b6:	d4 22       	ld.a %a2,[%a2]
800241b8:	39 23 04 00 	ld.bu %d3,[%a2]4
800241bc:	39 22 05 00 	ld.bu %d2,[%a2]5
800241c0:	8f 82 00 20 	sh %d2,%d2,8
800241c4:	a6 32       	or %d2,%d3
800241c6:	39 23 06 00 	ld.bu %d3,[%a2]6
800241ca:	8f 03 01 30 	sh %d3,%d3,16
800241ce:	a6 32       	or %d2,%d3
800241d0:	39 23 07 00 	ld.bu %d3,[%a2]7
800241d4:	8f 83 01 30 	sh %d3,%d3,24
800241d8:	a6 32       	or %d2,%d3
800241da:	02 24       	mov %d4,%d2
800241dc:	6d ff d4 99 	call 80017584 <lwip_htonl>
800241e0:	0b 28 80 20 	sub %d2,%d8,%d2
  while (*cur_seg &&
800241e4:	bf 02 c0 7f 	jlt %d2,0,80024164 <tcp_rexmit+0x8a>
  }
  seg->next = *cur_seg;
800241e8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800241ec:	54 22       	ld.w %d2,[%a2]
800241ee:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800241f2:	74 22       	st.w [%a2],%d2
  *cur_seg = seg;
800241f4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800241f8:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800241fc:	74 22       	st.w [%a2],%d2
#if TCP_OVERSIZE
  if (seg->next == NULL) {
800241fe:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024202:	54 22       	ld.w %d2,[%a2]
80024204:	df 02 07 80 	jne %d2,0,80024212 <tcp_rexmit+0x138>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
80024208:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002420c:	82 02       	mov %d2,0
8002420e:	f9 22 2c 10 	st.h [%a2]108,%d2
  }
#endif /* TCP_OVERSIZE */

  if (pcb->nrtx < 0xFF) {
80024212:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024216:	39 22 06 10 	ld.bu %d2,[%a2]70
8002421a:	8b f2 0f 22 	eq %d2,%d2,255
8002421e:	df 02 0d 80 	jne %d2,0,80024238 <tcp_rexmit+0x15e>
    ++pcb->nrtx;
80024222:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024226:	39 22 06 10 	ld.bu %d2,[%a2]70
8002422a:	c2 12       	add %d2,1
8002422c:	8f f2 0f 21 	and %d2,%d2,255
80024230:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024234:	e9 22 06 10 	st.b [%a2]70,%d2
  }

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
80024238:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002423c:	82 02       	mov %d2,0
8002423e:	d9 22 38 00 	lea %a2,[%a2]56
80024242:	74 22       	st.w [%a2],%d2

  /* Do the actual retransmission. */
  MIB2_STATS_INC(mib2.tcpretranssegs);
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
  return ERR_OK;
80024244:	82 02       	mov %d2,0
}
80024246:	00 90       	ret 

80024248 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
80024248:	40 ae       	mov.aa %a14,%sp
8002424a:	20 18       	sub.a %sp,24
8002424c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
80024250:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80024254:	df 02 17 80 	jne %d2,0,80024282 <tcp_rexmit_fast+0x3a>
80024258:	91 00 00 28 	movh.a %a2,32768
8002425c:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80024260:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80024264:	3b 90 6f 20 	mov %d2,1785
80024268:	59 a2 04 00 	st.w [%sp]4,%d2
8002426c:	91 00 00 28 	movh.a %a2,32768
80024270:	d9 22 02 33 	lea %a2,[%a2]12482 <800030c2 <IfxCpu_Trap_vectorTable0_end+0x2ece>>
80024274:	f4 a2       	st.a [%sp],%a2
80024276:	91 00 00 28 	movh.a %a2,32768
8002427a:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002427e:	6d ff 5c 08 	call 80005336 <Ifx_Lwip_printf>

  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
80024282:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024286:	d9 22 34 10 	lea %a2,[%a2]116
8002428a:	54 22       	ld.w %d2,[%a2]
8002428c:	df 02 61 00 	jeq %d2,0,8002434e <tcp_rexmit_fast+0x106>
80024290:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024294:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80024298:	8f 42 00 21 	and %d2,%d2,4
8002429c:	df 02 59 80 	jne %d2,0,8002434e <tcp_rexmit_fast+0x106>
    LWIP_DEBUGF(TCP_FR_DEBUG,
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 lwip_ntohl(pcb->unacked->tcphdr->seqno)));
    if (tcp_rexmit(pcb) == ERR_OK) {
800242a0:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800242a4:	6d ff 1b ff 	call 800240da <tcp_rexmit>
800242a8:	df 02 53 80 	jne %d2,0,8002434e <tcp_rexmit_fast+0x106>
      /* Set ssthresh to half of the minimum of the current
       * cwnd and the advertised window */
      pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
800242ac:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800242b0:	b9 23 24 10 	ld.hu %d3,[%a2]100
800242b4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800242b8:	b9 22 0c 10 	ld.hu %d2,[%a2]76
800242bc:	0b 23 90 21 	min.u %d2,%d3,%d2
800242c0:	37 02 70 20 	extr.u %d2,%d2,0,16
800242c4:	8f 12 1e 30 	sh %d3,%d2,-31
800242c8:	42 32       	add %d2,%d3
800242ca:	86 f2       	sha %d2,-1
800242cc:	37 02 70 20 	extr.u %d2,%d2,0,16
800242d0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800242d4:	f9 22 0e 10 	st.h [%a2]78,%d2

      /* The minimum value for ssthresh should be 2 MSS */
      if (pcb->ssthresh < (2U * pcb->mss)) {
800242d8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800242dc:	b9 22 0e 10 	ld.hu %d2,[%a2]78
800242e0:	02 23       	mov %d3,%d2
800242e2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800242e6:	b9 22 36 00 	ld.hu %d2,[%a2]54
800242ea:	06 12       	sh %d2,1
800242ec:	7f 23 0d 80 	jge.u %d3,%d2,80024306 <tcp_rexmit_fast+0xbe>
        LWIP_DEBUGF(TCP_FR_DEBUG,
                    ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
                     " should be min 2 mss %"U16_F"...\n",
                     pcb->ssthresh, (u16_t)(2 * pcb->mss)));
        pcb->ssthresh = 2 * pcb->mss;
800242f0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800242f4:	b9 22 36 00 	ld.hu %d2,[%a2]54
800242f8:	06 12       	sh %d2,1
800242fa:	37 02 70 20 	extr.u %d2,%d2,0,16
800242fe:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024302:	f9 22 0e 10 	st.h [%a2]78,%d2
      }

      pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
80024306:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002430a:	b9 23 0e 10 	ld.hu %d3,[%a2]78
8002430e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024312:	b9 22 36 00 	ld.hu %d2,[%a2]54
80024316:	53 32 20 20 	mul %d2,%d2,3
8002431a:	37 02 70 20 	extr.u %d2,%d2,0,16
8002431e:	42 32       	add %d2,%d3
80024320:	37 02 70 20 	extr.u %d2,%d2,0,16
80024324:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024328:	f9 22 0c 10 	st.h [%a2]76,%d2
      tcp_set_flags(pcb, TF_INFR);
8002432c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024330:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80024334:	8f 42 40 21 	or %d2,%d2,4
80024338:	37 02 70 20 	extr.u %d2,%d2,0,16
8002433c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024340:	f9 22 1e 00 	st.h [%a2]30,%d2

      /* Reset the retransmission timer to prevent immediate rto retransmissions */
      pcb->rtime = 0;
80024344:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024348:	82 02       	mov %d2,0
8002434a:	f9 22 34 00 	st.h [%a2]52,%d2
    }
  }
}
8002434e:	00 00       	nop 
80024350:	00 90       	ret 

80024352 <tcp_output_alloc_header_common>:

static struct pbuf *
tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */,
                        u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
{
80024352:	40 ae       	mov.aa %a14,%sp
80024354:	20 38       	sub.a %sp,56
80024356:	59 e4 f4 ff 	st.w [%a14]-12,%d4
8002435a:	02 52       	mov %d2,%d5
8002435c:	02 63       	mov %d3,%d6
8002435e:	59 e7 e8 ff 	st.w [%a14]-24,%d7
80024362:	54 e7       	ld.w %d7,[%a14]
80024364:	19 e6 04 00 	ld.w %d6,[%a14]4
80024368:	19 e5 08 00 	ld.w %d5,[%a14]8
8002436c:	19 e4 0c 00 	ld.w %d4,[%a14]12
80024370:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
80024374:	02 32       	mov %d2,%d3
80024376:	f9 e2 ec ff 	st.h [%a14]-20,%d2
8002437a:	02 72       	mov %d2,%d7
8002437c:	f9 e2 e4 ff 	st.h [%a14]-28,%d2
80024380:	02 62       	mov %d2,%d6
80024382:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
80024386:	02 52       	mov %d2,%d5
80024388:	e9 e2 dc ff 	st.b [%a14]-36,%d2
8002438c:	02 42       	mov %d2,%d4
8002438e:	f9 e2 d8 ff 	st.h [%a14]-40,%d2
  struct tcp_hdr *tcphdr;
  struct pbuf *p;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
80024392:	c9 e3 f0 ff 	ld.h %d3,[%a14]-16
80024396:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
8002439a:	42 32       	add %d2,%d3
8002439c:	37 02 70 20 	extr.u %d2,%d2,0,16
800243a0:	1b 42 01 20 	addi %d2,%d2,20
800243a4:	37 02 70 20 	extr.u %d2,%d2,0,16
800243a8:	3b 00 28 60 	mov %d6,640
800243ac:	02 25       	mov %d5,%d2
800243ae:	3b 40 02 40 	mov %d4,36
800243b2:	6d ff 97 a9 	call 800196e0 <pbuf_alloc>
800243b6:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (p != NULL) {
800243ba:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800243be:	df 02 de 00 	jeq %d2,0,8002457a <tcp_output_alloc_header_common+0x228>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
800243c2:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
800243c6:	1b 32 01 20 	addi %d2,%d2,19
800243ca:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800243ce:	b9 23 0a 00 	ld.hu %d3,[%a2]10
800243d2:	3f 32 17 00 	jlt %d2,%d3,80024400 <tcp_output_alloc_header_common+0xae>
800243d6:	91 00 00 28 	movh.a %a2,32768
800243da:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800243de:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800243e2:	3b 30 72 20 	mov %d2,1827
800243e6:	59 a2 04 00 	st.w [%sp]4,%d2
800243ea:	91 00 00 28 	movh.a %a2,32768
800243ee:	d9 22 1f 33 	lea %a2,[%a2]12511 <800030df <IfxCpu_Trap_vectorTable0_end+0x2eeb>>
800243f2:	f4 a2       	st.a [%sp],%a2
800243f4:	91 00 00 28 	movh.a %a2,32768
800243f8:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800243fc:	6d ff 9d 07 	call 80005336 <Ifx_Lwip_printf>
                (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
80024400:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024404:	b0 42       	add.a %a2,4
80024406:	54 22       	ld.w %d2,[%a2]
80024408:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    tcphdr->src = lwip_htons(src_port);
8002440c:	b9 e2 e4 ff 	ld.hu %d2,[%a14]-28
80024410:	02 24       	mov %d4,%d2
80024412:	6d ff a1 98 	call 80017554 <lwip_htons>
80024416:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002441a:	8f f2 0f 31 	and %d3,%d2,255
8002441e:	82 04       	mov %d4,0
80024420:	a6 43       	or %d3,%d4
80024422:	34 23       	st.b [%a2],%d3
80024424:	06 82       	sh %d2,-8
80024426:	37 02 70 20 	extr.u %d2,%d2,0,16
8002442a:	82 03       	mov %d3,0
8002442c:	a6 32       	or %d2,%d3
8002442e:	e9 22 01 00 	st.b [%a2]1,%d2
    tcphdr->dest = lwip_htons(dst_port);
80024432:	b9 e2 e0 ff 	ld.hu %d2,[%a14]-32
80024436:	02 24       	mov %d4,%d2
80024438:	6d ff 8e 98 	call 80017554 <lwip_htons>
8002443c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024440:	8f f2 0f 31 	and %d3,%d2,255
80024444:	82 04       	mov %d4,0
80024446:	a6 43       	or %d3,%d4
80024448:	e9 23 02 00 	st.b [%a2]2,%d3
8002444c:	06 82       	sh %d2,-8
8002444e:	37 02 70 20 	extr.u %d2,%d2,0,16
80024452:	82 03       	mov %d3,0
80024454:	a6 32       	or %d2,%d3
80024456:	e9 22 03 00 	st.b [%a2]3,%d2
    tcphdr->seqno = seqno_be;
8002445a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002445e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80024462:	8f f2 0f 21 	and %d2,%d2,255
80024466:	82 03       	mov %d3,0
80024468:	a6 32       	or %d2,%d3
8002446a:	e9 22 04 00 	st.b [%a2]4,%d2
8002446e:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80024472:	06 82       	sh %d2,-8
80024474:	8f f2 0f 21 	and %d2,%d2,255
80024478:	82 03       	mov %d3,0
8002447a:	a6 32       	or %d2,%d3
8002447c:	e9 22 05 00 	st.b [%a2]5,%d2
80024480:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80024484:	8f 02 1f 20 	sh %d2,%d2,-16
80024488:	8f f2 0f 21 	and %d2,%d2,255
8002448c:	82 03       	mov %d3,0
8002448e:	a6 32       	or %d2,%d3
80024490:	e9 22 06 00 	st.b [%a2]6,%d2
80024494:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80024498:	8f 82 1e 20 	sh %d2,%d2,-24
8002449c:	82 03       	mov %d3,0
8002449e:	a6 32       	or %d2,%d3
800244a0:	e9 22 07 00 	st.b [%a2]7,%d2
    tcphdr->ackno = lwip_htonl(ackno);
800244a4:	19 e4 f4 ff 	ld.w %d4,[%a14]-12
800244a8:	6d ff 6e 98 	call 80017584 <lwip_htonl>
800244ac:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800244b0:	8f f2 0f 31 	and %d3,%d2,255
800244b4:	82 04       	mov %d4,0
800244b6:	a6 43       	or %d3,%d4
800244b8:	e9 23 08 00 	st.b [%a2]8,%d3
800244bc:	8f 82 1f 30 	sh %d3,%d2,-8
800244c0:	8f f3 0f 31 	and %d3,%d3,255
800244c4:	82 04       	mov %d4,0
800244c6:	a6 43       	or %d3,%d4
800244c8:	e9 23 09 00 	st.b [%a2]9,%d3
800244cc:	8f 02 1f 30 	sh %d3,%d2,-16
800244d0:	8f f3 0f 31 	and %d3,%d3,255
800244d4:	82 04       	mov %d4,0
800244d6:	a6 43       	or %d3,%d4
800244d8:	e9 23 0a 00 	st.b [%a2]10,%d3
800244dc:	8f 82 1e 20 	sh %d2,%d2,-24
800244e0:	82 03       	mov %d3,0
800244e2:	a6 32       	or %d2,%d3
800244e4:	e9 22 0b 00 	st.b [%a2]11,%d2
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
800244e8:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
800244ec:	06 e2       	sh %d2,-2
800244ee:	37 02 70 20 	extr.u %d2,%d2,0,16
800244f2:	c2 52       	add %d2,5
800244f4:	37 02 70 20 	extr.u %d2,%d2,0,16
800244f8:	8f c2 00 20 	sh %d2,%d2,12
800244fc:	37 02 70 30 	extr.u %d3,%d2,0,16
80024500:	39 e2 dc ff 	ld.bu %d2,[%a14]-36
80024504:	37 02 70 20 	extr.u %d2,%d2,0,16
80024508:	a6 32       	or %d2,%d3
8002450a:	37 02 70 20 	extr.u %d2,%d2,0,16
8002450e:	02 24       	mov %d4,%d2
80024510:	6d ff 22 98 	call 80017554 <lwip_htons>
80024514:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024518:	8f f2 0f 31 	and %d3,%d2,255
8002451c:	82 04       	mov %d4,0
8002451e:	a6 43       	or %d3,%d4
80024520:	e9 23 0c 00 	st.b [%a2]12,%d3
80024524:	06 82       	sh %d2,-8
80024526:	37 02 70 20 	extr.u %d2,%d2,0,16
8002452a:	82 03       	mov %d3,0
8002452c:	a6 32       	or %d2,%d3
8002452e:	e9 22 0d 00 	st.b [%a2]13,%d2
    tcphdr->wnd = lwip_htons(wnd);
80024532:	b9 e2 d8 ff 	ld.hu %d2,[%a14]-40
80024536:	02 24       	mov %d4,%d2
80024538:	6d ff 0e 98 	call 80017554 <lwip_htons>
8002453c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024540:	8f f2 0f 31 	and %d3,%d2,255
80024544:	82 04       	mov %d4,0
80024546:	a6 43       	or %d3,%d4
80024548:	e9 23 0e 00 	st.b [%a2]14,%d3
8002454c:	06 82       	sh %d2,-8
8002454e:	37 02 70 20 	extr.u %d2,%d2,0,16
80024552:	82 03       	mov %d3,0
80024554:	a6 32       	or %d2,%d3
80024556:	e9 22 0f 00 	st.b [%a2]15,%d2
    tcphdr->chksum = 0;
8002455a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002455e:	82 02       	mov %d2,0
80024560:	e9 22 10 00 	st.b [%a2]16,%d2
80024564:	82 02       	mov %d2,0
80024566:	e9 22 11 00 	st.b [%a2]17,%d2
    tcphdr->urgp = 0;
8002456a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002456e:	82 02       	mov %d2,0
80024570:	e9 22 12 00 	st.b [%a2]18,%d2
80024574:	82 02       	mov %d2,0
80024576:	e9 22 13 00 	st.b [%a2]19,%d2
  }
  return p;
8002457a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
8002457e:	60 22       	mov.a %a2,%d2
80024580:	00 90       	ret 

80024582 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                        u32_t seqno_be /* already in network byte order */)
{
80024582:	40 ae       	mov.aa %a14,%sp
80024584:	20 28       	sub.a %sp,40
80024586:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
8002458a:	02 42       	mov %d2,%d4
8002458c:	02 53       	mov %d3,%d5
8002458e:	59 e6 e8 ff 	st.w [%a14]-24,%d6
80024592:	f9 e2 f0 ff 	st.h [%a14]-16,%d2
80024596:	02 32       	mov %d2,%d3
80024598:	f9 e2 ec ff 	st.h [%a14]-20,%d2
  struct pbuf *p;

  LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
8002459c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800245a0:	df 02 17 80 	jne %d2,0,800245ce <tcp_output_alloc_header+0x4c>
800245a4:	91 00 00 28 	movh.a %a2,32768
800245a8:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800245ac:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800245b0:	3b 20 74 20 	mov %d2,1858
800245b4:	59 a2 04 00 	st.w [%sp]4,%d2
800245b8:	91 00 00 28 	movh.a %a2,32768
800245bc:	d9 22 0d 43 	lea %a2,[%a2]12557 <8000310d <IfxCpu_Trap_vectorTable0_end+0x2f19>>
800245c0:	f4 a2       	st.a [%sp],%a2
800245c2:	91 00 00 28 	movh.a %a2,32768
800245c6:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800245ca:	6d ff b6 06 	call 80005336 <Ifx_Lwip_printf>

  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
800245ce:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800245d2:	d9 22 28 00 	lea %a2,[%a2]40
800245d6:	54 24       	ld.w %d4,[%a2]
800245d8:	b9 e2 f0 ff 	ld.hu %d2,[%a14]-16
800245dc:	b9 e3 ec ff 	ld.hu %d3,[%a14]-20
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
800245e0:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800245e4:	b9 25 1a 00 	ld.hu %d5,[%a2]26
  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
800245e8:	02 56       	mov %d6,%d5
    seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
800245ea:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800245ee:	b9 25 1c 00 	ld.hu %d5,[%a2]28
  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
800245f2:	02 57       	mov %d7,%d5
    TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
800245f4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800245f8:	b9 25 2e 00 	ld.hu %d5,[%a2]46
  p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
800245fc:	59 a5 0c 00 	st.w [%sp]12,%d5
80024600:	3b 00 01 50 	mov %d5,16
80024604:	59 a5 08 00 	st.w [%sp]8,%d5
80024608:	59 a7 04 00 	st.w [%sp]4,%d7
8002460c:	74 a6       	st.w [%sp],%d6
8002460e:	19 e7 e8 ff 	ld.w %d7,[%a14]-24
80024612:	02 36       	mov %d6,%d3
80024614:	02 25       	mov %d5,%d2
80024616:	6d ff 9e fe 	call 80024352 <tcp_output_alloc_header_common>
8002461a:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (p != NULL) {
8002461e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80024622:	df 02 11 00 	jeq %d2,0,80024644 <tcp_output_alloc_header+0xc2>
    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
80024626:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002462a:	d9 22 28 00 	lea %a2,[%a2]40
8002462e:	54 23       	ld.w %d3,[%a2]
80024630:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024634:	b9 22 2e 00 	ld.hu %d2,[%a2]46
80024638:	42 32       	add %d2,%d3
8002463a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002463e:	d9 22 30 00 	lea %a2,[%a2]48
80024642:	74 22       	st.w [%a2],%d2
  }
  return p;
80024644:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
80024648:	60 22       	mov.a %a2,%d2
8002464a:	00 90       	ret 

8002464c <tcp_output_fill_options>:

/* Fill in options for control segments */
static void
tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
{
8002464c:	40 ae       	mov.aa %a14,%sp
8002464e:	20 30       	sub.a %sp,48
80024650:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80024654:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80024658:	02 42       	mov %d2,%d4
8002465a:	02 53       	mov %d3,%d5
8002465c:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
80024660:	02 32       	mov %d2,%d3
80024662:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
  struct tcp_hdr *tcphdr;
  u32_t *opts;
  u16_t sacks_len = 0;
80024666:	82 02       	mov %d2,0
80024668:	f9 e2 fe ff 	st.h [%a14]-2,%d2

  LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
8002466c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80024670:	df 02 17 80 	jne %d2,0,8002469e <tcp_output_fill_options+0x52>
80024674:	91 00 00 28 	movh.a %a2,32768
80024678:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
8002467c:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80024680:	3b 60 75 20 	mov %d2,1878
80024684:	59 a2 04 00 	st.w [%sp]4,%d2
80024688:	91 00 00 28 	movh.a %a2,32768
8002468c:	d9 22 32 43 	lea %a2,[%a2]12594 <80003132 <IfxCpu_Trap_vectorTable0_end+0x2f3e>>
80024690:	f4 a2       	st.a [%sp],%a2
80024692:	91 00 00 28 	movh.a %a2,32768
80024696:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002469a:	6d ff 4e 06 	call 80005336 <Ifx_Lwip_printf>

  tcphdr = (struct tcp_hdr *)p->payload;
8002469e:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800246a2:	b0 42       	add.a %a2,4
800246a4:	54 22       	ld.w %d2,[%a2]
800246a6:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  opts = (u32_t *)(void *)(tcphdr + 1);
800246aa:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800246ae:	1b 42 01 20 	addi %d2,%d2,20
800246b2:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
#endif

  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(sacks_len);
  LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
800246b6:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800246ba:	06 22       	sh %d2,2
800246bc:	02 23       	mov %d3,%d2
800246be:	39 e2 e4 ff 	ld.bu %d2,[%a14]-28
800246c2:	06 22       	sh %d2,2
800246c4:	8f 42 00 21 	and %d2,%d2,4
800246c8:	42 32       	add %d2,%d3
800246ca:	1b 42 01 20 	addi %d2,%d2,20
800246ce:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
800246d2:	42 32       	add %d2,%d3
800246d4:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
800246d8:	5f 23 17 00 	jeq %d3,%d2,80024706 <tcp_output_fill_options+0xba>
800246dc:	91 00 00 28 	movh.a %a2,32768
800246e0:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800246e4:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800246e8:	3b 50 77 20 	mov %d2,1909
800246ec:	59 a2 04 00 	st.w [%sp]4,%d2
800246f0:	91 00 00 28 	movh.a %a2,32768
800246f4:	d9 22 34 03 	lea %a2,[%a2]12340 <80003034 <IfxCpu_Trap_vectorTable0_end+0x2e40>>
800246f8:	f4 a2       	st.a [%sp],%a2
800246fa:	91 00 00 28 	movh.a %a2,32768
800246fe:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80024702:	6d ff 1a 06 	call 80005336 <Ifx_Lwip_printf>
  LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
  LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
}
80024706:	00 90       	ret 

80024708 <tcp_output_control_segment>:
 * header checksum and calling ip_output_if while handling netif hints and stats.
 */
static err_t
tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
                           const ip_addr_t *src, const ip_addr_t *dst)
{
80024708:	40 ae       	mov.aa %a14,%sp
8002470a:	20 30       	sub.a %sp,48
8002470c:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80024710:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80024714:	b5 e6 e4 ff 	st.a [%a14]-28,%a6
80024718:	b5 e7 e0 ff 	st.a [%a14]-32,%a7
  err_t err;
  struct netif *netif;

  LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
8002471c:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80024720:	df 02 17 80 	jne %d2,0,8002474e <tcp_output_control_segment+0x46>
80024724:	91 00 00 28 	movh.a %a2,32768
80024728:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
8002472c:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80024730:	3b 70 78 20 	mov %d2,1927
80024734:	59 a2 04 00 	st.w [%sp]4,%d2
80024738:	91 00 00 28 	movh.a %a2,32768
8002473c:	d9 22 18 53 	lea %a2,[%a2]12632 <80003158 <IfxCpu_Trap_vectorTable0_end+0x2f64>>
80024740:	f4 a2       	st.a [%sp],%a2
80024742:	91 00 00 28 	movh.a %a2,32768
80024746:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
8002474a:	6d ff f6 05 	call 80005336 <Ifx_Lwip_printf>

  netif = tcp_route(pcb, src, dst);
8002474e:	99 e6 e0 ff 	ld.a %a6,[%a14]-32
80024752:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
80024756:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8002475a:	6d ff f7 e8 	call 80021948 <tcp_route>
8002475e:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  if (netif == NULL) {
80024762:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80024766:	df 02 07 80 	jne %d2,0,80024774 <tcp_output_control_segment+0x6c>
    err = ERR_RTE;
8002476a:	82 c2       	mov %d2,-4
8002476c:	e9 e2 ff ff 	st.b [%a14]-1,%d2
80024770:	1d 00 5f 00 	j 8002482e <tcp_output_control_segment+0x126>
  } else {
    u8_t ttl, tos;
#if CHECKSUM_GEN_TCP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
      struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
80024774:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80024778:	b0 42       	add.a %a2,4
8002477a:	54 22       	ld.w %d2,[%a2]
8002477c:	59 e2 f4 ff 	st.w [%a14]-12,%d2
      tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
80024780:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
80024784:	b9 22 08 00 	ld.hu %d2,[%a2]8
80024788:	99 e6 e0 ff 	ld.a %a6,[%a14]-32
8002478c:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
80024790:	02 25       	mov %d5,%d2
80024792:	82 64       	mov %d4,6
80024794:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80024798:	6d ff a8 98 	call 800178e8 <ip_chksum_pseudo>
8002479c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800247a0:	8f f2 0f 31 	and %d3,%d2,255
800247a4:	82 04       	mov %d4,0
800247a6:	a6 43       	or %d3,%d4
800247a8:	e9 23 10 00 	st.b [%a2]16,%d3
800247ac:	06 82       	sh %d2,-8
800247ae:	37 02 70 20 	extr.u %d2,%d2,0,16
800247b2:	82 03       	mov %d3,0
800247b4:	a6 32       	or %d2,%d3
800247b6:	e9 22 11 00 	st.b [%a2]17,%d2
                                        src, dst);
    }
#endif
    if (pcb != NULL) {
800247ba:	19 e2 ec ff 	ld.w %d2,[%a14]-20
800247be:	df 02 10 00 	jeq %d2,0,800247de <tcp_output_control_segment+0xd6>
      NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
      ttl = pcb->ttl;
800247c2:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800247c6:	79 22 0b 00 	ld.b %d2,[%a2]11
800247ca:	e9 e2 fe ff 	st.b [%a14]-2,%d2
      tos = pcb->tos;
800247ce:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800247d2:	79 22 0a 00 	ld.b %d2,[%a2]10
800247d6:	e9 e2 fd ff 	st.b [%a14]-3,%d2
800247da:	1d 00 08 00 	j 800247ea <tcp_output_control_segment+0xe2>
    } else {
      /* Send output with hardcoded TTL/HL since we have no access to the pcb */
      ttl = TCP_TTL;
800247de:	82 f2       	mov %d2,-1
800247e0:	e9 e2 fe ff 	st.b [%a14]-2,%d2
      tos = 0;
800247e4:	82 02       	mov %d2,0
800247e6:	e9 e2 fd ff 	st.b [%a14]-3,%d2
    }
    TCP_STATS_INC(tcp.xmit);
800247ea:	91 10 00 27 	movh.a %a2,28673
800247ee:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800247f2:	b9 22 10 20 	ld.hu %d2,[%a2]144 <70010090 <ram_heap+0x4ffc>>
800247f6:	c2 12       	add %d2,1
800247f8:	37 02 70 20 	extr.u %d2,%d2,0,16
800247fc:	91 10 00 27 	movh.a %a2,28673
80024800:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80024804:	f9 22 10 20 	st.h [%a2]144 <70010090 <ram_heap+0x4ffc>>,%d2
    err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
80024808:	39 e2 fe ff 	ld.bu %d2,[%a14]-2 <70010090 <ram_heap+0x4ffc>>
8002480c:	39 e3 fd ff 	ld.bu %d3,[%a14]-3 <70010090 <ram_heap+0x4ffc>>
80024810:	99 e7 f8 ff 	ld.a %a7,[%a14]-8 <70010090 <ram_heap+0x4ffc>>
80024814:	82 66       	mov %d6,6
80024816:	02 35       	mov %d5,%d3
80024818:	02 24       	mov %d4,%d2
8002481a:	99 e6 e0 ff 	ld.a %a6,[%a14]-32
8002481e:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
80024822:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80024826:	6d ff 19 87 	call 80015658 <ip4_output_if>
8002482a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    NETIF_RESET_HINTS(netif);
  }
  pbuf_free(p);
8002482e:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80024832:	6d ff b3 ab 	call 80019f98 <pbuf_free>
  return err;
80024836:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
8002483a:	00 90       	ret 

8002483c <tcp_rst>:
 */
void
tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
        const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
        u16_t local_port, u16_t remote_port)
{
8002483c:	40 ae       	mov.aa %a14,%sp
8002483e:	20 38       	sub.a %sp,56
80024840:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80024844:	59 e4 f0 ff 	st.w [%a14]-16,%d4
80024848:	59 e5 ec ff 	st.w [%a14]-20,%d5
8002484c:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80024850:	b5 e6 e4 ff 	st.a [%a14]-28,%a6
80024854:	02 62       	mov %d2,%d6
80024856:	02 73       	mov %d3,%d7
80024858:	f9 e2 e0 ff 	st.h [%a14]-32,%d2
8002485c:	02 32       	mov %d2,%d3
8002485e:	f9 e2 dc ff 	st.h [%a14]-36,%d2
  struct pbuf *p;
  u16_t wnd;
  u8_t optlen;

  LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
80024862:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
80024866:	df 02 17 80 	jne %d2,0,80024894 <tcp_rst+0x58>
8002486a:	91 00 00 28 	movh.a %a2,32768
8002486e:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80024872:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80024876:	3b 40 7c 20 	mov %d2,1988
8002487a:	59 a2 04 00 	st.w [%sp]4,%d2
8002487e:	91 00 00 28 	movh.a %a2,32768
80024882:	d9 22 01 63 	lea %a2,[%a2]12673 <80003181 <IfxCpu_Trap_vectorTable0_end+0x2f8d>>
80024886:	f4 a2       	st.a [%sp],%a2
80024888:	91 00 00 28 	movh.a %a2,32768
8002488c:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80024890:	6d ff 53 05 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
80024894:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80024898:	df 02 17 80 	jne %d2,0,800248c6 <tcp_rst+0x8a>
8002489c:	91 00 00 28 	movh.a %a2,32768
800248a0:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
800248a4:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
800248a8:	3b 50 7c 20 	mov %d2,1989
800248ac:	59 a2 04 00 	st.w [%sp]4,%d2
800248b0:	91 00 00 28 	movh.a %a2,32768
800248b4:	d9 22 1b 63 	lea %a2,[%a2]12699 <8000319b <IfxCpu_Trap_vectorTable0_end+0x2fa7>>
800248b8:	f4 a2       	st.a [%sp],%a2
800248ba:	91 00 00 28 	movh.a %a2,32768
800248be:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
800248c2:	6d ff 3a 05 	call 80005336 <Ifx_Lwip_printf>

  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
800248c6:	82 02       	mov %d2,0
800248c8:	e9 e2 ff ff 	st.b [%a14]-1,%d2

#if LWIP_WND_SCALE
  wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
#else
  wnd = PP_HTONS(TCP_WND);
800248cc:	3b 80 00 26 	mov %d2,24584
800248d0:	f9 e2 fc ff 	st.h [%a14]-4,%d2
#endif

  p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
800248d4:	39 e8 ff ff 	ld.bu %d8,[%a14]-1
800248d8:	19 e4 f0 ff 	ld.w %d4,[%a14]-16
800248dc:	6d ff 54 96 	call 80017584 <lwip_htonl>
800248e0:	b9 e3 e0 ff 	ld.hu %d3,[%a14]-32
800248e4:	b9 e4 dc ff 	ld.hu %d4,[%a14]-36
800248e8:	b9 e5 fc ff 	ld.hu %d5,[%a14]-4
800248ec:	59 a5 0c 00 	st.w [%sp]12,%d5
800248f0:	3b 40 01 50 	mov %d5,20
800248f4:	59 a5 08 00 	st.w [%sp]8,%d5
800248f8:	59 a4 04 00 	st.w [%sp]4,%d4
800248fc:	74 a3       	st.w [%sp],%d3
800248fe:	02 27       	mov %d7,%d2
80024900:	82 06       	mov %d6,0
80024902:	02 85       	mov %d5,%d8
80024904:	19 e4 ec ff 	ld.w %d4,[%a14]-20
80024908:	6d ff 25 fd 	call 80024352 <tcp_output_alloc_header_common>
8002490c:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
    remote_port, TCP_RST | TCP_ACK, wnd);
  if (p == NULL) {
80024910:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80024914:	df 02 17 00 	jeq %d2,0,80024942 <tcp_rst+0x106>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
    return;
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
80024918:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8002491c:	02 25       	mov %d5,%d2
8002491e:	82 04       	mov %d4,0
80024920:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80024924:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80024928:	6d ff 92 fe 	call 8002464c <tcp_output_fill_options>

  MIB2_STATS_INC(mib2.tcpoutrsts);

  tcp_output_control_segment(pcb, p, local_ip, remote_ip);
8002492c:	99 e7 e4 ff 	ld.a %a7,[%a14]-28
80024930:	99 e6 e8 ff 	ld.a %a6,[%a14]-24
80024934:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80024938:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8002493c:	6d ff e6 fe 	call 80024708 <tcp_output_control_segment>
80024940:	00 90       	ret 
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
80024942:	00 90       	ret 

80024944 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
80024944:	40 ae       	mov.aa %a14,%sp
80024946:	20 28       	sub.a %sp,40
80024948:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  err_t err;
  struct pbuf *p;
  u8_t optlen, optflags = 0;
8002494c:	82 02       	mov %d2,0
8002494e:	e9 e2 ff ff 	st.b [%a14]-1,%d2
  u8_t num_sacks = 0;
80024952:	82 02       	mov %d2,0
80024954:	e9 e2 fe ff 	st.b [%a14]-2,%d2

  LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
80024958:	19 e2 ec ff 	ld.w %d2,[%a14]-20
8002495c:	df 02 17 80 	jne %d2,0,8002498a <tcp_send_empty_ack+0x46>
80024960:	91 00 00 28 	movh.a %a2,32768
80024964:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80024968:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
8002496c:	3b a0 7e 20 	mov %d2,2026
80024970:	59 a2 04 00 	st.w [%sp]4,%d2
80024974:	91 00 00 28 	movh.a %a2,32768
80024978:	d9 22 36 63 	lea %a2,[%a2]12726 <800031b6 <IfxCpu_Trap_vectorTable0_end+0x2fc2>>
8002497c:	f4 a2       	st.a [%sp],%a2
8002497e:	91 00 00 28 	movh.a %a2,32768
80024982:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80024986:	6d ff d8 04 	call 80005336 <Ifx_Lwip_printf>
#if LWIP_TCP_TIMESTAMPS
  if (pcb->flags & TF_TIMESTAMP) {
    optflags = TF_SEG_OPTS_TS;
  }
#endif
  optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
8002498a:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8002498e:	06 22       	sh %d2,2
80024990:	8f f2 0f 21 	and %d2,%d2,255
80024994:	8f 42 00 21 	and %d2,%d2,4
80024998:	e9 e2 fd ff 	st.b [%a14]-3,%d2
  if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
    optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
8002499c:	39 e8 fd ff 	ld.bu %d8,[%a14]-3
800249a0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800249a4:	d9 22 14 10 	lea %a2,[%a2]84
800249a8:	54 22       	ld.w %d2,[%a2]
800249aa:	02 24       	mov %d4,%d2
800249ac:	6d ff ec 95 	call 80017584 <lwip_htonl>
800249b0:	02 26       	mov %d6,%d2
800249b2:	82 05       	mov %d5,0
800249b4:	02 84       	mov %d4,%d8
800249b6:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800249ba:	6d ff e4 fd 	call 80024582 <tcp_output_alloc_header>
800249be:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  if (p == NULL) {
800249c2:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800249c6:	df 02 10 80 	jne %d2,0,800249e6 <tcp_send_empty_ack+0xa2>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
800249ca:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800249ce:	b9 22 1e 00 	ld.hu %d2,[%a2]30
800249d2:	8f 32 40 21 	or %d2,%d2,3
800249d6:	37 02 70 20 	extr.u %d2,%d2,0,16
800249da:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800249de:	f9 22 1e 00 	st.h [%a2]30,%d2
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
800249e2:	82 e2       	mov %d2,-2
800249e4:	00 90       	ret 
  }
  tcp_output_fill_options(pcb, p, optflags, num_sacks);
800249e6:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
800249ea:	39 e3 fe ff 	ld.bu %d3,[%a14]-2
800249ee:	02 35       	mov %d5,%d3
800249f0:	02 24       	mov %d4,%d2
800249f2:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
800249f6:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800249fa:	6d ff 29 fe 	call 8002464c <tcp_output_fill_options>
  pcb->ts_lastacksent = pcb->rcv_nxt;
#endif

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
800249fe:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80024a02:	19 e3 ec ff 	ld.w %d3,[%a14]-20
80024a06:	c2 43       	add %d3,4
80024a08:	60 37       	mov.a %a7,%d3
80024a0a:	60 26       	mov.a %a6,%d2
80024a0c:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80024a10:	99 e4 ec ff 	ld.a %a4,[%a14]-20
80024a14:	6d ff 7a fe 	call 80024708 <tcp_output_control_segment>
80024a18:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
  if (err != ERR_OK) {
80024a1c:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
80024a20:	df 02 10 00 	jeq %d2,0,80024a40 <tcp_send_empty_ack+0xfc>
    /* let tcp_fasttmr retry sending this ACK */
    tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
80024a24:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80024a28:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80024a2c:	8f 32 40 21 	or %d2,%d2,3
80024a30:	37 02 70 20 	extr.u %d2,%d2,0,16
80024a34:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80024a38:	f9 22 1e 00 	st.h [%a2]30,%d2
80024a3c:	1d 00 0e 00 	j 80024a58 <tcp_send_empty_ack+0x114>
  } else {
    /* remove ACK flags from the PCB, as we sent an empty ACK now */
    tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
80024a40:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80024a44:	b9 22 1e 00 	ld.hu %d2,[%a2]30
80024a48:	8f 32 c0 21 	andn %d2,%d2,3
80024a4c:	37 02 70 20 	extr.u %d2,%d2,0,16
80024a50:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80024a54:	f9 22 1e 00 	st.h [%a2]30,%d2
  }

  return err;
80024a58:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
}
80024a5c:	00 90       	ret 

80024a5e <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
err_t
tcp_keepalive(struct tcp_pcb *pcb)
{
80024a5e:	40 ae       	mov.aa %a14,%sp
80024a60:	20 20       	sub.a %sp,32
80024a62:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  err_t err;
  struct pbuf *p;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
80024a66:	82 02       	mov %d2,0
80024a68:	e9 e2 fa ff 	st.b [%a14]-6,%d2

  LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
80024a6c:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80024a70:	df 02 17 80 	jne %d2,0,80024a9e <tcp_keepalive+0x40>
80024a74:	91 00 00 28 	movh.a %a2,32768
80024a78:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80024a7c:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80024a80:	3b 40 82 20 	mov %d2,2084
80024a84:	59 a2 04 00 	st.w [%sp]4,%d2
80024a88:	91 00 00 28 	movh.a %a2,32768
80024a8c:	d9 22 16 73 	lea %a2,[%a2]12758 <800031d6 <IfxCpu_Trap_vectorTable0_end+0x2fe2>>
80024a90:	f4 a2       	st.a [%sp],%a2
80024a92:	91 00 00 28 	movh.a %a2,32768
80024a96:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80024a9a:	6d ff 4e 04 	call 80005336 <Ifx_Lwip_printf>
  LWIP_DEBUGF(TCP_DEBUG, ("\n"));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
                          tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
80024a9e:	39 e8 fa ff 	ld.bu %d8,[%a14]-6
80024aa2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024aa6:	d9 22 14 10 	lea %a2,[%a2]84
80024aaa:	54 22       	ld.w %d2,[%a2]
80024aac:	c2 f2       	add %d2,-1
80024aae:	02 24       	mov %d4,%d2
80024ab0:	6d ff 6a 95 	call 80017584 <lwip_htonl>
80024ab4:	02 26       	mov %d6,%d2
80024ab6:	82 05       	mov %d5,0
80024ab8:	02 84       	mov %d4,%d8
80024aba:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80024abe:	6d ff 62 fd 	call 80024582 <tcp_output_alloc_header>
80024ac2:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  if (p == NULL) {
80024ac6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80024aca:	df 02 04 80 	jne %d2,0,80024ad2 <tcp_keepalive+0x74>
    LWIP_DEBUGF(TCP_DEBUG,
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return ERR_MEM;
80024ace:	82 f2       	mov %d2,-1
80024ad0:	00 90       	ret 
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
80024ad2:	39 e2 fa ff 	ld.bu %d2,[%a14]-6
80024ad6:	02 25       	mov %d5,%d2
80024ad8:	82 04       	mov %d4,0
80024ada:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80024ade:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80024ae2:	6d ff b5 fd 	call 8002464c <tcp_output_fill_options>
  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
80024ae6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80024aea:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80024aee:	c2 43       	add %d3,4
80024af0:	60 37       	mov.a %a7,%d3
80024af2:	60 26       	mov.a %a6,%d2
80024af4:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80024af8:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80024afc:	6d ff 06 fe 	call 80024708 <tcp_output_control_segment>
80024b00:	e9 e2 fb ff 	st.b [%a14]-5,%d2

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
80024b04:	79 e2 fb ff 	ld.b %d2,[%a14]-5
}
80024b08:	00 90       	ret 

80024b0a <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
err_t
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
80024b0a:	40 ae       	mov.aa %a14,%sp
80024b0c:	20 38       	sub.a %sp,56
80024b0e:	b5 e4 dc ff 	st.a [%a14]-36,%a4
  struct tcp_hdr *tcphdr;
  struct tcp_seg *seg;
  u16_t len;
  u8_t is_fin;
  u32_t snd_nxt;
  u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
80024b12:	82 02       	mov %d2,0
80024b14:	e9 e2 eb ff 	st.b [%a14]-21,%d2

  LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
80024b18:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80024b1c:	df 02 17 80 	jne %d2,0,80024b4a <tcp_zero_window_probe+0x40>
80024b20:	91 00 00 28 	movh.a %a2,32768
80024b24:	d9 22 9f 82 	lea %a2,[%a2]10783 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>
80024b28:	b5 a2 08 00 	st.a [%sp]8 <80002a1f <IfxCpu_Trap_vectorTable0_end+0x282b>>,%a2
80024b2c:	3b f0 84 20 	mov %d2,2127
80024b30:	59 a2 04 00 	st.w [%sp]4,%d2
80024b34:	91 00 00 28 	movh.a %a2,32768
80024b38:	d9 22 31 73 	lea %a2,[%a2]12785 <800031f1 <IfxCpu_Trap_vectorTable0_end+0x2ffd>>
80024b3c:	f4 a2       	st.a [%sp],%a2
80024b3e:	91 00 00 28 	movh.a %a2,32768
80024b42:	d9 24 b7 72 	lea %a4,[%a2]10743 <800029f7 <IfxCpu_Trap_vectorTable0_end+0x2803>>
80024b46:	6d ff f8 03 	call 80005336 <Ifx_Lwip_printf>
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
               tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));

  /* Only consider unsent, persist timer should be off when there is data in-flight */
  seg = pcb->unsent;
80024b4a:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80024b4e:	d9 22 30 10 	lea %a2,[%a2]112
80024b52:	54 22       	ld.w %d2,[%a2]
80024b54:	59 e2 fc ff 	st.w [%a14]-4,%d2
  if (seg == NULL) {
80024b58:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80024b5c:	df 02 04 80 	jne %d2,0,80024b64 <tcp_zero_window_probe+0x5a>
    /* Not expected, persist timer should be off when the send buffer is empty */
    return ERR_OK;
80024b60:	82 02       	mov %d2,0
80024b62:	00 90       	ret 

  /* increment probe count. NOTE: we record probe even if it fails
     to actually transmit due to an error. This ensures memory exhaustion/
     routing problem doesn't leave a zero-window pcb as an indefinite zombie.
     RTO mechanism has similar behavior, see pcb->nrtx */
  if (pcb->persist_probe < 0xFF) {
80024b64:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80024b68:	39 22 1e 20 	ld.bu %d2,[%a2]158
80024b6c:	8b f2 0f 22 	eq %d2,%d2,255
80024b70:	df 02 0d 80 	jne %d2,0,80024b8a <tcp_zero_window_probe+0x80>
    ++pcb->persist_probe;
80024b74:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80024b78:	39 22 1e 20 	ld.bu %d2,[%a2]158
80024b7c:	c2 12       	add %d2,1
80024b7e:	8f f2 0f 21 	and %d2,%d2,255
80024b82:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80024b86:	e9 22 1e 20 	st.b [%a2]158,%d2
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
80024b8a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024b8e:	d9 22 10 00 	lea %a2,[%a2]16
80024b92:	d4 22       	ld.a %a2,[%a2]
80024b94:	39 23 0c 00 	ld.bu %d3,[%a2]12
80024b98:	39 22 0d 00 	ld.bu %d2,[%a2]13
80024b9c:	8f 82 00 20 	sh %d2,%d2,8
80024ba0:	a6 32       	or %d2,%d3
80024ba2:	37 02 70 20 	extr.u %d2,%d2,0,16
80024ba6:	02 24       	mov %d4,%d2
80024ba8:	6d ff d6 94 	call 80017554 <lwip_htons>
80024bac:	8f f2 0f 21 	and %d2,%d2,255
80024bb0:	8f 12 00 21 	and %d2,%d2,1
80024bb4:	df 02 0b 00 	jeq %d2,0,80024bca <tcp_zero_window_probe+0xc0>
80024bb8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024bbc:	b9 22 08 00 	ld.hu %d2,[%a2]8
80024bc0:	df 02 05 80 	jne %d2,0,80024bca <tcp_zero_window_probe+0xc0>
80024bc4:	82 12       	mov %d2,1
80024bc6:	1d 00 03 00 	j 80024bcc <tcp_zero_window_probe+0xc2>
80024bca:	82 02       	mov %d2,0
80024bcc:	e9 e2 fb ff 	st.b [%a14]-5,%d2
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
80024bd0:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80024bd4:	8b 02 00 22 	eq %d2,%d2,0
80024bd8:	8f f2 0f 21 	and %d2,%d2,255
80024bdc:	f9 e2 f8 ff 	st.h [%a14]-8,%d2

  p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
80024be0:	39 e7 eb ff 	ld.bu %d7,[%a14]-21
80024be4:	b9 e4 f8 ff 	ld.hu %d4,[%a14]-8
80024be8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024bec:	d9 22 10 00 	lea %a2,[%a2]16
80024bf0:	d4 22       	ld.a %a2,[%a2]
80024bf2:	39 23 04 00 	ld.bu %d3,[%a2]4
80024bf6:	39 22 05 00 	ld.bu %d2,[%a2]5
80024bfa:	8f 82 00 20 	sh %d2,%d2,8
80024bfe:	a6 32       	or %d2,%d3
80024c00:	39 23 06 00 	ld.bu %d3,[%a2]6
80024c04:	8f 03 01 30 	sh %d3,%d3,16
80024c08:	a6 32       	or %d2,%d3
80024c0a:	39 23 07 00 	ld.bu %d3,[%a2]7
80024c0e:	8f 83 01 30 	sh %d3,%d3,24
80024c12:	a6 32       	or %d2,%d3
80024c14:	02 26       	mov %d6,%d2
80024c16:	02 45       	mov %d5,%d4
80024c18:	02 74       	mov %d4,%d7
80024c1a:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80024c1e:	6d ff b2 fc 	call 80024582 <tcp_output_alloc_header>
80024c22:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
  if (p == NULL) {
80024c26:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80024c2a:	df 02 04 80 	jne %d2,0,80024c32 <tcp_zero_window_probe+0x128>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return ERR_MEM;
80024c2e:	82 f2       	mov %d2,-1
80024c30:	00 90       	ret 
  }
  tcphdr = (struct tcp_hdr *)p->payload;
80024c32:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024c36:	b0 42       	add.a %a2,4
80024c38:	54 22       	ld.w %d2,[%a2]
80024c3a:	59 e2 f0 ff 	st.w [%a14]-16,%d2

  if (is_fin) {
80024c3e:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80024c42:	df 02 30 00 	jeq %d2,0,80024ca2 <tcp_zero_window_probe+0x198>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
80024c46:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80024c4a:	39 23 0c 00 	ld.bu %d3,[%a2]12
80024c4e:	39 22 0d 00 	ld.bu %d2,[%a2]13
80024c52:	8f 82 00 20 	sh %d2,%d2,8
80024c56:	a6 32       	or %d2,%d3
80024c58:	37 02 70 20 	extr.u %d2,%d2,0,16
80024c5c:	37 02 50 20 	extr %d2,%d2,0,16
80024c60:	3b f0 0f 3c 	mov %d3,-16129
80024c64:	26 32       	and %d2,%d3
80024c66:	37 02 50 80 	extr %d8,%d2,0,16
80024c6a:	3b 10 01 40 	mov %d4,17
80024c6e:	6d ff 73 94 	call 80017554 <lwip_htons>
80024c72:	37 02 50 20 	extr %d2,%d2,0,16
80024c76:	a6 82       	or %d2,%d8
80024c78:	37 02 50 20 	extr %d2,%d2,0,16
80024c7c:	37 02 70 20 	extr.u %d2,%d2,0,16
80024c80:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80024c84:	8f f2 0f 31 	and %d3,%d2,255
80024c88:	82 04       	mov %d4,0
80024c8a:	a6 43       	or %d3,%d4
80024c8c:	e9 23 0c 00 	st.b [%a2]12,%d3
80024c90:	06 82       	sh %d2,-8
80024c92:	37 02 70 20 	extr.u %d2,%d2,0,16
80024c96:	82 03       	mov %d3,0
80024c98:	a6 32       	or %d2,%d3
80024c9a:	e9 22 0d 00 	st.b [%a2]13,%d2
80024c9e:	1d 00 23 00 	j 80024ce4 <tcp_zero_window_probe+0x1da>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
80024ca2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80024ca6:	b0 42       	add.a %a2,4
80024ca8:	54 22       	ld.w %d2,[%a2]
80024caa:	1b 42 01 20 	addi %d2,%d2,20
80024cae:	59 e2 ec ff 	st.w [%a14]-20,%d2
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
80024cb2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024cb6:	b0 42       	add.a %a2,4
80024cb8:	54 26       	ld.w %d6,[%a2]
80024cba:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024cbe:	b0 42       	add.a %a2,4
80024cc0:	d4 22       	ld.a %a2,[%a2]
80024cc2:	b9 23 08 00 	ld.hu %d3,[%a2]8
80024cc6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024cca:	b9 22 08 00 	ld.hu %d2,[%a2]8
80024cce:	0b 23 80 20 	sub %d2,%d3,%d2
80024cd2:	37 02 70 20 	extr.u %d2,%d2,0,16
80024cd6:	02 25       	mov %d5,%d2
80024cd8:	82 14       	mov %d4,1
80024cda:	99 e5 ec ff 	ld.a %a5,[%a14]-20
80024cde:	60 64       	mov.a %a4,%d6
80024ce0:	6d ff 87 ac 	call 8001a5ee <pbuf_copy_partial>
  }

  /* The byte may be acknowledged without the window being opened. */
  snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
80024ce4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024ce8:	d9 22 10 00 	lea %a2,[%a2]16
80024cec:	d4 22       	ld.a %a2,[%a2]
80024cee:	39 23 04 00 	ld.bu %d3,[%a2]4
80024cf2:	39 22 05 00 	ld.bu %d2,[%a2]5
80024cf6:	8f 82 00 20 	sh %d2,%d2,8
80024cfa:	a6 32       	or %d2,%d3
80024cfc:	39 23 06 00 	ld.bu %d3,[%a2]6
80024d00:	8f 03 01 30 	sh %d3,%d3,16
80024d04:	a6 32       	or %d2,%d3
80024d06:	39 23 07 00 	ld.bu %d3,[%a2]7
80024d0a:	8f 83 01 30 	sh %d3,%d3,24
80024d0e:	a6 32       	or %d2,%d3
80024d10:	02 24       	mov %d4,%d2
80024d12:	6d ff 39 94 	call 80017584 <lwip_htonl>
80024d16:	c2 12       	add %d2,1
80024d18:	59 e2 e4 ff 	st.w [%a14]-28,%d2
  if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
80024d1c:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80024d20:	d9 22 14 10 	lea %a2,[%a2]84
80024d24:	54 23       	ld.w %d3,[%a2]
80024d26:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80024d2a:	0b 23 80 20 	sub %d2,%d3,%d2
80024d2e:	ff 02 09 00 	jge %d2,0,80024d40 <tcp_zero_window_probe+0x236>
    pcb->snd_nxt = snd_nxt;
80024d32:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80024d36:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80024d3a:	d9 22 14 10 	lea %a2,[%a2]84
80024d3e:	74 22       	st.w [%a2],%d2
  }
  tcp_output_fill_options(pcb, p, 0, optlen);
80024d40:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80024d44:	02 25       	mov %d5,%d2
80024d46:	82 04       	mov %d4,0
80024d48:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80024d4c:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80024d50:	6d ff 7e fc 	call 8002464c <tcp_output_fill_options>

  err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
80024d54:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80024d58:	19 e3 dc ff 	ld.w %d3,[%a14]-36
80024d5c:	c2 43       	add %d3,4
80024d5e:	60 37       	mov.a %a7,%d3
80024d60:	60 26       	mov.a %a6,%d2
80024d62:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
80024d66:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80024d6a:	6d ff cf fc 	call 80024708 <tcp_output_control_segment>
80024d6e:	e9 e2 e3 ff 	st.b [%a14]-29,%d2

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F" err %d.\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
  return err;
80024d72:	79 e2 e3 ff 	ld.b %d2,[%a14]-29
}
80024d76:	00 90       	ret 

80024d78 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
80024d78:	40 ae       	mov.aa %a14,%sp
80024d7a:	20 08       	sub.a %sp,8
80024d7c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
80024d80:	6d ff 8f ad 	call 8001a89e <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
80024d84:	91 10 00 27 	movh.a %a2,28673
80024d88:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
80024d8c:	54 22       	ld.w %d2,[%a2]
80024d8e:	df 02 09 80 	jne %d2,0,80024da0 <tcpip_tcp_timer+0x28>
80024d92:	91 10 00 27 	movh.a %a2,28673
80024d96:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
80024d9a:	54 22       	ld.w %d2,[%a2]
80024d9c:	df 02 0d 00 	jeq %d2,0,80024db6 <tcpip_tcp_timer+0x3e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
80024da0:	a0 05       	mov.a %a5,0
80024da2:	91 20 00 28 	movh.a %a2,32770
80024da6:	d9 24 f8 54 	lea %a4,[%a2]19832 <80024d78 <tcpip_tcp_timer>>
80024daa:	3b a0 0f 40 	mov %d4,250
80024dae:	6d 00 5b 01 	call 80025064 <sys_timeout>
80024db2:	1d 00 09 00 	j 80024dc4 <tcpip_tcp_timer+0x4c>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
80024db6:	91 10 00 27 	movh.a %a2,28673
80024dba:	d9 22 4c 84 	lea %a2,[%a2]17932 <7001460c <tcpip_tcp_timer_active>>
80024dbe:	82 02       	mov %d2,0
80024dc0:	74 22       	st.w [%a2],%d2
  }
}
80024dc2:	00 00       	nop 
80024dc4:	00 00       	nop 
80024dc6:	00 90       	ret 

80024dc8 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
80024dc8:	40 ae       	mov.aa %a14,%sp
  LWIP_ASSERT_CORE_LOCKED();

  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
80024dca:	91 10 00 27 	movh.a %a2,28673
80024dce:	d9 22 4c 84 	lea %a2,[%a2]17932 <7001460c <tcpip_tcp_timer_active>>
80024dd2:	54 22       	ld.w %d2,[%a2]
80024dd4:	df 02 1f 80 	jne %d2,0,80024e12 <tcp_timer_needed+0x4a>
80024dd8:	91 10 00 27 	movh.a %a2,28673
80024ddc:	d9 22 7c 64 	lea %a2,[%a2]17852 <700145bc <tcp_active_pcbs>>
80024de0:	54 22       	ld.w %d2,[%a2]
80024de2:	df 02 09 80 	jne %d2,0,80024df4 <tcp_timer_needed+0x2c>
80024de6:	91 10 00 27 	movh.a %a2,28673
80024dea:	d9 22 40 74 	lea %a2,[%a2]17856 <700145c0 <tcp_tw_pcbs>>
80024dee:	54 22       	ld.w %d2,[%a2]
80024df0:	df 02 11 00 	jeq %d2,0,80024e12 <tcp_timer_needed+0x4a>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
80024df4:	91 10 00 27 	movh.a %a2,28673
80024df8:	d9 22 4c 84 	lea %a2,[%a2]17932 <7001460c <tcpip_tcp_timer_active>>
80024dfc:	82 12       	mov %d2,1
80024dfe:	74 22       	st.w [%a2],%d2
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
80024e00:	a0 05       	mov.a %a5,0
80024e02:	91 20 00 28 	movh.a %a2,32770
80024e06:	d9 24 f8 54 	lea %a4,[%a2]19832 <80024d78 <tcpip_tcp_timer>>
80024e0a:	3b a0 0f 40 	mov %d4,250
80024e0e:	6d 00 2b 01 	call 80025064 <sys_timeout>
  }
}
80024e12:	00 00       	nop 
80024e14:	00 90       	ret 

80024e16 <sys_timeout_abs>:
#if LWIP_DEBUG_TIMERNAMES
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
#endif
{
80024e16:	40 ae       	mov.aa %a14,%sp
80024e18:	20 28       	sub.a %sp,40
80024e1a:	59 e4 f4 ff 	st.w [%a14]-12,%d4
80024e1e:	b5 e4 f0 ff 	st.a [%a14]-16,%a4
80024e22:	b5 e5 ec ff 	st.a [%a14]-20,%a5
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
80024e26:	82 64       	mov %d4,6
80024e28:	6d ff d1 9d 	call 800189ca <memp_malloc>
80024e2c:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
  if (timeout == NULL) {
80024e30:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80024e34:	df 02 1d 80 	jne %d2,0,80024e6e <sys_timeout_abs+0x58>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
80024e38:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80024e3c:	df 02 9c 80 	jne %d2,0,80024f74 <sys_timeout_abs+0x15e>
80024e40:	91 00 00 28 	movh.a %a2,32768
80024e44:	d9 22 3c 83 	lea %a2,[%a2]12860 <8000323c <IfxCpu_Trap_vectorTable0_end+0x3048>>
80024e48:	b5 a2 08 00 	st.a [%sp]8 <8000323c <IfxCpu_Trap_vectorTable0_end+0x3048>>,%a2
80024e4c:	3b e0 0b 20 	mov %d2,190
80024e50:	59 a2 04 00 	st.w [%sp]4,%d2
80024e54:	91 00 00 28 	movh.a %a2,32768
80024e58:	d9 22 2b 93 	lea %a2,[%a2]12907 <8000326b <IfxCpu_Trap_vectorTable0_end+0x3077>>
80024e5c:	f4 a2       	st.a [%sp],%a2
80024e5e:	91 00 00 28 	movh.a %a2,32768
80024e62:	d9 24 14 83 	lea %a4,[%a2]12820 <80003214 <IfxCpu_Trap_vectorTable0_end+0x3020>>
80024e66:	6d ff 68 02 	call 80005336 <Ifx_Lwip_printf>
    return;
80024e6a:	1d 00 85 00 	j 80024f74 <sys_timeout_abs+0x15e>
  }

  timeout->next = NULL;
80024e6e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024e72:	82 02       	mov %d2,0
80024e74:	74 22       	st.w [%a2],%d2
  timeout->h = handler;
80024e76:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024e7a:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80024e7e:	d9 22 08 00 	lea %a2,[%a2]8
80024e82:	74 22       	st.w [%a2],%d2
  timeout->arg = arg;
80024e84:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024e88:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80024e8c:	d9 22 0c 00 	lea %a2,[%a2]12
80024e90:	74 22       	st.w [%a2],%d2
  timeout->time = abs_time;
80024e92:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024e96:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80024e9a:	b0 42       	add.a %a2,4
80024e9c:	74 22       	st.w [%a2],%d2
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
                             (void *)timeout, abs_time, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
80024e9e:	91 10 00 27 	movh.a %a2,28673
80024ea2:	d9 22 44 84 	lea %a2,[%a2]17924 <70014604 <next_timeout>>
80024ea6:	54 22       	ld.w %d2,[%a2]
80024ea8:	df 02 0a 80 	jne %d2,0,80024ebc <sys_timeout_abs+0xa6>
    next_timeout = timeout;
80024eac:	91 10 00 27 	movh.a %a2,28673
80024eb0:	d9 22 44 84 	lea %a2,[%a2]17924 <70014604 <next_timeout>>
80024eb4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <70014604 <next_timeout>>
80024eb8:	74 22       	st.w [%a2],%d2
    return;
80024eba:	00 90       	ret 
  }
  if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
80024ebc:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024ec0:	b0 42       	add.a %a2,4
80024ec2:	54 23       	ld.w %d3,[%a2]
80024ec4:	91 10 00 27 	movh.a %a2,28673
80024ec8:	d9 22 44 84 	lea %a2,[%a2]17924 <70014604 <next_timeout>>
80024ecc:	d4 22       	ld.a %a2,[%a2]
80024ece:	b0 42       	add.a %a2,4
80024ed0:	54 22       	ld.w %d2,[%a2]
80024ed2:	0b 23 80 20 	sub %d2,%d3,%d2
80024ed6:	8f 12 1e 20 	sh %d2,%d2,-31
80024eda:	8f 12 00 21 	and %d2,%d2,1
80024ede:	8f f2 0f 21 	and %d2,%d2,255
80024ee2:	df 02 12 00 	jeq %d2,0,80024f06 <sys_timeout_abs+0xf0>
    timeout->next = next_timeout;
80024ee6:	91 10 00 27 	movh.a %a2,28673
80024eea:	d9 22 44 84 	lea %a2,[%a2]17924 <70014604 <next_timeout>>
80024eee:	54 22       	ld.w %d2,[%a2]
80024ef0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8 <70014604 <next_timeout>>
80024ef4:	74 22       	st.w [%a2],%d2
    next_timeout = timeout;
80024ef6:	91 10 00 27 	movh.a %a2,28673
80024efa:	d9 22 44 84 	lea %a2,[%a2]17924 <70014604 <next_timeout>>
80024efe:	19 e2 f8 ff 	ld.w %d2,[%a14]-8 <70014604 <next_timeout>>
80024f02:	74 22       	st.w [%a2],%d2
80024f04:	00 90       	ret 
  } else {
    for (t = next_timeout; t != NULL; t = t->next) {
80024f06:	91 10 00 27 	movh.a %a2,28673
80024f0a:	d9 22 44 84 	lea %a2,[%a2]17924 <70014604 <next_timeout>>
80024f0e:	54 22       	ld.w %d2,[%a2]
80024f10:	59 e2 fc ff 	st.w [%a14]-4 <70014604 <next_timeout>>,%d2
80024f14:	1d 00 2b 00 	j 80024f6a <sys_timeout_abs+0x154>
      if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
80024f18:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024f1c:	54 22       	ld.w %d2,[%a2]
80024f1e:	df 02 15 00 	jeq %d2,0,80024f48 <sys_timeout_abs+0x132>
80024f22:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024f26:	b0 42       	add.a %a2,4
80024f28:	54 23       	ld.w %d3,[%a2]
80024f2a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024f2e:	d4 22       	ld.a %a2,[%a2]
80024f30:	b0 42       	add.a %a2,4
80024f32:	54 22       	ld.w %d2,[%a2]
80024f34:	0b 23 80 20 	sub %d2,%d3,%d2
80024f38:	8f 12 1e 20 	sh %d2,%d2,-31
80024f3c:	8f 12 00 21 	and %d2,%d2,1
80024f40:	8f f2 0f 21 	and %d2,%d2,255
80024f44:	df 02 0e 00 	jeq %d2,0,80024f60 <sys_timeout_abs+0x14a>
        timeout->next = t->next;
80024f48:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024f4c:	54 22       	ld.w %d2,[%a2]
80024f4e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80024f52:	74 22       	st.w [%a2],%d2
        t->next = timeout;
80024f54:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024f58:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80024f5c:	74 22       	st.w [%a2],%d2
        break;
80024f5e:	00 90       	ret 
    for (t = next_timeout; t != NULL; t = t->next) {
80024f60:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024f64:	54 22       	ld.w %d2,[%a2]
80024f66:	59 e2 fc ff 	st.w [%a14]-4,%d2
80024f6a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80024f6e:	df 02 d5 ff 	jne %d2,0,80024f18 <sys_timeout_abs+0x102>
80024f72:	00 90       	ret 
    return;
80024f74:	00 00       	nop 
      }
    }
  }
}
80024f76:	00 90       	ret 

80024f78 <lwip_cyclic_timer>:
#if !LWIP_TESTMODE
static
#endif
void
lwip_cyclic_timer(void *arg)
{
80024f78:	40 ae       	mov.aa %a14,%sp
80024f7a:	20 18       	sub.a %sp,24
80024f7c:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  u32_t now;
  u32_t next_timeout_time;
  const struct lwip_cyclic_timer *cyclic = (const struct lwip_cyclic_timer *)arg;
80024f80:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80024f84:	59 e2 fc ff 	st.w [%a14]-4,%d2

#if LWIP_DEBUG_TIMERNAMES
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
#endif
  cyclic->handler();
80024f88:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024f8c:	b0 42       	add.a %a2,4
80024f8e:	d4 22       	ld.a %a2,[%a2]
80024f90:	2d 02 00 00 	calli %a2

  now = sys_now();
80024f94:	6d ff aa 01 	call 800052e8 <sys_now>
80024f98:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
80024f9c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024fa0:	54 23       	ld.w %d3,[%a2]
80024fa2:	91 10 00 27 	movh.a %a2,28673
80024fa6:	d9 22 48 84 	lea %a2,[%a2]17928 <70014608 <current_timeout_due_time>>
80024faa:	54 22       	ld.w %d2,[%a2]
80024fac:	42 32       	add %d2,%d3
80024fae:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  if (TIME_LESS_THAN(next_timeout_time, now)) {
80024fb2:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80024fb6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80024fba:	0b 23 80 20 	sub %d2,%d3,%d2
80024fbe:	8f 12 1e 20 	sh %d2,%d2,-31
80024fc2:	8f 12 00 21 	and %d2,%d2,1
80024fc6:	8f f2 0f 21 	and %d2,%d2,255
80024fca:	df 02 13 00 	jeq %d2,0,80024ff0 <lwip_cyclic_timer+0x78>
    /* timer would immediately expire again -> "overload" -> restart without any correction */
#if LWIP_DEBUG_TIMERNAMES
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
80024fce:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80024fd2:	54 23       	ld.w %d3,[%a2]
80024fd4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80024fd8:	42 32       	add %d2,%d3
80024fda:	99 e5 ec ff 	ld.a %a5,[%a14]-20
80024fde:	91 20 00 28 	movh.a %a2,32770
80024fe2:	d9 24 f8 d4 	lea %a4,[%a2]20344 <80024f78 <lwip_cyclic_timer>>
80024fe6:	02 24       	mov %d4,%d2
80024fe8:	6d ff 17 ff 	call 80024e16 <sys_timeout_abs>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
#else
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
#endif
  }
}
80024fec:	1d 00 0c 00 	j 80025004 <lwip_cyclic_timer+0x8c>
    sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
80024ff0:	99 e5 ec ff 	ld.a %a5,[%a14]-20
80024ff4:	91 20 00 28 	movh.a %a2,32770
80024ff8:	d9 24 f8 d4 	lea %a4,[%a2]20344 <80024f78 <lwip_cyclic_timer>>
80024ffc:	19 e4 f4 ff 	ld.w %d4,[%a14]-12 <80024f78 <lwip_cyclic_timer>>
80025000:	6d ff 0b ff 	call 80024e16 <sys_timeout_abs>
}
80025004:	00 00       	nop 
80025006:	00 90       	ret 

80025008 <sys_timeouts_init>:

/** Initialize this module */
void sys_timeouts_init(void)
{
80025008:	40 ae       	mov.aa %a14,%sp
8002500a:	20 08       	sub.a %sp,8
  size_t i;
  /* tcp_tmr() at index 0 is started on demand */
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
8002500c:	82 12       	mov %d2,1
8002500e:	59 e2 fc ff 	st.w [%a14]-4,%d2
80025012:	1d 00 22 00 	j 80025056 <sys_timeouts_init+0x4e>
    /* we have to cast via size_t to get rid of const warning
      (this is OK as cyclic_timer() casts back to const* */
    sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
80025016:	91 00 00 28 	movh.a %a2,32768
8002501a:	d9 22 60 84 	lea %a2,[%a2]17952 <80004620 <lwip_cyclic_timers>>
8002501e:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <80004620 <lwip_cyclic_timers>>
80025022:	06 32       	sh %d2,3
80025024:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80025028:	54 23       	ld.w %d3,[%a2]
8002502a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002502e:	06 32       	sh %d2,3
80025030:	91 00 00 28 	movh.a %a2,32768
80025034:	d9 22 60 84 	lea %a2,[%a2]17952 <80004620 <lwip_cyclic_timers>>
80025038:	80 24       	mov.d %d4,%a2
8002503a:	42 42       	add %d2,%d4
8002503c:	60 25       	mov.a %a5,%d2
8002503e:	91 20 00 28 	movh.a %a2,32770
80025042:	d9 24 f8 d4 	lea %a4,[%a2]20344 <80024f78 <lwip_cyclic_timer>>
80025046:	02 34       	mov %d4,%d3
80025048:	6d 00 0e 00 	call 80025064 <sys_timeout>
  for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
8002504c:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80025050:	c2 12       	add %d2,1
80025052:	59 e2 fc ff 	st.w [%a14]-4,%d2
80025056:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002505a:	bf 52 de ff 	jlt.u %d2,5,80025016 <sys_timeouts_init+0xe>
  }
}
8002505e:	00 00       	nop 
80025060:	00 00       	nop 
80025062:	00 90       	ret 

80025064 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char *handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
80025064:	40 ae       	mov.aa %a14,%sp
80025066:	20 28       	sub.a %sp,40
80025068:	59 e4 f4 ff 	st.w [%a14]-12,%d4
8002506c:	b5 e4 f0 ff 	st.a [%a14]-16,%a4
80025070:	b5 e5 ec ff 	st.a [%a14]-20,%a5
  u32_t next_timeout_time;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
80025074:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025078:	7b 00 00 34 	movh %d3,16384
8002507c:	3f 32 17 80 	jlt.u %d2,%d3,800250aa <sys_timeout+0x46>
80025080:	91 00 00 28 	movh.a %a2,32768
80025084:	d9 22 3c 83 	lea %a2,[%a2]12860 <8000323c <IfxCpu_Trap_vectorTable0_end+0x3048>>
80025088:	b5 a2 08 00 	st.a [%sp]8 <8000323c <IfxCpu_Trap_vectorTable0_end+0x3048>>,%a2
8002508c:	3b 90 12 20 	mov %d2,297
80025090:	59 a2 04 00 	st.w [%sp]4,%d2
80025094:	91 00 00 28 	movh.a %a2,32768
80025098:	d9 22 28 a3 	lea %a2,[%a2]12968 <800032a8 <IfxCpu_Trap_vectorTable0_end+0x30b4>>
8002509c:	f4 a2       	st.a [%sp],%a2
8002509e:	91 00 00 28 	movh.a %a2,32768
800250a2:	d9 24 14 83 	lea %a4,[%a2]12820 <80003214 <IfxCpu_Trap_vectorTable0_end+0x3020>>
800250a6:	6d ff 48 01 	call 80005336 <Ifx_Lwip_printf>

  next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
800250aa:	6d ff 1f 01 	call 800052e8 <sys_now>
800250ae:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
800250b2:	42 32       	add %d2,%d3
800250b4:	59 e2 fc ff 	st.w [%a14]-4,%d2

#if LWIP_DEBUG_TIMERNAMES
  sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
#else
  sys_timeout_abs(next_timeout_time, handler, arg);
800250b8:	99 e5 ec ff 	ld.a %a5,[%a14]-20
800250bc:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
800250c0:	19 e4 fc ff 	ld.w %d4,[%a14]-4
800250c4:	6d ff a9 fe 	call 80024e16 <sys_timeout_abs>
#endif
}
800250c8:	00 00       	nop 
800250ca:	00 90       	ret 

800250cc <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
800250cc:	40 ae       	mov.aa %a14,%sp
#ifdef LWIP_RAND
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RAND */
}
800250ce:	00 00       	nop 
800250d0:	00 90       	ret 

800250d2 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
800250d2:	40 ae       	mov.aa %a14,%sp
800250d4:	20 08       	sub.a %sp,8
  u16_t n = 0;
800250d6:	82 02       	mov %d2,0
800250d8:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  struct udp_pcb *pcb;

again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
800250dc:	91 10 00 27 	movh.a %a2,28673
800250e0:	d9 22 b8 4a 	lea %a2,[%a2]-22216 <7000a938 <udp_port>>
800250e4:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
800250e8:	1b 12 00 30 	addi %d3,%d2,1
800250ec:	37 03 70 30 	extr.u %d3,%d3,0,16
800250f0:	91 10 00 27 	movh.a %a2,28673
800250f4:	d9 22 b8 4a 	lea %a2,[%a2]-22216 <7000a938 <udp_port>>
800250f8:	b4 23       	st.h [%a2],%d3
800250fa:	bb f0 ff 3f 	mov.u %d3,65535
800250fe:	5f 32 09 80 	jne %d2,%d3,80025110 <udp_new_port+0x3e>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
80025102:	91 10 00 27 	movh.a %a2,28673
80025106:	d9 22 b8 4a 	lea %a2,[%a2]-22216 <7000a938 <udp_port>>
8002510a:	3b 00 00 2c 	mov %d2,-16384
8002510e:	b4 22       	st.h [%a2],%d2
  }
  /* Check all PCBs. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
80025110:	91 10 00 27 	movh.a %a2,28673
80025114:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025118:	54 22       	ld.w %d2,[%a2]
8002511a:	59 e2 f8 ff 	st.w [%a14]-8 <70014610 <udp_pcbs>>,%d2
8002511e:	1d 00 22 00 	j 80025162 <udp_new_port+0x90>
    if (pcb->local_port == udp_port) {
80025122:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80025126:	b9 23 12 00 	ld.hu %d3,[%a2]18
8002512a:	91 10 00 27 	movh.a %a2,28673
8002512e:	d9 22 b8 4a 	lea %a2,[%a2]-22216 <7000a938 <udp_port>>
80025132:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
80025136:	5f 23 0f 80 	jne %d3,%d2,80025154 <udp_new_port+0x82>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
8002513a:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
8002513e:	c2 12       	add %d2,1
80025140:	f9 e2 fe ff 	st.h [%a14]-2,%d2
80025144:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80025148:	3b 00 00 34 	mov %d3,16384
8002514c:	3f 32 c8 ff 	jlt.u %d2,%d3,800250dc <udp_new_port+0xa>
        return 0;
80025150:	82 02       	mov %d2,0
80025152:	00 90       	ret 
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
80025154:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80025158:	d9 22 0c 00 	lea %a2,[%a2]12
8002515c:	54 22       	ld.w %d2,[%a2]
8002515e:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80025162:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80025166:	df 02 de ff 	jne %d2,0,80025122 <udp_new_port+0x50>
      }
      goto again;
    }
  }
  return udp_port;
8002516a:	91 10 00 27 	movh.a %a2,28673
8002516e:	d9 22 b8 4a 	lea %a2,[%a2]-22216 <7000a938 <udp_port>>
80025172:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
}
80025176:	00 90       	ret 

80025178 <udp_input_local_match>:
 * @param broadcast 1 if his is an IPv4 broadcast (global or subnet-only), 0 otherwise (only used for IPv4)
 * @return 1 on match, 0 otherwise
 */
static u8_t
udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
{
80025178:	40 ae       	mov.aa %a14,%sp
8002517a:	20 20       	sub.a %sp,32
8002517c:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80025180:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
80025184:	02 42       	mov %d2,%d4
80025186:	e9 e2 f4 ff 	st.b [%a14]-12,%d2
  LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
  LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */

  LWIP_ASSERT("udp_input_local_match: invalid pcb", pcb != NULL);
8002518a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002518e:	df 02 17 80 	jne %d2,0,800251bc <udp_input_local_match+0x44>
80025192:	91 00 00 28 	movh.a %a2,32768
80025196:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
8002519a:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
8002519e:	3b 70 08 20 	mov %d2,135
800251a2:	59 a2 04 00 	st.w [%sp]4,%d2
800251a6:	91 00 00 28 	movh.a %a2,32768
800251aa:	d9 22 02 d3 	lea %a2,[%a2]13122 <80003342 <IfxCpu_Trap_vectorTable0_end+0x314e>>
800251ae:	f4 a2       	st.a [%sp],%a2
800251b0:	91 00 00 28 	movh.a %a2,32768
800251b4:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
800251b8:	6d ff bf 00 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("udp_input_local_match: invalid netif", inp != NULL);
800251bc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800251c0:	df 02 17 80 	jne %d2,0,800251ee <udp_input_local_match+0x76>
800251c4:	91 00 00 28 	movh.a %a2,32768
800251c8:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
800251cc:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
800251d0:	3b 80 08 20 	mov %d2,136
800251d4:	59 a2 04 00 	st.w [%sp]4,%d2
800251d8:	91 00 00 28 	movh.a %a2,32768
800251dc:	d9 22 25 d3 	lea %a2,[%a2]13157 <80003365 <IfxCpu_Trap_vectorTable0_end+0x3171>>
800251e0:	f4 a2       	st.a [%sp],%a2
800251e2:	91 00 00 28 	movh.a %a2,32768
800251e6:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
800251ea:	6d ff a6 00 	call 80005336 <Ifx_Lwip_printf>

  /* check if PCB is bound to specific netif */
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
800251ee:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800251f2:	39 22 08 00 	ld.bu %d2,[%a2]8
800251f6:	df 02 15 00 	jeq %d2,0,80025220 <udp_input_local_match+0xa8>
      (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
800251fa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800251fe:	39 22 08 00 	ld.bu %d2,[%a2]8
80025202:	91 10 00 27 	movh.a %a2,28673
80025206:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8002520a:	b0 42       	add.a %a2,4
8002520c:	d4 22       	ld.a %a2,[%a2]
8002520e:	39 23 34 00 	ld.bu %d3,[%a2]52
80025212:	c2 13       	add %d3,1
80025214:	8f f3 0f 31 	and %d3,%d3,255
  if ((pcb->netif_idx != NETIF_NO_INDEX) &&
80025218:	5f 32 04 00 	jeq %d2,%d3,80025220 <udp_input_local_match+0xa8>
    return 0;
8002521c:	82 02       	mov %d2,0
8002521e:	00 90       	ret 
  /* Only need to check PCB if incoming IP version matches PCB IP version */
  if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
#if LWIP_IPV4
    /* Special case: IPv4 broadcast: all or broadcasts in my subnet
     * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
    if (broadcast != 0) {
80025220:	39 e2 f4 ff 	ld.bu %d2,[%a14]-12
80025224:	df 02 2a 00 	jeq %d2,0,80025278 <udp_input_local_match+0x100>
#if IP_SOF_BROADCAST_RECV
      if (ip_get_option(pcb, SOF_BROADCAST))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
80025228:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002522c:	df 02 24 00 	jeq %d2,0,80025274 <udp_input_local_match+0xfc>
80025230:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025234:	54 22       	ld.w %d2,[%a2]
80025236:	df 02 1f 00 	jeq %d2,0,80025274 <udp_input_local_match+0xfc>
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
8002523a:	91 10 00 27 	movh.a %a2,28673
8002523e:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80025242:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80025246:	54 22       	ld.w %d2,[%a2]
        if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
80025248:	df f2 16 00 	jeq %d2,-1,80025274 <udp_input_local_match+0xfc>
            ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
8002524c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025250:	54 23       	ld.w %d3,[%a2]
80025252:	91 10 00 27 	movh.a %a2,28673
80025256:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8002525a:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
8002525e:	54 22       	ld.w %d2,[%a2]
80025260:	c6 32       	xor %d2,%d3
80025262:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80025266:	60 32       	mov.a %a2,%d3
80025268:	d9 22 08 00 	lea %a2,[%a2]8
8002526c:	54 23       	ld.w %d3,[%a2]
8002526e:	26 32       	and %d2,%d3
            ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
80025270:	df 02 1b 80 	jne %d2,0,800252a6 <udp_input_local_match+0x12e>
          return 1;
80025274:	82 12       	mov %d2,1
80025276:	00 90       	ret 
        }
      }
    } else
#endif /* LWIP_IPV4 */
      /* Handle IPv4 and IPv6: all or exact match */
      if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
80025278:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002527c:	df 02 13 00 	jeq %d2,0,800252a2 <udp_input_local_match+0x12a>
80025280:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025284:	54 22       	ld.w %d2,[%a2]
80025286:	df 02 0e 00 	jeq %d2,0,800252a2 <udp_input_local_match+0x12a>
8002528a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002528e:	54 23       	ld.w %d3,[%a2]
80025290:	91 10 00 27 	movh.a %a2,28673
80025294:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
80025298:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
8002529c:	54 22       	ld.w %d2,[%a2]
8002529e:	5f 23 04 80 	jne %d3,%d2,800252a6 <udp_input_local_match+0x12e>
        return 1;
800252a2:	82 12       	mov %d2,1
800252a4:	00 90       	ret 
      }
  }

  return 0;
800252a6:	82 02       	mov %d2,0
}
800252a8:	00 90       	ret 

800252aa <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
800252aa:	40 ae       	mov.aa %a14,%sp
800252ac:	20 38       	sub.a %sp,56
800252ae:	b5 e4 dc ff 	st.a [%a14]-36,%a4
800252b2:	b5 e5 d8 ff 	st.a [%a14]-40,%a5
  struct udp_hdr *udphdr;
  struct udp_pcb *pcb, *prev;
  struct udp_pcb *uncon_pcb;
  u16_t src, dest;
  u8_t broadcast;
  u8_t for_us = 0;
800252b6:	82 02       	mov %d2,0
800252b8:	e9 e2 f3 ff 	st.b [%a14]-13,%d2

  LWIP_UNUSED_ARG(inp);

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ASSERT("udp_input: invalid pbuf", p != NULL);
800252bc:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800252c0:	df 02 17 80 	jne %d2,0,800252ee <udp_input+0x44>
800252c4:	91 00 00 28 	movh.a %a2,32768
800252c8:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
800252cc:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
800252d0:	3b f0 0c 20 	mov %d2,207
800252d4:	59 a2 04 00 	st.w [%sp]4,%d2
800252d8:	91 00 00 28 	movh.a %a2,32768
800252dc:	d9 22 0a e3 	lea %a2,[%a2]13194 <8000338a <IfxCpu_Trap_vectorTable0_end+0x3196>>
800252e0:	f4 a2       	st.a [%sp],%a2
800252e2:	91 00 00 28 	movh.a %a2,32768
800252e6:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
800252ea:	6d ff 26 00 	call 80005336 <Ifx_Lwip_printf>
  LWIP_ASSERT("udp_input: invalid netif", inp != NULL);
800252ee:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
800252f2:	df 02 17 80 	jne %d2,0,80025320 <udp_input+0x76>
800252f6:	91 00 00 28 	movh.a %a2,32768
800252fa:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
800252fe:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025302:	3b 00 0d 20 	mov %d2,208
80025306:	59 a2 04 00 	st.w [%sp]4,%d2
8002530a:	91 00 00 28 	movh.a %a2,32768
8002530e:	d9 22 22 e3 	lea %a2,[%a2]13218 <800033a2 <IfxCpu_Trap_vectorTable0_end+0x31ae>>
80025312:	f4 a2       	st.a [%sp],%a2
80025314:	91 00 00 28 	movh.a %a2,32768
80025318:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
8002531c:	6d ff 0d 00 	call 80005336 <Ifx_Lwip_printf>

  PERF_START;

  UDP_STATS_INC(udp.recv);
80025320:	91 10 00 27 	movh.a %a2,28673
80025324:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025328:	b9 22 3a 10 	ld.hu %d2,[%a2]122 <7001007a <ram_heap+0x4fe6>>
8002532c:	c2 12       	add %d2,1
8002532e:	37 02 70 20 	extr.u %d2,%d2,0,16
80025332:	91 10 00 27 	movh.a %a2,28673
80025336:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002533a:	f9 22 3a 10 	st.h [%a2]122 <7001007a <ram_heap+0x4fe6>>,%d2

  /* Check minimum length (UDP header) */
  if (p->len < UDP_HLEN) {
8002533e:	99 e2 dc ff 	ld.a %a2,[%a14]-36 <7001007a <ram_heap+0x4fe6>>
80025342:	b9 22 0a 00 	ld.hu %d2,[%a2]10 <7001007a <ram_heap+0x4fe6>>
80025346:	ff 82 25 80 	jge.u %d2,8,80025390 <udp_input+0xe6>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
8002534a:	91 10 00 27 	movh.a %a2,28673
8002534e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025352:	b9 22 02 20 	ld.hu %d2,[%a2]130 <70010082 <ram_heap+0x4fee>>
80025356:	c2 12       	add %d2,1
80025358:	37 02 70 20 	extr.u %d2,%d2,0,16
8002535c:	91 10 00 27 	movh.a %a2,28673
80025360:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025364:	f9 22 02 20 	st.h [%a2]130 <70010082 <ram_heap+0x4fee>>,%d2
    UDP_STATS_INC(udp.drop);
80025368:	91 10 00 27 	movh.a %a2,28673
8002536c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025370:	b9 22 3e 10 	ld.hu %d2,[%a2]126 <7001007e <ram_heap+0x4fea>>
80025374:	c2 12       	add %d2,1
80025376:	37 02 70 20 	extr.u %d2,%d2,0,16
8002537a:	91 10 00 27 	movh.a %a2,28673
8002537e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025382:	f9 22 3e 10 	st.h [%a2]126 <7001007e <ram_heap+0x4fea>>,%d2
    MIB2_STATS_INC(mib2.udpinerrors);
    pbuf_free(p);
80025386:	99 e4 dc ff 	ld.a %a4,[%a14]-36 <7001007e <ram_heap+0x4fea>>
8002538a:	6d ff 07 a6 	call 80019f98 <pbuf_free>
    goto end;
8002538e:	00 90       	ret 
  }

  udphdr = (struct udp_hdr *)p->payload;
80025390:	99 e2 dc ff 	ld.a %a2,[%a14]-36
80025394:	b0 42       	add.a %a2,4
80025396:	54 22       	ld.w %d2,[%a2]
80025398:	59 e2 ec ff 	st.w [%a14]-20,%d2

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
8002539c:	91 10 00 27 	movh.a %a2,28673
800253a0:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800253a4:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
800253a8:	54 22       	ld.w %d2,[%a2]
800253aa:	91 10 00 27 	movh.a %a2,28673
800253ae:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800253b2:	54 23       	ld.w %d3,[%a2]
800253b4:	60 34       	mov.a %a4,%d3
800253b6:	02 24       	mov %d4,%d2
800253b8:	6d ff 4a 84 	call 80015c4c <ip4_addr_isbroadcast_u32>
800253bc:	e9 e2 eb ff 	st.b [%a14]-21,%d2

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = lwip_ntohs(udphdr->src);
800253c0:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800253c4:	14 23       	ld.bu %d3,[%a2]
800253c6:	39 22 01 00 	ld.bu %d2,[%a2]1
800253ca:	8f 82 00 20 	sh %d2,%d2,8
800253ce:	a6 32       	or %d2,%d3
800253d0:	37 02 70 20 	extr.u %d2,%d2,0,16
800253d4:	02 24       	mov %d4,%d2
800253d6:	6d ff bf 90 	call 80017554 <lwip_htons>
800253da:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
  dest = lwip_ntohs(udphdr->dest);
800253de:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800253e2:	39 23 02 00 	ld.bu %d3,[%a2]2
800253e6:	39 22 03 00 	ld.bu %d2,[%a2]3
800253ea:	8f 82 00 20 	sh %d2,%d2,8
800253ee:	a6 32       	or %d2,%d3
800253f0:	37 02 70 20 	extr.u %d2,%d2,0,16
800253f4:	02 24       	mov %d4,%d2
800253f6:	6d ff af 90 	call 80017554 <lwip_htons>
800253fa:	f9 e2 e6 ff 	st.h [%a14]-26,%d2
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_dest_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
  ip_addr_debug_print_val(UDP_DEBUG, *ip_current_src_addr());
  LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));

  pcb = NULL;
800253fe:	82 02       	mov %d2,0
80025400:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  prev = NULL;
80025404:	82 02       	mov %d2,0
80025406:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  uncon_pcb = NULL;
8002540a:	82 02       	mov %d2,0
8002540c:	59 e2 fc ff 	st.w [%a14]-4,%d2
  /* Iterate through the UDP pcb list for a matching pcb.
   * 'Perfect match' pcbs (connected to the remote port & ip address) are
   * preferred. If no perfect match is found, the first unconnected pcb that
   * matches the local port and ip address gets the datagram. */
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
80025410:	91 10 00 27 	movh.a %a2,28673
80025414:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025418:	54 22       	ld.w %d2,[%a2]
8002541a:	59 e2 f4 ff 	st.w [%a14]-12 <70014610 <udp_pcbs>>,%d2
8002541e:	1d 00 a4 00 	j 80025566 <udp_input+0x2bc>
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
    ip_addr_debug_print_val(UDP_DEBUG, pcb->remote_ip);
    LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));

    /* compare PCB local addr+port to UDP destination addr+port */
    if ((pcb->local_port == dest) &&
80025422:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025426:	b9 22 12 00 	ld.hu %d2,[%a2]18
8002542a:	b9 e3 e6 ff 	ld.hu %d3,[%a14]-26
8002542e:	5f 23 91 80 	jne %d3,%d2,80025550 <udp_input+0x2a6>
        (udp_input_local_match(pcb, inp, broadcast) != 0)) {
80025432:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80025436:	02 24       	mov %d4,%d2
80025438:	99 e5 d8 ff 	ld.a %a5,[%a14]-40
8002543c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80025440:	6d ff 9c fe 	call 80025178 <udp_input_local_match>
    if ((pcb->local_port == dest) &&
80025444:	df 02 86 00 	jeq %d2,0,80025550 <udp_input+0x2a6>
      if ((pcb->flags & UDP_FLAGS_CONNECTED) == 0) {
80025448:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002544c:	39 22 10 00 	ld.bu %d2,[%a2]16
80025450:	8f 42 00 21 	and %d2,%d2,4
80025454:	df 02 31 80 	jne %d2,0,800254b6 <udp_input+0x20c>
        if (uncon_pcb == NULL) {
80025458:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002545c:	df 02 08 80 	jne %d2,0,8002546c <udp_input+0x1c2>
          /* the first unconnected matching PCB */
          uncon_pcb = pcb;
80025460:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025464:	59 e2 fc ff 	st.w [%a14]-4,%d2
80025468:	1d 00 27 00 	j 800254b6 <udp_input+0x20c>
#if LWIP_IPV4
        } else if (broadcast && ip4_current_dest_addr()->addr == IPADDR_BROADCAST) {
8002546c:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
80025470:	df 02 23 00 	jeq %d2,0,800254b6 <udp_input+0x20c>
80025474:	91 10 00 27 	movh.a %a2,28673
80025478:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
8002547c:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
80025480:	54 22       	ld.w %d2,[%a2]
80025482:	df f2 1a 80 	jne %d2,-1,800254b6 <udp_input+0x20c>
          /* global broadcast address (only valid for IPv4; match was checked before) */
          if (!IP_IS_V4_VAL(uncon_pcb->local_ip) || !ip4_addr_cmp(ip_2_ip4(&uncon_pcb->local_ip), netif_ip4_addr(inp))) {
80025486:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002548a:	54 23       	ld.w %d3,[%a2]
8002548c:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80025490:	60 22       	mov.a %a2,%d2
80025492:	b0 42       	add.a %a2,4
80025494:	54 22       	ld.w %d2,[%a2]
80025496:	5f 23 10 00 	jeq %d3,%d2,800254b6 <udp_input+0x20c>
            /* uncon_pcb does not match the input netif, check this pcb */
            if (IP_IS_V4_VAL(pcb->local_ip) && ip4_addr_cmp(ip_2_ip4(&pcb->local_ip), netif_ip4_addr(inp))) {
8002549a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002549e:	54 23       	ld.w %d3,[%a2]
800254a0:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
800254a4:	60 22       	mov.a %a2,%d2
800254a6:	b0 42       	add.a %a2,4
800254a8:	54 22       	ld.w %d2,[%a2]
800254aa:	5f 23 06 80 	jne %d3,%d2,800254b6 <udp_input+0x20c>
              /* better match */
              uncon_pcb = pcb;
800254ae:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800254b2:	59 e2 fc ff 	st.w [%a14]-4,%d2
        }
#endif /* SO_REUSE */
      }

      /* compare PCB remote addr+port to UDP source addr+port */
      if ((pcb->remote_port == src) &&
800254b6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800254ba:	b9 22 14 00 	ld.hu %d2,[%a2]20
800254be:	b9 e3 e8 ff 	ld.hu %d3,[%a14]-24
800254c2:	5f 23 47 80 	jne %d3,%d2,80025550 <udp_input+0x2a6>
          (ip_addr_isany_val(pcb->remote_ip) ||
800254c6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800254ca:	b0 42       	add.a %a2,4
800254cc:	54 22       	ld.w %d2,[%a2]
      if ((pcb->remote_port == src) &&
800254ce:	df 02 0f 00 	jeq %d2,0,800254ec <udp_input+0x242>
           ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
800254d2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800254d6:	b0 42       	add.a %a2,4
800254d8:	54 23       	ld.w %d3,[%a2]
800254da:	91 10 00 27 	movh.a %a2,28673
800254de:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800254e2:	d9 22 10 00 	lea %a2,[%a2]16 <70010010 <ram_heap+0x4f7c>>
800254e6:	54 22       	ld.w %d2,[%a2]
          (ip_addr_isany_val(pcb->remote_ip) ||
800254e8:	5f 23 34 80 	jne %d3,%d2,80025550 <udp_input+0x2a6>
        /* the first fully matching PCB */
        if (prev != NULL) {
800254ec:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
800254f0:	df 02 1f 00 	jeq %d2,0,8002552e <udp_input+0x284>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
800254f4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800254f8:	d9 22 0c 00 	lea %a2,[%a2]12
800254fc:	54 22       	ld.w %d2,[%a2]
800254fe:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80025502:	d9 22 0c 00 	lea %a2,[%a2]12
80025506:	74 22       	st.w [%a2],%d2
          pcb->next = udp_pcbs;
80025508:	91 10 00 27 	movh.a %a2,28673
8002550c:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025510:	54 22       	ld.w %d2,[%a2]
80025512:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <70014610 <udp_pcbs>>
80025516:	d9 22 0c 00 	lea %a2,[%a2]12 <70014610 <udp_pcbs>>
8002551a:	74 22       	st.w [%a2],%d2
          udp_pcbs = pcb;
8002551c:	91 10 00 27 	movh.a %a2,28673
80025520:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025524:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <70014610 <udp_pcbs>>
80025528:	74 22       	st.w [%a2],%d2
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
8002552a:	1d 00 22 00 	j 8002556e <udp_input+0x2c4>
          UDP_STATS_INC(udp.cachehit);
8002552e:	91 10 00 27 	movh.a %a2,28673
80025532:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025536:	b9 22 0e 20 	ld.hu %d2,[%a2]142 <7001008e <ram_heap+0x4ffa>>
8002553a:	c2 12       	add %d2,1
8002553c:	37 02 70 20 	extr.u %d2,%d2,0,16
80025540:	91 10 00 27 	movh.a %a2,28673
80025544:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025548:	f9 22 0e 20 	st.h [%a2]142 <7001008e <ram_heap+0x4ffa>>,%d2
        break;
8002554c:	1d 00 11 00 	j 8002556e <udp_input+0x2c4>
      }
    }

    prev = pcb;
80025550:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025554:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
80025558:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002555c:	d9 22 0c 00 	lea %a2,[%a2]12
80025560:	54 22       	ld.w %d2,[%a2]
80025562:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80025566:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8002556a:	df 02 5c ff 	jne %d2,0,80025422 <udp_input+0x178>
  }
  /* no fully matching pcb found? then look for an unconnected pcb */
  if (pcb == NULL) {
8002556e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025572:	df 02 06 80 	jne %d2,0,8002557e <udp_input+0x2d4>
    pcb = uncon_pcb;
80025576:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002557a:	59 e2 f4 ff 	st.w [%a14]-12,%d2
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL) {
8002557e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025582:	df 02 07 00 	jeq %d2,0,80025590 <udp_input+0x2e6>
    for_us = 1;
80025586:	82 12       	mov %d2,1
80025588:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
8002558c:	1d 00 14 00 	j 800255b4 <udp_input+0x30a>
      for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
    }
#endif /* LWIP_IPV6 */
#if LWIP_IPV4
    if (!ip_current_is_v6()) {
      for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
80025590:	19 e2 d8 ff 	ld.w %d2,[%a14]-40
80025594:	60 22       	mov.a %a2,%d2
80025596:	b0 42       	add.a %a2,4
80025598:	54 22       	ld.w %d2,[%a2]
8002559a:	91 10 00 27 	movh.a %a2,28673
8002559e:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800255a2:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
800255a6:	54 23       	ld.w %d3,[%a2]
800255a8:	0b 32 00 21 	eq %d2,%d2,%d3
800255ac:	8f f2 0f 21 	and %d2,%d2,255
800255b0:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
    }
#endif /* LWIP_IPV4 */
  }

  if (for_us) {
800255b4:	39 e2 f3 ff 	ld.bu %d2,[%a14]-13
800255b8:	df 02 c8 00 	jeq %d2,0,80025748 <udp_input+0x49e>
          goto chkerr;
        }
      } else
#endif /* LWIP_UDPLITE */
      {
        if (udphdr->chksum != 0) {
800255bc:	99 e2 ec ff 	ld.a %a2,[%a14]-20
800255c0:	39 23 06 00 	ld.bu %d3,[%a2]6
800255c4:	39 22 07 00 	ld.bu %d2,[%a2]7
800255c8:	8f 82 00 20 	sh %d2,%d2,8
800255cc:	a6 32       	or %d2,%d3
800255ce:	37 02 70 20 	extr.u %d2,%d2,0,16
800255d2:	df 02 17 00 	jeq %d2,0,80025600 <udp_input+0x356>
          if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
800255d6:	99 e2 dc ff 	ld.a %a2,[%a14]-36
800255da:	b9 22 08 00 	ld.hu %d2,[%a2]8
800255de:	91 10 00 27 	movh.a %a2,28673
800255e2:	d9 26 10 2b 	lea %a6,[%a2]-20336 <7000b090 <ip_data+0x14>>
800255e6:	91 10 00 27 	movh.a %a2,28673
800255ea:	d9 25 0c 2b 	lea %a5,[%a2]-20340 <7000b08c <ip_data+0x10>>
800255ee:	02 25       	mov %d5,%d2
800255f0:	3b 10 01 40 	mov %d4,17
800255f4:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800255f8:	6d ff 78 91 	call 800178e8 <ip_chksum_pseudo>
800255fc:	df 02 ab 80 	jne %d2,0,80025752 <udp_input+0x4a8>
          }
        }
      }
    }
#endif /* CHECKSUM_CHECK_UDP */
    if (pbuf_remove_header(p, UDP_HLEN)) {
80025600:	3b 80 00 40 	mov %d4,8
80025604:	99 e4 dc ff 	ld.a %a4,[%a14]-36
80025608:	6d ff 02 a4 	call 80019e0c <pbuf_remove_header>
8002560c:	df 02 2b 00 	jeq %d2,0,80025662 <udp_input+0x3b8>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_remove_header failed\n", 0);
80025610:	91 00 00 28 	movh.a %a2,32768
80025614:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025618:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
8002561c:	3b 00 17 20 	mov %d2,368
80025620:	59 a2 04 00 	st.w [%sp]4,%d2
80025624:	91 00 00 28 	movh.a %a2,32768
80025628:	d9 22 3b e3 	lea %a2,[%a2]13243 <800033bb <IfxCpu_Trap_vectorTable0_end+0x31c7>>
8002562c:	f4 a2       	st.a [%sp],%a2
8002562e:	91 00 00 28 	movh.a %a2,32768
80025632:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025636:	6d fe 80 fe 	call 80005336 <Ifx_Lwip_printf>
      UDP_STATS_INC(udp.drop);
8002563a:	91 10 00 27 	movh.a %a2,28673
8002563e:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025642:	b9 22 3e 10 	ld.hu %d2,[%a2]126 <7001007e <ram_heap+0x4fea>>
80025646:	c2 12       	add %d2,1
80025648:	37 02 70 20 	extr.u %d2,%d2,0,16
8002564c:	91 10 00 27 	movh.a %a2,28673
80025650:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025654:	f9 22 3e 10 	st.h [%a2]126 <7001007e <ram_heap+0x4fea>>,%d2
      MIB2_STATS_INC(mib2.udpinerrors);
      pbuf_free(p);
80025658:	99 e4 dc ff 	ld.a %a4,[%a14]-36 <7001007e <ram_heap+0x4fea>>
8002565c:	6d ff 9e a4 	call 80019f98 <pbuf_free>
      goto end;
80025660:	00 90       	ret 
    }

    if (pcb != NULL) {
80025662:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025666:	df 02 27 00 	jeq %d2,0,800256b4 <udp_input+0x40a>
          }
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
8002566a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002566e:	d9 22 18 00 	lea %a2,[%a2]24
80025672:	54 22       	ld.w %d2,[%a2]
80025674:	df 02 1b 00 	jeq %d2,0,800256aa <udp_input+0x400>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
80025678:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002567c:	d9 22 18 00 	lea %a2,[%a2]24
80025680:	d4 23       	ld.a %a3,[%a2]
80025682:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025686:	d9 22 1c 00 	lea %a2,[%a2]28
8002568a:	54 23       	ld.w %d3,[%a2]
8002568c:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
80025690:	02 24       	mov %d4,%d2
80025692:	91 10 00 27 	movh.a %a2,28673
80025696:	d9 27 0c 2b 	lea %a7,[%a2]-20340 <7000b08c <ip_data+0x10>>
8002569a:	99 e6 dc ff 	ld.a %a6,[%a14]-36 <7000b08c <ip_data+0x10>>
8002569e:	99 e5 f4 ff 	ld.a %a5,[%a14]-12 <7000b08c <ip_data+0x10>>
800256a2:	60 34       	mov.a %a4,%d3
800256a4:	2d 03 00 00 	calli %a3
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
  return;
800256a8:	00 90       	ret 
        pbuf_free(p);
800256aa:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800256ae:	6d ff 75 a4 	call 80019f98 <pbuf_free>
        goto end;
800256b2:	00 90       	ret 
      if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
800256b4:	39 e2 eb ff 	ld.bu %d2,[%a14]-21
800256b8:	df 02 25 80 	jne %d2,0,80025702 <udp_input+0x458>
800256bc:	91 10 00 27 	movh.a %a2,28673
800256c0:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800256c4:	d9 22 14 00 	lea %a2,[%a2]20 <70010014 <ram_heap+0x4f80>>
800256c8:	54 22       	ld.w %d2,[%a2]
800256ca:	8f 02 0f 21 	and %d2,%d2,240
800256ce:	8b 02 0e 22 	eq %d2,%d2,224
800256d2:	df 02 18 80 	jne %d2,0,80025702 <udp_input+0x458>
        pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
800256d6:	91 10 00 27 	movh.a %a2,28673
800256da:	d9 22 3c 1b 	lea %a2,[%a2]-20356 <7000b07c <ip_data>>
800256de:	b9 22 0c 00 	ld.hu %d2,[%a2]12 <7001000c <ram_heap+0x4f78>>
800256e2:	1b 82 00 20 	addi %d2,%d2,8
800256e6:	37 02 70 20 	extr.u %d2,%d2,0,16
800256ea:	37 02 50 20 	extr %d2,%d2,0,16
800256ee:	02 24       	mov %d4,%d2
800256f0:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800256f4:	6d ff 42 a4 	call 80019f78 <pbuf_header_force>
        icmp_port_unreach(ip_current_is_v6(), p);
800256f8:	82 34       	mov %d4,3
800256fa:	99 e4 dc ff 	ld.a %a4,[%a14]-36
800256fe:	6d ff ed 7a 	call 80014cd8 <icmp_dest_unreach>
      UDP_STATS_INC(udp.proterr);
80025702:	91 10 00 27 	movh.a %a2,28673
80025706:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002570a:	b9 22 08 20 	ld.hu %d2,[%a2]136 <70010088 <ram_heap+0x4ff4>>
8002570e:	c2 12       	add %d2,1
80025710:	37 02 70 20 	extr.u %d2,%d2,0,16
80025714:	91 10 00 27 	movh.a %a2,28673
80025718:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002571c:	f9 22 08 20 	st.h [%a2]136 <70010088 <ram_heap+0x4ff4>>,%d2
      UDP_STATS_INC(udp.drop);
80025720:	91 10 00 27 	movh.a %a2,28673
80025724:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025728:	b9 22 3e 10 	ld.hu %d2,[%a2]126 <7001007e <ram_heap+0x4fea>>
8002572c:	c2 12       	add %d2,1
8002572e:	37 02 70 20 	extr.u %d2,%d2,0,16
80025732:	91 10 00 27 	movh.a %a2,28673
80025736:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002573a:	f9 22 3e 10 	st.h [%a2]126 <7001007e <ram_heap+0x4fea>>,%d2
      pbuf_free(p);
8002573e:	99 e4 dc ff 	ld.a %a4,[%a14]-36 <7001007e <ram_heap+0x4fea>>
80025742:	6d ff 2b a4 	call 80019f98 <pbuf_free>
  return;
80025746:	00 90       	ret 
    pbuf_free(p);
80025748:	99 e4 dc ff 	ld.a %a4,[%a14]-36
8002574c:	6d ff 26 a4 	call 80019f98 <pbuf_free>
  return;
80025750:	00 90       	ret 
            goto chkerr;
80025752:	00 00       	nop 
#if CHECKSUM_CHECK_UDP
chkerr:
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
              ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
  UDP_STATS_INC(udp.chkerr);
80025754:	91 10 00 27 	movh.a %a2,28673
80025758:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002575c:	b9 22 00 20 	ld.hu %d2,[%a2]128 <70010080 <ram_heap+0x4fec>>
80025760:	c2 12       	add %d2,1
80025762:	37 02 70 20 	extr.u %d2,%d2,0,16
80025766:	91 10 00 27 	movh.a %a2,28673
8002576a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002576e:	f9 22 00 20 	st.h [%a2]128 <70010080 <ram_heap+0x4fec>>,%d2
  UDP_STATS_INC(udp.drop);
80025772:	91 10 00 27 	movh.a %a2,28673
80025776:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002577a:	b9 22 3e 10 	ld.hu %d2,[%a2]126 <7001007e <ram_heap+0x4fea>>
8002577e:	c2 12       	add %d2,1
80025780:	37 02 70 20 	extr.u %d2,%d2,0,16
80025784:	91 10 00 27 	movh.a %a2,28673
80025788:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
8002578c:	f9 22 3e 10 	st.h [%a2]126 <7001007e <ram_heap+0x4fea>>,%d2
  MIB2_STATS_INC(mib2.udpinerrors);
  pbuf_free(p);
80025790:	99 e4 dc ff 	ld.a %a4,[%a14]-36 <7001007e <ram_heap+0x4fea>>
80025794:	6d ff 02 a4 	call 80019f98 <pbuf_free>
  PERF_STOP("udp_input");
#endif /* CHECKSUM_CHECK_UDP */
}
80025798:	00 90       	ret 

8002579a <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
              const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
8002579a:	40 ae       	mov.aa %a14,%sp
8002579c:	20 30       	sub.a %sp,48
8002579e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
800257a2:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
800257a6:	b5 e6 ec ff 	st.a [%a14]-20,%a6
800257aa:	02 42       	mov %d2,%d4
800257ac:	b5 e7 e4 ff 	st.a [%a14]-28,%a7
800257b0:	f9 e2 e8 ff 	st.h [%a14]-24,%d2
                     u16_t chksum)
{
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  const ip_addr_t *src_ip;

  LWIP_ERROR("udp_sendto_if: invalid pcb", pcb != NULL, return ERR_ARG);
800257b4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800257b8:	df 02 1a 80 	jne %d2,0,800257ec <udp_sendto_if+0x52>
800257bc:	91 00 00 28 	movh.a %a2,32768
800257c0:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
800257c4:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
800257c8:	3b 00 28 20 	mov %d2,640
800257cc:	59 a2 04 00 	st.w [%sp]4,%d2
800257d0:	91 00 00 28 	movh.a %a2,32768
800257d4:	d9 22 4f 13 	lea %a2,[%a2]13391 <8000344f <IfxCpu_Trap_vectorTable0_end+0x325b>>
800257d8:	f4 a2       	st.a [%sp],%a2
800257da:	91 00 00 28 	movh.a %a2,32768
800257de:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
800257e2:	6d fe aa fd 	call 80005336 <Ifx_Lwip_printf>
800257e6:	3b 00 ff 2f 	mov %d2,-16
800257ea:	00 90       	ret 
  LWIP_ERROR("udp_sendto_if: invalid pbuf", p != NULL, return ERR_ARG);
800257ec:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800257f0:	df 02 1a 80 	jne %d2,0,80025824 <udp_sendto_if+0x8a>
800257f4:	91 00 00 28 	movh.a %a2,32768
800257f8:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
800257fc:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025800:	3b 10 28 20 	mov %d2,641
80025804:	59 a2 04 00 	st.w [%sp]4,%d2
80025808:	91 00 00 28 	movh.a %a2,32768
8002580c:	d9 22 6a 13 	lea %a2,[%a2]13418 <8000346a <IfxCpu_Trap_vectorTable0_end+0x3276>>
80025810:	f4 a2       	st.a [%sp],%a2
80025812:	91 00 00 28 	movh.a %a2,32768
80025816:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
8002581a:	6d fe 8e fd 	call 80005336 <Ifx_Lwip_printf>
8002581e:	3b 00 ff 2f 	mov %d2,-16
80025822:	00 90       	ret 
  LWIP_ERROR("udp_sendto_if: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
80025824:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80025828:	df 02 1a 80 	jne %d2,0,8002585c <udp_sendto_if+0xc2>
8002582c:	91 00 00 28 	movh.a %a2,32768
80025830:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025834:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025838:	3b 20 28 20 	mov %d2,642
8002583c:	59 a2 04 00 	st.w [%sp]4,%d2
80025840:	91 00 00 28 	movh.a %a2,32768
80025844:	d9 22 46 23 	lea %a2,[%a2]13446 <80003486 <IfxCpu_Trap_vectorTable0_end+0x3292>>
80025848:	f4 a2       	st.a [%sp],%a2
8002584a:	91 00 00 28 	movh.a %a2,32768
8002584e:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025852:	6d fe 72 fd 	call 80005336 <Ifx_Lwip_printf>
80025856:	3b 00 ff 2f 	mov %d2,-16
8002585a:	00 90       	ret 
  LWIP_ERROR("udp_sendto_if: invalid netif", netif != NULL, return ERR_ARG);
8002585c:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80025860:	df 02 1a 80 	jne %d2,0,80025894 <udp_sendto_if+0xfa>
80025864:	91 00 00 28 	movh.a %a2,32768
80025868:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
8002586c:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025870:	3b 30 28 20 	mov %d2,643
80025874:	59 a2 04 00 	st.w [%sp]4,%d2
80025878:	91 00 00 28 	movh.a %a2,32768
8002587c:	d9 22 64 23 	lea %a2,[%a2]13476 <800034a4 <IfxCpu_Trap_vectorTable0_end+0x32b0>>
80025880:	f4 a2       	st.a [%sp],%a2
80025882:	91 00 00 28 	movh.a %a2,32768
80025886:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
8002588a:	6d fe 56 fd 	call 80005336 <Ifx_Lwip_printf>
8002588e:	3b 00 ff 2f 	mov %d2,-16
80025892:	00 90       	ret 
#endif /* LWIP_IPV6 */
#if LWIP_IPV4 && LWIP_IPV6
  else
#endif /* LWIP_IPV4 && LWIP_IPV6 */
#if LWIP_IPV4
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
80025894:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025898:	df 02 10 00 	jeq %d2,0,800258b8 <udp_sendto_if+0x11e>
8002589c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800258a0:	54 22       	ld.w %d2,[%a2]
800258a2:	df 02 0b 00 	jeq %d2,0,800258b8 <udp_sendto_if+0x11e>
        ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
800258a6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800258aa:	54 22       	ld.w %d2,[%a2]
800258ac:	8f 02 0f 21 	and %d2,%d2,240
    if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
800258b0:	8b 02 2e 22 	ne %d2,%d2,224
800258b4:	df 02 09 80 	jne %d2,0,800258c6 <udp_sendto_if+0x12c>
      /* if the local_ip is any or multicast
       * use the outgoing network interface IP address as source address */
      src_ip = netif_ip_addr4(netif);
800258b8:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800258bc:	c2 42       	add %d2,4
800258be:	59 e2 fc ff 	st.w [%a14]-4,%d2
800258c2:	1d 00 12 00 	j 800258e6 <udp_sendto_if+0x14c>
    } else {
      /* check if UDP PCB local IP address is correct
       * this could be an old address if netif->ip_addr has changed */
      if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
800258c6:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800258ca:	54 23       	ld.w %d3,[%a2]
800258cc:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800258d0:	60 22       	mov.a %a2,%d2
800258d2:	b0 42       	add.a %a2,4
800258d4:	54 22       	ld.w %d2,[%a2]
800258d6:	5f 23 04 00 	jeq %d3,%d2,800258de <udp_sendto_if+0x144>
        /* local_ip doesn't match, drop the packet */
        return ERR_RTE;
800258da:	82 c2       	mov %d2,-4
800258dc:	00 90       	ret 
      }
      /* use UDP PCB local IP address as source address */
      src_ip = &pcb->local_ip;
800258de:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800258e2:	59 e2 fc ff 	st.w [%a14]-4,%d2
    }
#endif /* LWIP_IPV4 */
#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
  return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
#else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
  return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
800258e6:	b9 e2 e8 ff 	ld.hu %d2,[%a14]-24
800258ea:	19 e3 fc ff 	ld.w %d3,[%a14]-4
800258ee:	74 a3       	st.w [%sp],%d3
800258f0:	99 e7 e4 ff 	ld.a %a7,[%a14]-28
800258f4:	02 24       	mov %d4,%d2
800258f6:	99 e6 ec ff 	ld.a %a6,[%a14]-20
800258fa:	99 e5 f0 ff 	ld.a %a5,[%a14]-16
800258fe:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80025902:	6d 00 03 00 	call 80025908 <udp_sendto_if_src>
#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
}
80025906:	00 90       	ret 

80025908 <udp_sendto_if_src>:
/** @ingroup udp_raw
 * Same as @ref udp_sendto_if, but with source address */
err_t
udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
                  const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *src_ip)
{
80025908:	40 ae       	mov.aa %a14,%sp
8002590a:	20 40       	sub.a %sp,64
8002590c:	b5 e4 e4 ff 	st.a [%a14]-28,%a4
80025910:	b5 e5 e0 ff 	st.a [%a14]-32,%a5
80025914:	b5 e6 dc ff 	st.a [%a14]-36,%a6
80025918:	02 42       	mov %d2,%d4
8002591a:	b5 e7 d4 ff 	st.a [%a14]-44,%a7
8002591e:	f9 e2 d8 ff 	st.h [%a14]-40,%d2
  u8_t ip_proto;
  u8_t ttl;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_sendto_if_src: invalid pcb", pcb != NULL, return ERR_ARG);
80025922:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80025926:	df 02 1a 80 	jne %d2,0,8002595a <udp_sendto_if_src+0x52>
8002592a:	91 00 00 28 	movh.a %a2,32768
8002592e:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025932:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025936:	3b 10 2d 20 	mov %d2,721
8002593a:	59 a2 04 00 	st.w [%sp]4,%d2
8002593e:	91 00 00 28 	movh.a %a2,32768
80025942:	d9 22 41 33 	lea %a2,[%a2]13505 <800034c1 <IfxCpu_Trap_vectorTable0_end+0x32cd>>
80025946:	f4 a2       	st.a [%sp],%a2
80025948:	91 00 00 28 	movh.a %a2,32768
8002594c:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025950:	6d fe f3 fc 	call 80005336 <Ifx_Lwip_printf>
80025954:	3b 00 ff 2f 	mov %d2,-16
80025958:	00 90       	ret 
  LWIP_ERROR("udp_sendto_if_src: invalid pbuf", p != NULL, return ERR_ARG);
8002595a:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
8002595e:	df 02 1a 80 	jne %d2,0,80025992 <udp_sendto_if_src+0x8a>
80025962:	91 00 00 28 	movh.a %a2,32768
80025966:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
8002596a:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
8002596e:	3b 20 2d 20 	mov %d2,722
80025972:	59 a2 04 00 	st.w [%sp]4,%d2
80025976:	91 00 00 28 	movh.a %a2,32768
8002597a:	d9 22 60 33 	lea %a2,[%a2]13536 <800034e0 <IfxCpu_Trap_vectorTable0_end+0x32ec>>
8002597e:	f4 a2       	st.a [%sp],%a2
80025980:	91 00 00 28 	movh.a %a2,32768
80025984:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025988:	6d fe d7 fc 	call 80005336 <Ifx_Lwip_printf>
8002598c:	3b 00 ff 2f 	mov %d2,-16
80025990:	00 90       	ret 
  LWIP_ERROR("udp_sendto_if_src: invalid dst_ip", dst_ip != NULL, return ERR_ARG);
80025992:	19 e2 dc ff 	ld.w %d2,[%a14]-36
80025996:	df 02 1a 80 	jne %d2,0,800259ca <udp_sendto_if_src+0xc2>
8002599a:	91 00 00 28 	movh.a %a2,32768
8002599e:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
800259a2:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
800259a6:	3b 30 2d 20 	mov %d2,723
800259aa:	59 a2 04 00 	st.w [%sp]4,%d2
800259ae:	91 00 00 28 	movh.a %a2,32768
800259b2:	d9 22 40 43 	lea %a2,[%a2]13568 <80003500 <IfxCpu_Trap_vectorTable0_end+0x330c>>
800259b6:	f4 a2       	st.a [%sp],%a2
800259b8:	91 00 00 28 	movh.a %a2,32768
800259bc:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
800259c0:	6d fe bb fc 	call 80005336 <Ifx_Lwip_printf>
800259c4:	3b 00 ff 2f 	mov %d2,-16
800259c8:	00 90       	ret 
  LWIP_ERROR("udp_sendto_if_src: invalid src_ip", src_ip != NULL, return ERR_ARG);
800259ca:	54 e2       	ld.w %d2,[%a14]
800259cc:	df 02 1a 80 	jne %d2,0,80025a00 <udp_sendto_if_src+0xf8>
800259d0:	91 00 00 28 	movh.a %a2,32768
800259d4:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
800259d8:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
800259dc:	3b 40 2d 20 	mov %d2,724
800259e0:	59 a2 04 00 	st.w [%sp]4,%d2
800259e4:	91 00 00 28 	movh.a %a2,32768
800259e8:	d9 22 62 43 	lea %a2,[%a2]13602 <80003522 <IfxCpu_Trap_vectorTable0_end+0x332e>>
800259ec:	f4 a2       	st.a [%sp],%a2
800259ee:	91 00 00 28 	movh.a %a2,32768
800259f2:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
800259f6:	6d fe a0 fc 	call 80005336 <Ifx_Lwip_printf>
800259fa:	3b 00 ff 2f 	mov %d2,-16
800259fe:	00 90       	ret 
  LWIP_ERROR("udp_sendto_if_src: invalid netif", netif != NULL, return ERR_ARG);
80025a00:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
80025a04:	df 02 1a 80 	jne %d2,0,80025a38 <udp_sendto_if_src+0x130>
80025a08:	91 00 00 28 	movh.a %a2,32768
80025a0c:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025a10:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025a14:	3b 50 2d 20 	mov %d2,725
80025a18:	59 a2 04 00 	st.w [%sp]4,%d2
80025a1c:	91 00 00 28 	movh.a %a2,32768
80025a20:	d9 22 44 53 	lea %a2,[%a2]13636 <80003544 <IfxCpu_Trap_vectorTable0_end+0x3350>>
80025a24:	f4 a2       	st.a [%sp],%a2
80025a26:	91 00 00 28 	movh.a %a2,32768
80025a2a:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025a2e:	6d fe 84 fc 	call 80005336 <Ifx_Lwip_printf>
80025a32:	3b 00 ff 2f 	mov %d2,-16
80025a36:	00 90       	ret 
    return ERR_VAL;
  }
#endif /* LWIP_IPV4 && IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
80025a38:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80025a3c:	b9 22 12 00 	ld.hu %d2,[%a2]18
80025a40:	df 02 17 80 	jne %d2,0,80025a6e <udp_sendto_if_src+0x166>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
80025a44:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80025a48:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80025a4c:	b9 23 12 00 	ld.hu %d3,[%a2]18
80025a50:	02 34       	mov %d4,%d3
80025a52:	60 25       	mov.a %a5,%d2
80025a54:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80025a58:	6d 00 19 01 	call 80025c8a <udp_bind>
80025a5c:	e9 e2 f7 ff 	st.b [%a14]-9,%d2
    if (err != ERR_OK) {
80025a60:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
80025a64:	df 02 05 00 	jeq %d2,0,80025a6e <udp_sendto_if_src+0x166>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
80025a68:	79 e2 f7 ff 	ld.b %d2,[%a14]-9
80025a6c:	00 90       	ret 
    }
  }

  /* packet too large to add a UDP header without causing an overflow? */
  if ((u16_t)(p->tot_len + UDP_HLEN) < p->tot_len) {
80025a6e:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80025a72:	b9 22 08 00 	ld.hu %d2,[%a2]8
80025a76:	bb 80 ff 3f 	mov.u %d3,65528
80025a7a:	3f 32 04 80 	jlt.u %d2,%d3,80025a82 <udp_sendto_if_src+0x17a>
    return ERR_MEM;
80025a7e:	82 f2       	mov %d2,-1
80025a80:	00 90       	ret 
  }
  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_add_header(p, UDP_HLEN)) {
80025a82:	3b 80 00 40 	mov %d4,8
80025a86:	99 e4 e0 ff 	ld.a %a4,[%a14]-32
80025a8a:	6d ff b3 a1 	call 80019df0 <pbuf_add_header>
80025a8e:	df 02 20 00 	jeq %d2,0,80025ace <udp_sendto_if_src+0x1c6>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
80025a92:	3b 00 28 60 	mov %d6,640
80025a96:	3b 80 00 50 	mov %d5,8
80025a9a:	3b 40 02 40 	mov %d4,36
80025a9e:	6d ff 21 9e 	call 800196e0 <pbuf_alloc>
80025aa2:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
80025aa6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80025aaa:	df 02 04 80 	jne %d2,0,80025ab2 <udp_sendto_if_src+0x1aa>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
80025aae:	82 f2       	mov %d2,-1
80025ab0:	00 90       	ret 
    }
    if (p->tot_len != 0) {
80025ab2:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
80025ab6:	b9 22 08 00 	ld.hu %d2,[%a2]8
80025aba:	df 02 0e 00 	jeq %d2,0,80025ad6 <udp_sendto_if_src+0x1ce>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
80025abe:	99 e5 e0 ff 	ld.a %a5,[%a14]-32
80025ac2:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80025ac6:	6d ff 27 a4 	call 8001a314 <pbuf_chain>
80025aca:	1d 00 06 00 	j 80025ad6 <udp_sendto_if_src+0x1ce>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
80025ace:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80025ad2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
80025ad6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80025ada:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80025ade:	ff 82 17 80 	jge.u %d2,8,80025b0c <udp_sendto_if_src+0x204>
80025ae2:	91 00 00 28 	movh.a %a2,32768
80025ae6:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025aea:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025aee:	3b d0 30 20 	mov %d2,781
80025af2:	59 a2 04 00 	st.w [%sp]4,%d2
80025af6:	91 00 00 28 	movh.a %a2,32768
80025afa:	d9 22 65 53 	lea %a2,[%a2]13669 <80003565 <IfxCpu_Trap_vectorTable0_end+0x3371>>
80025afe:	f4 a2       	st.a [%sp],%a2
80025b00:	91 00 00 28 	movh.a %a2,32768
80025b04:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025b08:	6d fe 17 fc 	call 80005336 <Ifx_Lwip_printf>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
80025b0c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80025b10:	b0 42       	add.a %a2,4
80025b12:	54 22       	ld.w %d2,[%a2]
80025b14:	59 e2 f0 ff 	st.w [%a14]-16,%d2
  udphdr->src = lwip_htons(pcb->local_port);
80025b18:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80025b1c:	b9 22 12 00 	ld.hu %d2,[%a2]18
80025b20:	02 24       	mov %d4,%d2
80025b22:	6d ff 19 8d 	call 80017554 <lwip_htons>
80025b26:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025b2a:	8f f2 0f 31 	and %d3,%d2,255
80025b2e:	82 04       	mov %d4,0
80025b30:	a6 43       	or %d3,%d4
80025b32:	34 23       	st.b [%a2],%d3
80025b34:	06 82       	sh %d2,-8
80025b36:	37 02 70 20 	extr.u %d2,%d2,0,16
80025b3a:	82 03       	mov %d3,0
80025b3c:	a6 32       	or %d2,%d3
80025b3e:	e9 22 01 00 	st.b [%a2]1,%d2
  udphdr->dest = lwip_htons(dst_port);
80025b42:	b9 e2 d8 ff 	ld.hu %d2,[%a14]-40
80025b46:	02 24       	mov %d4,%d2
80025b48:	6d ff 06 8d 	call 80017554 <lwip_htons>
80025b4c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025b50:	8f f2 0f 31 	and %d3,%d2,255
80025b54:	82 04       	mov %d4,0
80025b56:	a6 43       	or %d3,%d4
80025b58:	e9 23 02 00 	st.b [%a2]2,%d3
80025b5c:	06 82       	sh %d2,-8
80025b5e:	37 02 70 20 	extr.u %d2,%d2,0,16
80025b62:	82 03       	mov %d3,0
80025b64:	a6 32       	or %d2,%d3
80025b66:	e9 22 03 00 	st.b [%a2]3,%d2
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000;
80025b6a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025b6e:	82 02       	mov %d2,0
80025b70:	e9 22 06 00 	st.b [%a2]6,%d2
80025b74:	82 02       	mov %d2,0
80025b76:	e9 22 07 00 	st.b [%a2]7,%d2
    ip_proto = IP_PROTO_UDPLITE;
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = lwip_htons(q->tot_len);
80025b7a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80025b7e:	b9 22 08 00 	ld.hu %d2,[%a2]8
80025b82:	02 24       	mov %d4,%d2
80025b84:	6d ff e8 8c 	call 80017554 <lwip_htons>
80025b88:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025b8c:	8f f2 0f 31 	and %d3,%d2,255
80025b90:	82 04       	mov %d4,0
80025b92:	a6 43       	or %d3,%d4
80025b94:	e9 23 04 00 	st.b [%a2]4,%d3
80025b98:	06 82       	sh %d2,-8
80025b9a:	37 02 70 20 	extr.u %d2,%d2,0,16
80025b9e:	82 03       	mov %d3,0
80025ba0:	a6 32       	or %d2,%d3
80025ba2:	e9 22 05 00 	st.b [%a2]5,%d2
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
      /* Checksum is mandatory over IPv6. */
      if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
80025ba6:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80025baa:	39 22 10 00 	ld.bu %d2,[%a2]16
80025bae:	8f 12 00 21 	and %d2,%d2,1
80025bb2:	df 02 2c 80 	jne %d2,0,80025c0a <udp_sendto_if_src+0x302>
          acc = udpchksum + (u16_t)~(chksum);
          udpchksum = FOLD_U32T(acc);
        } else
#endif /* LWIP_CHECKSUM_ON_COPY */
        {
          udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
80025bb6:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80025bba:	b9 22 08 00 	ld.hu %d2,[%a2]8
80025bbe:	99 e6 dc ff 	ld.a %a6,[%a14]-36
80025bc2:	d4 e5       	ld.a %a5,[%a14]
80025bc4:	02 25       	mov %d5,%d2
80025bc6:	3b 10 01 40 	mov %d4,17
80025bca:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80025bce:	6d ff 8d 8e 	call 800178e8 <ip_chksum_pseudo>
80025bd2:	f9 e2 fe ff 	st.h [%a14]-2,%d2
                                       src_ip, dst_ip);
        }

        /* chksum zero must become 0xffff, as zero means 'no checksum' */
        if (udpchksum == 0x0000) {
80025bd6:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80025bda:	df 02 05 80 	jne %d2,0,80025be4 <udp_sendto_if_src+0x2dc>
          udpchksum = 0xffff;
80025bde:	82 f2       	mov %d2,-1
80025be0:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        }
        udphdr->chksum = udpchksum;
80025be4:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025be8:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80025bec:	8f f2 0f 21 	and %d2,%d2,255
80025bf0:	82 03       	mov %d3,0
80025bf2:	a6 32       	or %d2,%d3
80025bf4:	e9 22 06 00 	st.b [%a2]6,%d2
80025bf8:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80025bfc:	06 82       	sh %d2,-8
80025bfe:	37 02 70 20 	extr.u %d2,%d2,0,16
80025c02:	82 03       	mov %d3,0
80025c04:	a6 32       	or %d2,%d3
80025c06:	e9 22 07 00 	st.b [%a2]7,%d2
      }
    }
#endif /* CHECKSUM_GEN_UDP */
    ip_proto = IP_PROTO_UDP;
80025c0a:	3b 10 01 20 	mov %d2,17
80025c0e:	e9 e2 ef ff 	st.b [%a14]-17,%d2

  /* Determine TTL to use */
#if LWIP_MULTICAST_TX_OPTIONS
  ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
#else /* LWIP_MULTICAST_TX_OPTIONS */
  ttl = pcb->ttl;
80025c12:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80025c16:	79 22 0b 00 	ld.b %d2,[%a2]11
80025c1a:	e9 e2 ee ff 	st.b [%a14]-18,%d2

  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
  LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
  /* output to IP */
  NETIF_SET_HINTS(netif, &(pcb->netif_hints));
  err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
80025c1e:	39 e2 ee ff 	ld.bu %d2,[%a14]-18
80025c22:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80025c26:	39 23 0a 00 	ld.bu %d3,[%a2]10
80025c2a:	02 34       	mov %d4,%d3
80025c2c:	39 e3 ef ff 	ld.bu %d3,[%a14]-17
80025c30:	99 e7 d4 ff 	ld.a %a7,[%a14]-44
80025c34:	02 36       	mov %d6,%d3
80025c36:	02 45       	mov %d5,%d4
80025c38:	02 24       	mov %d4,%d2
80025c3a:	99 e6 dc ff 	ld.a %a6,[%a14]-36
80025c3e:	d4 e5       	ld.a %a5,[%a14]
80025c40:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80025c44:	6d ff 49 7d 	call 800156d6 <ip4_output_if_src>
80025c48:	e9 e2 f7 ff 	st.b [%a14]-9,%d2

  /* @todo: must this be increased even if error occurred? */
  MIB2_STATS_INC(mib2.udpoutdatagrams);

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
80025c4c:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80025c50:	19 e2 e0 ff 	ld.w %d2,[%a14]-32
80025c54:	5f 23 09 00 	jeq %d3,%d2,80025c66 <udp_sendto_if_src+0x35e>
    /* free the header pbuf */
    pbuf_free(q);
80025c58:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80025c5c:	6d ff 9e a1 	call 80019f98 <pbuf_free>
    q = NULL;
80025c60:	82 02       	mov %d2,0
80025c62:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
80025c66:	91 10 00 27 	movh.a %a2,28673
80025c6a:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025c6e:	b9 22 38 10 	ld.hu %d2,[%a2]120 <70010078 <ram_heap+0x4fe4>>
80025c72:	c2 12       	add %d2,1
80025c74:	37 02 70 20 	extr.u %d2,%d2,0,16
80025c78:	91 10 00 27 	movh.a %a2,28673
80025c7c:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80025c80:	f9 22 38 10 	st.h [%a2]120 <70010078 <ram_heap+0x4fe4>>,%d2
  return err;
80025c84:	79 e2 f7 ff 	ld.b %d2,[%a14]-9 <70010078 <ram_heap+0x4fe4>>
}
80025c88:	00 90       	ret 

80025c8a <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
80025c8a:	40 ae       	mov.aa %a14,%sp
80025c8c:	20 28       	sub.a %sp,40
80025c8e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80025c92:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
80025c96:	02 42       	mov %d2,%d4
80025c98:	f9 e2 ec ff 	st.h [%a14]-20,%d2

  LWIP_ASSERT_CORE_LOCKED();

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
  if (ipaddr == NULL) {
80025c9c:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80025ca0:	df 02 08 80 	jne %d2,0,80025cb0 <udp_bind+0x26>
    ipaddr = IP4_ADDR_ANY;
80025ca4:	91 00 00 28 	movh.a %a2,32768
80025ca8:	d9 22 5c 44 	lea %a2,[%a2]17692 <8000451c <ip_addr_any>>
80025cac:	b5 e2 f0 ff 	st.a [%a14]-16 <8000451c <ip_addr_any>>,%a2
  }
#else /* LWIP_IPV4 */
  LWIP_ERROR("udp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
#endif /* LWIP_IPV4 */

  LWIP_ERROR("udp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
80025cb0:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <8000451c <ip_addr_any>>
80025cb4:	df 02 1a 80 	jne %d2,0,80025ce8 <udp_bind+0x5e>
80025cb8:	91 00 00 28 	movh.a %a2,32768
80025cbc:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025cc0:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025cc4:	3b 70 3b 20 	mov %d2,951
80025cc8:	59 a2 04 00 	st.w [%sp]4,%d2
80025ccc:	91 00 00 28 	movh.a %a2,32768
80025cd0:	d9 22 53 63 	lea %a2,[%a2]13715 <80003593 <IfxCpu_Trap_vectorTable0_end+0x339f>>
80025cd4:	f4 a2       	st.a [%sp],%a2
80025cd6:	91 00 00 28 	movh.a %a2,32768
80025cda:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025cde:	6d fe 2c fb 	call 80005336 <Ifx_Lwip_printf>
80025ce2:	3b 00 ff 2f 	mov %d2,-16
80025ce6:	00 90       	ret 

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
80025ce8:	82 02       	mov %d2,0
80025cea:	e9 e2 fb ff 	st.b [%a14]-5,%d2
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
80025cee:	91 10 00 27 	movh.a %a2,28673
80025cf2:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025cf6:	54 22       	ld.w %d2,[%a2]
80025cf8:	59 e2 fc ff 	st.w [%a14]-4 <70014610 <udp_pcbs>>,%d2
80025cfc:	1d 00 14 00 	j 80025d24 <udp_bind+0x9a>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
80025d00:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80025d04:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80025d08:	5f 23 07 80 	jne %d3,%d2,80025d16 <udp_bind+0x8c>
      rebind = 1;
80025d0c:	82 12       	mov %d2,1
80025d0e:	e9 e2 fb ff 	st.b [%a14]-5,%d2
      break;
80025d12:	1d 00 0d 00 	j 80025d2c <udp_bind+0xa2>
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
80025d16:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025d1a:	d9 22 0c 00 	lea %a2,[%a2]12
80025d1e:	54 22       	ld.w %d2,[%a2]
80025d20:	59 e2 fc ff 	st.w [%a14]-4,%d2
80025d24:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80025d28:	df 02 ec ff 	jne %d2,0,80025d00 <udp_bind+0x76>
    ipaddr = &zoned_ipaddr;
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  /* no port specified? */
  if (port == 0) {
80025d2c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80025d30:	df 02 0c 80 	jne %d2,0,80025d48 <udp_bind+0xbe>
    port = udp_new_port();
80025d34:	6d ff cf f9 	call 800250d2 <udp_new_port>
80025d38:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    if (port == 0) {
80025d3c:	b9 e2 ec ff 	ld.hu %d2,[%a14]-20
80025d40:	df 02 42 80 	jne %d2,0,80025dc4 <udp_bind+0x13a>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
80025d44:	82 82       	mov %d2,-8
80025d46:	00 90       	ret 
    }
  } else {
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
80025d48:	91 10 00 27 	movh.a %a2,28673
80025d4c:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025d50:	54 22       	ld.w %d2,[%a2]
80025d52:	59 e2 fc ff 	st.w [%a14]-4 <70014610 <udp_pcbs>>,%d2
80025d56:	1d 00 33 00 	j 80025dbc <udp_bind+0x132>
      if (pcb != ipcb) {
80025d5a:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80025d5e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80025d62:	5f 23 26 00 	jeq %d3,%d2,80025dae <udp_bind+0x124>
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(ipcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          /* port matches that of PCB in list and REUSEADDR not set -> reject */
          if ((ipcb->local_port == port) &&
80025d66:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025d6a:	b9 22 12 00 	ld.hu %d2,[%a2]18
80025d6e:	b9 e3 ec ff 	ld.hu %d3,[%a14]-20
80025d72:	5f 23 1e 80 	jne %d3,%d2,80025dae <udp_bind+0x124>
              /* IP address matches or any IP used? */
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
80025d76:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025d7a:	54 23       	ld.w %d3,[%a2]
80025d7c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025d80:	54 22       	ld.w %d2,[%a2]
          if ((ipcb->local_port == port) &&
80025d82:	5f 23 14 00 	jeq %d3,%d2,80025daa <udp_bind+0x120>
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
80025d86:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80025d8a:	df 02 10 00 	jeq %d2,0,80025daa <udp_bind+0x120>
80025d8e:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025d92:	54 22       	ld.w %d2,[%a2]
80025d94:	df 02 0b 00 	jeq %d2,0,80025daa <udp_bind+0x120>
              ip_addr_isany(&ipcb->local_ip))) {
80025d98:	19 e2 fc ff 	ld.w %d2,[%a14]-4
              (ip_addr_cmp(&ipcb->local_ip, ipaddr) || ip_addr_isany(ipaddr) ||
80025d9c:	df 02 07 00 	jeq %d2,0,80025daa <udp_bind+0x120>
              ip_addr_isany(&ipcb->local_ip))) {
80025da0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025da4:	54 22       	ld.w %d2,[%a2]
80025da6:	df 02 04 80 	jne %d2,0,80025dae <udp_bind+0x124>
            /* other PCB already binds to this local IP and port */
            LWIP_DEBUGF(UDP_DEBUG,
                        ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
            return ERR_USE;
80025daa:	82 82       	mov %d2,-8
80025dac:	00 90       	ret 
    for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
80025dae:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025db2:	d9 22 0c 00 	lea %a2,[%a2]12
80025db6:	54 22       	ld.w %d2,[%a2]
80025db8:	59 e2 fc ff 	st.w [%a14]-4,%d2
80025dbc:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80025dc0:	df 02 cd ff 	jne %d2,0,80025d5a <udp_bind+0xd0>
        }
      }
    }
  }

  ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
80025dc4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80025dc8:	df 02 07 00 	jeq %d2,0,80025dd6 <udp_bind+0x14c>
80025dcc:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025dd0:	54 22       	ld.w %d2,[%a2]
80025dd2:	1d 00 03 00 	j 80025dd8 <udp_bind+0x14e>
80025dd6:	82 02       	mov %d2,0
80025dd8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025ddc:	74 22       	st.w [%a2],%d2

  pcb->local_port = port;
80025dde:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025de2:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
80025de6:	f9 22 12 00 	st.h [%a2]18,%d2
  mib2_udp_bind(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
80025dea:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
80025dee:	df 02 13 80 	jne %d2,0,80025e14 <udp_bind+0x18a>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
80025df2:	91 10 00 27 	movh.a %a2,28673
80025df6:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025dfa:	54 22       	ld.w %d2,[%a2]
80025dfc:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <70014610 <udp_pcbs>>
80025e00:	d9 22 0c 00 	lea %a2,[%a2]12 <70014610 <udp_pcbs>>
80025e04:	74 22       	st.w [%a2],%d2
    udp_pcbs = pcb;
80025e06:	91 10 00 27 	movh.a %a2,28673
80025e0a:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025e0e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <70014610 <udp_pcbs>>
80025e12:	74 22       	st.w [%a2],%d2
  }
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, pcb->local_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
  return ERR_OK;
80025e14:	82 02       	mov %d2,0
}
80025e16:	00 90       	ret 

80025e18 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
{
80025e18:	40 ae       	mov.aa %a14,%sp
80025e1a:	20 28       	sub.a %sp,40
80025e1c:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80025e20:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
80025e24:	02 42       	mov %d2,%d4
80025e26:	f9 e2 ec ff 	st.h [%a14]-20,%d2
  struct udp_pcb *ipcb;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
80025e2a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025e2e:	df 02 1a 80 	jne %d2,0,80025e62 <udp_connect+0x4a>
80025e32:	91 00 00 28 	movh.a %a2,32768
80025e36:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025e3a:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025e3e:	3b 50 43 20 	mov %d2,1077
80025e42:	59 a2 04 00 	st.w [%sp]4,%d2
80025e46:	91 00 00 28 	movh.a %a2,32768
80025e4a:	d9 22 69 63 	lea %a2,[%a2]13737 <800035a9 <IfxCpu_Trap_vectorTable0_end+0x33b5>>
80025e4e:	f4 a2       	st.a [%sp],%a2
80025e50:	91 00 00 28 	movh.a %a2,32768
80025e54:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025e58:	6d fe 6f fa 	call 80005336 <Ifx_Lwip_printf>
80025e5c:	3b 00 ff 2f 	mov %d2,-16
80025e60:	00 90       	ret 
  LWIP_ERROR("udp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
80025e62:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80025e66:	df 02 1a 80 	jne %d2,0,80025e9a <udp_connect+0x82>
80025e6a:	91 00 00 28 	movh.a %a2,32768
80025e6e:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025e72:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025e76:	3b 60 43 20 	mov %d2,1078
80025e7a:	59 a2 04 00 	st.w [%sp]4,%d2
80025e7e:	91 00 00 28 	movh.a %a2,32768
80025e82:	d9 22 42 73 	lea %a2,[%a2]13762 <800035c2 <IfxCpu_Trap_vectorTable0_end+0x33ce>>
80025e86:	f4 a2       	st.a [%sp],%a2
80025e88:	91 00 00 28 	movh.a %a2,32768
80025e8c:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025e90:	6d fe 53 fa 	call 80005336 <Ifx_Lwip_printf>
80025e94:	3b 00 ff 2f 	mov %d2,-16
80025e98:	00 90       	ret 

  if (pcb->local_port == 0) {
80025e9a:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025e9e:	b9 22 12 00 	ld.hu %d2,[%a2]18
80025ea2:	df 02 17 80 	jne %d2,0,80025ed0 <udp_connect+0xb8>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
80025ea6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025eaa:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025eae:	b9 23 12 00 	ld.hu %d3,[%a2]18
80025eb2:	02 34       	mov %d4,%d3
80025eb4:	60 25       	mov.a %a5,%d2
80025eb6:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80025eba:	6d ff e8 fe 	call 80025c8a <udp_bind>
80025ebe:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    if (err != ERR_OK) {
80025ec2:	79 e2 ff ff 	ld.b %d2,[%a14]-1
80025ec6:	df 02 05 00 	jeq %d2,0,80025ed0 <udp_connect+0xb8>
      return err;
80025eca:	79 e2 ff ff 	ld.b %d2,[%a14]-1
80025ece:	00 90       	ret 
    }
  }

  ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
80025ed0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80025ed4:	df 02 07 00 	jeq %d2,0,80025ee2 <udp_connect+0xca>
80025ed8:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80025edc:	54 22       	ld.w %d2,[%a2]
80025ede:	1d 00 03 00 	j 80025ee4 <udp_connect+0xcc>
80025ee2:	82 02       	mov %d2,0
80025ee4:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025ee8:	b0 42       	add.a %a2,4
80025eea:	74 22       	st.w [%a2],%d2
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNKNOWN)) {
    ip6_addr_select_zone(ip_2_ip6(&pcb->remote_ip), ip_2_ip6(&pcb->local_ip));
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  pcb->remote_port = port;
80025eec:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025ef0:	c9 e2 ec ff 	ld.h %d2,[%a14]-20
80025ef4:	f9 22 14 00 	st.h [%a2]20,%d2
  pcb->flags |= UDP_FLAGS_CONNECTED;
80025ef8:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025efc:	39 22 10 00 	ld.bu %d2,[%a2]16
80025f00:	8f 42 40 21 	or %d2,%d2,4
80025f04:	8f f2 0f 21 	and %d2,%d2,255
80025f08:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80025f0c:	e9 22 10 00 	st.b [%a2]16,%d2
  ip_addr_debug_print_val(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                          pcb->remote_ip);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
80025f10:	91 10 00 27 	movh.a %a2,28673
80025f14:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025f18:	54 22       	ld.w %d2,[%a2]
80025f1a:	59 e2 f8 ff 	st.w [%a14]-8 <70014610 <udp_pcbs>>,%d2
80025f1e:	1d 00 11 00 	j 80025f40 <udp_connect+0x128>
    if (pcb == ipcb) {
80025f22:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
80025f26:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80025f2a:	5f 23 04 80 	jne %d3,%d2,80025f32 <udp_connect+0x11a>
      /* already on the list, just return */
      return ERR_OK;
80025f2e:	82 02       	mov %d2,0
80025f30:	00 90       	ret 
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
80025f32:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80025f36:	d9 22 0c 00 	lea %a2,[%a2]12
80025f3a:	54 22       	ld.w %d2,[%a2]
80025f3c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80025f40:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80025f44:	df 02 ef ff 	jne %d2,0,80025f22 <udp_connect+0x10a>
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
80025f48:	91 10 00 27 	movh.a %a2,28673
80025f4c:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025f50:	54 22       	ld.w %d2,[%a2]
80025f52:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <70014610 <udp_pcbs>>
80025f56:	d9 22 0c 00 	lea %a2,[%a2]12 <70014610 <udp_pcbs>>
80025f5a:	74 22       	st.w [%a2],%d2
  udp_pcbs = pcb;
80025f5c:	91 10 00 27 	movh.a %a2,28673
80025f60:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80025f64:	19 e2 f4 ff 	ld.w %d2,[%a14]-12 <70014610 <udp_pcbs>>
80025f68:	74 22       	st.w [%a2],%d2
  return ERR_OK;
80025f6a:	82 02       	mov %d2,0
}
80025f6c:	00 90       	ret 

80025f6e <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
80025f6e:	40 ae       	mov.aa %a14,%sp
80025f70:	20 20       	sub.a %sp,32
80025f72:	b5 e4 fc ff 	st.a [%a14]-4,%a4
80025f76:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
80025f7a:	b5 e6 f4 ff 	st.a [%a14]-12,%a6
  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_recv: invalid pcb", pcb != NULL, return);
80025f7e:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80025f82:	df 02 18 80 	jne %d2,0,80025fb2 <udp_recv+0x44>
80025f86:	91 00 00 28 	movh.a %a2,32768
80025f8a:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025f8e:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025f92:	3b a0 48 20 	mov %d2,1162
80025f96:	59 a2 04 00 	st.w [%sp]4,%d2
80025f9a:	91 00 00 28 	movh.a %a2,32768
80025f9e:	d9 22 7a 73 	lea %a2,[%a2]13818 <800035fa <IfxCpu_Trap_vectorTable0_end+0x3406>>
80025fa2:	f4 a2       	st.a [%sp],%a2
80025fa4:	91 00 00 28 	movh.a %a2,32768
80025fa8:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80025fac:	6d fe c5 f9 	call 80005336 <Ifx_Lwip_printf>
80025fb0:	00 90       	ret 

  /* remember recv() callback and user data */
  pcb->recv = recv;
80025fb2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025fb6:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80025fba:	d9 22 18 00 	lea %a2,[%a2]24
80025fbe:	74 22       	st.w [%a2],%d2
  pcb->recv_arg = recv_arg;
80025fc0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80025fc4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025fc8:	d9 22 1c 00 	lea %a2,[%a2]28
80025fcc:	74 22       	st.w [%a2],%d2
}
80025fce:	00 90       	ret 

80025fd0 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
80025fd0:	40 ae       	mov.aa %a14,%sp
80025fd2:	20 20       	sub.a %sp,32
80025fd4:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
  struct udp_pcb *pcb2;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("udp_remove: invalid pcb", pcb != NULL, return);
80025fd8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80025fdc:	df 02 18 80 	jne %d2,0,8002600c <udp_remove+0x3c>
80025fe0:	91 00 00 28 	movh.a %a2,32768
80025fe4:	d9 22 18 c3 	lea %a2,[%a2]13080 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>
80025fe8:	b5 a2 08 00 	st.a [%sp]8 <80003318 <IfxCpu_Trap_vectorTable0_end+0x3124>>,%a2
80025fec:	3b 10 4a 20 	mov %d2,1185
80025ff0:	59 a2 04 00 	st.w [%sp]4,%d2
80025ff4:	91 00 00 28 	movh.a %a2,32768
80025ff8:	d9 22 50 83 	lea %a2,[%a2]13840 <80003610 <IfxCpu_Trap_vectorTable0_end+0x341c>>
80025ffc:	f4 a2       	st.a [%sp],%a2
80025ffe:	91 00 00 28 	movh.a %a2,32768
80026002:	d9 24 30 b3 	lea %a4,[%a2]13040 <800032f0 <IfxCpu_Trap_vectorTable0_end+0x30fc>>
80026006:	6d fe 98 f9 	call 80005336 <Ifx_Lwip_printf>
8002600a:	00 90       	ret 

  mib2_udp_unbind(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
8002600c:	91 10 00 27 	movh.a %a2,28673
80026010:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80026014:	54 22       	ld.w %d2,[%a2]
80026016:	19 e3 f4 ff 	ld.w %d3,[%a14]-12 <70014610 <udp_pcbs>>
8002601a:	5f 23 11 80 	jne %d3,%d2,8002603c <udp_remove+0x6c>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
8002601e:	91 10 00 27 	movh.a %a2,28673
80026022:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80026026:	d4 22       	ld.a %a2,[%a2]
80026028:	d9 22 0c 00 	lea %a2,[%a2]12 <70014610 <udp_pcbs>>
8002602c:	54 22       	ld.w %d2,[%a2]
8002602e:	91 10 00 27 	movh.a %a2,28673
80026032:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80026036:	74 22       	st.w [%a2],%d2
80026038:	1d 00 32 00 	j 8002609c <udp_remove+0xcc>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
8002603c:	91 10 00 27 	movh.a %a2,28673
80026040:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80026044:	54 22       	ld.w %d2,[%a2]
80026046:	59 e2 fc ff 	st.w [%a14]-4 <70014610 <udp_pcbs>>,%d2
8002604a:	1d 00 25 00 	j 80026094 <udp_remove+0xc4>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
8002604e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80026052:	d9 22 0c 00 	lea %a2,[%a2]12
80026056:	54 22       	ld.w %d2,[%a2]
80026058:	df 02 17 00 	jeq %d2,0,80026086 <udp_remove+0xb6>
8002605c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80026060:	d9 22 0c 00 	lea %a2,[%a2]12
80026064:	54 22       	ld.w %d2,[%a2]
80026066:	19 e3 f4 ff 	ld.w %d3,[%a14]-12
8002606a:	5f 23 0e 80 	jne %d3,%d2,80026086 <udp_remove+0xb6>
        /* remove pcb from list */
        pcb2->next = pcb->next;
8002606e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80026072:	d9 22 0c 00 	lea %a2,[%a2]12
80026076:	54 22       	ld.w %d2,[%a2]
80026078:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002607c:	d9 22 0c 00 	lea %a2,[%a2]12
80026080:	74 22       	st.w [%a2],%d2
        break;
80026082:	1d 00 0d 00 	j 8002609c <udp_remove+0xcc>
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
80026086:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002608a:	d9 22 0c 00 	lea %a2,[%a2]12
8002608e:	54 22       	ld.w %d2,[%a2]
80026090:	59 e2 fc ff 	st.w [%a14]-4,%d2
80026094:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80026098:	df 02 db ff 	jne %d2,0,8002604e <udp_remove+0x7e>
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
8002609c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800260a0:	82 04       	mov %d4,0
800260a2:	6d ff 0a 95 	call 80018ab6 <memp_free>
}
800260a6:	00 90       	ret 

800260a8 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
800260a8:	40 ae       	mov.aa %a14,%sp
800260aa:	20 08       	sub.a %sp,8
  struct udp_pcb *pcb;

  LWIP_ASSERT_CORE_LOCKED();

  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
800260ac:	82 04       	mov %d4,0
800260ae:	6d ff 8e 94 	call 800189ca <memp_malloc>
800260b2:	b5 e2 fc ff 	st.a [%a14]-4,%a2
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
800260b6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800260ba:	df 02 0e 00 	jeq %d2,0,800260d6 <udp_new+0x2e>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
800260be:	3b 00 02 50 	mov %d5,32
800260c2:	82 04       	mov %d4,0
800260c4:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800260c8:	6d 00 b4 08 	call 80027230 <memset>
    pcb->ttl = UDP_TTL;
800260cc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800260d0:	82 f2       	mov %d2,-1
800260d2:	e9 22 0b 00 	st.b [%a2]11,%d2
#if LWIP_MULTICAST_TX_OPTIONS
    udp_set_multicast_ttl(pcb, UDP_TTL);
#endif /* LWIP_MULTICAST_TX_OPTIONS */
  }
  return pcb;
800260d6:	19 e2 fc ff 	ld.w %d2,[%a14]-4
}
800260da:	60 22       	mov.a %a2,%d2
800260dc:	00 90       	ret 

800260de <udp_netif_ip_addr_changed>:
 *
 * @param old_addr IP address of the netif before change
 * @param new_addr IP address of the netif after change
 */
void udp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
{
800260de:	40 ae       	mov.aa %a14,%sp
800260e0:	20 10       	sub.a %sp,16
800260e2:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
800260e6:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
  struct udp_pcb *upcb;

  if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
800260ea:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800260ee:	df 02 32 00 	jeq %d2,0,80026152 <udp_netif_ip_addr_changed+0x74>
800260f2:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
800260f6:	54 22       	ld.w %d2,[%a2]
800260f8:	df 02 2d 00 	jeq %d2,0,80026152 <udp_netif_ip_addr_changed+0x74>
800260fc:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80026100:	df 02 29 00 	jeq %d2,0,80026152 <udp_netif_ip_addr_changed+0x74>
80026104:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80026108:	54 22       	ld.w %d2,[%a2]
8002610a:	df 02 24 00 	jeq %d2,0,80026152 <udp_netif_ip_addr_changed+0x74>
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
8002610e:	91 10 00 27 	movh.a %a2,28673
80026112:	d9 22 50 84 	lea %a2,[%a2]17936 <70014610 <udp_pcbs>>
80026116:	54 22       	ld.w %d2,[%a2]
80026118:	59 e2 fc ff 	st.w [%a14]-4 <70014610 <udp_pcbs>>,%d2
8002611c:	1d 00 17 00 	j 8002614a <udp_netif_ip_addr_changed+0x6c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
80026120:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80026124:	54 23       	ld.w %d3,[%a2]
80026126:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
8002612a:	54 22       	ld.w %d2,[%a2]
8002612c:	5f 23 08 80 	jne %d3,%d2,8002613c <udp_netif_ip_addr_changed+0x5e>
        /* The PCB is bound to the old ipaddr and
         * is set to bound to the new one instead */
        ip_addr_copy(upcb->local_ip, *new_addr);
80026130:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80026134:	54 22       	ld.w %d2,[%a2]
80026136:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002613a:	74 22       	st.w [%a2],%d2
    for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
8002613c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80026140:	d9 22 0c 00 	lea %a2,[%a2]12
80026144:	54 22       	ld.w %d2,[%a2]
80026146:	59 e2 fc ff 	st.w [%a14]-4,%d2
8002614a:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002614e:	df 02 e9 ff 	jne %d2,0,80026120 <udp_netif_ip_addr_changed+0x42>
      }
    }
  }
}
80026152:	00 00       	nop 
80026154:	00 90       	ret 

80026156 <low_level_init>:
 *
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void low_level_init(netif_t *netif)
{
80026156:	40 ae       	mov.aa %a14,%sp
80026158:	d9 aa f8 7f 	lea %sp,[%sp]-520
8002615c:	b5 e4 fc 7f 	st.a [%a14]-516,%a4
	IfxGeth_Eth *ethernetif = netif->state;
80026160:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
80026164:	d9 22 1c 00 	lea %a2,[%a2]28
80026168:	54 22       	ld.w %d2,[%a2]
8002616a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    int     i;

    /* set MAC hardware address length */
    netif->hwaddr_len = ETHARP_HWADDR_LEN;
8002616e:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
80026172:	82 62       	mov %d2,6
80026174:	e9 22 30 00 	st.b [%a2]48,%d2

    /* set MAC hardware address */
    for (i = 0; i < ETHARP_HWADDR_LEN; i++)
80026178:	82 02       	mov %d2,0
8002617a:	59 e2 fc ff 	st.w [%a14]-4,%d2
8002617e:	1d 00 1d 00 	j 800261b8 <low_level_init+0x62>
    {
        netif->hwaddr[i] = g_Lwip.eth_addr.addr[i];
80026182:	91 00 00 27 	movh.a %a2,28672
80026186:	d9 22 04 00 	lea %a2,[%a2]4 <70000004 <g_Lwip>>
8002618a:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <70000004 <g_Lwip>>
8002618e:	80 23       	mov.d %d3,%a2
80026190:	42 23       	add %d3,%d2
80026192:	02 32       	mov %d2,%d3
80026194:	60 22       	mov.a %a2,%d2
80026196:	d9 22 2c 10 	lea %a2,[%a2]108
8002619a:	14 22       	ld.bu %d2,[%a2]
8002619c:	19 e4 fc 7f 	ld.w %d4,[%a14]-516
800261a0:	19 e3 fc ff 	ld.w %d3,[%a14]-4
800261a4:	42 43       	add %d3,%d4
800261a6:	60 32       	mov.a %a2,%d3
800261a8:	d9 22 2a 00 	lea %a2,[%a2]42
800261ac:	34 22       	st.b [%a2],%d2
    for (i = 0; i < ETHARP_HWADDR_LEN; i++)
800261ae:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800261b2:	c2 12       	add %d2,1
800261b4:	59 e2 fc ff 	st.w [%a14]-4,%d2
800261b8:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800261bc:	bf 62 e3 7f 	jlt %d2,6,80026182 <low_level_init+0x2c>
    }

    /* maximum transfer unit */
    netif->mtu = 1500;
800261c0:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
800261c4:	3b c0 5d 20 	mov %d2,1500
800261c8:	f9 22 28 00 	st.h [%a2]40,%d2

    /* device capabilities */
    /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
    /* we don't set the LINK_UP flag because we don't say when it is linked */
    netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
800261cc:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
800261d0:	3b a0 00 20 	mov %d2,10
800261d4:	e9 22 31 00 	st.b [%a2]49,%d2

    /* Do whatever else is needed to initialize interface. */
    {
    	IfxGeth_Eth_Config GethConfig;

    	IfxGeth_Eth_initModuleConfig(&GethConfig, &MODULE_GETH);
800261d8:	d9 e2 c0 8f 	lea %a2,[%a14]-512
800261dc:	91 20 00 5f 	movh.a %a5,61442
800261e0:	d9 55 00 0d 	lea %a5,[%a5]-12288 <f001d000 <bmhd_3_copy+0x40c1ba00>>
800261e4:	40 24       	mov.aa %a4,%a2
800261e6:	6d ff 0e 23 	call 8000a802 <IfxGeth_Eth_initModuleConfig>
   		// this is our RTL8211F
   		GethConfig.phyInterfaceMode = IfxGeth_PhyInterfaceMode_rgmii;
800261ea:	82 12       	mov %d2,1
800261ec:	59 e2 c4 8f 	st.w [%a14]-508,%d2
        GethConfig.pins.rgmiiPins = &rtl8211f_pins;
800261f0:	91 00 00 28 	movh.a %a2,32768
800261f4:	d9 22 48 94 	lea %a2,[%a2]17992 <80004648 <rtl8211f_pins>>
800261f8:	b5 e2 cc 8f 	st.a [%a14]-500 <80004648 <rtl8211f_pins>>,%a2
       	GethConfig.mac.lineSpeed = IfxGeth_LineSpeed_1000Mbps;
800261fc:	82 22       	mov %d2,2
800261fe:	59 e2 d8 8f 	st.w [%a14]-488,%d2
    	// MAC core configuration
    	GethConfig.mac.loopbackMode = IfxGeth_LoopbackMode_disable;
80026202:	82 02       	mov %d2,0
80026204:	59 e2 dc 8f 	st.w [%a14]-484,%d2
    	GethConfig.mac.macAddress[0] = netif->hwaddr[0];
80026208:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
8002620c:	39 22 2a 00 	ld.bu %d2,[%a2]42
80026210:	e9 e2 e0 8f 	st.b [%a14]-480,%d2
    	GethConfig.mac.macAddress[1] = netif->hwaddr[1];
80026214:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
80026218:	39 22 2b 00 	ld.bu %d2,[%a2]43
8002621c:	e9 e2 e1 8f 	st.b [%a14]-479,%d2
    	GethConfig.mac.macAddress[2] = netif->hwaddr[2];
80026220:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
80026224:	39 22 2c 00 	ld.bu %d2,[%a2]44
80026228:	e9 e2 e2 8f 	st.b [%a14]-478,%d2
    	GethConfig.mac.macAddress[3] = netif->hwaddr[3];
8002622c:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
80026230:	39 22 2d 00 	ld.bu %d2,[%a2]45
80026234:	e9 e2 e3 8f 	st.b [%a14]-477,%d2
    	GethConfig.mac.macAddress[4] = netif->hwaddr[4];
80026238:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
8002623c:	39 22 2e 00 	ld.bu %d2,[%a2]46
80026240:	e9 e2 e4 8f 	st.b [%a14]-476,%d2
    	GethConfig.mac.macAddress[5] = netif->hwaddr[5];
80026244:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
80026248:	39 22 2f 00 	ld.bu %d2,[%a2]47
8002624c:	e9 e2 e5 8f 	st.b [%a14]-475,%d2

    	// MTL configuration
    	GethConfig.mtl.numOfTxQueues = 1;
80026250:	82 12       	mov %d2,1
80026252:	59 e2 e8 8f 	st.w [%a14]-472,%d2
    	GethConfig.mtl.numOfRxQueues = 1;
80026256:	82 12       	mov %d2,1
80026258:	59 e2 f0 8f 	st.w [%a14]-464,%d2
    	GethConfig.mtl.txQueue[0].txQueueSize = IfxGeth_QueueSize_2560Bytes;
8002625c:	3b 90 00 20 	mov %d2,9
80026260:	59 e2 fc 8f 	st.w [%a14]-452,%d2
    	GethConfig.mtl.txQueue[0].storeAndForward = TRUE;
80026264:	82 12       	mov %d2,1
80026266:	e9 e2 f8 8f 	st.b [%a14]-456,%d2
    	GethConfig.mtl.rxQueue[0].rxQueueSize = IfxGeth_QueueSize_2560Bytes;
8002626a:	3b 90 00 20 	mov %d2,9
8002626e:	59 e2 ec 9f 	st.w [%a14]-404,%d2
    	GethConfig.mtl.rxQueue[0].rxDmaChannelMap = IfxGeth_RxDmaChannel_0;
80026272:	82 02       	mov %d2,0
80026274:	59 e2 f4 9f 	st.w [%a14]-396,%d2
    	GethConfig.mtl.rxQueue[0].storeAndForward = TRUE;
80026278:	82 12       	mov %d2,1
8002627a:	e9 e2 e8 9f 	st.b [%a14]-408,%d2

    	GethConfig.dma.numOfTxChannels = 1;
8002627e:	82 12       	mov %d2,1
80026280:	59 e2 c4 bf 	st.w [%a14]-316,%d2
    	GethConfig.dma.numOfRxChannels = 1;
80026284:	82 12       	mov %d2,1
80026286:	59 e2 c8 bf 	st.w [%a14]-312,%d2
    	GethConfig.dma.txChannel[0].channelId = IfxGeth_TxDmaChannel_0;
8002628a:	82 02       	mov %d2,0
8002628c:	59 e2 d0 bf 	st.w [%a14]-304,%d2
    	GethConfig.dma.txChannel[0].txDescrList = (IfxGeth_TxDescrList*)&IfxGeth_Eth_txDescrList[0];
80026290:	91 10 00 27 	movh.a %a2,28673
80026294:	d9 22 c8 3a 	lea %a2,[%a2]-21304 <7000acc8 <IfxGeth_Eth_txDescrList>>
80026298:	b5 e2 d8 bf 	st.a [%a14]-296 <7000acc8 <IfxGeth_Eth_txDescrList>>,%a2
    	GethConfig.dma.txChannel[0].txBuffer1StartAddress = (uint32 *)&channel0TxBuffer1[0][0]; // user buffer
8002629c:	91 00 00 27 	movh.a %a2,28672
800262a0:	d9 22 28 40 	lea %a2,[%a2]296 <70000128 <channel0TxBuffer1>>
800262a4:	b5 e2 dc bf 	st.a [%a14]-292 <70000128 <channel0TxBuffer1>>,%a2
    	GethConfig.dma.txChannel[0].txBuffer1Size = IFXGETH_MAX_TX_BUFFER_SIZE; // used to calculate the next descriptor  buffer offset
800262a8:	3b 00 a1 20 	mov %d2,2576
800262ac:	f9 e2 e0 bf 	st.h [%a14]-288,%d2

    	GethConfig.dma.rxChannel[0].channelId = IfxGeth_RxDmaChannel_0;
800262b0:	82 02       	mov %d2,0
800262b2:	59 e2 e0 cf 	st.w [%a14]-224,%d2
    	GethConfig.dma.rxChannel[0].rxDescrList = (IfxGeth_RxDescrList *)&IfxGeth_Eth_rxDescrList[0];
800262b6:	91 10 00 27 	movh.a %a2,28673
800262ba:	d9 22 88 ba 	lea %a2,[%a2]-21816 <7000aac8 <IfxGeth_Eth_rxDescrList>>
800262be:	b5 e2 e8 cf 	st.a [%a14]-216 <7000aac8 <IfxGeth_Eth_rxDescrList>>,%a2
    	GethConfig.dma.rxChannel[0].rxBuffer1StartAddress = (uint32 *)&channel0RxBuffer1[0][0]; // user buffer
800262c2:	91 00 00 27 	movh.a %a2,28672
800262c6:	d9 22 28 65 	lea %a2,[%a2]20904 <700051a8 <channel0RxBuffer1>>
800262ca:	b5 e2 ec cf 	st.a [%a14]-212 <700051a8 <channel0RxBuffer1>>,%a2
    	GethConfig.dma.rxChannel[0].rxBuffer1Size = IFXGETH_MAX_RX_BUFFER_SIZE; // user defined variable
800262ce:	3b 00 a1 20 	mov %d2,2576
800262d2:	f9 e2 f0 cf 	st.h [%a14]-208,%d2

    	IfxSrc_Tos gethIsrProvider;

        if (CPU_WHICH_SERVICE_ETHERNET) gethIsrProvider = (IfxSrc_Tos)(CPU_WHICH_SERVICE_ETHERNET+1);
        else  gethIsrProvider = (IfxSrc_Tos)CPU_WHICH_SERVICE_ETHERNET;
800262d6:	82 02       	mov %d2,0
800262d8:	59 e2 f4 ff 	st.w [%a14]-12,%d2

    	GethConfig.dma.txInterrupt[0].channelId = IfxGeth_DmaChannel_0;
800262dc:	82 02       	mov %d2,0
800262de:	59 e2 f0 df 	st.w [%a14]-144,%d2
    	GethConfig.dma.txInterrupt[0].priority = ISR_PRIORITY_GETH_TX;	// priority
800262e2:	3b 40 06 20 	mov %d2,100
800262e6:	f9 e2 f4 df 	st.h [%a14]-140,%d2
    	GethConfig.dma.txInterrupt[0].provider = gethIsrProvider;
800262ea:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800262ee:	59 e2 f8 df 	st.w [%a14]-136,%d2
    	GethConfig.dma.rxInterrupt[0].channelId = IfxGeth_DmaChannel_0;
800262f2:	82 02       	mov %d2,0
800262f4:	59 e2 e0 ef 	st.w [%a14]-96,%d2
    	GethConfig.dma.rxInterrupt[0].priority = ISR_PRIORITY_GETH_RX;	// priority
800262f8:	3b 50 06 20 	mov %d2,101
800262fc:	f9 e2 e4 ef 	st.h [%a14]-92,%d2
    	GethConfig.dma.rxInterrupt[0].provider = gethIsrProvider;
80026300:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80026304:	59 e2 e8 ef 	st.w [%a14]-88,%d2


    	/* first we reset our phy manually, to make sure that the phy is ready when we init our module */
        {
        	IfxGeth_enableModule(&MODULE_GETH);
80026308:	91 20 00 4f 	movh.a %a4,61442
8002630c:	d9 44 00 0d 	lea %a4,[%a4]-12288 <f001d000 <bmhd_3_copy+0x40c1ba00>>
80026310:	6d ff ee 13 	call 80008aec <IfxGeth_enableModule>
        	IfxPort_setPinModeOutput(ETH_MDC_PIN.pin.port, ETH_MDC_PIN.pin.pinIndex, IfxPort_OutputMode_pushPull, ETH_MDC_PIN.select);
80026314:	91 00 00 28 	movh.a %a2,32768
80026318:	d9 22 0c 24 	lea %a2,[%a2]16524 <8000408c <IfxGeth_MDC_P12_0_OUT>>
8002631c:	b0 42       	add.a %a2,4
8002631e:	54 24       	ld.w %d4,[%a2]
80026320:	91 00 00 28 	movh.a %a2,32768
80026324:	d9 22 0c 24 	lea %a2,[%a2]16524 <8000408c <IfxGeth_MDC_P12_0_OUT>>
80026328:	39 22 08 00 	ld.bu %d2,[%a2]8 <80000008 <LCF_STARTPTR_CPU0+0x8>>
8002632c:	91 00 00 28 	movh.a %a2,32768
80026330:	d9 22 0c 24 	lea %a2,[%a2]16524 <8000408c <IfxGeth_MDC_P12_0_OUT>>
80026334:	d9 22 0c 00 	lea %a2,[%a2]12 <8000000c <LCF_STARTPTR_CPU0+0xc>>
80026338:	54 23       	ld.w %d3,[%a2]
8002633a:	59 e4 f0 ff 	st.w [%a14]-16 <8000000c <LCF_STARTPTR_CPU0+0xc>>,%d4
8002633e:	e9 e2 ef ff 	st.b [%a14]-17 <8000000c <LCF_STARTPTR_CPU0+0xc>>,%d2
80026342:	3b 00 08 20 	mov %d2,128
80026346:	59 e2 e8 ff 	st.w [%a14]-24,%d2
8002634a:	59 e3 e4 ff 	st.w [%a14]-28,%d3
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
8002634e:	39 e3 ef ff 	ld.bu %d3,[%a14]-17
80026352:	19 e4 e8 ff 	ld.w %d4,[%a14]-24
80026356:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
8002635a:	a6 42       	or %d2,%d4
8002635c:	02 25       	mov %d5,%d2
8002635e:	02 34       	mov %d4,%d3
80026360:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026364:	6d ff b5 12 	call 800088ce <IfxPort_setPinMode>
}
80026368:	00 00       	nop 
            GETH_GPCTL.B.ALTI0  = ETH_MDIO_PIN.inSelect;
8002636a:	91 00 00 28 	movh.a %a2,32768
8002636e:	d9 22 1c 24 	lea %a2,[%a2]16540 <8000409c <IfxGeth_MDIO_P12_1_INOUT>>
80026372:	d9 22 0c 00 	lea %a2,[%a2]12 <8000000c <LCF_STARTPTR_CPU0+0xc>>
80026376:	54 22       	ld.w %d2,[%a2]
80026378:	91 20 00 2f 	movh.a %a2,61442
8002637c:	d9 22 08 0f 	lea %a2,[%a2]-4088 <f001f008 <bmhd_3_copy+0x40c1da08>>
80026380:	8f 32 00 21 	and %d2,%d2,3
80026384:	8f f2 0f 31 	and %d3,%d2,255
80026388:	54 22       	ld.w %d2,[%a2]
8002638a:	37 32 02 20 	insert %d2,%d2,%d3,0,2
8002638e:	74 22       	st.w [%a2],%d2

            while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
80026390:	00 00       	nop 
80026392:	91 20 00 2f 	movh.a %a2,61442
80026396:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
8002639a:	54 22       	ld.w %d2,[%a2]
8002639c:	37 02 61 20 	extr.u %d2,%d2,0,1
800263a0:	8f f2 0f 21 	and %d2,%d2,255
800263a4:	df 02 f7 ff 	jne %d2,0,80026392 <low_level_init+0x23c>
            // first we wait that we are able to communicate with the Phy
            do
            {
            	GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) | (3 << 2) | (1 << 0);
800263a8:	91 20 00 2f 	movh.a %a2,61442
800263ac:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
800263b0:	3b d0 00 20 	mov %d2,13
800263b4:	74 22       	st.w [%a2],%d2
                while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
800263b6:	00 00       	nop 
800263b8:	91 20 00 2f 	movh.a %a2,61442
800263bc:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
800263c0:	54 22       	ld.w %d2,[%a2]
800263c2:	37 02 61 20 	extr.u %d2,%d2,0,1
800263c6:	8f f2 0f 21 	and %d2,%d2,255
800263ca:	df 02 f7 ff 	jne %d2,0,800263b8 <low_level_init+0x262>
            } while (GETH_MAC_MDIO_DATA.U & 0x8000);                                                      // wait for reset to finish
800263ce:	91 20 00 2f 	movh.a %a2,61442
800263d2:	d9 22 04 8d 	lea %a2,[%a2]-11772 <f001d204 <bmhd_3_copy+0x40c1bc04>>
800263d6:	54 22       	ld.w %d2,[%a2]
800263d8:	bb 00 00 38 	mov.u %d3,32768
800263dc:	26 32       	and %d2,%d3
800263de:	df 02 e5 ff 	jne %d2,0,800263a8 <low_level_init+0x252>
            // reset PHY
            // put data
        	GETH_MAC_MDIO_DATA.U = 0x8000;
800263e2:	91 20 00 2f 	movh.a %a2,61442
800263e6:	d9 22 04 8d 	lea %a2,[%a2]-11772 <f001d204 <bmhd_3_copy+0x40c1bc04>>
800263ea:	bb 00 00 28 	mov.u %d2,32768
800263ee:	74 22       	st.w [%a2],%d2
            GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) |  (1 << 2) | (1 << 0);
800263f0:	91 20 00 2f 	movh.a %a2,61442
800263f4:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
800263f8:	82 52       	mov %d2,5
800263fa:	74 22       	st.w [%a2],%d2
            while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
800263fc:	00 00       	nop 
800263fe:	91 20 00 2f 	movh.a %a2,61442
80026402:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
80026406:	54 22       	ld.w %d2,[%a2]
80026408:	37 02 61 20 	extr.u %d2,%d2,0,1
8002640c:	8f f2 0f 21 	and %d2,%d2,255
80026410:	df 02 f7 ff 	jne %d2,0,800263fe <low_level_init+0x2a8>

            do
            {
            	GETH_MAC_MDIO_ADDRESS.U = (0 << 21) | (0 << 16) | (0 << 8) | (3 << 2) | (1 << 0);
80026414:	91 20 00 2f 	movh.a %a2,61442
80026418:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
8002641c:	3b d0 00 20 	mov %d2,13
80026420:	74 22       	st.w [%a2],%d2
                while (GETH_MAC_MDIO_ADDRESS.B.GB) {};
80026422:	00 00       	nop 
80026424:	91 20 00 2f 	movh.a %a2,61442
80026428:	d9 22 00 8d 	lea %a2,[%a2]-11776 <f001d200 <bmhd_3_copy+0x40c1bc00>>
8002642c:	54 22       	ld.w %d2,[%a2]
8002642e:	37 02 61 20 	extr.u %d2,%d2,0,1
80026432:	8f f2 0f 21 	and %d2,%d2,255
80026436:	df 02 f7 ff 	jne %d2,0,80026424 <low_level_init+0x2ce>
            } while (GETH_MAC_MDIO_DATA.U & 0x8000);                                                      // wait for reset to finish
8002643a:	91 20 00 2f 	movh.a %a2,61442
8002643e:	d9 22 04 8d 	lea %a2,[%a2]-11772 <f001d204 <bmhd_3_copy+0x40c1bc04>>
80026442:	54 22       	ld.w %d2,[%a2]
80026444:	bb 00 00 38 	mov.u %d3,32768
80026448:	26 32       	and %d2,%d3
8002644a:	df 02 e5 ff 	jne %d2,0,80026414 <low_level_init+0x2be>
        }

        // initialize the module
    	IfxGeth_Eth_initModule(ethernetif, &GethConfig);
8002644e:	d9 e2 c0 8f 	lea %a2,[%a14]-512
80026452:	40 25       	mov.aa %a5,%a2
80026454:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80026458:	6d ff 69 20 	call 8000a52a <IfxGeth_Eth_initModule>

   		IfxGeth_Eth_Phy_Rtl8211f_init();
8002645c:	6d fe af f7 	call 800053ba <IfxGeth_Eth_Phy_Rtl8211f_init>

    	// and enable transmitter/receiver
    	IfxGeth_Eth_startTransmitters(ethernetif, 1);
80026460:	82 14       	mov %d4,1
80026462:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80026466:	6d ff 88 36 	call 8000d176 <IfxGeth_Eth_startTransmitters>
    	IfxGeth_Eth_startReceivers(ethernetif, 1);
8002646a:	82 14       	mov %d4,1
8002646c:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
80026470:	6d ff 1c 36 	call 8000d0a8 <IfxGeth_Eth_startReceivers>

    	// The ETH is ready for use now!
        /* we set the LINK_UP flag if we have a valid link */
    	if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSTS == 1)
80026474:	91 20 00 2f 	movh.a %a2,61442
80026478:	d9 22 38 3d 	lea %a2,[%a2]-12040 <f001d0f8 <bmhd_3_copy+0x40c1baf8>>
8002647c:	54 22       	ld.w %d2,[%a2]
8002647e:	37 02 e1 29 	extr.u %d2,%d2,19,1
80026482:	8f f2 0f 21 	and %d2,%d2,255
80026486:	df 12 73 80 	jne %d2,1,8002656c <low_level_init+0x416>
    	{
    		// we have a valid link
    		netif->flags |= NETIF_FLAG_LINK_UP;
8002648a:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
8002648e:	39 22 31 00 	ld.bu %d2,[%a2]49
80026492:	8f 42 40 21 	or %d2,%d2,4
80026496:	8f f2 0f 21 	and %d2,%d2,255
8002649a:	99 e2 fc 7f 	ld.a %a2,[%a14]-516
8002649e:	e9 22 31 00 	st.b [%a2]49,%d2
    		// we set the correct duplexMode
    		if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKMOD == 1)
800264a2:	91 20 00 2f 	movh.a %a2,61442
800264a6:	d9 22 38 3d 	lea %a2,[%a2]-12040 <f001d0f8 <bmhd_3_copy+0x40c1baf8>>
800264aa:	54 22       	ld.w %d2,[%a2]
800264ac:	37 02 61 28 	extr.u %d2,%d2,16,1
800264b0:	8f f2 0f 21 	and %d2,%d2,255
800264b4:	df 12 18 80 	jne %d2,1,800264e4 <low_level_init+0x38e>
    			IfxGeth_mac_setDuplexMode(ethernetif->gethSFR, IfxGeth_DuplexMode_fullDuplex);
800264b8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800264bc:	54 22       	ld.w %d2,[%a2]
800264be:	59 e2 e0 ff 	st.w [%a14]-32,%d2
800264c2:	82 12       	mov %d2,1
800264c4:	59 e2 dc ff 	st.w [%a14]-36,%d2
    gethSFR->MAC_CONFIGURATION.B.DM = mode;
800264c8:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800264cc:	8f 12 00 21 	and %d2,%d2,1
800264d0:	8f f2 0f 31 	and %d3,%d2,255
800264d4:	99 e2 e0 ff 	ld.a %a2,[%a14]-32
800264d8:	54 22       	ld.w %d2,[%a2]
800264da:	67 32 0d 20 	ins.t %d2,%d2,13,%d3,0
800264de:	74 22       	st.w [%a2],%d2
}
800264e0:	1d 00 17 00 	j 8002650e <low_level_init+0x3b8>
    		else
    			IfxGeth_mac_setDuplexMode(ethernetif->gethSFR, IfxGeth_DuplexMode_halfDuplex);
800264e4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
800264e8:	54 22       	ld.w %d2,[%a2]
800264ea:	59 e2 d8 ff 	st.w [%a14]-40,%d2
800264ee:	82 02       	mov %d2,0
800264f0:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    gethSFR->MAC_CONFIGURATION.B.DM = mode;
800264f4:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800264f8:	8f 12 00 21 	and %d2,%d2,1
800264fc:	8f f2 0f 31 	and %d3,%d2,255
80026500:	99 e2 d8 ff 	ld.a %a2,[%a14]-40
80026504:	54 22       	ld.w %d2,[%a2]
80026506:	67 32 0d 20 	ins.t %d2,%d2,13,%d3,0
8002650a:	74 22       	st.w [%a2],%d2
}
8002650c:	00 00       	nop 
    		// we set the correct speed
    		if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED == 0)
8002650e:	91 20 00 2f 	movh.a %a2,61442
80026512:	d9 22 38 3d 	lea %a2,[%a2]-12040 <f001d0f8 <bmhd_3_copy+0x40c1baf8>>
80026516:	54 22       	ld.w %d2,[%a2]
80026518:	37 02 e2 28 	extr.u %d2,%d2,17,2
8002651c:	8f f2 0f 21 	and %d2,%d2,255
80026520:	df 02 0b 80 	jne %d2,0,80026536 <low_level_init+0x3e0>
    			// 10MBit speed
    			IfxGeth_mac_setLineSpeed(ethernetif->gethSFR, IfxGeth_LineSpeed_10Mbps);
80026524:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026528:	54 22       	ld.w %d2,[%a2]
8002652a:	82 04       	mov %d4,0
8002652c:	60 24       	mov.a %a4,%d2
8002652e:	6d ff 2b 13 	call 80008b84 <IfxGeth_mac_setLineSpeed>
        		else
        			// 1000MBit speed
        			IfxGeth_mac_setLineSpeed(ethernetif->gethSFR, IfxGeth_LineSpeed_1000Mbps);
    	}
    }
}
80026532:	1d 00 1d 00 	j 8002656c <low_level_init+0x416>
        		if (GETH_MAC_PHYIF_CONTROL_STATUS.B.LNKSPEED == 1)
80026536:	91 20 00 2f 	movh.a %a2,61442
8002653a:	d9 22 38 3d 	lea %a2,[%a2]-12040 <f001d0f8 <bmhd_3_copy+0x40c1baf8>>
8002653e:	54 22       	ld.w %d2,[%a2]
80026540:	37 02 e2 28 	extr.u %d2,%d2,17,2
80026544:	8f f2 0f 21 	and %d2,%d2,255
80026548:	df 12 0b 80 	jne %d2,1,8002655e <low_level_init+0x408>
        			IfxGeth_mac_setLineSpeed(ethernetif->gethSFR, IfxGeth_LineSpeed_100Mbps);
8002654c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026550:	54 22       	ld.w %d2,[%a2]
80026552:	82 14       	mov %d4,1
80026554:	60 24       	mov.a %a4,%d2
80026556:	6d ff 17 13 	call 80008b84 <IfxGeth_mac_setLineSpeed>
}
8002655a:	1d 00 09 00 	j 8002656c <low_level_init+0x416>
        			IfxGeth_mac_setLineSpeed(ethernetif->gethSFR, IfxGeth_LineSpeed_1000Mbps);
8002655e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026562:	54 22       	ld.w %d2,[%a2]
80026564:	82 24       	mov %d4,2
80026566:	60 24       	mov.a %a4,%d2
80026568:	6d ff 0e 13 	call 80008b84 <IfxGeth_mac_setLineSpeed>
}
8002656c:	00 00       	nop 
8002656e:	00 90       	ret 

80026570 <low_level_output>:
 *       strange results. You might consider waiting for space in the DMA queue
 *       to become availale since the stack doesn't retry to send a packet
 *       dropped because of memory failure (except for the TCP timers).
 */
static err_t low_level_output(netif_t *netif, pbuf_t *p)
{
80026570:	40 ae       	mov.aa %a14,%sp
80026572:	20 48       	sub.a %sp,72
80026574:	b5 e4 cc ff 	st.a [%a14]-52,%a4
80026578:	b5 e5 c8 ff 	st.a [%a14]-56,%a5
	IfxGeth_Eth      *ethernetif = netif->state;
8002657c:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80026580:	d9 22 1c 00 	lea %a2,[%a2]28
80026584:	54 22       	ld.w %d2,[%a2]
80026586:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    struct pbuf *q;

    u16_t        length = p->tot_len;
8002658a:	99 e2 c8 ff 	ld.a %a2,[%a14]-56
8002658e:	c9 22 08 00 	ld.h %d2,[%a2]8
80026592:	f9 e2 f2 ff 	st.h [%a14]-14,%d2
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_output (p=%#x)\n", p));

#if ETH_PAD_SIZE
    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
80026596:	82 e4       	mov %d4,-2
80026598:	99 e4 c8 ff 	ld.a %a4,[%a14]-56
8002659c:	6d ff de 9c 	call 80019f58 <pbuf_header>
#endif

    if ((p->type_internal == PBUF_REF) || (p->type_internal == PBUF_ROM))
800265a0:	99 e2 c8 ff 	ld.a %a2,[%a14]-56
800265a4:	39 22 0c 00 	ld.bu %d2,[%a2]12
800265a8:	8b 12 04 22 	eq %d2,%d2,65
800265ac:	df 02 08 80 	jne %d2,0,800265bc <low_level_output+0x4c>
800265b0:	99 e2 c8 ff 	ld.a %a2,[%a14]-56
800265b4:	39 22 0c 00 	ld.bu %d2,[%a2]12
800265b8:	df 12 0e 80 	jne %d2,1,800265d4 <low_level_output+0x64>
    {
        // if PBUF_REF or PBUF_ROM, no copy into ethernet RAM buffer is needed.
        // see pbuf_alloc_special()
    	IfxGeth_Eth_sendTransmitBuffer(ethernetif, p->tot_len, IfxGeth_TxDmaChannel_0);
800265bc:	99 e2 c8 ff 	ld.a %a2,[%a14]-56
800265c0:	b9 22 08 00 	ld.hu %d2,[%a2]8
800265c4:	82 05       	mov %d5,0
800265c6:	02 24       	mov %d4,%d2
800265c8:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800265cc:	6d ff 85 26 	call 8000b2d6 <IfxGeth_Eth_sendTransmitBuffer>
800265d0:	1d 00 88 00 	j 800266e0 <low_level_output+0x170>
800265d4:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800265d8:	59 e2 e4 ff 	st.w [%a14]-28,%d2
800265dc:	82 02       	mov %d2,0
800265de:	59 e2 e0 ff 	st.w [%a14]-32,%d2
{
    void *tx;

    do
    {
        tx = IfxGeth_Eth_getTransmitBuffer(geth, channelId);
800265e2:	19 e4 e0 ff 	ld.w %d4,[%a14]-32
800265e6:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
800265ea:	6d ff 6e 1f 	call 8000a4c6 <IfxGeth_Eth_getTransmitBuffer>
800265ee:	b5 e2 dc ff 	st.a [%a14]-36,%a2
    } while (tx == NULL_PTR);
800265f2:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800265f6:	df 02 f6 7f 	jeq %d2,0,800265e2 <low_level_output+0x72>

    return tx;
800265fa:	19 e2 dc ff 	ld.w %d2,[%a14]-36
    }
    else
    {
        //initiate transfer();
        u8_t *tbuf = IfxGeth_Eth_waitTransmitBuffer(ethernetif, IfxGeth_TxDmaChannel_0);
800265fe:	59 e2 ec ff 	st.w [%a14]-20,%d2
        u16_t l    = 0;
80026602:	82 02       	mov %d2,0
80026604:	f9 e2 fe ff 	st.h [%a14]-2,%d2

        for (q = p; q != NULL; q = q->next)
80026608:	19 e2 c8 ff 	ld.w %d2,[%a14]-56
8002660c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80026610:	1d 00 3c 00 	j 80026688 <low_level_output+0x118>
        {
            /* Send the data from the pbuf to the interface, one pbuf at a
             * time. The size of the data in each pbuf is kept in the ->len
             * variable. */
            memcpy((u8_t *)&tbuf[l], q->payload, q->len);
80026614:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
80026618:	19 e3 ec ff 	ld.w %d3,[%a14]-20
8002661c:	42 32       	add %d2,%d3
8002661e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026622:	b0 42       	add.a %a2,4
80026624:	54 23       	ld.w %d3,[%a2]
80026626:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002662a:	b9 24 0a 00 	ld.hu %d4,[%a2]10
8002662e:	60 35       	mov.a %a5,%d3
80026630:	60 24       	mov.a %a4,%d2
80026632:	6d 00 f5 05 	call 8002721c <memcpy>
            l = l + q->len;
80026636:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
8002663a:	b9 23 0a 00 	ld.hu %d3,[%a2]10
8002663e:	c9 e2 fe ff 	ld.h %d2,[%a14]-2
80026642:	42 32       	add %d2,%d3
80026644:	f9 e2 fe ff 	st.h [%a14]-2,%d2
            LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_output: data=%#x, %d\n", q->payload, q->len));
            LWIP_ASSERT("low_level_output: length overflow the buffer\n", (l < 2048));
80026648:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
8002664c:	3b 00 80 30 	mov %d3,2048
80026650:	3f 32 17 80 	jlt.u %d2,%d3,8002667e <low_level_output+0x10e>
80026654:	91 00 00 28 	movh.a %a2,32768
80026658:	d9 22 4e a3 	lea %a2,[%a2]13966 <8000368e <IfxCpu_Trap_vectorTable0_end+0x349a>>
8002665c:	b5 a2 08 00 	st.a [%sp]8 <8000368e <IfxCpu_Trap_vectorTable0_end+0x349a>>,%a2
80026660:	3b 50 14 20 	mov %d2,325
80026664:	59 a2 04 00 	st.w [%sp]4,%d2
80026668:	91 00 00 28 	movh.a %a2,32768
8002666c:	d9 22 7a a3 	lea %a2,[%a2]14010 <800036ba <IfxCpu_Trap_vectorTable0_end+0x34c6>>
80026670:	f4 a2       	st.a [%sp],%a2
80026672:	91 00 00 28 	movh.a %a2,32768
80026676:	d9 24 66 93 	lea %a4,[%a2]13926 <80003666 <IfxCpu_Trap_vectorTable0_end+0x3472>>
8002667a:	6d fe 5e f6 	call 80005336 <Ifx_Lwip_printf>
        for (q = p; q != NULL; q = q->next)
8002667e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026682:	54 22       	ld.w %d2,[%a2]
80026684:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80026688:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8002668c:	df 02 c4 ff 	jne %d2,0,80026614 <low_level_output+0xa4>
80026690:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80026694:	59 e2 d8 ff 	st.w [%a14]-40,%d2
80026698:	82 02       	mov %d2,0
8002669a:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    return geth->txChannel[channelId].txDescrPtr;
8002669e:	19 e3 d8 ff 	ld.w %d3,[%a14]-40
800266a2:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800266a6:	c2 12       	add %d2,1
800266a8:	53 42 21 20 	mul %d2,%d2,20
800266ac:	60 32       	mov.a %a2,%d3
800266ae:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800266b2:	54 22       	ld.w %d2,[%a2]
        }
        /* we correct the buffer 1 size (maybe overwritten in earlier packet */
        IfxGeth_TxDescr *pactTxDescriptor;
        pactTxDescriptor = (IfxGeth_TxDescr *)IfxGeth_Eth_getActualTxDescriptor(ethernetif, IfxGeth_TxDmaChannel_0);
800266b4:	59 e2 e8 ff 	st.w [%a14]-24,%d2
        /* set the buffer length to the max. available */
        pactTxDescriptor->TDES2.R.B1L = IFXGETH_MAX_TX_BUFFER_SIZE;
800266b8:	99 e2 e8 ff 	ld.a %a2,[%a14]-24
800266bc:	d9 23 08 00 	lea %a3,[%a2]8
800266c0:	54 32       	ld.w %d2,[%a3]
800266c2:	3b 00 a1 30 	mov %d3,2576
800266c6:	37 32 0e 20 	insert %d2,%d2,%d3,0,14
800266ca:	d9 22 08 00 	lea %a2,[%a2]8
800266ce:	74 22       	st.w [%a2],%d2
		IfxGeth_Eth_sendTransmitBuffer(ethernetif, l, IfxGeth_TxDmaChannel_0);
800266d0:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
800266d4:	82 05       	mov %d5,0
800266d6:	02 24       	mov %d4,%d2
800266d8:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800266dc:	6d ff fd 25 	call 8000b2d6 <IfxGeth_Eth_sendTransmitBuffer>
    }

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_output: signal length: %d\n", length));

#if ETH_PAD_SIZE
    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
800266e0:	82 24       	mov %d4,2
800266e2:	99 e4 c8 ff 	ld.a %a4,[%a14]-56
800266e6:	6d ff 39 9c 	call 80019f58 <pbuf_header>
#endif

    LINK_STATS_INC(link.xmit);
800266ea:	91 10 00 27 	movh.a %a2,28673
800266ee:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800266f2:	b9 22 00 00 	ld.hu %d2,[%a2]0 <70010000 <ram_heap+0x4f6c>>
800266f6:	c2 12       	add %d2,1
800266f8:	37 02 70 20 	extr.u %d2,%d2,0,16
800266fc:	91 10 00 27 	movh.a %a2,28673
80026700:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80026704:	b4 22       	st.h [%a2],%d2

    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_output: return OK\n"));

    return ERR_OK;
80026706:	82 02       	mov %d2,0
}
80026708:	00 90       	ret 

8002670a <GetRxFrameSize>:

static uint16 GetRxFrameSize(IfxGeth_RxDescr *descr)
{
8002670a:	40 ae       	mov.aa %a14,%sp
8002670c:	20 18       	sub.a %sp,24
8002670e:	b5 e4 ec ff 	st.a [%a14]-20,%a4
  uint16 len;

  uint32 rdes3 = descr->RDES3.U;
80026712:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80026716:	d9 22 0c 00 	lea %a2,[%a2]12
8002671a:	54 22       	ld.w %d2,[%a2]
8002671c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
  uint32 rdes1 = descr->RDES1.U;
80026720:	99 e2 ec ff 	ld.a %a2,[%a14]-20
80026724:	b0 42       	add.a %a2,4
80026726:	54 22       	ld.w %d2,[%a2]
80026728:	59 e2 f4 ff 	st.w [%a14]-12,%d2

  if (((rdes3 & (1UL << 15)) != 0U) ||
8002672c:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80026730:	bb 00 00 38 	mov.u %d3,32768
80026734:	26 32       	and %d2,%d3
80026736:	df 02 0f 80 	jne %d2,0,80026754 <GetRxFrameSize+0x4a>
	  ((rdes1 & (1UL << 7)) != 0U) ||
8002673a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
8002673e:	8f 02 08 21 	and %d2,%d2,128
  if (((rdes3 & (1UL << 15)) != 0U) ||
80026742:	df 02 09 80 	jne %d2,0,80026754 <GetRxFrameSize+0x4a>
	  ((rdes3 & (1UL << 28)) == 0U))
80026746:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
8002674a:	7b 00 00 31 	movh %d3,4096
8002674e:	26 32       	and %d2,%d3
	  ((rdes1 & (1UL << 7)) != 0U) ||
80026750:	df 02 07 80 	jne %d2,0,8002675e <GetRxFrameSize+0x54>
  {
	/* Error, this block is invalid */
	len = 0xFFFFU;
80026754:	82 f2       	mov %d2,-1
80026756:	f9 e2 fe ff 	st.h [%a14]-2,%d2
8002675a:	1d 00 0e 00 	j 80026776 <GetRxFrameSize+0x6c>
  }
  else
  {
    /* Subtract CRC */
	len = (rdes3 & 0x7FFF) - 4U;
8002675e:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80026762:	37 02 70 20 	extr.u %d2,%d2,0,16
80026766:	3b f0 ff 37 	mov %d3,32767
8002676a:	26 32       	and %d2,%d3
8002676c:	37 02 70 20 	extr.u %d2,%d2,0,16
80026770:	c2 c2       	add %d2,-4
80026772:	f9 e2 fe ff 	st.h [%a14]-2,%d2
  }

  return len;
80026776:	b9 e2 fe ff 	ld.hu %d2,[%a14]-2
}
8002677a:	00 90       	ret 

8002677c <low_level_input>:
 * @param netif the lwip network interface structure for this ethernetif
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static pbuf_t *low_level_input(netif_t *netif)
{
8002677c:	40 ae       	mov.aa %a14,%sp
8002677e:	20 38       	sub.a %sp,56
80026780:	b5 e4 cc ff 	st.a [%a14]-52,%a4
	IfxGeth_Eth *ethernetif = netif->state;
80026784:	99 e2 cc ff 	ld.a %a2,[%a14]-52
80026788:	d9 22 1c 00 	lea %a2,[%a2]28
8002678c:	54 22       	ld.w %d2,[%a2]
8002678e:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    pbuf_t *p, *q;
    u16_t   len;

    len = 0;
80026792:	82 02       	mov %d2,0
80026794:	f9 e2 fa ff 	st.h [%a14]-6,%d2
80026798:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8002679c:	59 e2 e8 ff 	st.w [%a14]-24,%d2
800267a0:	82 02       	mov %d2,0
800267a2:	59 e2 e4 ff 	st.w [%a14]-28,%d2
800267a6:	19 e2 e8 ff 	ld.w %d2,[%a14]-24
800267aa:	59 e2 e0 ff 	st.w [%a14]-32,%d2
800267ae:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
800267b2:	59 e2 dc ff 	st.w [%a14]-36,%d2
    return geth->rxChannel[channelId].rxDescrPtr;
800267b6:	19 e3 e0 ff 	ld.w %d3,[%a14]-32
800267ba:	19 e2 dc ff 	ld.w %d2,[%a14]-36
800267be:	06 42       	sh %d2,4
800267c0:	42 32       	add %d2,%d3
800267c2:	60 22       	mov.a %a2,%d2
800267c4:	d9 22 24 10 	lea %a2,[%a2]100
800267c8:	d4 22       	ld.a %a2,[%a2]
    return IfxGeth_Eth_getActualRxDescriptor(geth, channelId)->RDES3.R.OWN == 0;
800267ca:	d9 22 0c 00 	lea %a2,[%a2]12
800267ce:	54 22       	ld.w %d2,[%a2]
800267d0:	37 02 e1 2f 	extr.u %d2,%d2,31,1
800267d4:	8f f2 0f 21 	and %d2,%d2,255
800267d8:	8f 12 80 21 	xor %d2,%d2,1
800267dc:	8f f2 0f 21 	and %d2,%d2,255
    if (IfxGeth_Eth_isRxDataAvailable(ethernetif, IfxGeth_RxDmaChannel_0) != FALSE)
800267e0:	df 02 18 00 	jeq %d2,0,80026810 <low_level_input+0x94>
800267e4:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
800267e8:	59 e2 d8 ff 	st.w [%a14]-40,%d2
800267ec:	82 02       	mov %d2,0
800267ee:	59 e2 d4 ff 	st.w [%a14]-44,%d2
    return geth->rxChannel[channelId].rxDescrPtr;
800267f2:	19 e3 d8 ff 	ld.w %d3,[%a14]-40
800267f6:	19 e2 d4 ff 	ld.w %d2,[%a14]-44
800267fa:	06 42       	sh %d2,4
800267fc:	42 32       	add %d2,%d3
800267fe:	60 22       	mov.a %a2,%d2
80026800:	d9 22 24 10 	lea %a2,[%a2]100
80026804:	54 22       	ld.w %d2,[%a2]
    {
        len = GetRxFrameSize((IfxGeth_RxDescr *)IfxGeth_Eth_getActualRxDescriptor(ethernetif, IfxGeth_RxDmaChannel_0));
80026806:	60 24       	mov.a %a4,%d2
80026808:	6d ff 81 ff 	call 8002670a <GetRxFrameSize>
8002680c:	f9 e2 fa ff 	st.h [%a14]-6,%d2
    }

    if (len == 0)
80026810:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
80026814:	df 02 05 80 	jne %d2,0,8002681e <low_level_input+0xa2>
    {
        return (pbuf_t *)0;
80026818:	82 02       	mov %d2,0
8002681a:	1d 00 83 00 	j 80026920 <low_level_input+0x1a4>
    }

#if ETH_PAD_SIZE
    len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
8002681e:	c9 e2 fa ff 	ld.h %d2,[%a14]-6
80026822:	c2 22       	add %d2,2
80026824:	f9 e2 fa ff 	st.h [%a14]-6,%d2
#endif

    /* We allocate a pbuf chain of pbufs from the pool. */
    p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
80026828:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
8002682c:	3b 20 18 60 	mov %d6,386
80026830:	02 25       	mov %d5,%d2
80026832:	82 04       	mov %d4,0
80026834:	6d ff 56 97 	call 800196e0 <pbuf_alloc>
80026838:	b5 e2 ec ff 	st.a [%a14]-20,%a2

    if (p != NULL)
8002683c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80026840:	df 02 50 00 	jeq %d2,0,800268e0 <low_level_input+0x164>
    {
#if ETH_PAD_SIZE
        pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
80026844:	82 e4       	mov %d4,-2
80026846:	99 e4 ec ff 	ld.a %a4,[%a14]-20
8002684a:	6d ff 87 9b 	call 80019f58 <pbuf_header>
#endif

        u8_t *src = IfxGeth_Eth_getReceiveBuffer(ethernetif, IfxGeth_RxDmaChannel_0);
8002684e:	82 04       	mov %d4,0
80026850:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026854:	6d ff d0 1d 	call 8000a3f4 <IfxGeth_Eth_getReceiveBuffer>
80026858:	b5 e2 f4 ff 	st.a [%a14]-12,%a2

        /* We iterate over the pbuf chain until we have read the entire
         * packet into the pbuf. */
        for (q = p; q != NULL; q = q->next)
8002685c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80026860:	59 e2 fc ff 	st.w [%a14]-4,%d2
80026864:	1d 00 1f 00 	j 800268a2 <low_level_input+0x126>
             * pbufs for a DMA-enabled MAC and after receiving truncate it to the
             * actually received size. In this case, ensure the tot_len member of the
             * pbuf is the sum of the chained pbuf len members.
             */
            //read data into(q->payload, q->len);
            memcpy(q->payload, src, q->len);
80026868:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002686c:	b0 42       	add.a %a2,4
8002686e:	54 22       	ld.w %d2,[%a2]
80026870:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80026874:	b9 23 0a 00 	ld.hu %d3,[%a2]10
80026878:	02 34       	mov %d4,%d3
8002687a:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8002687e:	60 24       	mov.a %a4,%d2
80026880:	6d 00 ce 04 	call 8002721c <memcpy>
            src = &src[q->len];
80026884:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80026888:	b9 22 0a 00 	ld.hu %d2,[%a2]10
8002688c:	02 23       	mov %d3,%d2
8002688e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80026892:	42 32       	add %d2,%d3
80026894:	59 e2 f4 ff 	st.w [%a14]-12,%d2
        for (q = p; q != NULL; q = q->next)
80026898:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002689c:	54 22       	ld.w %d2,[%a2]
8002689e:	59 e2 fc ff 	st.w [%a14]-4,%d2
800268a2:	19 e2 fc ff 	ld.w %d2,[%a14]-4
800268a6:	df 02 e1 ff 	jne %d2,0,80026868 <low_level_input+0xec>

            LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("low_level_input: payload=0x%x, len=%d\n", q->payload, q->len));
        }

        //acknowledge that packet has been read();
        IfxGeth_Eth_freeReceiveBuffer(ethernetif, IfxGeth_RxDmaChannel_0);
800268aa:	82 04       	mov %d4,0
800268ac:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
800268b0:	6d ff 5c 1d 	call 8000a368 <IfxGeth_Eth_freeReceiveBuffer>

#if ETH_PAD_SIZE
        pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
800268b4:	82 24       	mov %d4,2
800268b6:	99 e4 ec ff 	ld.a %a4,[%a14]-20
800268ba:	6d ff 4f 9b 	call 80019f58 <pbuf_header>
#endif

        LINK_STATS_INC(link.recv);
800268be:	91 10 00 27 	movh.a %a2,28673
800268c2:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800268c6:	b9 22 02 00 	ld.hu %d2,[%a2]2 <70010002 <ram_heap+0x4f6e>>
800268ca:	c2 12       	add %d2,1
800268cc:	37 02 70 20 	extr.u %d2,%d2,0,16
800268d0:	91 10 00 27 	movh.a %a2,28673
800268d4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800268d8:	f9 22 02 00 	st.h [%a2]2 <70010002 <ram_heap+0x4f6e>>,%d2
800268dc:	1d 00 20 00 	j 8002691c <low_level_input+0x1a0>
    }
    else
    {
        //TODO: drop packet();
        LINK_STATS_INC(link.memerr);
800268e0:	91 10 00 27 	movh.a %a2,28673
800268e4:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800268e8:	b9 22 0c 00 	ld.hu %d2,[%a2]12 <7001000c <ram_heap+0x4f78>>
800268ec:	c2 12       	add %d2,1
800268ee:	37 02 70 20 	extr.u %d2,%d2,0,16
800268f2:	91 10 00 27 	movh.a %a2,28673
800268f6:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
800268fa:	f9 22 0c 00 	st.h [%a2]12 <7001000c <ram_heap+0x4f78>>,%d2
        LINK_STATS_INC(link.drop);
800268fe:	91 10 00 27 	movh.a %a2,28673
80026902:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80026906:	b9 22 06 00 	ld.hu %d2,[%a2]6 <70010006 <ram_heap+0x4f72>>
8002690a:	c2 12       	add %d2,1
8002690c:	37 02 70 20 	extr.u %d2,%d2,0,16
80026910:	91 10 00 27 	movh.a %a2,28673
80026914:	d9 22 54 34 	lea %a2,[%a2]17620 <700144d4 <lwip_stats>>
80026918:	f9 22 06 00 	st.h [%a2]6 <70010006 <ram_heap+0x4f72>>,%d2
    }

    return p;
8002691c:	19 e2 ec ff 	ld.w %d2,[%a14]-20 <70010006 <ram_heap+0x4f72>>
}
80026920:	60 22       	mov.a %a2,%d2
80026922:	00 90       	ret 

80026924 <ifx_netif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
err_t ifx_netif_input(netif_t *netif)
{
80026924:	40 ae       	mov.aa %a14,%sp
80026926:	20 10       	sub.a %sp,16
80026928:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
    //Ifx_GETH *ethernetif = netif->state;
    eth_hdr_t *ethhdr;
    pbuf_t    *p;

    /* move received packet into a new pbuf */
    p = low_level_input(netif);
8002692c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80026930:	6d ff 26 ff 	call 8002677c <low_level_input>
80026934:	b5 e2 fc ff 	st.a [%a14]-4,%a2

    /* no packet could be read, silently ignore this */
    if (p == NULL)
80026938:	19 e2 fc ff 	ld.w %d2,[%a14]-4
8002693c:	df 02 04 80 	jne %d2,0,80026944 <ifx_netif_input+0x20>
    {
        //LWIP_DEBUGF(NETIF_DEBUG, ("ifx_netif_input: p == NULL!\n"));
        return ERR_OK;
80026940:	82 02       	mov %d2,0
80026942:	00 90       	ret 
    }

    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
80026944:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80026948:	b0 42       	add.a %a2,4
8002694a:	54 22       	ld.w %d2,[%a2]
8002694c:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    switch (htons(ethhdr->type))
80026950:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026954:	39 23 0e 00 	ld.bu %d3,[%a2]14
80026958:	39 22 0f 00 	ld.bu %d2,[%a2]15
8002695c:	8f 82 00 20 	sh %d2,%d2,8
80026960:	a6 32       	or %d2,%d3
80026962:	37 02 70 20 	extr.u %d2,%d2,0,16
80026966:	02 24       	mov %d4,%d2
80026968:	6d ff f6 85 	call 80017554 <lwip_htons>
8002696c:	3b 00 80 30 	mov %d3,2048
80026970:	5f 32 06 00 	jeq %d2,%d3,8002697c <ifx_netif_input+0x58>
80026974:	3b 60 80 30 	mov %d3,2054
80026978:	5f 32 18 80 	jne %d2,%d3,800269a8 <ifx_netif_input+0x84>
    case ETHTYPE_PPPOEDISC:
    case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */

        /* full packet send to tcpip_thread to process */
        if (netif->input(p, netif) != ERR_OK)
8002697c:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80026980:	d9 22 10 00 	lea %a2,[%a2]16
80026984:	d4 22       	ld.a %a2,[%a2]
80026986:	99 e5 f4 ff 	ld.a %a5,[%a14]-12
8002698a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8002698e:	2d 02 00 00 	calli %a2
80026992:	df 02 14 00 	jeq %d2,0,800269ba <ifx_netif_input+0x96>
        {
            LWIP_DEBUGF(NETIF_DEBUG, ("ifx_netif_input: IP input error\n"));
            pbuf_free(p);
80026996:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8002699a:	6d ff ff 9a 	call 80019f98 <pbuf_free>
            p = NULL;
8002699e:	82 02       	mov %d2,0
800269a0:	59 e2 fc ff 	st.w [%a14]-4,%d2
        }

        break;
800269a4:	1d 00 0b 00 	j 800269ba <ifx_netif_input+0x96>

    default:
        LWIP_DEBUGF(NETIF_DEBUG, ("ifx_netif_input: type unknown\n"));
        pbuf_free(p);
800269a8:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800269ac:	6d ff f6 9a 	call 80019f98 <pbuf_free>
        p = NULL;
800269b0:	82 02       	mov %d2,0
800269b2:	59 e2 fc ff 	st.w [%a14]-4,%d2
        break;
800269b6:	1d 00 03 00 	j 800269bc <ifx_netif_input+0x98>
        break;
800269ba:	00 00       	nop 
    }

    return ERR_OK;
800269bc:	82 02       	mov %d2,0
}
800269be:	00 90       	ret 

800269c0 <ifx_netif_init>:
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t ifx_netif_init(netif_t *netif)
{
800269c0:	40 ae       	mov.aa %a14,%sp
800269c2:	20 20       	sub.a %sp,32
800269c4:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
	IfxGeth_Eth *ethernetif;

    LWIP_ASSERT("netif != NULL", (netif != NULL));
800269c8:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
800269cc:	df 02 17 80 	jne %d2,0,800269fa <ifx_netif_init+0x3a>
800269d0:	91 00 00 28 	movh.a %a2,32768
800269d4:	d9 22 4e a3 	lea %a2,[%a2]13966 <8000368e <IfxCpu_Trap_vectorTable0_end+0x349a>>
800269d8:	b5 a2 08 00 	st.a [%sp]8 <8000368e <IfxCpu_Trap_vectorTable0_end+0x349a>>,%a2
800269dc:	3b e0 20 20 	mov %d2,526
800269e0:	59 a2 04 00 	st.w [%sp]4,%d2
800269e4:	91 00 00 28 	movh.a %a2,32768
800269e8:	d9 22 68 b3 	lea %a2,[%a2]14056 <800036e8 <IfxCpu_Trap_vectorTable0_end+0x34f4>>
800269ec:	f4 a2       	st.a [%sp],%a2
800269ee:	91 00 00 28 	movh.a %a2,32768
800269f2:	d9 24 66 93 	lea %a4,[%a2]13926 <80003666 <IfxCpu_Trap_vectorTable0_end+0x3472>>
800269f6:	6d fe a0 f4 	call 80005336 <Ifx_Lwip_printf>
}

/* This function is used to get the low-level driver */
IFX_INLINE IfxGeth_Eth *IfxGeth_get(void)
{
    return &g_IfxGeth;
800269fa:	91 00 00 27 	movh.a %a2,28672
800269fe:	d9 22 04 20 	lea %a2,[%a2]132 <70000084 <g_IfxGeth>>
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE, ("ifx_netif_init ( %#x)\n", netif));

    ethernetif = IfxGeth_get();
80026a02:	b5 e2 fc ff 	st.a [%a14]-4 <70000084 <g_IfxGeth>>,%a2

    if (ethernetif == NULL)
80026a06:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <70000084 <g_IfxGeth>>
80026a0a:	df 02 04 80 	jne %d2,0,80026a12 <ifx_netif_init+0x52>
    {
        LWIP_DEBUGF(NETIF_DEBUG, ("ifx_netif_init: out of memory\n"));
        return ERR_MEM;
80026a0e:	82 f2       	mov %d2,-1
80026a10:	00 90       	ret 
    }

#if LWIP_NETIF_HOSTNAME
    /* Initialize interface hostname */
    netif->hostname = "lwip";
80026a12:	99 e3 f4 ff 	ld.a %a3,[%a14]-12
80026a16:	91 00 00 28 	movh.a %a2,32768
80026a1a:	d9 22 76 b3 	lea %a2,[%a2]14070 <800036f6 <IfxCpu_Trap_vectorTable0_end+0x3502>>
80026a1e:	d9 33 24 00 	lea %a3,[%a3]36 <800036f6 <IfxCpu_Trap_vectorTable0_end+0x3502>>
80026a22:	f4 32       	st.a [%a3],%a2
     * The last argument should be replaced with your link speed, in units
     * of bits per second.
     */
    //NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

    netif->state      = ethernetif;
80026a24:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <800036f6 <IfxCpu_Trap_vectorTable0_end+0x3502>>
80026a28:	19 e2 fc ff 	ld.w %d2,[%a14]-4 <800036f6 <IfxCpu_Trap_vectorTable0_end+0x3502>>
80026a2c:	d9 22 1c 00 	lea %a2,[%a2]28 <800036f6 <IfxCpu_Trap_vectorTable0_end+0x3502>>
80026a30:	74 22       	st.w [%a2],%d2
    netif->name[0]    = IFNAME0;
80026a32:	99 e2 f4 ff 	ld.a %a2,[%a14]-12 <800036f6 <IfxCpu_Trap_vectorTable0_end+0x3502>>
80026a36:	3b 50 06 20 	mov %d2,101
80026a3a:	e9 22 32 00 	st.b [%a2]50,%d2
    netif->name[1]    = IFNAME1;
80026a3e:	99 e2 f4 ff 	ld.a %a2,[%a14]-12
80026a42:	3b e0 06 20 	mov %d2,110
80026a46:	e9 22 33 00 	st.b [%a2]51,%d2
    /* We directly use etharp_output() here to save a function call.
     * You can instead declare your own function an call etharp_output()
     * from it if you have to do some checks before sending (e.g. if link
     * is available...) */
    netif->output     = etharp_output;
80026a4a:	99 e3 f4 ff 	ld.a %a3,[%a14]-12
80026a4e:	91 10 00 28 	movh.a %a2,32769
80026a52:	d9 22 f2 83 	lea %a2,[%a2]15922 <80013e32 <etharp_output>>
80026a56:	d9 33 14 00 	lea %a3,[%a3]20 <80013e32 <etharp_output>>
80026a5a:	f4 32       	st.a [%a3],%a2
    netif->linkoutput = low_level_output;
80026a5c:	99 e3 f4 ff 	ld.a %a3,[%a14]-12 <80013e32 <etharp_output>>
80026a60:	91 20 00 28 	movh.a %a2,32770
80026a64:	d9 22 70 56 	lea %a2,[%a2]25968 <80026570 <low_level_output>>
80026a68:	d9 33 18 00 	lea %a3,[%a3]24 <80026570 <low_level_output>>
80026a6c:	f4 32       	st.a [%a3],%a2

    /* initialize the hardware */
    low_level_init(netif);
80026a6e:	99 e4 f4 ff 	ld.a %a4,[%a14]-12 <80026570 <low_level_output>>
80026a72:	6d ff 72 fb 	call 80026156 <low_level_init>

    return ERR_OK;
80026a76:	82 02       	mov %d2,0
}
80026a78:	00 90       	ret 

80026a7a <Ifx_Ssw_Pms_Init>:
#pragma GCC optimize ("O1")
#endif

#if (IFX_CFG_SSW_ENABLE_PMS_INIT == 1U)
void Ifx_Ssw_Pms_Init(void)
{
80026a7a:	40 ae       	mov.aa %a14,%sp
    uint16 password = MODULE_SCU.SEICON0.B.EPW ^ 0x003F;
80026a7c:	91 30 00 2f 	movh.a %a2,61443
80026a80:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
80026a84:	19 22 34 a0 	ld.w %d2,[%a2]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>
80026a88:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint32                                      regVal;
    uint16                                      endinitSfty_pw = IfxScuWdt_getGlobalSafetyEndinitPasswordInline();
    const IfxPmsEvr_initSequencePhase          *phaseConfig;
    const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;

    if (PMS_EVRSTAT.B.EVRC == 1U)
80026a8c:	91 50 02 2f 	movh.a %a2,61477
80026a90:	d9 22 2c 08 	lea %a2,[%a2]-32724 <f024802c <bmhd_3_copy+0x40e46a2c>>
80026a94:	54 23       	ld.w %d3,[%a2]
80026a96:	6f 03 04 80 	jnz.t %d3,0,80026a9e <Ifx_Ssw_Pms_Init+0x24>
}


IFX_SSW_INLINE void Ifx_Ssw_jumpBackToLink(void)
{
    __asm__ volatile ("ji %a11");
80026a9a:	dc 0b       	ji %a11
        __debug();
        /* Application may have call to error handling here */
    }

    Ifx_Ssw_jumpBackToLink();
}
80026a9c:	00 90       	ret 
    {
        /*Loop through each configured phase*/
        for (phaseConfig = &sequence->phaseConfig[0];
80026a9e:	91 00 00 28 	movh.a %a2,32768
80026aa2:	d9 23 38 f4 	lea %a3,[%a2]17400 <800043f8 <IfxPmsEvr_cfgSequenceDefault>>
80026aa6:	b0 43       	add.a %a3,4
80026aa8:	d4 33       	ld.a %a3,[%a3]
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
80026aaa:	39 27 38 f4 	ld.bu %d7,[%a2]17400 <800043f8 <IfxPmsEvr_cfgSequenceDefault>>
80026aae:	53 c7 20 70 	mul %d7,%d7,12
80026ab2:	80 33       	mov.d %d3,%a3
80026ab4:	42 73       	add %d3,%d7
80026ab6:	80 34       	mov.d %d4,%a3
80026ab8:	7f 34 f1 ff 	jge.u %d4,%d3,80026a9a <Ifx_Ssw_Pms_Init+0x20>
             phaseConfig++)
        {
            IfxScuWdt_clearGlobalSafetyEndinitInline(endinitSfty_pw);
80026abc:	8f f2 83 21 	xor %d2,%d2,63
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF);
80026ac0:	06 22       	sh %d2,2
80026ac2:	7b c0 ff 0f 	movh %d0,65532
80026ac6:	a6 20       	or %d0,%d2
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF) | (1 << IFX_SCU_SEICON0_ENDINIT_OFF);
80026ac8:	7b c0 ff 1f 	movh %d1,65532
80026acc:	c2 21       	add %d1,2
80026ace:	a6 21       	or %d1,%d2
    boolean                                     pmsInitDone    = TRUE;
80026ad0:	82 18       	mov %d8,1
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF);
80026ad2:	91 30 00 4f 	movh.a %a4,61443
80026ad6:	d9 44 00 06 	lea %a4,[%a4]24576 <f0036000 <bmhd_3_copy+0x40c34a00>>
    while (MODULE_SCU.SEICON0.B.ENDINIT == 1)
80026ada:	02 84       	mov %d4,%d8
                 * However, for this function, as this is used only with CPU0 startup no wait required
                 */
                (*((volatile uint32 *)regConfig->regAddr)) = regVal; /*Write to the physical register*/
            }

            PMS_EVRSDCTRL0.B.UP = 1;
80026adc:	91 50 02 5f 	movh.a %a5,61477
80026ae0:	d9 55 08 48 	lea %a5,[%a5]-32504 <f0248108 <bmhd_3_copy+0x40e46b08>>
            /*Now, wait for the UP bit at EVRSDCTRL0 is reset, which is to indicate the configurations are done*/
            do
            {
                if (--timeoutCount <= 0)
                {
                    pmsInitDone = FALSE;
80026ae4:	82 09       	mov %d9,0
}


IFX_INLINE void IfxPmsEvr_wait(float32 waitInSec)
{
    uint32 stmCount      = (uint32)((float32)33000000UL * waitInSec);
80026ae6:	7b c0 bf 64 	movh %d6,19452
80026aea:	1b 06 52 6c 	addi %d6,%d6,-15072
    uint32 stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80026aee:	c5 f6 10 01 	lea %a6,f0001010 <bmhd_3_copy+0x40bffa10>
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
80026af2:	d9 2c 38 f4 	lea %a12,[%a2]17400 <800043f8 <IfxPmsEvr_cfgSequenceDefault>>
80026af6:	1d 00 15 00 	j 80026b20 <Ifx_Ssw_Pms_Init+0xa6>
    uint32 stmCount      = (uint32)((float32)33000000UL * waitInSec);
80026afa:	19 32 08 00 	ld.w %d2,[%a3]8
80026afe:	4b 26 41 20 	mul.f %d2,%d6,%d2
80026b02:	4b 02 71 31 	ftouz %d3,%d2
    uint32 stmCountBegin = STM0_TIM0.U;     /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */
80026b06:	54 65       	ld.w %d5,[%a6]

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80026b08:	54 62       	ld.w %d2,[%a6]
80026b0a:	a2 52       	sub %d2,%d5
80026b0c:	3f 32 fe ff 	jlt.u %d2,%d3,80026b08 <Ifx_Ssw_Pms_Init+0x8e>
             phaseConfig++)
80026b10:	d9 33 0c 00 	lea %a3,[%a3]12
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
80026b14:	19 c2 04 00 	ld.w %d2,[%a12]4
80026b18:	42 72       	add %d2,%d7
80026b1a:	80 33       	mov.d %d3,%a3
80026b1c:	7f 23 3d 80 	jge.u %d3,%d2,80026b96 <Ifx_Ssw_Pms_Init+0x11c>
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF);
80026b20:	59 40 34 a0 	st.w [%a4]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>,%d0
    while (MODULE_SCU.SEICON0.B.ENDINIT == 1)
80026b24:	19 42 34 a0 	ld.w %d2,[%a4]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>
80026b28:	37 02 e1 20 	extr.u %d2,%d2,1,1
80026b2c:	5f 42 fc 7f 	jeq %d2,%d4,80026b24 <Ifx_Ssw_Pms_Init+0xaa>
            for (regConfig = &phaseConfig->regConfig[0];
80026b30:	99 32 04 00 	ld.a %a2,[%a3]4
                 regConfig < &phaseConfig->regConfig[phaseConfig->numOfRegisters];
80026b34:	14 32       	ld.bu %d2,[%a3]
80026b36:	80 23       	mov.d %d3,%a2
80026b38:	13 c2 20 23 	madd %d2,%d3,%d2,12
80026b3c:	7f 23 16 80 	jge.u %d3,%d2,80026b68 <Ifx_Ssw_Pms_Init+0xee>
                regVal  = (*((volatile uint32 *)regConfig->regAddr));
80026b40:	d4 27       	ld.a %a7,[%a2]
80026b42:	54 72       	ld.w %d2,[%a7]
                regVal &= ~regConfig->mask;
80026b44:	19 23 08 00 	ld.w %d3,[%a2]8
80026b48:	0f 32 e0 20 	andn %d2,%d2,%d3
                regVal |= regConfig->value;
80026b4c:	19 23 04 00 	ld.w %d3,[%a2]4
80026b50:	a6 32       	or %d2,%d3
                (*((volatile uint32 *)regConfig->regAddr)) = regVal; /*Write to the physical register*/
80026b52:	74 72       	st.w [%a7],%d2
                 regConfig++)
80026b54:	d9 22 0c 00 	lea %a2,[%a2]12
                 regConfig < &phaseConfig->regConfig[phaseConfig->numOfRegisters];
80026b58:	14 32       	ld.bu %d2,[%a3]
80026b5a:	19 33 04 00 	ld.w %d3,[%a3]4
80026b5e:	13 c2 20 23 	madd %d2,%d3,%d2,12
80026b62:	80 23       	mov.d %d3,%a2
80026b64:	3f 23 ee ff 	jlt.u %d3,%d2,80026b40 <Ifx_Ssw_Pms_Init+0xc6>
            PMS_EVRSDCTRL0.B.UP = 1;
80026b68:	54 52       	ld.w %d2,[%a5]
80026b6a:	b7 12 01 2f 	insert %d2,%d2,1,30,1
80026b6e:	74 52       	st.w [%a5],%d2
    MODULE_SCU.SEICON0.U = (0xFFFCU << 16U) | (password << IFX_SCU_SEICON0_EPW_OFF) | (1 << IFX_SCU_SEICON0_ENDINIT_OFF);
80026b70:	59 41 34 a0 	st.w [%a4]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>,%d1
    while (MODULE_SCU.SEICON0.B.ENDINIT == 0)
80026b74:	19 42 34 a0 	ld.w %d2,[%a4]692 <f00302b4 <bmhd_3_copy+0x40c2ecb4>>
80026b78:	6f 12 fe 7f 	jz.t %d2,1,80026b74 <Ifx_Ssw_Pms_Init+0xfa>
80026b7c:	3b f0 0f 20 	mov %d2,255
            } while (PMS_EVRSDCTRL0.B.UP == 1);
80026b80:	54 53       	ld.w %d3,[%a5]
80026b82:	37 03 61 3f 	extr.u %d3,%d3,30,1
80026b86:	5f 43 ba ff 	jne %d3,%d4,80026afa <Ifx_Ssw_Pms_Init+0x80>
                if (--timeoutCount <= 0)
80026b8a:	c2 f2       	add %d2,-1
80026b8c:	df 02 fa ff 	jne %d2,0,80026b80 <Ifx_Ssw_Pms_Init+0x106>
                    pmsInitDone = FALSE;
80026b90:	02 98       	mov %d8,%d9
80026b92:	1d ff b4 ff 	j 80026afa <Ifx_Ssw_Pms_Init+0x80>
    if (IfxPmsEvr_runInitSequence(&IfxPmsEvr_cfgSequenceDefault) == 0)
80026b96:	df 08 82 ff 	jne %d8,0,80026a9a <Ifx_Ssw_Pms_Init+0x20>
    __asm__ volatile ("debug" : : : "memory");
80026b9a:	00 a0       	debug 
}
80026b9c:	1d ff 7f ff 	j 80026a9a <Ifx_Ssw_Pms_Init+0x20>

80026ba0 <Ifx_Ssw_Pms_InitCheck>:

#if (IFX_CFG_SSW_ENABLE_PMS_INIT_CHECK == 1U)
void Ifx_Ssw_Pms_InitCheck(void)
{
80026ba0:	40 ae       	mov.aa %a14,%sp
    if (PMS_EVRSTAT.B.EVRC == 1U)
80026ba2:	91 50 02 2f 	movh.a %a2,61477
80026ba6:	d9 22 2c 08 	lea %a2,[%a2]-32724 <f024802c <bmhd_3_copy+0x40e46a2c>>
80026baa:	54 22       	ld.w %d2,[%a2]
80026bac:	6f 02 04 80 	jnz.t %d2,0,80026bb4 <Ifx_Ssw_Pms_InitCheck+0x14>
80026bb0:	dc 0b       	ji %a11
    {
        __debug();
        /* Application may have call to error handling here */
    }
    Ifx_Ssw_jumpBackToLink();
}
80026bb2:	00 90       	ret 
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
80026bb4:	91 00 00 28 	movh.a %a2,32768
80026bb8:	39 25 48 44 	ld.bu %d5,[%a2]17672 <80004508 <IfxPmsEvr_checkRegCfgDefault>>
80026bbc:	bf 15 1d 00 	jlt %d5,1,80026bf6 <Ifx_Ssw_Pms_InitCheck+0x56>
            const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig = &checkConfig->regConfig[regCfgCount];
80026bc0:	91 00 00 28 	movh.a %a2,32768
80026bc4:	99 22 4c 44 	ld.a %a2,[%a2]17676 <8000450c <IfxPmsEvr_checkRegCfgDefault+0x4>>
    boolean allRight = TRUE;
80026bc8:	82 12       	mov %d2,1
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
80026bca:	82 03       	mov %d3,0
            regVal  = (*((volatile uint32 *)regConfig->regAddr));
80026bcc:	d4 23       	ld.a %a3,[%a2]
80026bce:	54 34       	ld.w %d4,[%a3]
            regVal &= regConfig->mask;
80026bd0:	19 26 08 00 	ld.w %d6,[%a2]8
80026bd4:	26 64       	and %d4,%d6
            if (regVal != regConfig->value)
80026bd6:	19 26 04 00 	ld.w %d6,[%a2]4
                allRight = FALSE;
80026bda:	0b 64 00 41 	eq %d4,%d4,%d6
80026bde:	ab 02 80 24 	sel %d2,%d4,%d2,0
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
80026be2:	c2 13       	add %d3,1
80026be4:	d9 22 0c 00 	lea %a2,[%a2]12
80026be8:	5f 53 f2 ff 	jne %d3,%d5,80026bcc <Ifx_Ssw_Pms_InitCheck+0x2c>
        if (allRight == TRUE)
80026bec:	df 12 05 00 	jeq %d2,1,80026bf6 <Ifx_Ssw_Pms_InitCheck+0x56>
    __asm__ volatile ("debug" : : : "memory");
80026bf0:	00 a0       	debug 
}
80026bf2:	1d ff df ff 	j 80026bb0 <Ifx_Ssw_Pms_InitCheck+0x10>
            if (PMS_EVRSTAT.B.SDVOK != 1)
80026bf6:	91 50 02 2f 	movh.a %a2,61477
80026bfa:	d9 22 2c 08 	lea %a2,[%a2]-32724 <f024802c <bmhd_3_copy+0x40e46a2c>>
80026bfe:	54 22       	ld.w %d2,[%a2]
80026c00:	ef 52 d8 ff 	jnz.t %d2,21,80026bb0 <Ifx_Ssw_Pms_InitCheck+0x10>
80026c04:	1d ff f6 ff 	j 80026bf0 <Ifx_Ssw_Pms_InitCheck+0x50>

80026c08 <echoInit>:
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the ECHO program */
void echoInit(void)
{
80026c08:	40 ae       	mov.aa %a14,%sp
80026c0a:	20 08       	sub.a %sp,8
    g_echoPcb = tcp_new();                                          /* Create a new TCP protocol control block                                                      */
80026c0c:	6d ff cc af 	call 8001cba4 <tcp_new>
80026c10:	80 22       	mov.d %d2,%a2
80026c12:	91 10 00 27 	movh.a %a2,28673
80026c16:	d9 22 60 84 	lea %a2,[%a2]17952 <70014620 <g_echoPcb>>
80026c1a:	74 22       	st.w [%a2],%d2
    if (g_echoPcb != NULL)                                          /* If the creation was successful...                                                            */
80026c1c:	91 10 00 27 	movh.a %a2,28673
80026c20:	d9 22 60 84 	lea %a2,[%a2]17952 <70014620 <g_echoPcb>>
80026c24:	54 22       	ld.w %d2,[%a2]
80026c26:	df 02 3c 00 	jeq %d2,0,80026c9e <echoInit+0x96>
    {
        err_t err = tcp_bind(g_echoPcb, IP_ADDR_ANY, 80);           /* ...bind the TCP procotol control block to any local address and local port 80.               */
80026c2a:	91 10 00 27 	movh.a %a2,28673
80026c2e:	d9 22 60 84 	lea %a2,[%a2]17952 <70014620 <g_echoPcb>>
80026c32:	54 22       	ld.w %d2,[%a2]
80026c34:	3b 00 05 40 	mov %d4,80
80026c38:	91 00 00 28 	movh.a %a2,32768
80026c3c:	d9 25 5c 44 	lea %a5,[%a2]17692 <8000451c <ip_addr_any>>
80026c40:	60 24       	mov.a %a4,%d2
80026c42:	6d ff 6c a2 	call 8001b11a <tcp_bind>
80026c46:	e9 e2 ff ff 	st.b [%a14]-1,%d2
        if (err == ERR_OK)                                          /* If the binding was successful...                                                             */
80026c4a:	79 e2 ff ff 	ld.b %d2,[%a14]-1
80026c4e:	df 02 20 80 	jne %d2,0,80026c8e <echoInit+0x86>
        {
            g_echoPcb = tcp_listen(g_echoPcb);                      /* ...set the TCP control block able to accept incoming connections.                            */
80026c52:	91 10 00 27 	movh.a %a2,28673
80026c56:	d9 22 60 84 	lea %a2,[%a2]17952 <70014620 <g_echoPcb>>
80026c5a:	54 22       	ld.w %d2,[%a2]
80026c5c:	3b f0 0f 40 	mov %d4,255
80026c60:	60 24       	mov.a %a4,%d2
80026c62:	6d ff 62 a3 	call 8001b326 <tcp_listen_with_backlog>
80026c66:	80 22       	mov.d %d2,%a2
80026c68:	91 10 00 27 	movh.a %a2,28673
80026c6c:	d9 22 60 84 	lea %a2,[%a2]17952 <70014620 <g_echoPcb>>
80026c70:	74 22       	st.w [%a2],%d2
            tcp_accept(g_echoPcb, echoAccept);                      /* Configure the callback function to be called when a new connection is established.           */
80026c72:	91 10 00 27 	movh.a %a2,28673
80026c76:	d9 22 60 84 	lea %a2,[%a2]17952 <70014620 <g_echoPcb>>
80026c7a:	54 22       	ld.w %d2,[%a2]
80026c7c:	91 20 00 28 	movh.a %a2,32770
80026c80:	d9 25 ee 26 	lea %a5,[%a2]27822 <80026cae <echoAccept>>
80026c84:	60 24       	mov.a %a4,%d2
80026c86:	6d ff 37 b0 	call 8001ccf4 <tcp_accept>
    }
    else
    {
        LWIP_DEBUGF(ECHO_DEBUG | LWIP_DBG_STATE, ("Echo: unable to create a TCP control block.\n"));
    }
}
80026c8a:	1d 00 10 00 	j 80026caa <echoInit+0xa2>
            LWIP_DEBUGF(ECHO_DEBUG | LWIP_DBG_STATE, ("Echo: unable to bind to any address on port 80.\n"));
80026c8e:	91 00 00 28 	movh.a %a2,32768
80026c92:	d9 24 95 83 	lea %a4,[%a2]14869 <80003a15 <IfxCpu_Trap_vectorTable0_end+0x3821>>
80026c96:	6d fe 50 f3 	call 80005336 <Ifx_Lwip_printf>
}
80026c9a:	1d 00 08 00 	j 80026caa <echoInit+0xa2>
        LWIP_DEBUGF(ECHO_DEBUG | LWIP_DBG_STATE, ("Echo: unable to create a TCP control block.\n"));
80026c9e:	91 00 00 28 	movh.a %a2,32768
80026ca2:	d9 24 86 93 	lea %a4,[%a2]14918 <80003a46 <IfxCpu_Trap_vectorTable0_end+0x3852>>
80026ca6:	6d fe 48 f3 	call 80005336 <Ifx_Lwip_printf>
}
80026caa:	00 00       	nop 
80026cac:	00 90       	ret 

80026cae <echoAccept>:

/* Accept callback: it is called every time a client establish a new connection */
err_t echoAccept(void *arg, tcpPcb *newPcb, err_t err)
{
80026cae:	40 ae       	mov.aa %a14,%sp
80026cb0:	20 18       	sub.a %sp,24
80026cb2:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80026cb6:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
80026cba:	02 42       	mov %d2,%d4
80026cbc:	e9 e2 ec ff 	st.b [%a14]-20,%d2
    LWIP_UNUSED_ARG(arg);                                               /* Eliminate compiler warning about unused arguments                                        */
    LWIP_UNUSED_ARG(err);                                               /* Eliminate compiler warning about unused arguments                                        */

    err_t retErr;                                                       /* Allocate memory for function return value                                                */
    EchoSession *es = (EchoSession*) mem_malloc(sizeof(EchoSession));   /* Allocate memory for the session data                                                     */
80026cc0:	3b 00 11 40 	mov %d4,272
80026cc4:	6d ff 7f 8b 	call 800183c2 <mem_malloc>
80026cc8:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
    if (es != NULL)                                                     /* If memory allocation was successful the session can be initialized                       */
80026ccc:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80026cd0:	df 02 63 00 	jeq %d2,0,80026d96 <echoAccept+0xe8>
    {
        es->state = ES_ACCEPTED;                                        /* The new session has been accepted                                                        */
80026cd4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026cd8:	82 12       	mov %d2,1
80026cda:	34 22       	st.b [%a2],%d2
        es->pcb = newPcb;                                               /* A pointer to the TCP control block to use for this session is saved in the session       */
80026cdc:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026ce0:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
80026ce4:	b0 42       	add.a %a2,4
80026ce6:	74 22       	st.w [%a2],%d2
        es->p = NULL;                                                   /* The packet buffer for received data is initially empty                                   */
80026ce8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026cec:	82 02       	mov %d2,0
80026cee:	d9 22 08 00 	lea %a2,[%a2]8
80026cf2:	74 22       	st.w [%a2],%d2
        memset(es->storage, 0, STORAGE_SIZE_BYTES);                     /* Allocate memory for storing processed received data                                      */
80026cf4:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80026cf8:	1b c2 00 20 	addi %d2,%d2,12
80026cfc:	3b 00 10 50 	mov %d5,256
80026d00:	82 04       	mov %d4,0
80026d02:	60 24       	mov.a %a4,%d2
80026d04:	6d 00 96 02 	call 80027230 <memset>
        es->nextFreeStoragePos = 0;                                     /* The first free position in the received data array is the beginning of the array         */
80026d08:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026d0c:	82 02       	mov %d2,0
80026d0e:	f9 22 0c 40 	st.h [%a2]268,%d2

        tcp_arg(newPcb, es);                                            /* Specify that the session shall be passed as argument to every callback function          */
80026d12:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026d16:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026d1a:	6d ff 4d af 	call 8001cbb4 <tcp_arg>
        tcp_recv(newPcb, echoRecv);                                     /* Configure the callback function to be called when new data is received                   */
80026d1e:	91 20 00 28 	movh.a %a2,32770
80026d22:	d9 25 e2 66 	lea %a5,[%a2]28066 <80026da2 <echoRecv>>
80026d26:	99 e4 f0 ff 	ld.a %a4,[%a14]-16 <80026da2 <echoRecv>>
80026d2a:	6d ff 58 af 	call 8001cbda <tcp_recv>
        tcp_sent(newPcb, echoSent);                                     /* Configure the callback function to be called when new data is sent                       */
80026d2e:	91 20 00 28 	movh.a %a2,32770
80026d32:	d9 25 ca f6 	lea %a5,[%a2]28618 <80026fca <echoSent>>
80026d36:	99 e4 f0 ff 	ld.a %a4,[%a14]-16 <80026fca <echoSent>>
80026d3a:	6d ff 7f af 	call 8001cc38 <tcp_sent>
        tcp_err(newPcb, echoError);                                     /* Configure the callback function to be called when a fatal connection error occurs        */
80026d3e:	91 20 00 28 	movh.a %a2,32770
80026d42:	d9 25 da c6 	lea %a5,[%a2]28442 <80026f1a <echoError>>
80026d46:	99 e4 f0 ff 	ld.a %a4,[%a14]-16 <80026f1a <echoError>>
80026d4a:	6d ff a6 af 	call 8001cc96 <tcp_err>
        tcp_poll(newPcb, echoPoll, 0);                                  /* Configure the callback function to be periodically called by TCP
80026d4e:	82 04       	mov %d4,0
80026d50:	91 20 00 28 	movh.a %a2,32770
80026d54:	d9 25 c2 d6 	lea %a5,[%a2]28482 <80026f42 <echoPoll>>
80026d58:	99 e4 f0 ff 	ld.a %a4,[%a14]-16 <80026f42 <echoPoll>>
80026d5c:	6d ff ea af 	call 8001cd30 <tcp_poll>
                                                                         * The time interval is specified as multiple of the TCP coarse timer interval, which is
                                                                         * called twice a second                                                                    */
        retErr = ERR_OK;                                                /* Set the return value when no error occured                                               */
80026d60:	82 02       	mov %d2,0
80026d62:	e9 e2 ff ff 	st.b [%a14]-1,%d2

        tcp_write(newPcb, g_Logo, strlen(g_Logo), 1);                   /* Send the Infineon logo to the remote client                                              */
80026d66:	91 10 00 27 	movh.a %a2,28673
80026d6a:	d9 22 bc 4a 	lea %a2,[%a2]-22212 <7000a93c <g_Logo>>
80026d6e:	54 28       	ld.w %d8,[%a2]
80026d70:	91 10 00 27 	movh.a %a2,28673
80026d74:	d9 22 bc 4a 	lea %a2,[%a2]-22212 <7000a93c <g_Logo>>
80026d78:	54 22       	ld.w %d2,[%a2]
80026d7a:	60 24       	mov.a %a4,%d2
80026d7c:	6d 00 61 0c 	call 8002863e <strlen>
80026d80:	37 02 70 20 	extr.u %d2,%d2,0,16
80026d84:	82 15       	mov %d5,1
80026d86:	02 24       	mov %d4,%d2
80026d88:	60 85       	mov.a %a5,%d8
80026d8a:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026d8e:	6d ff ee d8 	call 80021f6a <tcp_write>
80026d92:	1d 00 05 00 	j 80026d9c <echoAccept+0xee>
    }
    else                                                                /* If it was not possible to allocate the necessary memory for the session...               */
    {
        retErr = ERR_MEM;                                               /* ... set the return value to "Out of memory".                                             */
80026d96:	82 f2       	mov %d2,-1
80026d98:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    }
    return retErr;                                                      /* Return result                                                                            */
80026d9c:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
80026da0:	00 90       	ret 

80026da2 <echoRecv>:

/* Recv callback: it is called every time data is received through the TCP connection */
err_t echoRecv (void *arg, tcpPcb *tpcb, pBuf *p, err_t err)
{
80026da2:	40 ae       	mov.aa %a14,%sp
80026da4:	20 20       	sub.a %sp,32
80026da6:	b5 e4 ec ff 	st.a [%a14]-20,%a4
80026daa:	b5 e5 e8 ff 	st.a [%a14]-24,%a5
80026dae:	b5 e6 e4 ff 	st.a [%a14]-28,%a6
80026db2:	02 42       	mov %d2,%d4
80026db4:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
    err_t retErr;                                                       /* Allocate memory for function return value                                                */
    EchoSession *es = (EchoSession*) arg;                               /* Get a pointer to the current session                                                     */
80026db8:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80026dbc:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    if (p == NULL)                                                      /* If there is no enqueued received data after the RECV callback was called, it means the   */
80026dc0:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80026dc4:	df 02 26 80 	jne %d2,0,80026e10 <echoRecv+0x6e>
    {                                                                   /* remote client closed the connection in the meanwhile                                     */
        es->state = ES_CLOSING;                                         /* Set the state of this session to CLOSING in order to free its resources                  */
80026dc8:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026dcc:	82 32       	mov %d2,3
80026dce:	34 22       	st.b [%a2],%d2
        if (es->p == NULL)                                              /* If the session does not have any leftover unprocessed data...                            */
80026dd0:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026dd4:	d9 22 08 00 	lea %a2,[%a2]8
80026dd8:	54 22       	ld.w %d2,[%a2]
80026dda:	df 02 0a 80 	jne %d2,0,80026dee <echoRecv+0x4c>
        {
            echoClose(tpcb, es);                                        /* ... close the session and free its resources.                                            */
80026dde:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026de2:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80026de6:	6d 00 ed 01 	call 800271c0 <echoClose>
80026dea:	1d 00 0e 00 	j 80026e06 <echoRecv+0x64>
        }
        else                                                            /* If the session does have leftover unprocessed data...                                    */
        {
            echoUnpack(tpcb, es);                                       /* ... process unprocessed data ...                                                         */
80026dee:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026df2:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80026df6:	6d 00 6c 01 	call 800270ce <echoUnpack>
            echoSend(tpcb, es);                                         /* ... and send processed data.                                                             */
80026dfa:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026dfe:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80026e02:	6d 00 13 01 	call 80027028 <echoSend>
        }
        retErr = ERR_OK;                                                /* Signal a successful outcome                                                              */
80026e06:	82 02       	mov %d2,0
80026e08:	e9 e2 ff ff 	st.b [%a14]-1,%d2
80026e0c:	1d 00 84 00 	j 80026f14 <echoRecv+0x172>
    }
    else if (err != ERR_OK)                                             /* If there was an error while receiving data...                                            */
80026e10:	79 e2 e0 ff 	ld.b %d2,[%a14]-32
80026e14:	df 02 16 00 	jeq %d2,0,80026e40 <echoRecv+0x9e>
    {
        /* Cleanup, for unkown reason */
        if (p != NULL)                                                  /* ... if some data was received and stored...                                              */
80026e18:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80026e1c:	df 02 0c 00 	jeq %d2,0,80026e34 <echoRecv+0x92>
        {
            es->p = NULL;                                               /* ... invalidate the unprocessed data contained in the session.                            */
80026e20:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026e24:	82 02       	mov %d2,0
80026e26:	d9 22 08 00 	lea %a2,[%a2]8
80026e2a:	74 22       	st.w [%a2],%d2
            pbuf_free(p);                                               /* Dereference and deallocate last received data which is probably corrupted                */
80026e2c:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80026e30:	6d ff b4 98 	call 80019f98 <pbuf_free>
        }
        retErr = err;                                                   /* Propagate the error                                                                      */
80026e34:	79 e2 e0 ff 	ld.b %d2,[%a14]-32
80026e38:	e9 e2 ff ff 	st.b [%a14]-1,%d2
80026e3c:	1d 00 6c 00 	j 80026f14 <echoRecv+0x172>
    }
    else if (es->state == ES_ACCEPTED)                                  /* If the current session is in state ACCEPTED...                                           */
80026e40:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026e44:	14 22       	ld.bu %d2,[%a2]
80026e46:	df 12 1e 80 	jne %d2,1,80026e82 <echoRecv+0xe0>
    {
        es->state = ES_RECEIVING;                                       /* ... change its state to RECEIVING.                                                       */
80026e4a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026e4e:	82 22       	mov %d2,2
80026e50:	34 22       	st.b [%a2],%d2
        es->p = p;                                                      /* Set the unprocessed data buffer of the session to the received one                       */
80026e52:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026e56:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80026e5a:	d9 22 08 00 	lea %a2,[%a2]8
80026e5e:	74 22       	st.w [%a2],%d2
        echoUnpack(tpcb, es);                                           /* Perform a first incoming data processing                                                 */
80026e60:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026e64:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80026e68:	6d 00 33 01 	call 800270ce <echoUnpack>
        echoSend(tpcb, es);                                             /* Send the first echo to remote client                                                     */
80026e6c:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026e70:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80026e74:	6d 00 da 00 	call 80027028 <echoSend>
        retErr = ERR_OK;                                                /* Signal a successful outcome                                                              */
80026e78:	82 02       	mov %d2,0
80026e7a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
80026e7e:	1d 00 4b 00 	j 80026f14 <echoRecv+0x172>
    }
    else if (es->state == ES_RECEIVING)                                 /* If the current session was already receiving data...                                     */
80026e82:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026e86:	14 22       	ld.bu %d2,[%a2]
80026e88:	df 22 30 80 	jne %d2,2,80026ee8 <echoRecv+0x146>
    {
        if (es->p == NULL)                                              /* ... and no unprocessed data is contained in the session...                               */
80026e8c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026e90:	d9 22 08 00 	lea %a2,[%a2]8
80026e94:	54 22       	ld.w %d2,[%a2]
80026e96:	df 02 17 80 	jne %d2,0,80026ec4 <echoRecv+0x122>
        {
            es->p = p;                                                  /* ... set the unprocessed data buffer of the session to the received one                   */
80026e9a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026e9e:	19 e2 e4 ff 	ld.w %d2,[%a14]-28
80026ea2:	d9 22 08 00 	lea %a2,[%a2]8
80026ea6:	74 22       	st.w [%a2],%d2
            echoUnpack(tpcb, es);                                       /* Process the incoming data                                                                */
80026ea8:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026eac:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80026eb0:	6d 00 0f 01 	call 800270ce <echoUnpack>
            echoSend(tpcb, es);                                         /* Send an echo to the remote client                                                        */
80026eb4:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026eb8:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80026ebc:	6d 00 b6 00 	call 80027028 <echoSend>
80026ec0:	1d 00 0f 00 	j 80026ede <echoRecv+0x13c>
        }
        else                                                            /* If the session still contains some unprocessed received data...                          */
        {
            pBuf *ptr = es->p;                                          /* ... create a local reference for the received data                                       */
80026ec4:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026ec8:	d9 22 08 00 	lea %a2,[%a2]8
80026ecc:	54 22       	ld.w %d2,[%a2]
80026ece:	59 e2 f4 ff 	st.w [%a14]-12,%d2
            pbuf_chain(ptr, p);                                         /* Chain the old unprocessed data contained in the session with the new one                 */
80026ed2:	99 e5 e4 ff 	ld.a %a5,[%a14]-28
80026ed6:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
80026eda:	6d ff 1d 9a 	call 8001a314 <pbuf_chain>
        }
        retErr = ERR_OK;                                                /* Signal a successful outcome                                                              */
80026ede:	82 02       	mov %d2,0
80026ee0:	e9 e2 ff ff 	st.b [%a14]-1,%d2
80026ee4:	1d 00 18 00 	j 80026f14 <echoRecv+0x172>
    }
    else                                                                /* If we got new incoming data in an unknown state, discard the data                        */
    {
        tcp_recved(tpcb, p->tot_len);                                   /* Mark the incoming data as received                                                       */
80026ee8:	99 e2 e4 ff 	ld.a %a2,[%a14]-28
80026eec:	b9 22 08 00 	ld.hu %d2,[%a2]8
80026ef0:	02 24       	mov %d4,%d2
80026ef2:	99 e4 e8 ff 	ld.a %a4,[%a14]-24
80026ef6:	6d ff ef a3 	call 8001b6d4 <tcp_recved>
        es->p = NULL;                                                   /* Invalidate the unprocessed data contained in the session                                 */
80026efa:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026efe:	82 02       	mov %d2,0
80026f00:	d9 22 08 00 	lea %a2,[%a2]8
80026f04:	74 22       	st.w [%a2],%d2
        pbuf_free(p);                                                   /* Dereference and deallocate last received data                                            */
80026f06:	99 e4 e4 ff 	ld.a %a4,[%a14]-28
80026f0a:	6d ff 47 98 	call 80019f98 <pbuf_free>
        retErr = ERR_OK;                                                /* Signal a successful outcome                                                              */
80026f0e:	82 02       	mov %d2,0
80026f10:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    }
    return retErr;                                                      /* Return result                                                                            */
80026f14:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
80026f18:	00 90       	ret 

80026f1a <echoError>:

/* Error callback: it is called if a fatal error has already occurred on the connection */
void echoError(void *arg, err_t err)
{
80026f1a:	40 ae       	mov.aa %a14,%sp
80026f1c:	20 10       	sub.a %sp,16
80026f1e:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80026f22:	02 42       	mov %d2,%d4
80026f24:	e9 e2 f0 ff 	st.b [%a14]-16,%d2
    LWIP_UNUSED_ARG(err);                                               /* Eliminate compiler warning about unused arguments                                        */

    EchoSession *es = (EchoSession*) arg;                               /* Get a pointer to the current session                                                     */
80026f28:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80026f2c:	59 e2 fc ff 	st.w [%a14]-4,%d2

    if (es != NULL)                                                     /* If a session exists we cannot do anything with it anymore, since the fatal error         */
80026f30:	19 e2 fc ff 	ld.w %d2,[%a14]-4
80026f34:	df 02 06 00 	jeq %d2,0,80026f40 <echoError+0x26>
    {                                                                   /* occurred ...                                                                             */
        mem_free(es);                                                   /* ... free memory assigned to the session                                                  */
80026f38:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80026f3c:	6d ff 61 87 	call 80017dfe <mem_free>
    }
}
80026f40:	00 90       	ret 

80026f42 <echoPoll>:

/* Poll function: it is called periodically by the TCP stack */
err_t echoPoll(void *arg, tcpPcb *tpcb)
{
80026f42:	40 ae       	mov.aa %a14,%sp
80026f44:	20 10       	sub.a %sp,16
80026f46:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80026f4a:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
    err_t retErr;                                                       /* Allocate memory for function return value                                                */
    EchoSession *es = (EchoSession*) arg;                               /* Get a pointer to the current session                                                     */
80026f4e:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80026f52:	59 e2 f8 ff 	st.w [%a14]-8,%d2

    if (es != NULL)                                                     /* If a session exists ...                                                                  */
80026f56:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80026f5a:	df 02 2d 00 	jeq %d2,0,80026fb4 <echoPoll+0x72>
    {
        if (es->p != NULL ||                                            /* ... and if the session has any leftover unprocessed data...                              */
80026f5e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026f62:	d9 22 08 00 	lea %a2,[%a2]8
80026f66:	54 22       	ld.w %d2,[%a2]
80026f68:	df 02 08 80 	jne %d2,0,80026f78 <echoPoll+0x36>
            es->nextFreeStoragePos != 0)                                /* ... or there is still data in the session storage to send back...                        */
80026f6c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026f70:	b9 22 0c 40 	ld.hu %d2,[%a2]268
        if (es->p != NULL ||                                            /* ... and if the session has any leftover unprocessed data...                              */
80026f74:	df 02 10 00 	jeq %d2,0,80026f94 <echoPoll+0x52>
        {
            echoUnpack(tpcb, es);                                       /* ... process unprocessed data ...                                                         */
80026f78:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026f7c:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026f80:	6d 00 a7 00 	call 800270ce <echoUnpack>
            echoSend(tpcb, es);                                         /* ... and send processed data.                                                             */
80026f84:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026f88:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026f8c:	6d 00 4e 00 	call 80027028 <echoSend>
80026f90:	1d 00 0d 00 	j 80026faa <echoPoll+0x68>
        }
        else                                                            /* If the session has no leftover unprocessed data...                                       */
        {
            if (es->state == ES_CLOSING)                                /* ... and the session was marked for being closed...                                       */
80026f94:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80026f98:	14 22       	ld.bu %d2,[%a2]
80026f9a:	df 32 08 80 	jne %d2,3,80026faa <echoPoll+0x68>
            {
                echoClose(tpcb, es);                                    /* ... close the session and free its resources.                                            */
80026f9e:	99 e5 f8 ff 	ld.a %a5,[%a14]-8
80026fa2:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026fa6:	6d 00 0d 01 	call 800271c0 <echoClose>
            }
        }
        retErr = ERR_OK;                                                /* Signal a successful outcome                                                              */
80026faa:	82 02       	mov %d2,0
80026fac:	e9 e2 ff ff 	st.b [%a14]-1,%d2
80026fb0:	1d 00 0a 00 	j 80026fc4 <echoPoll+0x82>
    }
    else                                                                /* If no session exists something went wrong, the TCP connection has to be aborted          */
    {
        tcp_abort(tpcb);                                                /* Abort the TCP connection                                                                 */
80026fb4:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026fb8:	6d ff a6 a0 	call 8001b104 <tcp_abort>
        retErr = ERR_ABRT;                                              /* Propagate the abort error                                                                */
80026fbc:	3b 30 ff 2f 	mov %d2,-13
80026fc0:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    }
    return retErr;                                                      /* Return result                                                                            */
80026fc4:	79 e2 ff ff 	ld.b %d2,[%a14]-1
}
80026fc8:	00 90       	ret 

80026fca <echoSent>:

/* Sent callback: it is called when TCP data has successfully been delivered to the remote host */
err_t echoSent(void *arg, tcpPcb *tpcb, u16_t len)
{
80026fca:	40 ae       	mov.aa %a14,%sp
80026fcc:	20 18       	sub.a %sp,24
80026fce:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80026fd2:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
80026fd6:	02 42       	mov %d2,%d4
80026fd8:	f9 e2 ec ff 	st.h [%a14]-20,%d2
    LWIP_UNUSED_ARG(len);                                               /* Eliminates compiler warning about unused arguments                                       */

    EchoSession *es = (EchoSession*) arg;                               /* Get a pointer to the current session                                                     */
80026fdc:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80026fe0:	59 e2 fc ff 	st.w [%a14]-4,%d2

    if (es->p != NULL )                                                 /* If the session has any leftover unprocessed data...                                      */
80026fe4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80026fe8:	d9 22 08 00 	lea %a2,[%a2]8
80026fec:	54 22       	ld.w %d2,[%a2]
80026fee:	df 02 10 00 	jeq %d2,0,8002700e <echoSent+0x44>
    {
        echoUnpack(tpcb, es);                                           /* ... process unprocessed data ...                                                         */
80026ff2:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80026ff6:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80026ffa:	6d 00 6a 00 	call 800270ce <echoUnpack>
        echoSend(tpcb, es);                                             /* ... and send processed data.                                                             */
80026ffe:	99 e5 fc ff 	ld.a %a5,[%a14]-4
80027002:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80027006:	6d 00 11 00 	call 80027028 <echoSend>
8002700a:	1d 00 0d 00 	j 80027024 <echoSent+0x5a>
    }
    else                                                                /* If the session has no leftover unprocessed data...                                       */
    {
        if (es->state == ES_CLOSING)                                    /* ... and the session was marked for being closed...                                       */
8002700e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80027012:	14 22       	ld.bu %d2,[%a2]
80027014:	df 32 08 80 	jne %d2,3,80027024 <echoSent+0x5a>
        {
            echoClose(tpcb, es);                                        /* ... close the session and free its resources.                                            */
80027018:	99 e5 fc ff 	ld.a %a5,[%a14]-4
8002701c:	99 e4 f0 ff 	ld.a %a4,[%a14]-16
80027020:	6d 00 d0 00 	call 800271c0 <echoClose>
        }
    }
    return ERR_OK;                                                      /* Return successful result                                                                 */
80027024:	82 02       	mov %d2,0
}
80027026:	00 90       	ret 

80027028 <echoSend>:

/* Send function: enqueues TCP data to be delivered to the remote client */
void echoSend(tcpPcb *tpcb, EchoSession *es)
{
80027028:	40 ae       	mov.aa %a14,%sp
8002702a:	20 10       	sub.a %sp,16
8002702c:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
80027030:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
    if(es->nextFreeStoragePos == 0)                                     /* If the next free position in the storage array is the beginning of the array, there is   */
80027034:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80027038:	b9 22 0c 40 	ld.hu %d2,[%a2]268
8002703c:	df 02 45 00 	jeq %d2,0,800270c6 <echoSend+0x9e>
    {                                                                   /* nothing to send                                                                          */
        return;
    }
    if(es->storage[es->nextFreeStoragePos - 1] != '\n' &&               /* If the string to be sent does not end with a new line...                                 */
80027040:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80027044:	b9 22 0c 40 	ld.hu %d2,[%a2]268
80027048:	c2 f2       	add %d2,-1
8002704a:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
8002704e:	60 32       	mov.a %a2,%d3
80027050:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80027054:	79 22 0c 00 	ld.b %d2,[%a2]12
80027058:	8b a2 00 22 	eq %d2,%d2,10
8002705c:	df 02 0a 80 	jne %d2,0,80027070 <echoSend+0x48>
       es->nextFreeStoragePos < STORAGE_SIZE_BYTES)                     /* ... and the storage is not full ...                                                      */
80027060:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80027064:	b9 22 0c 40 	ld.hu %d2,[%a2]268
    if(es->storage[es->nextFreeStoragePos - 1] != '\n' &&               /* If the string to be sent does not end with a new line...                                 */
80027068:	8b 02 b0 22 	ge.u %d2,%d2,256
8002706c:	df 02 2f 00 	jeq %d2,0,800270ca <echoSend+0xa2>
    {                                                                   /* ... do not send yet. Wait for the string to be echoed to terminate                       */
        return;                                                         /* or the storage to completely fill.                                                       */
    }
    err_t wrErr = tcp_write(tpcb, "Board: ", 7, 1);                     /* Enqueue an echo preamble to be sent to the remote client                                 */
80027070:	82 15       	mov %d5,1
80027072:	82 74       	mov %d4,7
80027074:	91 00 00 28 	movh.a %a2,32768
80027078:	d9 25 b3 93 	lea %a5,[%a2]14963 <80003a73 <IfxCpu_Trap_vectorTable0_end+0x387f>>
8002707c:	99 e4 f4 ff 	ld.a %a4,[%a14]-12 <80003a73 <IfxCpu_Trap_vectorTable0_end+0x387f>>
80027080:	6d ff 75 d7 	call 80021f6a <tcp_write>
80027084:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    wrErr |= tcp_write(tpcb, es->storage, es->nextFreeStoragePos, 1);   /* Enqueue the string stored in the session for sending                                     */
80027088:	19 e2 f0 ff 	ld.w %d2,[%a14]-16
8002708c:	1b c2 00 20 	addi %d2,%d2,12
80027090:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80027094:	b9 23 0c 40 	ld.hu %d3,[%a2]268
80027098:	82 15       	mov %d5,1
8002709a:	02 34       	mov %d4,%d3
8002709c:	60 25       	mov.a %a5,%d2
8002709e:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800270a2:	6d ff 64 d7 	call 80021f6a <tcp_write>
800270a6:	02 23       	mov %d3,%d2
800270a8:	79 e2 ff ff 	ld.b %d2,[%a14]-1
800270ac:	a6 32       	or %d2,%d3
800270ae:	e9 e2 ff ff 	st.b [%a14]-1,%d2
    if(wrErr == ERR_OK)                                                 /* If data was correctly enqueued for TCP transmission ...                                  */
800270b2:	79 e2 ff ff 	ld.b %d2,[%a14]-1
800270b6:	df 02 0b 80 	jne %d2,0,800270cc <echoSend+0xa4>
    {
        es->nextFreeStoragePos = 0;                                     /* ... remove sent data from the session storage.                                           */
800270ba:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800270be:	82 02       	mov %d2,0
800270c0:	f9 22 0c 40 	st.h [%a2]268,%d2
800270c4:	00 90       	ret 
        return;
800270c6:	00 00       	nop 
800270c8:	00 90       	ret 
        return;                                                         /* or the storage to completely fill.                                                       */
800270ca:	00 00       	nop 
    }
}
800270cc:	00 90       	ret 

800270ce <echoUnpack>:

/* Unpack function: dequeues data from the package buffer and copies it in the session storage */
void echoUnpack(tcpPcb *tpcb, EchoSession *es)
{
800270ce:	40 ae       	mov.aa %a14,%sp
800270d0:	20 10       	sub.a %sp,16
800270d2:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
800270d6:	b5 e5 f0 ff 	st.a [%a14]-16,%a5
    pBuf *ptr;                                                          /* Local reference to a packet buffer                                                       */

    while ((es->p != NULL))                                             /* Process data while there still are packets to process                                    */
800270da:	1d 00 69 00 	j 800271ac <echoUnpack+0xde>
    {
        ptr = es->p;                                                    /* Local reference of the packet to process                                                 */
800270de:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800270e2:	d9 22 08 00 	lea %a2,[%a2]8
800270e6:	54 22       	ld.w %d2,[%a2]
800270e8:	59 e2 fc ff 	st.w [%a14]-4,%d2

        if (es->nextFreeStoragePos + ptr->len <= STORAGE_SIZE_BYTES)    /* If there is enough space in the session storage for the new data ...                     */
800270ec:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800270f0:	b9 22 0c 40 	ld.hu %d2,[%a2]268
800270f4:	02 23       	mov %d3,%d2
800270f6:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800270fa:	b9 22 0a 00 	ld.hu %d2,[%a2]10
800270fe:	42 32       	add %d2,%d3
80027100:	3b 10 10 30 	mov %d3,257
80027104:	7f 32 54 00 	jge %d2,%d3,800271ac <echoUnpack+0xde>
        {
            memcpy(&es->storage[es->nextFreeStoragePos],                /* ... copy data in the session storage                                                     */
80027108:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8002710c:	b9 22 0c 40 	ld.hu %d2,[%a2]268
80027110:	1b c2 00 20 	addi %d2,%d2,12
80027114:	19 e3 f0 ff 	ld.w %d3,[%a14]-16
80027118:	42 32       	add %d2,%d3
                    ptr->payload,
8002711a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002711e:	b0 42       	add.a %a2,4
80027120:	54 23       	ld.w %d3,[%a2]
                    ptr->len);
80027122:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80027126:	b9 24 0a 00 	ld.hu %d4,[%a2]10
            memcpy(&es->storage[es->nextFreeStoragePos],                /* ... copy data in the session storage                                                     */
8002712a:	60 35       	mov.a %a5,%d3
8002712c:	60 24       	mov.a %a4,%d2
8002712e:	6d 00 77 00 	call 8002721c <memcpy>
            es->nextFreeStoragePos += ptr->len;                         /* Increase the index of the new free position in the session storage array                 */
80027132:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80027136:	b9 23 0c 40 	ld.hu %d3,[%a2]268
8002713a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8002713e:	b9 22 0a 00 	ld.hu %d2,[%a2]10
80027142:	42 32       	add %d2,%d3
80027144:	37 02 70 20 	extr.u %d2,%d2,0,16
80027148:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8002714c:	f9 22 0c 40 	st.h [%a2]268,%d2

            u16_t plen = ptr->len;                                      /* Number of bytes successfully received and stored                                         */
80027150:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80027154:	c9 22 0a 00 	ld.h %d2,[%a2]10
80027158:	f9 e2 fa ff 	st.h [%a14]-6,%d2

            es->p = ptr->next;                                          /* Get the next packet in the chain (if any)                                                */
8002715c:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80027160:	54 22       	ld.w %d2,[%a2]
80027162:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80027166:	d9 22 08 00 	lea %a2,[%a2]8
8002716a:	74 22       	st.w [%a2],%d2
            if (es->p != NULL)                                          /* If there is another packet to be processed...                                            */
8002716c:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
80027170:	d9 22 08 00 	lea %a2,[%a2]8
80027174:	54 22       	ld.w %d2,[%a2]
80027176:	df 02 0a 00 	jeq %d2,0,8002718a <echoUnpack+0xbc>
            {
                pbuf_ref(es->p);                                        /* Inform the LwIP framework that the packet to be processed is linked to the session,      */
8002717a:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
8002717e:	d9 22 08 00 	lea %a2,[%a2]8
80027182:	54 22       	ld.w %d2,[%a2]
80027184:	60 24       	mov.a %a4,%d2
80027186:	6d ff 06 98 	call 8001a192 <pbuf_ref>
            }                                                           /* and shall not be disposed                                                                */

            u8_t freed;                                                 /* Number of bytes successfully freed from memory                                           */
            do
            {
                freed = pbuf_free(ptr);                                 /* Free memory used by the packet that was just processed                                   */
8002718a:	99 e4 fc ff 	ld.a %a4,[%a14]-4
8002718e:	6d ff 05 97 	call 80019f98 <pbuf_free>
80027192:	e9 e2 f9 ff 	st.b [%a14]-7,%d2
            } while (freed == 0);
80027196:	39 e2 f9 ff 	ld.bu %d2,[%a14]-7
8002719a:	df 02 f8 7f 	jeq %d2,0,8002718a <echoUnpack+0xbc>

            tcp_recved(tpcb, plen);                                     /* Signal the remote host that more data can be received                                    */
8002719e:	b9 e2 fa ff 	ld.hu %d2,[%a14]-6
800271a2:	02 24       	mov %d4,%d2
800271a4:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
800271a8:	6d ff 96 a2 	call 8001b6d4 <tcp_recved>
    while ((es->p != NULL))                                             /* Process data while there still are packets to process                                    */
800271ac:	99 e2 f0 ff 	ld.a %a2,[%a14]-16
800271b0:	d9 22 08 00 	lea %a2,[%a2]8
800271b4:	54 22       	ld.w %d2,[%a2]
800271b6:	df 02 94 ff 	jne %d2,0,800270de <echoUnpack+0x10>
        }
    }
}
800271ba:	00 00       	nop 
800271bc:	00 00       	nop 
800271be:	00 90       	ret 

800271c0 <echoClose>:

/* Close function: closes a TCP connection and deallocates session resources */
void echoClose(tcpPcb *tpcb, EchoSession *es)
{
800271c0:	40 ae       	mov.aa %a14,%sp
800271c2:	20 08       	sub.a %sp,8
800271c4:	b5 e4 fc ff 	st.a [%a14]-4,%a4
800271c8:	b5 e5 f8 ff 	st.a [%a14]-8,%a5
    tcp_arg(tpcb, NULL);                                                /* Set the argument passed to every callback to NULL                                        */
800271cc:	a0 05       	mov.a %a5,0
800271ce:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800271d2:	6d ff f1 ac 	call 8001cbb4 <tcp_arg>
    tcp_sent(tpcb, NULL);                                               /* Set the data sent callback to NULL                                                       */
800271d6:	a0 05       	mov.a %a5,0
800271d8:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800271dc:	6d ff 2e ad 	call 8001cc38 <tcp_sent>
    tcp_recv(tpcb, NULL);                                               /* Set the data received callback to NULL                                                   */
800271e0:	a0 05       	mov.a %a5,0
800271e2:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800271e6:	6d ff fa ac 	call 8001cbda <tcp_recv>
    tcp_err(tpcb, NULL);                                                /* Set the data error callback to NULL                                                      */
800271ea:	a0 05       	mov.a %a5,0
800271ec:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800271f0:	6d ff 53 ad 	call 8001cc96 <tcp_err>
    tcp_poll(tpcb, NULL, 0);                                            /* Set the periodical callback to NULL                                                      */
800271f4:	82 04       	mov %d4,0
800271f6:	a0 05       	mov.a %a5,0
800271f8:	99 e4 fc ff 	ld.a %a4,[%a14]-4
800271fc:	6d ff 9a ad 	call 8001cd30 <tcp_poll>

    if (es != NULL)                                                     /* If a session still exists...                                                             */
80027200:	19 e2 f8 ff 	ld.w %d2,[%a14]-8
80027204:	df 02 06 00 	jeq %d2,0,80027210 <echoClose+0x50>
    {
        mem_free(es);                                                   /* ...free memory assigned to the session.                                                  */
80027208:	99 e4 f8 ff 	ld.a %a4,[%a14]-8
8002720c:	6d ff f9 85 	call 80017dfe <mem_free>
    }
    tcp_close(tpcb);                                                    /* Close the TCP connection                                                                 */
80027210:	99 e4 fc ff 	ld.a %a4,[%a14]-4
80027214:	6d ff fc 9d 	call 8001ae0c <tcp_close>
}
80027218:	00 00       	nop 
8002721a:	00 90       	ret 

8002721c <memcpy>:
8002721c:	40 42       	mov.aa %a2,%a4
8002721e:	df 04 08 00 	jeq %d4,0,8002722e <memcpy+0x12>
80027222:	60 43       	mov.a %a3,%d4
80027224:	b0 f3       	add.a %a3,-1
80027226:	04 54       	ld.bu %d4,[%a5+]
80027228:	24 44       	st.b [%a4+],%d4
8002722a:	fd 30 fe 7f 	loop %a3,80027226 <memcpy+0xa>
8002722e:	00 90       	ret 

80027230 <memset>:
80027230:	40 42       	mov.aa %a2,%a4
80027232:	df 05 07 00 	jeq %d5,0,80027240 <memset+0x10>
80027236:	60 53       	mov.a %a3,%d5
80027238:	b0 f3       	add.a %a3,-1
8002723a:	24 44       	st.b [%a4+],%d4
8002723c:	fd 30 ff 7f 	loop %a3,8002723a <memset+0xa>
80027240:	00 90       	ret 

80027242 <memcmp>:
80027242:	df 04 10 00 	jeq %d4,0,80027262 <memcmp+0x20>
80027246:	c2 f4       	add %d4,-1
80027248:	60 43       	mov.a %a3,%d4
8002724a:	04 42       	ld.bu %d2,[%a4+]
8002724c:	04 5f       	ld.bu %d15,[%a5+]
8002724e:	5f f2 08 00 	jeq %d2,%d15,8002725e <memcmp+0x1c>
80027252:	0b f2 50 21 	ge.u %d2,%d2,%d15
80027256:	82 13       	mov %d3,1
80027258:	ab f3 9f 22 	sel %d2,%d2,%d3,-1
8002725c:	00 90       	ret 
8002725e:	fd 30 f6 7f 	loop %a3,8002724a <memcmp+0x8>
80027262:	82 02       	mov %d2,0
80027264:	00 90       	ret 

80027266 <__fixunsdfsi>:
80027266:	82 06       	mov %d6,0
80027268:	7b 00 1e 74 	movh %d7,16864
8002726c:	60 4d       	mov.a %a13,%d4
8002726e:	60 5c       	mov.a %a12,%d5
80027270:	6d 00 ae 02 	call 800277cc <__gedf2>
80027274:	ff 02 07 00 	jge %d2,0,80027282 <__fixunsdfsi+0x1c>
80027278:	80 d4       	mov.d %d4,%a13
8002727a:	80 c5       	mov.d %d5,%a12
8002727c:	6d 00 c8 02 	call 8002780c <__fixdfsi>
80027280:	00 90       	ret 
80027282:	82 06       	mov %d6,0
80027284:	7b 00 1e 74 	movh %d7,16864
80027288:	80 d4       	mov.d %d4,%a13
8002728a:	80 c5       	mov.d %d5,%a12
8002728c:	6d 00 6b 01 	call 80027562 <__subdf3>
80027290:	0b 23 10 48 	mov %e4,%d3,%d2
80027294:	6d 00 bc 02 	call 8002780c <__fixdfsi>
80027298:	9b 02 00 28 	addih %d2,%d2,32768
8002729c:	00 90       	ret 

8002729e <__extendsfdf2>:
8002729e:	20 20       	sub.a %sp,32
800272a0:	d9 a5 10 00 	lea %a5,[%sp]16
800272a4:	d9 a4 0c 00 	lea %a4,[%sp]12
800272a8:	59 a4 0c 00 	st.w [%sp]12,%d4
800272ac:	6d 00 23 03 	call 800278f2 <__unpack_f>
800272b0:	19 a2 1c 00 	ld.w %d2,[%sp]28
800272b4:	19 a6 18 00 	ld.w %d6,[%sp]24
800272b8:	53 12 40 40 	mul.u %e4,%d2,1
800272bc:	77 45 00 3f 	dextr %d3,%d5,%d4,30
800272c0:	8f e4 01 20 	sh %d2,%d4,30
800272c4:	19 a5 14 00 	ld.w %d5,[%sp]20
800272c8:	19 a4 10 00 	ld.w %d4,[%sp]16
800272cc:	74 a2       	st.w [%sp],%d2
800272ce:	59 a3 04 00 	st.w [%sp]4,%d3
800272d2:	6d 00 db 02 	call 80027888 <__make_dp>
800272d6:	00 90       	ret 

800272d8 <_fpadd_parts>:
800272d8:	54 42       	ld.w %d2,[%a4]
800272da:	40 42       	mov.aa %a2,%a4
800272dc:	bf 22 c2 80 	jlt.u %d2,2,80027460 <_fpadd_parts+0x188>
800272e0:	54 53       	ld.w %d3,[%a5]
800272e2:	40 52       	mov.aa %a2,%a5
800272e4:	bf 23 be 80 	jlt.u %d3,2,80027460 <_fpadd_parts+0x188>
800272e8:	df 42 e3 00 	jeq %d2,4,800274ae <_fpadd_parts+0x1d6>
800272ec:	df 43 ba 00 	jeq %d3,4,80027460 <_fpadd_parts+0x188>
800272f0:	df 23 b9 00 	jeq %d3,2,80027462 <_fpadd_parts+0x18a>
800272f4:	df 22 b6 00 	jeq %d2,2,80027460 <_fpadd_parts+0x188>
800272f8:	19 40 08 00 	ld.w %d0,[%a4]8
800272fc:	19 57 08 00 	ld.w %d7,[%a5]8
80027300:	09 44 4c 09 	ld.d %e4,[%a4]12
80027304:	0b 70 80 60 	sub %d6,%d0,%d7
80027308:	09 52 4c 09 	ld.d %e2,[%a5]12
8002730c:	bf 06 c2 00 	jlt %d6,0,80027490 <_fpadd_parts+0x1b8>
80027310:	8b 06 84 12 	ge %d1,%d6,64
80027314:	df 01 c4 80 	jne %d1,0,8002749c <_fpadd_parts+0x1c4>
80027318:	df 06 2a 00 	jeq %d6,0,8002736c <_fpadd_parts+0x94>
8002731c:	8b 06 82 72 	ge %d7,%d6,32
80027320:	2b 32 50 97 	seln %d9,%d7,%d2,%d3
80027324:	ab 03 a0 87 	seln %d8,%d7,%d3,0
80027328:	8f f6 01 71 	and %d7,%d6,31
8002732c:	8b 07 02 11 	rsub %d1,%d7,32
80027330:	17 98 80 11 	dextr %d1,%d8,%d9,%d1
80027334:	2b 91 40 17 	sel %d1,%d7,%d1,%d9
80027338:	8b 06 82 a2 	ge %d10,%d6,32
8002733c:	32 57       	rsub %d7
8002733e:	02 19       	mov %d9,%d1
80027340:	8f f6 01 61 	and %d6,%d6,31
80027344:	82 f1       	mov %d1,-1
80027346:	0f 78 00 80 	sh %d8,%d8,%d7
8002734a:	17 11 80 76 	dextr %d7,%d1,%d1,%d6
8002734e:	0f 61 00 60 	sh %d6,%d1,%d6
80027352:	2b 67 50 7a 	seln %d7,%d10,%d7,%d6
80027356:	ab 06 a0 6a 	seln %d6,%d10,%d6,0
8002735a:	0f 62 e0 10 	andn %d1,%d2,%d6
8002735e:	0f 73 e0 60 	andn %d6,%d3,%d7
80027362:	a6 16       	or %d6,%d1
80027364:	8b 06 00 95 	or.ne %d9,%d6,0
80027368:	0b 98 10 28 	mov %e2,%d8,%d9
8002736c:	19 41 04 00 	ld.w %d1,[%a4]4
80027370:	19 56 04 00 	ld.w %d6,[%a5]4
80027374:	5f 61 4c 00 	jeq %d1,%d6,8002740c <_fpadd_parts+0x134>
80027378:	0b 24 c0 60 	subx %d6,%d4,%d2
8002737c:	0b 35 d0 70 	subc %d7,%d5,%d3
80027380:	df 01 06 00 	jeq %d1,0,8002738c <_fpadd_parts+0xb4>
80027384:	0b 42 c0 60 	subx %d6,%d2,%d4
80027388:	0b 53 d0 70 	subc %d7,%d3,%d5
8002738c:	8b 07 00 31 	rsub %d3,%d7,0
80027390:	8b 06 00 91 	rsub %d9,%d6,0
80027394:	ab f3 1f 36 	cadd %d3,%d6,%d3,-1
80027398:	82 12       	mov %d2,1
8002739a:	bf 07 05 00 	jlt %d7,0,800273a4 <_fpadd_parts+0xcc>
8002739e:	02 69       	mov %d9,%d6
800273a0:	02 73       	mov %d3,%d7
800273a2:	82 02       	mov %d2,0
800273a4:	8b f9 9f 70 	addx %d7,%d9,-1
800273a8:	82 f5       	mov %d5,-1
800273aa:	8b f3 bf 60 	addc %d6,%d3,-1
800273ae:	06 c5       	sh %d5,-4
800273b0:	59 62 04 00 	st.w [%a6]4,%d2
800273b4:	82 e1       	mov %d1,-2
800273b6:	0b 56 00 21 	eq %d2,%d6,%d5
800273ba:	0b 71 30 22 	and.lt.u %d2,%d1,%d7
800273be:	59 60 08 00 	st.w [%a6]8,%d0
800273c2:	59 69 0c 00 	st.w [%a6]12,%d9
800273c6:	59 63 10 00 	st.w [%a6]16,%d3
800273ca:	0b 65 a0 22 	or.lt.u %d2,%d5,%d6
800273ce:	df 02 2b 80 	jne %d2,0,80027424 <_fpadd_parts+0x14c>
800273d2:	1b f0 ff 7f 	addi %d7,%d0,-1
800273d6:	77 93 80 30 	dextr %d3,%d3,%d9,1
800273da:	06 19       	sh %d9,1
800273dc:	8b f9 9f 00 	addx %d0,%d9,-1
800273e0:	8b f3 bf 60 	addc %d6,%d3,-1
800273e4:	0b 56 00 21 	eq %d2,%d6,%d5
800273e8:	0b 01 50 22 	and.ge.u %d2,%d1,%d0
800273ec:	0b 56 a0 22 	or.lt.u %d2,%d6,%d5
800273f0:	02 78       	mov %d8,%d7
800273f2:	c2 f7       	add %d7,-1
800273f4:	df 02 f1 ff 	jne %d2,0,800273d6 <_fpadd_parts+0xfe>
800273f8:	82 32       	mov %d2,3
800273fa:	59 69 0c 00 	st.w [%a6]12,%d9
800273fe:	59 63 10 00 	st.w [%a6]16,%d3
80027402:	59 68 08 00 	st.w [%a6]8,%d8
80027406:	74 62       	st.w [%a6],%d2
80027408:	40 62       	mov.aa %a2,%a6
8002740a:	00 90       	ret 
8002740c:	0b 24 40 90 	addx %d9,%d4,%d2
80027410:	0b 35 50 30 	addc %d3,%d5,%d3
80027414:	59 61 04 00 	st.w [%a6]4,%d1
80027418:	59 60 08 00 	st.w [%a6]8,%d0
8002741c:	59 69 0c 00 	st.w [%a6]12,%d9
80027420:	59 63 10 00 	st.w [%a6]16,%d3
80027424:	82 32       	mov %d2,3
80027426:	7b 00 00 52 	movh %d5,8192
8002742a:	40 62       	mov.aa %a2,%a6
8002742c:	74 62       	st.w [%a6],%d2
8002742e:	0b 53 00 21 	eq %d2,%d3,%d5
80027432:	b7 02 01 20 	insert %d2,%d2,0,0,1
80027436:	0b 53 a0 22 	or.lt.u %d2,%d3,%d5
8002743a:	df 02 13 80 	jne %d2,0,80027460 <_fpadd_parts+0x188>
8002743e:	8f f3 1f 20 	sh %d2,%d3,-1
80027442:	77 93 80 5f 	dextr %d5,%d3,%d9,31
80027446:	8f 19 00 31 	and %d3,%d9,1
8002744a:	59 62 10 00 	st.w [%a6]16,%d2
8002744e:	19 62 08 00 	ld.w %d2,[%a6]8
80027452:	a6 53       	or %d3,%d5
80027454:	c2 12       	add %d2,1
80027456:	d9 63 08 00 	lea %a3,[%a6]8
8002745a:	59 63 0c 00 	st.w [%a6]12,%d3
8002745e:	74 32       	st.w [%a3],%d2
80027460:	00 90       	ret 
80027462:	40 42       	mov.aa %a2,%a4
80027464:	df 22 fe ff 	jne %d2,2,80027460 <_fpadd_parts+0x188>
80027468:	40 63       	mov.aa %a3,%a6
8002746a:	09 44 48 01 	ld.d %e4,[%a4+]8
8002746e:	89 34 48 01 	st.d [%a3+]8,%e4
80027472:	09 44 48 01 	ld.d %e4,[%a4+]8
80027476:	89 34 48 01 	st.d [%a3+]8,%e4
8002747a:	44 44       	ld.w %d4,[%a4+]
8002747c:	64 34       	st.w [%a3+],%d4
8002747e:	19 23 04 00 	ld.w %d3,[%a2]4
80027482:	19 52 04 00 	ld.w %d2,[%a5]4
80027486:	40 62       	mov.aa %a2,%a6
80027488:	26 32       	and %d2,%d3
8002748a:	59 62 04 00 	st.w [%a6]4,%d2
8002748e:	00 90       	ret 
80027490:	0b 07 80 60 	sub %d6,%d7,%d0
80027494:	8b 06 44 12 	lt %d1,%d6,64
80027498:	df 01 1d 80 	jne %d1,0,800274d2 <_fpadd_parts+0x1fa>
8002749c:	3f 07 06 00 	jlt %d7,%d0,800274a8 <_fpadd_parts+0x1d0>
800274a0:	d2 04       	mov %e4,0
800274a2:	02 70       	mov %d0,%d7
800274a4:	1d ff 64 ff 	j 8002736c <_fpadd_parts+0x94>
800274a8:	d2 02       	mov %e2,0
800274aa:	1d ff 61 ff 	j 8002736c <_fpadd_parts+0x94>
800274ae:	40 42       	mov.aa %a2,%a4
800274b0:	df 43 d8 ff 	jne %d3,4,80027460 <_fpadd_parts+0x188>
800274b4:	19 43 04 00 	ld.w %d3,[%a4]4
800274b8:	19 52 04 00 	ld.w %d2,[%a5]4
800274bc:	7b 00 00 48 	movh %d4,32768
800274c0:	0b 23 10 21 	ne %d2,%d3,%d2
800274c4:	1b c4 a7 43 	addi %d4,%d4,14972
800274c8:	80 43       	mov.d %d3,%a4
800274ca:	2b 43 50 22 	seln %d2,%d2,%d3,%d4
800274ce:	60 22       	mov.a %a2,%d2
800274d0:	00 90       	ret 
800274d2:	8b 06 82 02 	ge %d0,%d6,32
800274d6:	2b 54 50 90 	seln %d9,%d0,%d4,%d5
800274da:	ab 05 a0 80 	seln %d8,%d0,%d5,0
800274de:	8f f6 01 01 	and %d0,%d6,31
800274e2:	8b 00 02 11 	rsub %d1,%d0,32
800274e6:	17 98 80 11 	dextr %d1,%d8,%d9,%d1
800274ea:	2b 91 40 10 	sel %d1,%d0,%d1,%d9
800274ee:	8b 06 82 a2 	ge %d10,%d6,32
800274f2:	32 50       	rsub %d0
800274f4:	02 19       	mov %d9,%d1
800274f6:	8f f6 01 61 	and %d6,%d6,31
800274fa:	82 f1       	mov %d1,-1
800274fc:	0f 08 00 80 	sh %d8,%d8,%d0
80027500:	17 11 80 06 	dextr %d0,%d1,%d1,%d6
80027504:	0f 61 00 60 	sh %d6,%d1,%d6
80027508:	2b 60 50 0a 	seln %d0,%d10,%d0,%d6
8002750c:	ab 06 a0 6a 	seln %d6,%d10,%d6,0
80027510:	0f 64 e0 10 	andn %d1,%d4,%d6
80027514:	0f 05 e0 60 	andn %d6,%d5,%d0
80027518:	a6 16       	or %d6,%d1
8002751a:	8b 06 00 95 	or.ne %d9,%d6,0
8002751e:	0b 98 10 48 	mov %e4,%d8,%d9
80027522:	02 70       	mov %d0,%d7
80027524:	1d ff 24 ff 	j 8002736c <_fpadd_parts+0x94>

80027528 <__adddf3>:
80027528:	20 50       	sub.a %sp,80
8002752a:	d9 a5 14 00 	lea %a5,[%sp]20
8002752e:	d9 a4 04 00 	lea %a4,[%sp]4
80027532:	89 a4 44 09 	st.d [%sp]4,%e4
80027536:	89 a6 4c 09 	st.d [%sp]12,%e6
8002753a:	6d 00 ef 02 	call 80027b18 <__unpack_d>
8002753e:	d9 a5 28 00 	lea %a5,[%sp]40
80027542:	d9 a4 0c 00 	lea %a4,[%sp]12
80027546:	6d 00 e9 02 	call 80027b18 <__unpack_d>
8002754a:	d9 a4 14 00 	lea %a4,[%sp]20
8002754e:	d9 a6 3c 00 	lea %a6,[%sp]60
80027552:	d9 a5 28 00 	lea %a5,[%sp]40
80027556:	6d ff c1 fe 	call 800272d8 <_fpadd_parts>
8002755a:	40 24       	mov.aa %a4,%a2
8002755c:	6d 00 0f 02 	call 8002797a <__pack_d>
80027560:	00 90       	ret 

80027562 <__subdf3>:
80027562:	20 50       	sub.a %sp,80
80027564:	d9 a5 14 00 	lea %a5,[%sp]20
80027568:	d9 a4 04 00 	lea %a4,[%sp]4
8002756c:	89 a4 44 09 	st.d [%sp]4,%e4
80027570:	89 a6 4c 09 	st.d [%sp]12,%e6
80027574:	6d 00 d2 02 	call 80027b18 <__unpack_d>
80027578:	d9 a5 28 00 	lea %a5,[%sp]40
8002757c:	d9 a4 0c 00 	lea %a4,[%sp]12
80027580:	6d 00 cc 02 	call 80027b18 <__unpack_d>
80027584:	19 a2 2c 00 	ld.w %d2,[%sp]44
80027588:	d9 a4 14 00 	lea %a4,[%sp]20
8002758c:	8f 12 80 21 	xor %d2,%d2,1
80027590:	d9 a6 3c 00 	lea %a6,[%sp]60
80027594:	d9 a5 28 00 	lea %a5,[%sp]40
80027598:	59 a2 2c 00 	st.w [%sp]44,%d2
8002759c:	6d ff 9e fe 	call 800272d8 <_fpadd_parts>
800275a0:	40 24       	mov.aa %a4,%a2
800275a2:	6d 00 ec 01 	call 8002797a <__pack_d>
800275a6:	00 90       	ret 

800275a8 <__muldf3>:
800275a8:	20 50       	sub.a %sp,80
800275aa:	d9 a5 14 00 	lea %a5,[%sp]20
800275ae:	d9 a4 04 00 	lea %a4,[%sp]4
800275b2:	89 a4 44 09 	st.d [%sp]4,%e4
800275b6:	89 a6 4c 09 	st.d [%sp]12,%e6
800275ba:	6d 00 af 02 	call 80027b18 <__unpack_d>
800275be:	d9 a5 28 00 	lea %a5,[%sp]40
800275c2:	d9 a4 0c 00 	lea %a4,[%sp]12
800275c6:	6d 00 a9 02 	call 80027b18 <__unpack_d>
800275ca:	19 a2 14 00 	ld.w %d2,[%sp]20
800275ce:	ff 22 0f 80 	jge.u %d2,2,800275ec <__muldf3+0x44>
800275d2:	19 a3 18 00 	ld.w %d3,[%sp]24
800275d6:	19 a2 2c 00 	ld.w %d2,[%sp]44
800275da:	d9 a4 14 00 	lea %a4,[%sp]20
800275de:	0b 23 10 21 	ne %d2,%d3,%d2
800275e2:	59 a2 18 00 	st.w [%sp]24,%d2
800275e6:	6d 00 ca 01 	call 8002797a <__pack_d>
800275ea:	00 90       	ret 
800275ec:	19 a3 28 00 	ld.w %d3,[%sp]40
800275f0:	bf 23 14 80 	jlt.u %d3,2,80027618 <__muldf3+0x70>
800275f4:	df 42 0a 80 	jne %d2,4,80027608 <__muldf3+0x60>
800275f8:	91 00 00 48 	movh.a %a4,32768
800275fc:	d9 44 bc 93 	lea %a4,[%a4]14972 <80003a7c <__thenan_df>>
80027600:	df 23 f3 7f 	jeq %d3,2,800275e6 <__muldf3+0x3e>
80027604:	1d ff e7 ff 	j 800275d2 <__muldf3+0x2a>
80027608:	df 43 15 80 	jne %d3,4,80027632 <__muldf3+0x8a>
8002760c:	91 00 00 48 	movh.a %a4,32768
80027610:	d9 44 bc 93 	lea %a4,[%a4]14972 <80003a7c <__thenan_df>>
80027614:	df 22 e9 7f 	jeq %d2,2,800275e6 <__muldf3+0x3e>
80027618:	19 a2 2c 00 	ld.w %d2,[%sp]44
8002761c:	19 a3 18 00 	ld.w %d3,[%sp]24
80027620:	d9 a4 28 00 	lea %a4,[%sp]40
80027624:	0b 23 10 21 	ne %d2,%d3,%d2
80027628:	59 a2 2c 00 	st.w [%sp]44,%d2
8002762c:	6d 00 a7 01 	call 8002797a <__pack_d>
80027630:	00 90       	ret 
80027632:	19 a5 2c 00 	ld.w %d5,[%sp]44
80027636:	19 a4 18 00 	ld.w %d4,[%sp]24
8002763a:	0b 45 10 a1 	ne %d10,%d5,%d4
8002763e:	df 22 aa 00 	jeq %d2,2,80027792 <__muldf3+0x1ea>
80027642:	df 23 ae 00 	jeq %d3,2,8002779e <__muldf3+0x1f6>
80027646:	19 a6 34 00 	ld.w %d6,[%sp]52
8002764a:	19 a4 20 00 	ld.w %d4,[%sp]32
8002764e:	82 03       	mov %d3,0
80027650:	73 46 68 00 	mul.u %e0,%d6,%d4
80027654:	19 a2 38 00 	ld.w %d2,[%sp]56
80027658:	82 0b       	mov %d11,0
8002765a:	03 36 0a 11 	madd %d1,%d1,%d6,%d3
8002765e:	02 48       	mov %d8,%d4
80027660:	19 a7 24 00 	ld.w %d7,[%sp]36
80027664:	03 4b 0a 11 	madd %d1,%d1,%d11,%d4
80027668:	73 42 68 40 	mul.u %e4,%d2,%d4
8002766c:	82 0d       	mov %d13,0
8002766e:	82 0c       	mov %d12,0
80027670:	03 32 0a 55 	madd %d5,%d5,%d2,%d3
80027674:	03 8d 0a 55 	madd %d5,%d5,%d13,%d8
80027678:	73 27 68 80 	mul.u %e8,%d7,%d2
8002767c:	03 d7 0a 99 	madd %d9,%d9,%d7,%d13
80027680:	03 2c 0a 99 	madd %d9,%d9,%d12,%d2
80027684:	03 67 68 24 	madd.u %e2,%e4,%d7,%d6
80027688:	03 b7 0a 33 	madd %d3,%d3,%d7,%d11
8002768c:	03 6c 0a 33 	madd %d3,%d3,%d12,%d6
80027690:	0b 35 00 61 	eq %d6,%d5,%d3
80027694:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
80027698:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
8002769c:	02 67       	mov %d7,%d6
8002769e:	82 06       	mov %d6,0
800276a0:	0b 06 40 60 	addx %d6,%d6,%d0
800276a4:	0b 12 50 50 	addc %d5,%d2,%d1
800276a8:	0b 51 00 41 	eq %d4,%d1,%d5
800276ac:	0b 06 50 42 	and.ge.u %d4,%d6,%d0
800276b0:	0b 51 a0 42 	or.lt.u %d4,%d1,%d5
800276b4:	df 04 06 80 	jne %d4,0,800276c0 <__muldf3+0x118>
800276b8:	8b 1b 80 b0 	addx %d11,%d11,1
800276bc:	8b 07 a0 70 	addc %d7,%d7,0
800276c0:	82 04       	mov %d4,0
800276c2:	0b 83 40 30 	addx %d3,%d3,%d8
800276c6:	0b 94 50 20 	addc %d2,%d4,%d9
800276ca:	0b b3 40 30 	addx %d3,%d3,%d11
800276ce:	0b 72 50 20 	addc %d2,%d2,%d7
800276d2:	19 a4 1c 00 	ld.w %d4,[%sp]28
800276d6:	19 a7 30 00 	ld.w %d7,[%sp]48
800276da:	59 aa 00 10 	st.w [%sp]64,%d10
800276de:	0b 74 00 10 	add %d1,%d4,%d7
800276e2:	7b 00 00 42 	movh %d4,8192
800276e6:	1b 41 00 00 	addi %d0,%d1,4
800276ea:	0b 42 00 71 	eq %d7,%d2,%d4
800276ee:	b7 07 01 70 	insert %d7,%d7,0,0,1
800276f2:	59 a0 04 10 	st.w [%sp]68,%d0
800276f6:	0b 42 a0 72 	or.lt.u %d7,%d2,%d4
800276fa:	df 07 2b 80 	jne %d7,0,80027750 <__muldf3+0x1a8>
800276fe:	1b 51 00 70 	addi %d7,%d1,5
80027702:	8f 13 00 01 	and %d0,%d3,1
80027706:	02 71       	mov %d1,%d7
80027708:	df 00 07 00 	jeq %d0,0,80027716 <__muldf3+0x16e>
8002770c:	77 65 80 6f 	dextr %d6,%d5,%d6,31
80027710:	06 f5       	sh %d5,-1
80027712:	b7 f5 81 5f 	insert %d5,%d5,15,31,1
80027716:	77 32 80 3f 	dextr %d3,%d2,%d3,31
8002771a:	06 f2       	sh %d2,-1
8002771c:	0b 24 30 01 	lt.u %d0,%d4,%d2
80027720:	0b 24 70 02 	or.eq %d0,%d4,%d2
80027724:	c2 17       	add %d7,1
80027726:	df 00 ee ff 	jne %d0,0,80027702 <__muldf3+0x15a>
8002772a:	59 a1 04 10 	st.w [%sp]68,%d1
8002772e:	8f f3 0f 41 	and %d4,%d3,255
80027732:	8b 04 28 42 	ne %d4,%d4,128
80027736:	df 04 3a 00 	jeq %d4,0,800277aa <__muldf3+0x202>
8002773a:	59 a2 0c 10 	st.w [%sp]76,%d2
8002773e:	82 32       	mov %d2,3
80027740:	59 a3 08 10 	st.w [%sp]72,%d3
80027744:	d9 a4 3c 00 	lea %a4,[%sp]60
80027748:	59 a2 3c 00 	st.w [%sp]60,%d2
8002774c:	1d ff 4d ff 	j 800275e6 <__muldf3+0x3e>
80027750:	7b 00 00 71 	movh %d7,4096
80027754:	0b 27 30 41 	lt.u %d4,%d7,%d2
80027758:	0b 27 70 42 	or.eq %d4,%d7,%d2
8002775c:	df 04 e9 ff 	jne %d4,0,8002772e <__muldf3+0x186>
80027760:	77 32 80 20 	dextr %d2,%d2,%d3,1
80027764:	c2 f0       	add %d0,-1
80027766:	06 13       	sh %d3,1
80027768:	ff 05 06 00 	jge %d5,0,80027774 <__muldf3+0x1cc>
8002776c:	8f 13 40 11 	or %d1,%d3,1
80027770:	0b 21 10 28 	mov %e2,%d1,%d2
80027774:	0b 72 00 41 	eq %d4,%d2,%d7
80027778:	b7 04 01 40 	insert %d4,%d4,0,0,1
8002777c:	77 65 80 50 	dextr %d5,%d5,%d6,1
80027780:	0b 72 a0 42 	or.lt.u %d4,%d2,%d7
80027784:	06 16       	sh %d6,1
80027786:	df 04 ed ff 	jne %d4,0,80027760 <__muldf3+0x1b8>
8002778a:	59 a0 04 10 	st.w [%sp]68,%d0
8002778e:	1d ff d0 ff 	j 8002772e <__muldf3+0x186>
80027792:	59 aa 18 00 	st.w [%sp]24,%d10
80027796:	d9 a4 14 00 	lea %a4,[%sp]20
8002779a:	1d ff 26 ff 	j 800275e6 <__muldf3+0x3e>
8002779e:	59 aa 2c 00 	st.w [%sp]44,%d10
800277a2:	d9 a4 28 00 	lea %a4,[%sp]40
800277a6:	1d ff 20 ff 	j 800275e6 <__muldf3+0x3e>
800277aa:	77 32 00 4c 	dextr %d4,%d2,%d3,24
800277ae:	a6 65       	or %d5,%d6
800277b0:	8b 05 20 52 	ne %d5,%d5,0
800277b4:	0f 45 e0 40 	andn %d4,%d5,%d4
800277b8:	df 04 c1 7f 	jeq %d4,0,8002773a <__muldf3+0x192>
800277bc:	8b 03 88 30 	addx %d3,%d3,128
800277c0:	8b 02 a0 20 	addc %d2,%d2,0
800277c4:	8f f3 cf 31 	andn %d3,%d3,255
800277c8:	1d ff b9 ff 	j 8002773a <__muldf3+0x192>

800277cc <__gedf2>:
800277cc:	20 38       	sub.a %sp,56
800277ce:	d9 a5 10 00 	lea %a5,[%sp]16
800277d2:	40 a4       	mov.aa %a4,%sp
800277d4:	89 a4 40 09 	st.d [%sp],%e4
800277d8:	89 a6 48 09 	st.d [%sp]8,%e6
800277dc:	6d 00 9e 01 	call 80027b18 <__unpack_d>
800277e0:	d9 a5 24 00 	lea %a5,[%sp]36
800277e4:	d9 a4 08 00 	lea %a4,[%sp]8
800277e8:	6d 00 98 01 	call 80027b18 <__unpack_d>
800277ec:	19 a3 10 00 	ld.w %d3,[%sp]16
800277f0:	82 f2       	mov %d2,-1
800277f2:	bf 23 0c 80 	jlt.u %d3,2,8002780a <__gedf2+0x3e>
800277f6:	19 a3 24 00 	ld.w %d3,[%sp]36
800277fa:	bf 23 08 80 	jlt.u %d3,2,8002780a <__gedf2+0x3e>
800277fe:	d9 a5 24 00 	lea %a5,[%sp]36
80027802:	d9 a4 10 00 	lea %a4,[%sp]16
80027806:	6d 00 e8 01 	call 80027bd6 <__fpcmp_parts_d>
8002780a:	00 90       	ret 

8002780c <__fixdfsi>:
8002780c:	20 20       	sub.a %sp,32
8002780e:	d9 a5 0c 00 	lea %a5,[%sp]12
80027812:	d9 a4 04 00 	lea %a4,[%sp]4
80027816:	89 a4 44 09 	st.d [%sp]4,%e4
8002781a:	6d 00 7f 01 	call 80027b18 <__unpack_d>
8002781e:	19 a3 0c 00 	ld.w %d3,[%sp]12
80027822:	82 02       	mov %d2,0
80027824:	bf 33 25 80 	jlt.u %d3,3,8002786e <__fixdfsi+0x62>
80027828:	df 43 29 00 	jeq %d3,4,8002787a <__fixdfsi+0x6e>
8002782c:	19 a3 14 00 	ld.w %d3,[%sp]20
80027830:	bf 03 1f 00 	jlt %d3,0,8002786e <__fixdfsi+0x62>
80027834:	8b f3 41 22 	lt %d2,%d3,31
80027838:	19 a6 10 00 	ld.w %d6,[%sp]16
8002783c:	df 02 1a 00 	jeq %d2,0,80027870 <__fixdfsi+0x64>
80027840:	8b c3 03 21 	rsub %d2,%d3,60
80027844:	19 a5 1c 00 	ld.w %d5,[%sp]28
80027848:	19 a4 18 00 	ld.w %d4,[%sp]24
8002784c:	8b 02 82 32 	ge %d3,%d2,32
80027850:	2b 54 50 43 	seln %d4,%d3,%d4,%d5
80027854:	ab 05 a0 53 	seln %d5,%d3,%d5,0
80027858:	8f f2 01 31 	and %d3,%d2,31
8002785c:	8b 03 02 21 	rsub %d2,%d3,32
80027860:	17 45 80 22 	dextr %d2,%d5,%d4,%d2
80027864:	2b 42 40 23 	sel %d2,%d3,%d2,%d4
80027868:	df 06 03 00 	jeq %d6,0,8002786e <__fixdfsi+0x62>
8002786c:	32 52       	rsub %d2
8002786e:	00 90       	ret 
80027870:	82 f2       	mov %d2,-1
80027872:	06 f2       	sh %d2,-1
80027874:	ab 12 00 26 	cadd %d2,%d6,%d2,1
80027878:	00 90       	ret 
8002787a:	19 a3 10 00 	ld.w %d3,[%sp]16
8002787e:	82 f2       	mov %d2,-1
80027880:	06 f2       	sh %d2,-1
80027882:	ab 12 00 23 	cadd %d2,%d3,%d2,1
80027886:	00 90       	ret 

80027888 <__make_dp>:
80027888:	20 18       	sub.a %sp,24
8002788a:	09 a2 d8 09 	ld.da %a2,[%sp]24
8002788e:	d9 a4 04 00 	lea %a4,[%sp]4
80027892:	59 a4 04 00 	st.w [%sp]4,%d4
80027896:	59 a5 08 00 	st.w [%sp]8,%d5
8002789a:	59 a6 0c 00 	st.w [%sp]12,%d6
8002789e:	89 a2 d0 09 	st.da [%sp]16,%a2
800278a2:	6d 00 6c 00 	call 8002797a <__pack_d>
800278a6:	00 90       	ret 

800278a8 <memmove>:
800278a8:	80 42       	mov.d %d2,%a4
800278aa:	80 55       	mov.d %d5,%a5
800278ac:	1b f4 ff 3f 	addi %d3,%d4,-1
800278b0:	7f 52 0d 80 	jge.u %d2,%d5,800278ca <memmove+0x22>
800278b4:	01 54 00 26 	addsc.a %a2,%a5,%d4,0
800278b8:	40 43       	mov.aa %a3,%a4
800278ba:	df 04 06 00 	jeq %d4,0,800278c6 <memmove+0x1e>
800278be:	04 53       	ld.bu %d3,[%a5+]
800278c0:	24 33       	st.b [%a3+],%d3
800278c2:	7d 52 fe ff 	jne.a %a2,%a5,800278be <memmove+0x16>
800278c6:	60 22       	mov.a %a2,%d2
800278c8:	00 90       	ret 
800278ca:	01 53 00 26 	addsc.a %a2,%a5,%d3,0
800278ce:	df 04 fc 7f 	jeq %d4,0,800278c6 <memmove+0x1e>
800278d2:	01 54 00 36 	addsc.a %a3,%a5,%d4,0
800278d6:	01 44 00 56 	addsc.a %a5,%a4,%d4,0
800278da:	8b 14 00 41 	rsub %d4,%d4,1
800278de:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800278e2:	09 33 7f f4 	ld.bu %d3,[+%a3]-1
800278e6:	89 53 3f f4 	st.b [+%a5]-1,%d3
800278ea:	7d 23 fc ff 	jne.a %a3,%a2,800278e2 <memmove+0x3a>
800278ee:	60 22       	mov.a %a2,%d2
800278f0:	00 90       	ret 

800278f2 <__unpack_f>:
800278f2:	54 42       	ld.w %d2,[%a4]
800278f4:	8f 12 1e 50 	sh %d5,%d2,-31
800278f8:	37 02 e8 3b 	extr.u %d3,%d2,23,8
800278fc:	b7 02 89 4b 	insert %d4,%d2,0,23,9
80027900:	59 55 04 00 	st.w [%a5]4,%d5
80027904:	df 03 16 80 	jne %d3,0,80027930 <__unpack_f+0x3e>
80027908:	df 04 25 00 	jeq %d4,0,80027952 <__unpack_f+0x60>
8002790c:	82 33       	mov %d3,3
8002790e:	8f 74 00 20 	sh %d2,%d4,7
80027912:	7b 00 00 54 	movh %d5,16384
80027916:	74 53       	st.w [%a5],%d3
80027918:	3b 10 f8 3f 	mov %d3,-127
8002791c:	06 12       	sh %d2,1
8002791e:	02 34       	mov %d4,%d3
80027920:	c2 f3       	add %d3,-1
80027922:	3f 52 fd ff 	jlt.u %d2,%d5,8002791c <__unpack_f+0x2a>
80027926:	59 54 08 00 	st.w [%a5]8,%d4
8002792a:	59 52 0c 00 	st.w [%a5]12,%d2
8002792e:	00 90       	ret 
80027930:	8b f3 2f 52 	ne %d5,%d3,255
80027934:	df 05 12 00 	jeq %d5,0,80027958 <__unpack_f+0x66>
80027938:	82 32       	mov %d2,3
8002793a:	1b 13 f8 3f 	addi %d3,%d3,-127
8002793e:	74 52       	st.w [%a5],%d2
80027940:	8f 74 00 20 	sh %d2,%d4,7
80027944:	b7 f2 01 2f 	insert %d2,%d2,15,30,1
80027948:	59 53 08 00 	st.w [%a5]8,%d3
8002794c:	59 52 0c 00 	st.w [%a5]12,%d2
80027950:	00 90       	ret 
80027952:	82 22       	mov %d2,2
80027954:	74 52       	st.w [%a5],%d2
80027956:	00 90       	ret 
80027958:	df 04 05 80 	jne %d4,0,80027962 <__unpack_f+0x70>
8002795c:	82 42       	mov %d2,4
8002795e:	74 52       	st.w [%a5],%d2
80027960:	00 90       	ret 
80027962:	37 02 61 3b 	extr.u %d3,%d2,22,1
80027966:	06 72       	sh %d2,7
80027968:	74 53       	st.w [%a5],%d3
8002796a:	7b 00 00 32 	movh %d3,8192
8002796e:	1b 03 f8 3f 	addi %d3,%d3,-128
80027972:	26 32       	and %d2,%d3
80027974:	59 52 0c 00 	st.w [%a5]12,%d2
80027978:	00 90       	ret 

8002797a <__pack_d>:
8002797a:	54 44       	ld.w %d4,[%a4]
8002797c:	19 43 0c 00 	ld.w %d3,[%a4]12
80027980:	19 42 10 00 	ld.w %d2,[%a4]16
80027984:	19 41 04 00 	ld.w %d1,[%a4]4
80027988:	bf 24 56 80 	jlt.u %d4,2,80027a34 <__pack_d+0xba>
8002798c:	7b 00 ff 57 	movh %d5,32752
80027990:	d2 06       	mov %e6,0
80027992:	df 44 0b 00 	jeq %d4,4,800279a8 <__pack_d+0x2e>
80027996:	0f 23 a0 50 	or %d5,%d3,%d2
8002799a:	8b 05 00 02 	eq %d0,%d5,0
8002799e:	8b 24 e0 04 	or.eq %d0,%d4,2
800279a2:	82 05       	mov %d5,0
800279a4:	df 00 0c 00 	jeq %d0,0,800279bc <__pack_d+0x42>
800279a8:	0b 10 00 28 	mov %e2,%d1
800279ac:	a6 75       	or %d5,%d7
800279ae:	8f f2 01 20 	sh %d2,%d2,31
800279b2:	0f 25 a0 40 	or %d4,%d5,%d2
800279b6:	02 43       	mov %d3,%d4
800279b8:	02 62       	mov %d2,%d6
800279ba:	00 90       	ret 
800279bc:	19 44 08 00 	ld.w %d4,[%a4]8
800279c0:	3b 20 c0 0f 	mov %d0,-1022
800279c4:	3f 04 41 00 	jlt %d4,%d0,80027a46 <__pack_d+0xcc>
800279c8:	3b 00 40 00 	mov %d0,1024
800279cc:	7b 00 ff 57 	movh %d5,32752
800279d0:	7f 04 ec 7f 	jge %d4,%d0,800279a8 <__pack_d+0x2e>
800279d4:	8f f3 0f 51 	and %d5,%d3,255
800279d8:	8b 05 28 52 	ne %d5,%d5,128
800279dc:	df 05 1b 00 	jeq %d5,0,80027a12 <__pack_d+0x98>
800279e0:	8b f3 87 30 	addx %d3,%d3,127
800279e4:	8b 02 a0 20 	addc %d2,%d2,0
800279e8:	7b 00 00 52 	movh %d5,8192
800279ec:	0b 25 30 61 	lt.u %d6,%d5,%d2
800279f0:	0b 25 70 62 	or.eq %d6,%d5,%d2
800279f4:	df 06 19 80 	jne %d6,0,80027a26 <__pack_d+0xac>
800279f8:	1b f4 3f 40 	addi %d4,%d4,1023
800279fc:	0b 40 00 48 	mov %e4,%d4
80027a00:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80027a04:	06 82       	sh %d2,-8
80027a06:	b7 02 0c 7a 	insert %d7,%d2,0,20,12
80027a0a:	8f 44 01 50 	sh %d5,%d4,20
80027a0e:	1d ff cd ff 	j 800279a8 <__pack_d+0x2e>
80027a12:	8f 03 10 51 	and %d5,%d3,256
80027a16:	df 05 e9 7f 	jeq %d5,0,800279e8 <__pack_d+0x6e>
80027a1a:	8b 03 88 30 	addx %d3,%d3,128
80027a1e:	8b 02 a0 20 	addc %d2,%d2,0
80027a22:	1d ff e3 ff 	j 800279e8 <__pack_d+0x6e>
80027a26:	77 32 80 3f 	dextr %d3,%d2,%d3,31
80027a2a:	1b 04 40 40 	addi %d4,%d4,1024
80027a2e:	06 f2       	sh %d2,-1
80027a30:	1d ff e6 ff 	j 800279fc <__pack_d+0x82>
80027a34:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80027a38:	06 82       	sh %d2,-8
80027a3a:	b7 12 8d 79 	insert %d7,%d2,1,19,13
80027a3e:	7b 00 ff 57 	movh %d5,32752
80027a42:	1d ff b3 ff 	j 800279a8 <__pack_d+0x2e>
80027a46:	0b 40 80 40 	sub %d4,%d0,%d4
80027a4a:	8b 94 83 02 	ge %d0,%d4,57
80027a4e:	df 00 ad ff 	jne %d0,0,800279a8 <__pack_d+0x2e>
80027a52:	8b 04 82 52 	ge %d5,%d4,32
80027a56:	2b 23 50 05 	seln %d0,%d5,%d3,%d2
80027a5a:	ab 02 a0 75 	seln %d7,%d5,%d2,0
80027a5e:	8f f4 01 51 	and %d5,%d4,31
80027a62:	8b 05 02 61 	rsub %d6,%d5,32
80027a66:	17 07 80 66 	dextr %d6,%d7,%d0,%d6
80027a6a:	2b 06 40 65 	sel %d6,%d5,%d6,%d0
80027a6e:	8b 04 82 82 	ge %d8,%d4,32
80027a72:	32 55       	rsub %d5
80027a74:	02 60       	mov %d0,%d6
80027a76:	8f f4 01 41 	and %d4,%d4,31
80027a7a:	82 f6       	mov %d6,-1
80027a7c:	0f 57 00 70 	sh %d7,%d7,%d5
80027a80:	17 66 80 54 	dextr %d5,%d6,%d6,%d4
80027a84:	0f 46 00 40 	sh %d4,%d6,%d4
80027a88:	2b 45 50 58 	seln %d5,%d8,%d5,%d4
80027a8c:	ab 04 a0 48 	seln %d4,%d8,%d4,0
80027a90:	0f 43 e0 30 	andn %d3,%d3,%d4
80027a94:	0f 52 e0 20 	andn %d2,%d2,%d5
80027a98:	a6 32       	or %d2,%d3
80027a9a:	02 03       	mov %d3,%d0
80027a9c:	8b 02 00 35 	or.ne %d3,%d2,0
80027aa0:	8f f3 0f 51 	and %d5,%d3,255
80027aa4:	82 12       	mov %d2,1
80027aa6:	8b 05 08 24 	and.eq %d2,%d5,128
80027aaa:	02 74       	mov %d4,%d7
80027aac:	df 02 14 80 	jne %d2,0,80027ad4 <__pack_d+0x15a>
80027ab0:	8b f3 87 30 	addx %d3,%d3,127
80027ab4:	8b 07 a0 20 	addc %d2,%d7,0
80027ab8:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80027abc:	7b 00 00 31 	movh %d3,4096
80027ac0:	8f 82 1f 70 	sh %d7,%d2,-8
80027ac4:	0b 32 50 21 	ge.u %d2,%d2,%d3
80027ac8:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80027acc:	8f 42 01 50 	sh %d5,%d2,20
80027ad0:	1d ff 6c ff 	j 800279a8 <__pack_d+0x2e>
80027ad4:	8b 03 88 60 	addx %d6,%d3,128
80027ad8:	8b 07 a0 20 	addc %d2,%d7,0
80027adc:	7b 00 00 a1 	movh %d10,4096
80027ae0:	8f 82 1f 70 	sh %d7,%d2,-8
80027ae4:	77 62 00 6c 	dextr %d6,%d2,%d6,24
80027ae8:	0b a2 50 21 	ge.u %d2,%d2,%d10
80027aec:	53 12 40 80 	mul.u %e8,%d2,1
80027af0:	8f 03 10 01 	and %d0,%d3,256
80027af4:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80027af8:	8f 48 01 50 	sh %d5,%d8,20
80027afc:	df 00 56 ff 	jne %d0,0,800279a8 <__pack_d+0x2e>
80027b00:	8f 84 1f 70 	sh %d7,%d4,-8
80027b04:	0b a4 50 21 	ge.u %d2,%d4,%d10
80027b08:	77 34 00 6c 	dextr %d6,%d4,%d3,24
80027b0c:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80027b10:	8f 42 01 50 	sh %d5,%d2,20
80027b14:	1d ff 4a ff 	j 800279a8 <__pack_d+0x2e>

80027b18 <__unpack_d>:
80027b18:	09 48 40 09 	ld.d %e8,[%a4]
80027b1c:	3b f0 7f 00 	mov %d0,2047
80027b20:	8f 19 1e 70 	sh %d7,%d9,-31
80027b24:	37 09 6b 5a 	extr.u %d5,%d9,20,11
80027b28:	b7 09 0c 6a 	insert %d6,%d9,0,20,12
80027b2c:	59 57 04 00 	st.w [%a5]4,%d7
80027b30:	df 05 26 80 	jne %d5,0,80027b7c <__unpack_d+0x64>
80027b34:	8b 08 20 22 	ne %d2,%d8,0
80027b38:	8b 06 00 25 	or.ne %d2,%d6,0
80027b3c:	df 02 33 00 	jeq %d2,0,80027ba2 <__unpack_d+0x8a>
80027b40:	82 32       	mov %d2,3
80027b42:	77 86 00 34 	dextr %d3,%d6,%d8,8
80027b46:	8f 88 00 40 	sh %d4,%d8,8
80027b4a:	74 52       	st.w [%a5],%d2
80027b4c:	3b 10 c0 5f 	mov %d5,-1023
80027b50:	7b 00 00 61 	movh %d6,4096
80027b54:	77 43 80 30 	dextr %d3,%d3,%d4,1
80027b58:	02 57       	mov %d7,%d5
80027b5a:	0b 63 00 21 	eq %d2,%d3,%d6
80027b5e:	b7 02 01 20 	insert %d2,%d2,0,0,1
80027b62:	06 14       	sh %d4,1
80027b64:	0b 63 a0 22 	or.lt.u %d2,%d3,%d6
80027b68:	c2 f5       	add %d5,-1
80027b6a:	df 02 f5 ff 	jne %d2,0,80027b54 <__unpack_d+0x3c>
80027b6e:	59 57 08 00 	st.w [%a5]8,%d7
80027b72:	59 54 0c 00 	st.w [%a5]12,%d4
80027b76:	59 53 10 00 	st.w [%a5]16,%d3
80027b7a:	00 90       	ret 
80027b7c:	5f 05 16 00 	jeq %d5,%d0,80027ba8 <__unpack_d+0x90>
80027b80:	82 32       	mov %d2,3
80027b82:	1b 15 c0 5f 	addi %d5,%d5,-1023
80027b86:	8f 88 00 40 	sh %d4,%d8,8
80027b8a:	74 52       	st.w [%a5],%d2
80027b8c:	77 86 00 24 	dextr %d2,%d6,%d8,8
80027b90:	59 55 08 00 	st.w [%a5]8,%d5
80027b94:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
80027b98:	59 54 0c 00 	st.w [%a5]12,%d4
80027b9c:	59 52 10 00 	st.w [%a5]16,%d2
80027ba0:	00 90       	ret 
80027ba2:	82 22       	mov %d2,2
80027ba4:	74 52       	st.w [%a5],%d2
80027ba6:	00 90       	ret 
80027ba8:	8b 08 20 52 	ne %d5,%d8,0
80027bac:	8b 06 00 55 	or.ne %d5,%d6,0
80027bb0:	df 05 05 80 	jne %d5,0,80027bba <__unpack_d+0xa2>
80027bb4:	82 42       	mov %d2,4
80027bb6:	74 52       	st.w [%a5],%d2
80027bb8:	00 90       	ret 
80027bba:	77 89 00 34 	dextr %d3,%d9,%d8,8
80027bbe:	37 09 e1 49 	extr.u %d4,%d9,19,1
80027bc2:	b7 03 85 3d 	insert %d3,%d3,0,27,5
80027bc6:	8f 88 00 20 	sh %d2,%d8,8
80027bca:	74 54       	st.w [%a5],%d4
80027bcc:	59 52 0c 00 	st.w [%a5]12,%d2
80027bd0:	59 53 10 00 	st.w [%a5]16,%d3
80027bd4:	00 90       	ret 

80027bd6 <__fpcmp_parts_d>:
80027bd6:	54 43       	ld.w %d3,[%a4]
80027bd8:	82 12       	mov %d2,1
80027bda:	bf 23 45 80 	jlt.u %d3,2,80027c64 <__fpcmp_parts_d+0x8e>
80027bde:	54 54       	ld.w %d4,[%a5]
80027be0:	bf 24 42 80 	jlt.u %d4,2,80027c64 <__fpcmp_parts_d+0x8e>
80027be4:	8b 44 00 52 	eq %d5,%d4,4
80027be8:	8b 43 00 54 	and.eq %d5,%d3,4
80027bec:	df 05 50 80 	jne %d5,0,80027c8c <__fpcmp_parts_d+0xb6>
80027bf0:	df 43 45 00 	jeq %d3,4,80027c7a <__fpcmp_parts_d+0xa4>
80027bf4:	df 44 3d 00 	jeq %d4,4,80027c6e <__fpcmp_parts_d+0x98>
80027bf8:	8b 24 00 52 	eq %d5,%d4,2
80027bfc:	8b 23 00 54 	and.eq %d5,%d3,2
80027c00:	82 02       	mov %d2,0
80027c02:	df 05 31 80 	jne %d5,0,80027c64 <__fpcmp_parts_d+0x8e>
80027c06:	df 23 34 00 	jeq %d3,2,80027c6e <__fpcmp_parts_d+0x98>
80027c0a:	19 42 04 00 	ld.w %d2,[%a4]4
80027c0e:	df 24 2c 00 	jeq %d4,2,80027c66 <__fpcmp_parts_d+0x90>
80027c12:	19 53 04 00 	ld.w %d3,[%a5]4
80027c16:	5f 23 28 80 	jne %d3,%d2,80027c66 <__fpcmp_parts_d+0x90>
80027c1a:	19 44 08 00 	ld.w %d4,[%a4]8
80027c1e:	19 53 08 00 	ld.w %d3,[%a5]8
80027c22:	3f 43 22 00 	jlt %d3,%d4,80027c66 <__fpcmp_parts_d+0x90>
80027c26:	3f 34 2f 00 	jlt %d4,%d3,80027c84 <__fpcmp_parts_d+0xae>
80027c2a:	19 45 10 00 	ld.w %d5,[%a4]16
80027c2e:	19 56 10 00 	ld.w %d6,[%a5]16
80027c32:	19 40 0c 00 	ld.w %d0,[%a4]12
80027c36:	0b 65 00 41 	eq %d4,%d5,%d6
80027c3a:	19 57 0c 00 	ld.w %d7,[%a5]12
80027c3e:	02 43       	mov %d3,%d4
80027c40:	0b 07 50 32 	and.ge.u %d3,%d7,%d0
80027c44:	0b 70 50 42 	and.ge.u %d4,%d0,%d7
80027c48:	0b 65 a0 32 	or.lt.u %d3,%d5,%d6
80027c4c:	0b 56 a0 42 	or.lt.u %d4,%d6,%d5
80027c50:	82 f5       	mov %d5,-1
80027c52:	ab 15 a0 52 	seln %d5,%d2,%d5,1
80027c56:	82 16       	mov %d6,1
80027c58:	ab f6 bf 22 	seln %d2,%d2,%d6,-1
80027c5c:	ab 05 a0 44 	seln %d4,%d4,%d5,0
80027c60:	2b 24 40 23 	sel %d2,%d3,%d4,%d2
80027c64:	00 90       	ret 
80027c66:	82 13       	mov %d3,1
80027c68:	ab f3 bf 22 	seln %d2,%d2,%d3,-1
80027c6c:	00 90       	ret 
80027c6e:	19 53 04 00 	ld.w %d3,[%a5]4
80027c72:	82 f2       	mov %d2,-1
80027c74:	ab 12 a0 23 	seln %d2,%d3,%d2,1
80027c78:	00 90       	ret 
80027c7a:	19 43 04 00 	ld.w %d3,[%a4]4
80027c7e:	ab f2 bf 23 	seln %d2,%d3,%d2,-1
80027c82:	00 90       	ret 
80027c84:	82 f3       	mov %d3,-1
80027c86:	ab 13 a0 22 	seln %d2,%d2,%d3,1
80027c8a:	00 90       	ret 
80027c8c:	19 53 04 00 	ld.w %d3,[%a5]4
80027c90:	19 42 04 00 	ld.w %d2,[%a4]4
80027c94:	0b 23 80 20 	sub %d2,%d3,%d2
80027c98:	00 90       	ret 

80027c9a <malloc>:
80027c9a:	91 10 00 47 	movh.a %a4,28673
80027c9e:	99 44 50 aa 	ld.a %a4,[%a4]-22896 <7000a690 <_impure_ptr>>
80027ca2:	6d 00 03 00 	call 80027ca8 <_malloc_r>
80027ca6:	00 90       	ret 

80027ca8 <_malloc_r>:
80027ca8:	1b b4 00 20 	addi %d2,%d4,11
80027cac:	8b 72 a1 32 	ge.u %d3,%d2,23
80027cb0:	40 4e       	mov.aa %a14,%a4
80027cb2:	df 03 32 80 	jne %d3,0,80027d16 <_malloc_r+0x6e>
80027cb6:	8b 14 a1 42 	ge.u %d4,%d4,17
80027cba:	df 04 db 80 	jne %d4,0,80027e70 <_malloc_r+0x1c8>
80027cbe:	6d 00 35 03 	call 80028328 <__malloc_lock>
80027cc2:	3b 80 01 30 	mov %d3,24
80027cc6:	82 26       	mov %d6,2
80027cc8:	3b 00 01 80 	mov %d8,16
80027ccc:	91 10 00 d7 	movh.a %a13,28673
80027cd0:	d9 dd 38 9a 	lea %a13,[%a13]-23944 <7000a278 <__malloc_av_>>
80027cd4:	01 d3 00 26 	addsc.a %a2,%a13,%d3,0
80027cd8:	99 2c 04 00 	ld.a %a12,[%a2]4
80027cdc:	d9 23 f8 ff 	lea %a3,[%a2]-8
80027ce0:	7d 3c ce 00 	jeq.a %a12,%a3,80027e7c <_malloc_r+0x1d4>
80027ce4:	99 c2 0c 00 	ld.a %a2,[%a12]12
80027ce8:	99 c3 08 00 	ld.a %a3,[%a12]8
80027cec:	19 c2 04 00 	ld.w %d2,[%a12]4
80027cf0:	b5 32 0c 00 	st.a [%a3]12,%a2
80027cf4:	8f 32 c0 21 	andn %d2,%d2,3
80027cf8:	b5 23 08 00 	st.a [%a2]8,%a3
80027cfc:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80027d00:	b7 10 21 20 	imask %e2,1,0,1
80027d04:	40 e4       	mov.aa %a4,%a14
80027d06:	d9 cc 08 00 	lea %a12,[%a12]8
80027d0a:	49 22 44 08 	ldmst [%a2]4,%e2
80027d0e:	6d 00 0e 03 	call 8002832a <__malloc_unlock>
80027d12:	40 c2       	mov.aa %a2,%a12
80027d14:	00 90       	ret 
80027d16:	8f 72 c0 81 	andn %d8,%d2,7
80027d1a:	0b 48 30 31 	lt.u %d3,%d8,%d4
80027d1e:	8b 02 20 35 	or.lt %d3,%d2,0
80027d22:	df 03 a7 80 	jne %d3,0,80027e70 <_malloc_r+0x1c8>
80027d26:	6d 00 01 03 	call 80028328 <__malloc_lock>
80027d2a:	8b 88 bf 22 	ge.u %d2,%d8,504
80027d2e:	df 02 07 02 	jeq %d2,0,8002813c <_malloc_r+0x494>
80027d32:	8f 78 1f 20 	sh %d2,%d8,-9
80027d36:	3b 00 20 30 	mov %d3,512
80027d3a:	3b 00 04 60 	mov %d6,64
80027d3e:	3b f0 03 50 	mov %d5,63
80027d42:	df 02 61 81 	jne %d2,0,80028004 <_malloc_r+0x35c>
80027d46:	91 10 00 d7 	movh.a %a13,28673
80027d4a:	d9 dd 38 9a 	lea %a13,[%a13]-23944 <7000a278 <__malloc_av_>>
80027d4e:	01 d3 00 36 	addsc.a %a3,%a13,%d3,0
80027d52:	99 3c 04 00 	ld.a %a12,[%a3]4
80027d56:	d9 32 f8 ff 	lea %a2,[%a3]-8
80027d5a:	7d c2 0a 80 	jne.a %a2,%a12,80027d6e <_malloc_r+0xc6>
80027d5e:	1d 00 13 00 	j 80027d84 <_malloc_r+0xdc>
80027d62:	ff 02 80 01 	jge %d2,0,80028062 <_malloc_r+0x3ba>
80027d66:	99 cc 0c 00 	ld.a %a12,[%a12]12
80027d6a:	7d c2 0d 00 	jeq.a %a2,%a12,80027d84 <_malloc_r+0xdc>
80027d6e:	19 c2 04 00 	ld.w %d2,[%a12]4
80027d72:	8f 32 c0 41 	andn %d4,%d2,3
80027d76:	0b 84 80 20 	sub %d2,%d4,%d8
80027d7a:	8b 02 81 32 	ge %d3,%d2,16
80027d7e:	df 03 f2 7f 	jeq %d3,0,80027d62 <_malloc_r+0xba>
80027d82:	02 56       	mov %d6,%d5
80027d84:	99 dc 10 00 	ld.a %a12,[%a13]16 <70010010 <ram_heap+0x4f7c>>
80027d88:	d9 d4 08 00 	lea %a4,[%a13]8 <70010008 <ram_heap+0x4f74>>
80027d8c:	7d 4c 83 00 	jeq.a %a12,%a4,80027e92 <_malloc_r+0x1ea>
80027d90:	19 c2 04 00 	ld.w %d2,[%a12]4
80027d94:	8f 32 c0 21 	andn %d2,%d2,3
80027d98:	0b 82 80 30 	sub %d3,%d2,%d8
80027d9c:	8b 03 41 42 	lt %d4,%d3,16
80027da0:	df 04 d4 01 	jeq %d4,0,80028148 <_malloc_r+0x4a0>
80027da4:	b5 d4 14 00 	st.a [%a13]20 <70010014 <ram_heap+0x4f80>>,%a4
80027da8:	b5 d4 10 00 	st.a [%a13]16 <70010010 <ram_heap+0x4f7c>>,%a4
80027dac:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80027db0:	ff 03 a8 7f 	jge %d3,0,80027d00 <_malloc_r+0x58>
80027db4:	3b 00 20 30 	mov %d3,512
80027db8:	7f 32 6a 81 	jge.u %d2,%d3,8002808c <_malloc_r+0x3e4>
80027dbc:	19 d4 04 00 	ld.w %d4,[%a13]4 <70010004 <ram_heap+0x4f70>>
80027dc0:	8f b2 1f 30 	sh %d3,%d2,-5
80027dc4:	8f 72 c0 21 	andn %d2,%d2,7
80027dc8:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
80027dcc:	1b 82 00 20 	addi %d2,%d2,8
80027dd0:	01 d2 00 36 	addsc.a %a3,%a13,%d2,0
80027dd4:	d9 d2 04 00 	lea %a2,[%a13]4 <70010004 <ram_heap+0x4f70>>
80027dd8:	d4 35       	ld.a %a5,[%a3]
80027dda:	74 23       	st.w [%a2],%d3
80027ddc:	40 32       	mov.aa %a2,%a3
80027dde:	b0 82       	add.a %a2,-8
80027de0:	b5 c2 0c 00 	st.a [%a12]12,%a2
80027de4:	b5 c5 08 00 	st.a [%a12]8,%a5
80027de8:	f4 3c       	st.a [%a3],%a12
80027dea:	b5 5c 0c 00 	st.a [%a5]12,%a12
80027dee:	8f e6 3f 40 	sha %d4,%d6,-2
80027df2:	82 12       	mov %d2,1
80027df4:	0f 42 00 20 	sh %d2,%d2,%d4
80027df8:	3f 23 56 80 	jlt.u %d3,%d2,80027ea4 <_malloc_r+0x1fc>
80027dfc:	0f 32 80 40 	and %d4,%d2,%d3
80027e00:	df 04 0a 80 	jne %d4,0,80027e14 <_malloc_r+0x16c>
80027e04:	8f 36 c0 61 	andn %d6,%d6,3
80027e08:	06 12       	sh %d2,1
80027e0a:	0f 32 80 40 	and %d4,%d2,%d3
80027e0e:	c2 46       	add %d6,4
80027e10:	df 04 fc 7f 	jeq %d4,0,80027e08 <_malloc_r+0x160>
80027e14:	8f 36 00 30 	sh %d3,%d6,3
80027e18:	01 d3 00 56 	addsc.a %a5,%a13,%d3,0
80027e1c:	02 67       	mov %d7,%d6
80027e1e:	40 52       	mov.aa %a2,%a5
80027e20:	99 23 0c 00 	ld.a %a3,[%a2]12
80027e24:	7d 32 62 01 	jeq.a %a2,%a3,800280e8 <_malloc_r+0x440>
80027e28:	19 33 04 00 	ld.w %d3,[%a3]4
80027e2c:	d9 36 04 00 	lea %a6,[%a3]4
80027e30:	8f 33 c0 51 	andn %d5,%d3,3
80027e34:	0b 85 80 30 	sub %d3,%d5,%d8
80027e38:	40 3c       	mov.aa %a12,%a3
80027e3a:	8b 03 41 42 	lt %d4,%d3,16
80027e3e:	d9 33 0c 00 	lea %a3,[%a3]12
80027e42:	d4 33       	ld.a %a3,[%a3]
80027e44:	df 04 5b 01 	jeq %d4,0,800280fa <_malloc_r+0x452>
80027e48:	bf 03 ee 7f 	jlt %d3,0,80027e24 <_malloc_r+0x17c>
80027e4c:	b7 10 21 20 	imask %e2,1,0,1
80027e50:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
80027e54:	d9 cc 08 00 	lea %a12,[%a12]8
80027e58:	40 e4       	mov.aa %a4,%a14
80027e5a:	49 22 44 08 	ldmst [%a2]4,%e2
80027e5e:	d4 c2       	ld.a %a2,[%a12]
80027e60:	b5 23 0c 00 	st.a [%a2]12,%a3
80027e64:	b5 32 08 00 	st.a [%a3]8,%a2
80027e68:	6d 00 61 02 	call 8002832a <__malloc_unlock>
80027e6c:	1d 00 06 00 	j 80027e78 <_malloc_r+0x1d0>
80027e70:	3b c0 00 20 	mov %d2,12
80027e74:	a0 0c       	mov.a %a12,0
80027e76:	74 e2       	st.w [%a14],%d2
80027e78:	40 c2       	mov.aa %a2,%a12
80027e7a:	00 90       	ret 
80027e7c:	99 2c 0c 00 	ld.a %a12,[%a2]12
80027e80:	c2 26       	add %d6,2
80027e82:	7d c2 31 ff 	jne.a %a2,%a12,80027ce4 <_malloc_r+0x3c>
80027e86:	99 dc 10 00 	ld.a %a12,[%a13]16
80027e8a:	d9 d4 08 00 	lea %a4,[%a13]8
80027e8e:	7d 4c 81 ff 	jne.a %a12,%a4,80027d90 <_malloc_r+0xe8>
80027e92:	8f e6 3f 40 	sha %d4,%d6,-2
80027e96:	82 12       	mov %d2,1
80027e98:	19 d3 04 00 	ld.w %d3,[%a13]4
80027e9c:	0f 42 00 20 	sh %d2,%d2,%d4
80027ea0:	7f 23 ae ff 	jge.u %d3,%d2,80027dfc <_malloc_r+0x154>
80027ea4:	99 dc 08 00 	ld.a %a12,[%a13]8
80027ea8:	19 c2 04 00 	ld.w %d2,[%a12]4
80027eac:	8f 32 c0 b1 	andn %d11,%d2,3
80027eb0:	0b 8b 80 20 	sub %d2,%d11,%d8
80027eb4:	8b 02 41 32 	lt %d3,%d2,16
80027eb8:	0b 8b a0 32 	or.lt.u %d3,%d11,%d8
80027ebc:	df 03 c0 00 	jeq %d3,0,8002803c <_malloc_r+0x394>
80027ec0:	80 c2       	mov.d %d2,%a12
80027ec2:	91 10 00 27 	movh.a %a2,28673
80027ec6:	0b b2 00 c0 	add %d12,%d2,%d11
80027eca:	19 22 b8 5a 	ld.w %d2,[%a2]-22152 <7000a978 <__malloc_top_pad>>
80027ece:	91 10 00 f7 	movh.a %a15,28673
80027ed2:	19 f4 30 9a 	ld.w %d4,[%a15]-23952 <7000a270 <__malloc_sbrk_base>>
80027ed6:	42 82       	add %d2,%d8
80027ed8:	1b 02 01 a0 	addi %d10,%d2,16
80027edc:	1b f2 08 20 	addi %d2,%d2,143
80027ee0:	8f f2 c7 21 	andn %d2,%d2,127
80027ee4:	8b f4 3f 42 	ne %d4,%d4,-1
80027ee8:	2b a2 40 a4 	sel %d10,%d4,%d2,%d10
80027eec:	02 a4       	mov %d4,%d10
80027eee:	40 e4       	mov.aa %a4,%a14
80027ef0:	6d 00 64 04 	call 800287b8 <_sbrk_r>
80027ef4:	80 29       	mov.d %d9,%a2
80027ef6:	df f9 8a 01 	jeq %d9,-1,8002820a <_malloc_r+0x562>
80027efa:	80 c3       	mov.d %d3,%a12
80027efc:	80 d4       	mov.d %d4,%a13
80027efe:	0b c9 30 21 	lt.u %d2,%d9,%d12
80027f02:	0b 43 10 22 	and.ne %d2,%d3,%d4
80027f06:	df 02 82 81 	jne %d2,0,8002820a <_malloc_r+0x562>
80027f0a:	7b 10 00 d7 	movh %d13,28673
80027f0e:	60 d2       	mov.a %a2,%d13
80027f10:	d9 22 88 5a 	lea %a2,[%a2]-22200
80027f14:	54 22       	ld.w %d2,[%a2]
80027f16:	60 d2       	mov.a %a2,%d13
80027f18:	42 a2       	add %d2,%d10
80027f1a:	59 22 88 5a 	st.w [%a2]-22200,%d2
80027f1e:	5f 9c 64 01 	jeq %d12,%d9,800281e6 <_malloc_r+0x53e>
80027f22:	19 f3 30 9a 	ld.w %d3,[%a15]-23952 <7000a270 <__malloc_sbrk_base>>
80027f26:	df f3 6e 01 	jeq %d3,-1,80028202 <_malloc_r+0x55a>
80027f2a:	0b c9 80 c0 	sub %d12,%d9,%d12
80027f2e:	42 c2       	add %d2,%d12
80027f30:	60 d2       	mov.a %a2,%d13
80027f32:	59 22 88 5a 	st.w [%a2]-22200,%d2
80027f36:	8f 79 00 e1 	and %d14,%d9,7
80027f3a:	df 0e 78 01 	jeq %d14,0,8002822a <_malloc_r+0x582>
80027f3e:	8b 8e 00 21 	rsub %d2,%d14,8
80027f42:	42 29       	add %d9,%d2
80027f44:	42 9a       	add %d10,%d9
80027f46:	8b 8e 08 21 	rsub %d2,%d14,136
80027f4a:	a2 a2       	sub %d2,%d10
80027f4c:	8f f2 07 c1 	and %d12,%d2,127
80027f50:	02 c4       	mov %d4,%d12
80027f52:	40 e4       	mov.aa %a4,%a14
80027f54:	6d 00 32 04 	call 800287b8 <_sbrk_r>
80027f58:	80 22       	mov.d %d2,%a2
80027f5a:	df f2 bd 01 	jeq %d2,-1,800282d4 <_malloc_r+0x62c>
80027f5e:	a2 92       	sub %d2,%d9
80027f60:	0b c2 00 a0 	add %d10,%d2,%d12
80027f64:	60 d2       	mov.a %a2,%d13
80027f66:	8f 1a 40 31 	or %d3,%d10,1
80027f6a:	d9 22 88 5a 	lea %a2,[%a2]-22200
80027f6e:	54 22       	ld.w %d2,[%a2]
80027f70:	60 d2       	mov.a %a2,%d13
80027f72:	42 c2       	add %d2,%d12
80027f74:	59 d9 08 00 	st.w [%a13]8,%d9
80027f78:	59 22 88 5a 	st.w [%a2]-22200,%d2
80027f7c:	60 92       	mov.a %a2,%d9
80027f7e:	59 23 04 00 	st.w [%a2]4,%d3
80027f82:	7d dc 7f 01 	jeq.a %a12,%a13,80028280 <_malloc_r+0x5d8>
80027f86:	8b 0b a1 32 	ge.u %d3,%d11,16
80027f8a:	df 03 7e 01 	jeq %d3,0,80028286 <_malloc_r+0x5de>
80027f8e:	19 c4 04 00 	ld.w %d4,[%a12]4
80027f92:	1b 4b ff 3f 	addi %d3,%d11,-12
80027f96:	8f 73 c0 31 	andn %d3,%d3,7
80027f9a:	8f 14 00 41 	and %d4,%d4,1
80027f9e:	a6 34       	or %d4,%d3
80027fa0:	d9 c2 04 00 	lea %a2,[%a12]4
80027fa4:	74 24       	st.w [%a2],%d4
80027fa6:	82 54       	mov %d4,5
80027fa8:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80027fac:	8b 03 a1 32 	ge.u %d3,%d3,16
80027fb0:	59 24 04 00 	st.w [%a2]4,%d4
80027fb4:	59 24 08 00 	st.w [%a2]8,%d4
80027fb8:	df 03 94 81 	jne %d3,0,800282e0 <_malloc_r+0x638>
80027fbc:	60 92       	mov.a %a2,%d9
80027fbe:	60 9c       	mov.a %a12,%d9
80027fc0:	19 23 04 00 	ld.w %d3,[%a2]4
80027fc4:	91 10 00 27 	movh.a %a2,28673
80027fc8:	19 24 b4 5a 	ld.w %d4,[%a2]-22156 <7000a974 <__malloc_max_sbrked_mem>>
80027fcc:	7f 24 04 80 	jge.u %d4,%d2,80027fd4 <_malloc_r+0x32c>
80027fd0:	59 22 b4 5a 	st.w [%a2]-22156 <7000a974 <__malloc_max_sbrked_mem>>,%d2
80027fd4:	91 10 00 27 	movh.a %a2,28673
80027fd8:	19 24 b0 5a 	ld.w %d4,[%a2]-22160 <7000a970 <__malloc_max_total_mem>>
80027fdc:	7f 24 04 80 	jge.u %d4,%d2,80027fe4 <_malloc_r+0x33c>
80027fe0:	59 22 b0 5a 	st.w [%a2]-22160 <7000a970 <__malloc_max_total_mem>>,%d2
80027fe4:	8f 33 c0 31 	andn %d3,%d3,3
80027fe8:	0b 83 80 20 	sub %d2,%d3,%d8
80027fec:	0b 83 30 41 	lt.u %d4,%d3,%d8
80027ff0:	8b 02 21 45 	or.lt %d4,%d2,16
80027ff4:	df 04 24 00 	jeq %d4,0,8002803c <_malloc_r+0x394>
80027ff8:	40 e4       	mov.aa %a4,%a14
80027ffa:	6d 00 98 01 	call 8002832a <__malloc_unlock>
80027ffe:	a0 0c       	mov.a %a12,0
80028000:	1d ff 3c ff 	j 80027e78 <_malloc_r+0x1d0>
80028004:	8f a8 1f 60 	sh %d6,%d8,-6
80028008:	1b 86 03 50 	addi %d5,%d6,56
8002800c:	1b 96 03 60 	addi %d6,%d6,57
80028010:	8f 36 00 30 	sh %d3,%d6,3
80028014:	bf 52 99 fe 	jlt.u %d2,5,80027d46 <_malloc_r+0x9e>
80028018:	8b 52 a1 32 	ge.u %d3,%d2,21
8002801c:	df 03 bc 00 	jeq %d3,0,80028194 <_malloc_r+0x4ec>
80028020:	8b 52 a5 32 	ge.u %d3,%d2,85
80028024:	df 03 20 81 	jne %d3,0,80028264 <_malloc_r+0x5bc>
80028028:	8f 48 1f 60 	sh %d6,%d8,-12
8002802c:	1b e6 06 50 	addi %d5,%d6,110
80028030:	1b f6 06 60 	addi %d6,%d6,111
80028034:	8f 36 00 30 	sh %d3,%d6,3
80028038:	1d ff 87 fe 	j 80027d46 <_malloc_r+0x9e>
8002803c:	8f 18 40 31 	or %d3,%d8,1
80028040:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
80028044:	8f 12 40 21 	or %d2,%d2,1
80028048:	59 c3 04 00 	st.w [%a12]4,%d3
8002804c:	b5 d2 08 00 	st.a [%a13]8,%a2
80028050:	59 22 04 00 	st.w [%a2]4,%d2
80028054:	40 e4       	mov.aa %a4,%a14
80028056:	6d 00 6a 01 	call 8002832a <__malloc_unlock>
8002805a:	d9 cc 08 00 	lea %a12,[%a12]8
8002805e:	40 c2       	mov.aa %a2,%a12
80028060:	00 90       	ret 
80028062:	99 c2 0c 00 	ld.a %a2,[%a12]12
80028066:	99 c3 08 00 	ld.a %a3,[%a12]8
8002806a:	b7 10 21 20 	imask %e2,1,0,1
8002806e:	40 e4       	mov.aa %a4,%a14
80028070:	b5 32 0c 00 	st.a [%a3]12,%a2
80028074:	b5 23 08 00 	st.a [%a2]8,%a3
80028078:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
8002807c:	d9 cc 08 00 	lea %a12,[%a12]8
80028080:	49 22 44 08 	ldmst [%a2]4,%e2
80028084:	6d 00 53 01 	call 8002832a <__malloc_unlock>
80028088:	1d ff 45 fe 	j 80027d12 <_malloc_r+0x6a>
8002808c:	8f 72 1f 30 	sh %d3,%d2,-9
80028090:	bf 53 78 80 	jlt.u %d3,5,80028180 <_malloc_r+0x4d8>
80028094:	8b 53 a1 42 	ge.u %d4,%d3,21
80028098:	df 04 d8 80 	jne %d4,0,80028248 <_malloc_r+0x5a0>
8002809c:	1b b3 05 50 	addi %d5,%d3,91
800280a0:	1b c3 05 30 	addi %d3,%d3,92
800280a4:	8f 33 00 40 	sh %d4,%d3,3
800280a8:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
800280ac:	40 23       	mov.aa %a3,%a2
800280ae:	d4 33       	ld.a %a3,[%a3]
800280b0:	b0 82       	add.a %a2,-8
800280b2:	7d 32 b2 00 	jeq.a %a2,%a3,80028216 <_malloc_r+0x56e>
800280b6:	19 33 04 00 	ld.w %d3,[%a3]4
800280ba:	8f 33 c0 31 	andn %d3,%d3,3
800280be:	7f 32 07 80 	jge.u %d2,%d3,800280cc <_malloc_r+0x424>
800280c2:	d9 33 08 00 	lea %a3,[%a3]8
800280c6:	d4 33       	ld.a %a3,[%a3]
800280c8:	7d 32 f7 ff 	jne.a %a2,%a3,800280b6 <_malloc_r+0x40e>
800280cc:	99 32 0c 00 	ld.a %a2,[%a3]12
800280d0:	19 d3 04 00 	ld.w %d3,[%a13]4
800280d4:	b5 c2 0c 00 	st.a [%a12]12,%a2
800280d8:	b5 c3 08 00 	st.a [%a12]8,%a3
800280dc:	b5 2c 08 00 	st.a [%a2]8,%a12
800280e0:	b5 3c 0c 00 	st.a [%a3]12,%a12
800280e4:	1d ff 85 fe 	j 80027dee <_malloc_r+0x146>
800280e8:	c2 17       	add %d7,1
800280ea:	8f 37 00 31 	and %d3,%d7,3
800280ee:	d9 22 08 00 	lea %a2,[%a2]8
800280f2:	df 03 97 fe 	jne %d3,0,80027e20 <_malloc_r+0x178>
800280f6:	1d 00 5d 00 	j 800281b0 <_malloc_r+0x508>
800280fa:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
800280fe:	8f 18 40 81 	or %d8,%d8,1
80028102:	99 c5 08 00 	ld.a %a5,[%a12]8
80028106:	8f 13 40 21 	or %d2,%d3,1
8002810a:	74 68       	st.w [%a6],%d8
8002810c:	b5 53 0c 00 	st.a [%a5]12,%a3
80028110:	b5 35 08 00 	st.a [%a3]8,%a5
80028114:	b5 d2 14 00 	st.a [%a13]20,%a2
80028118:	b5 d2 10 00 	st.a [%a13]16,%a2
8002811c:	b5 24 0c 00 	st.a [%a2]12,%a4
80028120:	b5 24 08 00 	st.a [%a2]8,%a4
80028124:	59 22 04 00 	st.w [%a2]4,%d2
80028128:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
8002812c:	40 e4       	mov.aa %a4,%a14
8002812e:	74 23       	st.w [%a2],%d3
80028130:	6d 00 fd 00 	call 8002832a <__malloc_unlock>
80028134:	d9 cc 08 00 	lea %a12,[%a12]8
80028138:	1d ff a0 fe 	j 80027e78 <_malloc_r+0x1d0>
8002813c:	8f d8 1f 60 	sh %d6,%d8,-3
80028140:	1b 88 00 30 	addi %d3,%d8,8
80028144:	1d ff c4 fd 	j 80027ccc <_malloc_r+0x24>
80028148:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8002814c:	8f 18 40 81 	or %d8,%d8,1
80028150:	8f 13 40 41 	or %d4,%d3,1
80028154:	59 c8 04 00 	st.w [%a12]4,%d8
80028158:	b5 d2 14 00 	st.a [%a13]20,%a2
8002815c:	b5 d2 10 00 	st.a [%a13]16,%a2
80028160:	b5 24 0c 00 	st.a [%a2]12,%a4
80028164:	b5 24 08 00 	st.a [%a2]8,%a4
80028168:	59 24 04 00 	st.w [%a2]4,%d4
8002816c:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80028170:	40 e4       	mov.aa %a4,%a14
80028172:	74 23       	st.w [%a2],%d3
80028174:	6d 00 db 00 	call 8002832a <__malloc_unlock>
80028178:	d9 cc 08 00 	lea %a12,[%a12]8
8002817c:	1d ff 7e fe 	j 80027e78 <_malloc_r+0x1d0>
80028180:	8f a2 1f 30 	sh %d3,%d2,-6
80028184:	1b 83 03 50 	addi %d5,%d3,56
80028188:	1b 93 03 30 	addi %d3,%d3,57
8002818c:	8f 33 00 40 	sh %d4,%d3,3
80028190:	1d ff 8c ff 	j 800280a8 <_malloc_r+0x400>
80028194:	1b c2 05 60 	addi %d6,%d2,92
80028198:	1b b2 05 50 	addi %d5,%d2,91
8002819c:	8f 36 00 30 	sh %d3,%d6,3
800281a0:	1d ff d3 fd 	j 80027d46 <_malloc_r+0x9e>
800281a4:	40 52       	mov.aa %a2,%a5
800281a6:	d4 22       	ld.a %a2,[%a2]
800281a8:	b0 85       	add.a %a5,-8
800281aa:	c2 f6       	add %d6,-1
800281ac:	7d 52 ba 80 	jne.a %a2,%a5,80028320 <_malloc_r+0x678>
800281b0:	8f 36 00 31 	and %d3,%d6,3
800281b4:	df 03 f8 ff 	jne %d3,0,800281a4 <_malloc_r+0x4fc>
800281b8:	19 d3 04 00 	ld.w %d3,[%a13]4
800281bc:	d9 d2 04 00 	lea %a2,[%a13]4
800281c0:	0f 23 e0 30 	andn %d3,%d3,%d2
800281c4:	74 23       	st.w [%a2],%d3
800281c6:	06 12       	sh %d2,1
800281c8:	1b f2 ff 4f 	addi %d4,%d2,-1
800281cc:	3f 34 06 80 	jlt.u %d4,%d3,800281d8 <_malloc_r+0x530>
800281d0:	1d ff 6a fe 	j 80027ea4 <_malloc_r+0x1fc>
800281d4:	c2 47       	add %d7,4
800281d6:	06 12       	sh %d2,1
800281d8:	0f 32 80 40 	and %d4,%d2,%d3
800281dc:	df 04 fc 7f 	jeq %d4,0,800281d4 <_malloc_r+0x52c>
800281e0:	02 76       	mov %d6,%d7
800281e2:	1d ff 19 fe 	j 80027e14 <_malloc_r+0x16c>
800281e6:	8f fc 07 31 	and %d3,%d12,127
800281ea:	df 03 9c fe 	jne %d3,0,80027f22 <_malloc_r+0x27a>
800281ee:	0b ab 00 30 	add %d3,%d11,%d10
800281f2:	99 dc 08 00 	ld.a %a12,[%a13]8
800281f6:	8f 13 40 31 	or %d3,%d3,1
800281fa:	59 c3 04 00 	st.w [%a12]4,%d3
800281fe:	1d ff e3 fe 	j 80027fc4 <_malloc_r+0x31c>
80028202:	59 f9 30 9a 	st.w [%a15]-23952,%d9
80028206:	1d ff 98 fe 	j 80027f36 <_malloc_r+0x28e>
8002820a:	99 dc 08 00 	ld.a %a12,[%a13]8
8002820e:	19 c3 04 00 	ld.w %d3,[%a12]4
80028212:	1d ff e9 fe 	j 80027fe4 <_malloc_r+0x33c>
80028216:	19 d3 04 00 	ld.w %d3,[%a13]4
8002821a:	86 e5       	sha %d5,-2
8002821c:	d7 13 01 35 	insert %d3,%d3,1,%d5,1
80028220:	d9 d5 04 00 	lea %a5,[%a13]4
80028224:	74 53       	st.w [%a5],%d3
80028226:	1d ff 57 ff 	j 800280d4 <_malloc_r+0x42c>
8002822a:	0b a9 00 20 	add %d2,%d9,%d10
8002822e:	32 52       	rsub %d2
80028230:	8f f2 07 c1 	and %d12,%d2,127
80028234:	02 c4       	mov %d4,%d12
80028236:	40 e4       	mov.aa %a4,%a14
80028238:	6d 00 c0 02 	call 800287b8 <_sbrk_r>
8002823c:	80 22       	mov.d %d2,%a2
8002823e:	df f2 90 fe 	jne %d2,-1,80027f5e <_malloc_r+0x2b6>
80028242:	82 0c       	mov %d12,0
80028244:	1d ff 90 fe 	j 80027f64 <_malloc_r+0x2bc>
80028248:	8b 53 a5 42 	ge.u %d4,%d3,85
8002824c:	df 04 22 80 	jne %d4,0,80028290 <_malloc_r+0x5e8>
80028250:	8f 42 1f 30 	sh %d3,%d2,-12
80028254:	1b e3 06 50 	addi %d5,%d3,110
80028258:	1b f3 06 30 	addi %d3,%d3,111
8002825c:	8f 33 00 40 	sh %d4,%d3,3
80028260:	1d ff 24 ff 	j 800280a8 <_malloc_r+0x400>
80028264:	8b 52 b5 32 	ge.u %d3,%d2,341
80028268:	df 03 22 80 	jne %d3,0,800282ac <_malloc_r+0x604>
8002826c:	8f 18 1f 60 	sh %d6,%d8,-15
80028270:	1b 76 07 50 	addi %d5,%d6,119
80028274:	1b 86 07 60 	addi %d6,%d6,120
80028278:	8f 36 00 30 	sh %d3,%d6,3
8002827c:	1d ff 65 fd 	j 80027d46 <_malloc_r+0x9e>
80028280:	60 9c       	mov.a %a12,%d9
80028282:	1d ff a1 fe 	j 80027fc4 <_malloc_r+0x31c>
80028286:	82 12       	mov %d2,1
80028288:	59 22 04 00 	st.w [%a2]4,%d2
8002828c:	1d ff b6 fe 	j 80027ff8 <_malloc_r+0x350>
80028290:	8b 53 b5 42 	ge.u %d4,%d3,341
80028294:	df 04 34 80 	jne %d4,0,800282fc <_malloc_r+0x654>
80028298:	8f 12 1f 30 	sh %d3,%d2,-15
8002829c:	1b 73 07 50 	addi %d5,%d3,119
800282a0:	1b 83 07 30 	addi %d3,%d3,120
800282a4:	8f 33 00 40 	sh %d4,%d3,3
800282a8:	1d ff 00 ff 	j 800280a8 <_malloc_r+0x400>
800282ac:	3b 50 55 40 	mov %d4,1365
800282b0:	3b 80 3f 30 	mov %d3,1016
800282b4:	3b f0 07 60 	mov %d6,127
800282b8:	3b e0 07 50 	mov %d5,126
800282bc:	7f 42 45 fd 	jge.u %d2,%d4,80027d46 <_malloc_r+0x9e>
800282c0:	8f e8 1e 60 	sh %d6,%d8,-18
800282c4:	1b c6 07 50 	addi %d5,%d6,124
800282c8:	1b d6 07 60 	addi %d6,%d6,125
800282cc:	8f 36 00 30 	sh %d3,%d6,3
800282d0:	1d ff 3b fd 	j 80027d46 <_malloc_r+0x9e>
800282d4:	c2 8e       	add %d14,-8
800282d6:	42 ea       	add %d10,%d14
800282d8:	a2 9a       	sub %d10,%d9
800282da:	82 0c       	mov %d12,0
800282dc:	1d ff 44 fe 	j 80027f64 <_malloc_r+0x2bc>
800282e0:	d9 c5 08 00 	lea %a5,[%a12]8
800282e4:	40 e4       	mov.aa %a4,%a14
800282e6:	6d 00 f8 02 	call 800288d6 <_free_r>
800282ea:	99 dc 08 00 	ld.a %a12,[%a13]8
800282ee:	60 d2       	mov.a %a2,%d13
800282f0:	19 c3 04 00 	ld.w %d3,[%a12]4
800282f4:	19 22 88 5a 	ld.w %d2,[%a2]-22200
800282f8:	1d ff 66 fe 	j 80027fc4 <_malloc_r+0x31c>
800282fc:	3b 50 55 70 	mov %d7,1365
80028300:	3b 80 3f 40 	mov %d4,1016
80028304:	3b e0 07 50 	mov %d5,126
80028308:	7f 73 d0 fe 	jge.u %d3,%d7,800280a8 <_malloc_r+0x400>
8002830c:	8f e2 1e 30 	sh %d3,%d2,-18
80028310:	1b c3 07 50 	addi %d5,%d3,124
80028314:	1b d3 07 30 	addi %d3,%d3,125
80028318:	8f 33 00 40 	sh %d4,%d3,3
8002831c:	1d ff c6 fe 	j 800280a8 <_malloc_r+0x400>
80028320:	19 d3 04 00 	ld.w %d3,[%a13]4
80028324:	1d ff 51 ff 	j 800281c6 <_malloc_r+0x51e>

80028328 <__malloc_lock>:
80028328:	00 90       	ret 

8002832a <__malloc_unlock>:
8002832a:	00 90       	ret 

8002832c <stdio_exit_handler>:
8002832c:	91 10 00 67 	movh.a %a6,28673
80028330:	91 30 00 58 	movh.a %a5,32771
80028334:	91 10 00 47 	movh.a %a4,28673
80028338:	d9 66 40 aa 	lea %a6,[%a6]-22912 <7000a680 <__sglue>>
8002833c:	d9 55 d8 8a 	lea %a5,[%a5]-20968 <8002ae18 <_fclose_r>>
80028340:	d9 44 54 aa 	lea %a4,[%a4]-22892 <7000a694 <_impure_data>>
80028344:	6d 00 c9 00 	call 800284d6 <_fwalk_sglue>
80028348:	00 90       	ret 

8002834a <cleanup_stdio>:
8002834a:	99 45 04 00 	ld.a %a5,[%a4]4
8002834e:	91 10 00 27 	movh.a %a2,28673
80028352:	d9 22 80 6a 	lea %a2,[%a2]-22144 <7000a980 <__sf>>
80028356:	40 4c       	mov.aa %a12,%a4
80028358:	7d 25 04 00 	jeq.a %a5,%a2,80028360 <cleanup_stdio+0x16>
8002835c:	6d 00 5e 15 	call 8002ae18 <_fclose_r>
80028360:	99 c5 08 00 	ld.a %a5,[%a12]8
80028364:	91 10 00 27 	movh.a %a2,28673
80028368:	d9 22 a8 7a 	lea %a2,[%a2]-22040 <7000a9e8 <__sf+0x68>>
8002836c:	7d 25 05 00 	jeq.a %a5,%a2,80028376 <cleanup_stdio+0x2c>
80028370:	40 c4       	mov.aa %a4,%a12
80028372:	6d 00 53 15 	call 8002ae18 <_fclose_r>
80028376:	99 c5 0c 00 	ld.a %a5,[%a12]12
8002837a:	91 10 00 27 	movh.a %a2,28673
8002837e:	d9 22 90 9a 	lea %a2,[%a2]-21936 <7000aa50 <__sf+0xd0>>
80028382:	7d 25 05 00 	jeq.a %a5,%a2,8002838c <cleanup_stdio+0x42>
80028386:	40 c4       	mov.aa %a4,%a12
80028388:	6d 00 48 15 	call 8002ae18 <_fclose_r>
8002838c:	00 90       	ret 

8002838e <global_stdio_init.part.0>:
8002838e:	91 30 00 38 	movh.a %a3,32771
80028392:	d9 33 2c c8 	lea %a3,[%a3]-31956 <8002832c <stdio_exit_handler>>
80028396:	91 10 00 27 	movh.a %a2,28673
8002839a:	82 08       	mov %d8,0
8002839c:	b5 23 b8 aa 	st.a [%a2]-21832 <7000aab8 <__stdio_exit_handler>>,%a3
800283a0:	82 42       	mov %d2,4
800283a2:	91 10 00 27 	movh.a %a2,28673
800283a6:	d9 2c 80 6a 	lea %a12,[%a2]-22144 <7000a980 <__sf>>
800283aa:	3b 80 00 50 	mov %d5,8
800283ae:	82 04       	mov %d4,0
800283b0:	d9 c4 1c 10 	lea %a4,[%a12]92
800283b4:	59 c2 0c 00 	st.w [%a12]12,%d2
800283b8:	59 c8 24 10 	st.w [%a12]100,%d8
800283bc:	59 28 80 6a 	st.w [%a2]-22144 <7000a980 <__sf>>,%d8
800283c0:	59 c8 04 00 	st.w [%a12]4 <7000a980 <__sf>>,%d8
800283c4:	59 c8 08 00 	st.w [%a12]8 <7000a980 <__sf>>,%d8
800283c8:	59 c8 10 00 	st.w [%a12]16 <7000a980 <__sf>>,%d8
800283cc:	59 c8 14 00 	st.w [%a12]20 <7000a980 <__sf>>,%d8
800283d0:	59 c8 18 00 	st.w [%a12]24 <7000a980 <__sf>>,%d8
800283d4:	6d ff 2e f7 	call 80027230 <memset>
800283d8:	91 30 00 28 	movh.a %a2,32771
800283dc:	80 22       	mov.d %d2,%a2
800283de:	1b e2 51 98 	addi %d9,%d2,-31458
800283e2:	7b 10 00 20 	movh %d2,1
800283e6:	1b 92 00 20 	addi %d2,%d2,9
800283ea:	91 30 00 f8 	movh.a %a15,32771
800283ee:	91 30 00 e8 	movh.a %a14,32771
800283f2:	91 30 00 d8 	movh.a %a13,32771
800283f6:	d9 ee 48 68 	lea %a14,[%a14]-31352 <80028588 <__sseek>>
800283fa:	d9 ff 4c 58 	lea %a15,[%a15]-31412 <8002854c <__swrite>>
800283fe:	d9 dd 76 68 	lea %a13,[%a13]-31306 <800285b6 <__sclose>>
80028402:	3b 80 00 50 	mov %d5,8
80028406:	82 04       	mov %d4,0
80028408:	d9 c4 04 30 	lea %a4,[%a12]196
8002840c:	59 c2 34 10 	st.w [%a12]116,%d2
80028410:	b5 cc 1c 00 	st.a [%a12]28,%a12
80028414:	59 c9 20 00 	st.w [%a12]32,%d9
80028418:	ec c9       	st.a [%a12]36,%a15
8002841a:	b5 ce 28 00 	st.a [%a12]40,%a14
8002841e:	b5 cd 2c 00 	st.a [%a12]44,%a13
80028422:	59 c8 0c 30 	st.w [%a12]204,%d8
80028426:	59 c8 28 10 	st.w [%a12]104,%d8
8002842a:	59 c8 2c 10 	st.w [%a12]108,%d8
8002842e:	59 c8 30 10 	st.w [%a12]112,%d8
80028432:	59 c8 38 10 	st.w [%a12]120,%d8
80028436:	59 c8 3c 10 	st.w [%a12]124,%d8
8002843a:	59 c8 00 20 	st.w [%a12]128,%d8
8002843e:	6d ff f9 f6 	call 80027230 <memset>
80028442:	7b 20 00 20 	movh %d2,2
80028446:	1b 22 01 20 	addi %d2,%d2,18
8002844a:	d9 c2 28 10 	lea %a2,[%a12]104
8002844e:	3b 80 00 50 	mov %d5,8
80028452:	82 04       	mov %d4,0
80028454:	d9 c4 2c 40 	lea %a4,[%a12]300
80028458:	b5 c2 04 20 	st.a [%a12]132,%a2
8002845c:	59 c9 08 20 	st.w [%a12]136,%d9
80028460:	b5 cf 0c 20 	st.a [%a12]140,%a15
80028464:	b5 ce 10 20 	st.a [%a12]144,%a14
80028468:	b5 cd 14 20 	st.a [%a12]148,%a13
8002846c:	59 c8 34 40 	st.w [%a12]308,%d8
80028470:	59 c8 10 30 	st.w [%a12]208,%d8
80028474:	59 c8 14 30 	st.w [%a12]212,%d8
80028478:	59 c8 18 30 	st.w [%a12]216,%d8
8002847c:	59 c2 1c 30 	st.w [%a12]220,%d2
80028480:	59 c8 20 30 	st.w [%a12]224,%d8
80028484:	59 c8 24 30 	st.w [%a12]228,%d8
80028488:	59 c8 28 30 	st.w [%a12]232,%d8
8002848c:	6d ff d2 f6 	call 80027230 <memset>
80028490:	d9 c2 10 30 	lea %a2,[%a12]208
80028494:	b5 c2 2c 30 	st.a [%a12]236,%a2
80028498:	59 c9 30 30 	st.w [%a12]240,%d9
8002849c:	b5 cf 34 30 	st.a [%a12]244,%a15
800284a0:	b5 ce 38 30 	st.a [%a12]248,%a14
800284a4:	b5 cd 3c 30 	st.a [%a12]252,%a13
800284a8:	00 90       	ret 

800284aa <__sinit>:
800284aa:	19 42 34 00 	ld.w %d2,[%a4]52
800284ae:	df 02 03 00 	jeq %d2,0,800284b4 <__sinit+0xa>
800284b2:	00 90       	ret 
800284b4:	91 30 00 28 	movh.a %a2,32771
800284b8:	d9 22 0a d8 	lea %a2,[%a2]-31926 <8002834a <cleanup_stdio>>
800284bc:	b5 42 34 00 	st.a [%a4]52 <8002834a <cleanup_stdio>>,%a2
800284c0:	91 10 00 27 	movh.a %a2,28673
800284c4:	19 22 b8 aa 	ld.w %d2,[%a2]-21832 <7000aab8 <__stdio_exit_handler>>
800284c8:	df 02 f5 ff 	jne %d2,0,800284b2 <__sinit+0x8>
800284cc:	6d ff 61 ff 	call 8002838e <global_stdio_init.part.0>
800284d0:	00 90       	ret 

800284d2 <__sfp_lock_acquire>:
800284d2:	00 90       	ret 

800284d4 <__sfp_lock_release>:
800284d4:	00 90       	ret 

800284d6 <_fwalk_sglue>:
800284d6:	80 4a       	mov.d %d10,%a4
800284d8:	40 5f       	mov.aa %a15,%a5
800284da:	40 6e       	mov.aa %a14,%a6
800284dc:	82 08       	mov %d8,0
800284de:	82 19       	mov %d9,1
800284e0:	99 e2 04 00 	ld.a %a2,[%a14]4
800284e4:	99 ed 08 00 	ld.a %a13,[%a14]8
800284e8:	d9 2c ff ff 	lea %a12,[%a2]-1
800284ec:	80 c2       	mov.d %d2,%a12
800284ee:	bf 02 13 00 	jlt %d2,0,80028514 <_fwalk_sglue+0x3e>
800284f2:	b9 d2 0c 00 	ld.hu %d2,[%a13]12
800284f6:	7f 29 0b 80 	jge.u %d9,%d2,8002850c <_fwalk_sglue+0x36>
800284fa:	c9 d2 0e 00 	ld.h %d2,[%a13]14
800284fe:	df f2 07 00 	jeq %d2,-1,8002850c <_fwalk_sglue+0x36>
80028502:	60 a4       	mov.a %a4,%d10
80028504:	40 d5       	mov.aa %a5,%a13
80028506:	2d 0f 00 00 	calli %a15
8002850a:	a6 28       	or %d8,%d2
8002850c:	d9 dd 28 10 	lea %a13,[%a13]104
80028510:	fd c0 f1 7f 	loop %a12,800284f2 <_fwalk_sglue+0x1c>
80028514:	d4 ee       	ld.a %a14,[%a14]
80028516:	bd 0e e5 ff 	jnz.a %a14,800284e0 <_fwalk_sglue+0xa>
8002851a:	02 82       	mov %d2,%d8
8002851c:	00 90       	ret 

8002851e <__sread>:
8002851e:	40 5c       	mov.aa %a12,%a5
80028520:	02 45       	mov %d5,%d4
80028522:	c9 c4 0e 00 	ld.h %d4,[%a12]14
80028526:	40 65       	mov.aa %a5,%a6
80028528:	6d 00 36 01 	call 80028794 <_read_r>
8002852c:	bf 02 09 00 	jlt %d2,0,8002853e <__sread+0x20>
80028530:	19 c3 10 10 	ld.w %d3,[%a12]80
80028534:	d9 c2 10 10 	lea %a2,[%a12]80
80028538:	42 23       	add %d3,%d2
8002853a:	74 23       	st.w [%a2],%d3
8002853c:	00 90       	ret 
8002853e:	c9 c3 0c 00 	ld.h %d3,[%a12]12
80028542:	b7 03 01 36 	insert %d3,%d3,0,12,1
80028546:	f9 c3 0c 00 	st.h [%a12]12,%d3
8002854a:	00 90       	ret 

8002854c <__swrite>:
8002854c:	c9 52 0c 00 	ld.h %d2,[%a5]12
80028550:	80 48       	mov.d %d8,%a4
80028552:	40 5c       	mov.aa %a12,%a5
80028554:	80 6a       	mov.d %d10,%a6
80028556:	02 49       	mov %d9,%d4
80028558:	6f 82 0e 80 	jnz.t %d2,8,80028574 <__swrite+0x28>
8002855c:	b7 02 01 26 	insert %d2,%d2,0,12,1
80028560:	60 a5       	mov.a %a5,%d10
80028562:	c9 c4 0e 00 	ld.h %d4,[%a12]14
80028566:	60 84       	mov.a %a4,%d8
80028568:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002856c:	02 95       	mov %d5,%d9
8002856e:	6d 00 39 01 	call 800287e0 <_write_r>
80028572:	00 90       	ret 
80028574:	c9 54 0e 00 	ld.h %d4,[%a5]14
80028578:	82 26       	mov %d6,2
8002857a:	82 05       	mov %d5,0
8002857c:	6d 00 fb 00 	call 80028772 <_lseek_r>
80028580:	c9 c2 0c 00 	ld.h %d2,[%a12]12
80028584:	1d ff ec ff 	j 8002855c <__swrite+0x10>

80028588 <__sseek>:
80028588:	02 56       	mov %d6,%d5
8002858a:	02 45       	mov %d5,%d4
8002858c:	c9 54 0e 00 	ld.h %d4,[%a5]14
80028590:	40 5c       	mov.aa %a12,%a5
80028592:	6d 00 f0 00 	call 80028772 <_lseek_r>
80028596:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002859a:	df f2 09 00 	jeq %d2,-1,800285ac <__sseek+0x24>
8002859e:	b7 f3 01 36 	insert %d3,%d3,15,12,1
800285a2:	59 c2 10 10 	st.w [%a12]80,%d2
800285a6:	f9 c3 0c 00 	st.h [%a12]12,%d3
800285aa:	00 90       	ret 
800285ac:	b7 03 01 36 	insert %d3,%d3,0,12,1
800285b0:	f9 c3 0c 00 	st.h [%a12]12,%d3
800285b4:	00 90       	ret 

800285b6 <__sclose>:
800285b6:	c9 54 0e 00 	ld.h %d4,[%a5]14
800285ba:	6d 00 cb 00 	call 80028750 <_close_r>
800285be:	00 90       	ret 

800285c0 <vsnprintf>:
800285c0:	91 10 00 c7 	movh.a %a12,28673
800285c4:	99 cc 50 aa 	ld.a %a12,[%a12]-22896 <7000a690 <_impure_ptr>>
800285c8:	20 68       	sub.a %sp,104
800285ca:	40 67       	mov.aa %a7,%a6
800285cc:	bf 04 34 00 	jlt %d4,0,80028634 <vsnprintf+0x74>
800285d0:	3b 80 20 50 	mov %d5,520
800285d4:	f4 a4       	st.a [%sp],%a4
800285d6:	b5 a4 10 00 	st.a [%sp]16,%a4
800285da:	f9 a5 0c 00 	st.h [%sp]12,%d5
800285de:	df 04 18 00 	jeq %d4,0,8002860e <vsnprintf+0x4e>
800285e2:	c2 f4       	add %d4,-1
800285e4:	82 f3       	mov %d3,-1
800285e6:	40 56       	mov.aa %a6,%a5
800285e8:	40 c4       	mov.aa %a4,%a12
800285ea:	40 a5       	mov.aa %a5,%sp
800285ec:	59 a4 08 00 	st.w [%sp]8,%d4
800285f0:	59 a4 14 00 	st.w [%sp]20,%d4
800285f4:	f9 a3 0e 00 	st.h [%sp]14,%d3
800285f8:	6d 00 b6 02 	call 80028b64 <_svfprintf_r>
800285fc:	ff f2 05 00 	jge %d2,-1,80028606 <vsnprintf+0x46>
80028600:	3b b0 08 30 	mov %d3,139
80028604:	74 c3       	st.w [%a12],%d3
80028606:	d4 a2       	ld.a %a2,[%sp]
80028608:	82 03       	mov %d3,0
8002860a:	34 23       	st.b [%a2],%d3
8002860c:	00 90       	ret 
8002860e:	82 f3       	mov %d3,-1
80028610:	40 56       	mov.aa %a6,%a5
80028612:	40 c4       	mov.aa %a4,%a12
80028614:	40 a5       	mov.aa %a5,%sp
80028616:	59 a4 08 00 	st.w [%sp]8,%d4
8002861a:	59 a4 14 00 	st.w [%sp]20,%d4
8002861e:	f9 a3 0e 00 	st.h [%sp]14,%d3
80028622:	6d 00 a1 02 	call 80028b64 <_svfprintf_r>
80028626:	bf f2 03 00 	jlt %d2,-1,8002862c <vsnprintf+0x6c>
8002862a:	00 90       	ret 
8002862c:	3b b0 08 30 	mov %d3,139
80028630:	74 c3       	st.w [%a12],%d3
80028632:	00 90       	ret 
80028634:	3b b0 08 20 	mov %d2,139
80028638:	74 c2       	st.w [%a12],%d2
8002863a:	82 f2       	mov %d2,-1
8002863c:	00 90       	ret 

8002863e <strlen>:
8002863e:	80 42       	mov.d %d2,%a4
80028640:	8f 32 00 41 	and %d4,%d2,3
80028644:	80 43       	mov.d %d3,%a4
80028646:	df 04 09 80 	jne %d4,0,80028658 <strlen+0x1a>
8002864a:	1d 00 11 00 	j 8002866c <strlen+0x2e>
8002864e:	8f 33 00 41 	and %d4,%d3,3
80028652:	60 32       	mov.a %a2,%d3
80028654:	df 04 0d 00 	jeq %d4,0,8002866e <strlen+0x30>
80028658:	60 32       	mov.a %a2,%d3
8002865a:	c2 13       	add %d3,1
8002865c:	79 24 00 00 	ld.b %d4,[%a2]0
80028660:	df 04 f7 ff 	jne %d4,0,8002864e <strlen+0x10>
80028664:	80 23       	mov.d %d3,%a2
80028666:	a2 23       	sub %d3,%d2
80028668:	02 32       	mov %d2,%d3
8002866a:	00 90       	ret 
8002866c:	40 42       	mov.aa %a2,%a4
8002866e:	54 24       	ld.w %d4,[%a2]
80028670:	7b f0 ef 6f 	movh %d6,65279
80028674:	1b f6 ef 6f 	addi %d6,%d6,-257
80028678:	0b 64 00 30 	add %d3,%d4,%d6
8002867c:	7b 10 08 58 	movh %d5,32897
80028680:	0f 43 e0 30 	andn %d3,%d3,%d4
80028684:	1b 05 08 58 	addi %d5,%d5,-32640
80028688:	26 53       	and %d3,%d5
8002868a:	df 03 0e 80 	jne %d3,0,800286a6 <strlen+0x68>
8002868e:	d9 23 04 00 	lea %a3,[%a2]4
80028692:	40 32       	mov.aa %a2,%a3
80028694:	54 23       	ld.w %d3,[%a2]
80028696:	b0 43       	add.a %a3,4
80028698:	0b 63 00 40 	add %d4,%d3,%d6
8002869c:	0f 34 e0 30 	andn %d3,%d4,%d3
800286a0:	26 53       	and %d3,%d5
800286a2:	df 03 f8 7f 	jeq %d3,0,80028692 <strlen+0x54>
800286a6:	79 23 00 00 	ld.b %d3,[%a2]0
800286aa:	df 03 dd 7f 	jeq %d3,0,80028664 <strlen+0x26>
800286ae:	d9 23 01 00 	lea %a3,[%a2]1
800286b2:	40 32       	mov.aa %a2,%a3
800286b4:	79 23 00 00 	ld.b %d3,[%a2]0
800286b8:	b0 13       	add.a %a3,1
800286ba:	df 03 fc ff 	jne %d3,0,800286b2 <strlen+0x74>
800286be:	80 23       	mov.d %d3,%a2
800286c0:	a2 23       	sub %d3,%d2
800286c2:	02 32       	mov %d2,%d3
800286c4:	00 90       	ret 

800286c6 <strncpy>:
800286c6:	80 45       	mov.d %d5,%a4
800286c8:	80 52       	mov.d %d2,%a5
800286ca:	0f 25 a0 60 	or %d6,%d5,%d2
800286ce:	8f 36 00 61 	and %d6,%d6,3
800286d2:	8b 44 a0 32 	ge.u %d3,%d4,4
800286d6:	7b f0 ef 0f 	movh %d0,65279
800286da:	7b 10 08 78 	movh %d7,32897
800286de:	8b 06 00 34 	and.eq %d3,%d6,0
800286e2:	40 46       	mov.aa %a6,%a4
800286e4:	40 53       	mov.aa %a3,%a5
800286e6:	1b f0 ef 0f 	addi %d0,%d0,-257
800286ea:	1b 07 08 78 	addi %d7,%d7,-32640
800286ee:	df 03 13 80 	jne %d3,0,80028714 <strncpy+0x4e>
800286f2:	60 25       	mov.a %a5,%d2
800286f4:	df 04 0e 00 	jeq %d4,0,80028710 <strncpy+0x4a>
800286f8:	09 52 01 00 	ld.b %d2,[%a5+]1
800286fc:	40 63       	mov.aa %a3,%a6
800286fe:	24 32       	st.b [%a3+],%d2
80028700:	1b f4 ff 3f 	addi %d3,%d4,-1
80028704:	df 02 1d 00 	jeq %d2,0,8002873e <strncpy+0x78>
80028708:	02 34       	mov %d4,%d3
8002870a:	40 36       	mov.aa %a6,%a3
8002870c:	df 04 f6 ff 	jne %d4,0,800286f8 <strncpy+0x32>
80028710:	60 52       	mov.a %a2,%d5
80028712:	00 90       	ret 
80028714:	40 32       	mov.aa %a2,%a3
80028716:	54 23       	ld.w %d3,[%a2]
80028718:	80 32       	mov.d %d2,%a3
8002871a:	0b 03 00 60 	add %d6,%d3,%d0
8002871e:	0f 36 e0 60 	andn %d6,%d6,%d3
80028722:	26 76       	and %d6,%d7
80028724:	b0 43       	add.a %a3,4
80028726:	df 06 e6 ff 	jne %d6,0,800286f2 <strncpy+0x2c>
8002872a:	40 62       	mov.aa %a2,%a6
8002872c:	c2 c4       	add %d4,-4
8002872e:	74 23       	st.w [%a2],%d3
80028730:	80 32       	mov.d %d2,%a3
80028732:	b0 46       	add.a %a6,4
80028734:	ff 44 f0 ff 	jge.u %d4,4,80028714 <strncpy+0x4e>
80028738:	60 25       	mov.a %a5,%d2
8002873a:	1d ff dd ff 	j 800286f4 <strncpy+0x2e>
8002873e:	01 64 00 66 	addsc.a %a6,%a6,%d4,0
80028742:	df 03 e7 7f 	jeq %d3,0,80028710 <strncpy+0x4a>
80028746:	24 32       	st.b [%a3+],%d2
80028748:	7d 63 ff ff 	jne.a %a3,%a6,80028746 <strncpy+0x80>
8002874c:	60 52       	mov.a %a2,%d5
8002874e:	00 90       	ret 

80028750 <_close_r>:
80028750:	82 02       	mov %d2,0
80028752:	91 10 00 c7 	movh.a %a12,28673
80028756:	40 4d       	mov.aa %a13,%a4
80028758:	59 c2 80 ba 	st.w [%a12]-21824 <7000aac0 <errno>>,%d2
8002875c:	6d 00 5e 32 	call 8002ec18 <close>
80028760:	df f2 03 00 	jeq %d2,-1,80028766 <_close_r+0x16>
80028764:	00 90       	ret 
80028766:	19 c3 80 ba 	ld.w %d3,[%a12]-21824
8002876a:	df 03 fd 7f 	jeq %d3,0,80028764 <_close_r+0x14>
8002876e:	74 d3       	st.w [%a13],%d3
80028770:	00 90       	ret 

80028772 <_lseek_r>:
80028772:	82 02       	mov %d2,0
80028774:	91 10 00 c7 	movh.a %a12,28673
80028778:	40 4d       	mov.aa %a13,%a4
8002877a:	59 c2 80 ba 	st.w [%a12]-21824 <7000aac0 <errno>>,%d2
8002877e:	6d 00 51 32 	call 8002ec20 <lseek>
80028782:	df f2 03 00 	jeq %d2,-1,80028788 <_lseek_r+0x16>
80028786:	00 90       	ret 
80028788:	19 c3 80 ba 	ld.w %d3,[%a12]-21824
8002878c:	df 03 fd 7f 	jeq %d3,0,80028786 <_lseek_r+0x14>
80028790:	74 d3       	st.w [%a13],%d3
80028792:	00 90       	ret 

80028794 <_read_r>:
80028794:	82 02       	mov %d2,0
80028796:	40 4d       	mov.aa %a13,%a4
80028798:	91 10 00 c7 	movh.a %a12,28673
8002879c:	40 54       	mov.aa %a4,%a5
8002879e:	59 c2 80 ba 	st.w [%a12]-21824 <7000aac0 <errno>>,%d2
800287a2:	6d 00 43 32 	call 8002ec28 <read>
800287a6:	df f2 03 00 	jeq %d2,-1,800287ac <_read_r+0x18>
800287aa:	00 90       	ret 
800287ac:	19 c3 80 ba 	ld.w %d3,[%a12]-21824
800287b0:	df 03 fd 7f 	jeq %d3,0,800287aa <_read_r+0x16>
800287b4:	74 d3       	st.w [%a13],%d3
800287b6:	00 90       	ret 

800287b8 <_sbrk_r>:
800287b8:	82 02       	mov %d2,0
800287ba:	91 10 00 c7 	movh.a %a12,28673
800287be:	40 4d       	mov.aa %a13,%a4
800287c0:	59 c2 80 ba 	st.w [%a12]-21824 <7000aac0 <errno>>,%d2
800287c4:	6d 00 58 32 	call 8002ec74 <sbrk>
800287c8:	80 22       	mov.d %d2,%a2
800287ca:	df f2 04 00 	jeq %d2,-1,800287d2 <_sbrk_r+0x1a>
800287ce:	60 22       	mov.a %a2,%d2
800287d0:	00 90       	ret 
800287d2:	19 c3 80 ba 	ld.w %d3,[%a12]-21824
800287d6:	df 03 fc 7f 	jeq %d3,0,800287ce <_sbrk_r+0x16>
800287da:	60 22       	mov.a %a2,%d2
800287dc:	74 d3       	st.w [%a13],%d3
800287de:	00 90       	ret 

800287e0 <_write_r>:
800287e0:	82 02       	mov %d2,0
800287e2:	40 4d       	mov.aa %a13,%a4
800287e4:	91 10 00 c7 	movh.a %a12,28673
800287e8:	40 54       	mov.aa %a4,%a5
800287ea:	59 c2 80 ba 	st.w [%a12]-21824 <7000aac0 <errno>>,%d2
800287ee:	6d 00 29 32 	call 8002ec40 <write>
800287f2:	df f2 03 00 	jeq %d2,-1,800287f8 <_write_r+0x18>
800287f6:	00 90       	ret 
800287f8:	19 c3 80 ba 	ld.w %d3,[%a12]-21824
800287fc:	df 03 fd 7f 	jeq %d3,0,800287f6 <_write_r+0x16>
80028800:	74 d3       	st.w [%a13],%d3
80028802:	00 90       	ret 

80028804 <__errno>:
80028804:	91 10 00 27 	movh.a %a2,28673
80028808:	99 22 50 aa 	ld.a %a2,[%a2]-22896 <7000a690 <_impure_ptr>>
8002880c:	00 90       	ret 

8002880e <_malloc_trim_r>:
8002880e:	91 10 00 c7 	movh.a %a12,28673
80028812:	02 49       	mov %d9,%d4
80028814:	80 48       	mov.d %d8,%a4
80028816:	d9 cc 38 9a 	lea %a12,[%a12]-23944 <7000a278 <__malloc_av_>>
8002881a:	6d ff 87 fd 	call 80028328 <__malloc_lock>
8002881e:	99 c2 08 00 	ld.a %a2,[%a12]8 <70010008 <ram_heap+0x4f74>>
80028822:	8b f9 06 21 	rsub %d2,%d9,111
80028826:	19 2a 04 00 	ld.w %d10,[%a2]4
8002882a:	8f 3a c0 a1 	andn %d10,%d10,3
8002882e:	42 a2       	add %d2,%d10
80028830:	8f f2 c7 21 	andn %d2,%d2,127
80028834:	1b 02 f8 9f 	addi %d9,%d2,-128
80028838:	8b 09 88 22 	ge %d2,%d9,128
8002883c:	df 02 0c 00 	jeq %d2,0,80028854 <_malloc_trim_r+0x46>
80028840:	60 84       	mov.a %a4,%d8
80028842:	82 04       	mov %d4,0
80028844:	6d ff ba ff 	call 800287b8 <_sbrk_r>
80028848:	19 c2 08 00 	ld.w %d2,[%a12]8 <70010008 <ram_heap+0x4f74>>
8002884c:	80 23       	mov.d %d3,%a2
8002884e:	42 a2       	add %d2,%d10
80028850:	5f 23 07 00 	jeq %d3,%d2,8002885e <_malloc_trim_r+0x50>
80028854:	60 84       	mov.a %a4,%d8
80028856:	6d ff 6a fd 	call 8002832a <__malloc_unlock>
8002885a:	82 02       	mov %d2,0
8002885c:	00 90       	ret 
8002885e:	60 84       	mov.a %a4,%d8
80028860:	8b 09 00 41 	rsub %d4,%d9,0
80028864:	6d ff aa ff 	call 800287b8 <_sbrk_r>
80028868:	80 22       	mov.d %d2,%a2
8002886a:	df f2 18 00 	jeq %d2,-1,8002889a <_malloc_trim_r+0x8c>
8002886e:	0b 9a 80 20 	sub %d2,%d10,%d9
80028872:	99 c2 08 00 	ld.a %a2,[%a12]8
80028876:	8f 12 40 21 	or %d2,%d2,1
8002887a:	60 84       	mov.a %a4,%d8
8002887c:	59 22 04 00 	st.w [%a2]4,%d2
80028880:	91 10 00 27 	movh.a %a2,28673
80028884:	d9 23 88 5a 	lea %a3,[%a2]-22200 <7000a948 <__malloc_current_mallinfo>>
80028888:	54 32       	ld.w %d2,[%a3]
8002888a:	0b 92 80 90 	sub %d9,%d2,%d9
8002888e:	59 29 88 5a 	st.w [%a2]-22200 <7000a948 <__malloc_current_mallinfo>>,%d9
80028892:	6d ff 4c fd 	call 8002832a <__malloc_unlock>
80028896:	82 12       	mov %d2,1
80028898:	00 90       	ret 
8002889a:	60 84       	mov.a %a4,%d8
8002889c:	82 04       	mov %d4,0
8002889e:	6d ff 8d ff 	call 800287b8 <_sbrk_r>
800288a2:	80 24       	mov.d %d4,%a2
800288a4:	99 c2 08 00 	ld.a %a2,[%a12]8
800288a8:	80 22       	mov.d %d2,%a2
800288aa:	0b 24 80 30 	sub %d3,%d4,%d2
800288ae:	8b 03 41 22 	lt %d2,%d3,16
800288b2:	df 02 d1 ff 	jne %d2,0,80028854 <_malloc_trim_r+0x46>
800288b6:	91 10 00 37 	movh.a %a3,28673
800288ba:	19 32 30 9a 	ld.w %d2,[%a3]-23952 <7000a270 <__malloc_sbrk_base>>
800288be:	8f 13 40 31 	or %d3,%d3,1
800288c2:	0b 24 80 20 	sub %d2,%d4,%d2
800288c6:	91 10 00 37 	movh.a %a3,28673
800288ca:	59 23 04 00 	st.w [%a2]4,%d3
800288ce:	59 32 88 5a 	st.w [%a3]-22200 <7000a948 <__malloc_current_mallinfo>>,%d2
800288d2:	1d ff c1 ff 	j 80028854 <_malloc_trim_r+0x46>

800288d6 <_free_r>:
800288d6:	80 48       	mov.d %d8,%a4
800288d8:	40 5c       	mov.aa %a12,%a5
800288da:	bd 05 5c 00 	jz.a %a5,80028992 <_free_r+0xbc>
800288de:	6d ff 25 fd 	call 80028328 <__malloc_lock>
800288e2:	19 c3 fc ff 	ld.w %d3,[%a12]-4
800288e6:	d9 c3 f8 ff 	lea %a3,[%a12]-8
800288ea:	8f 13 c0 21 	andn %d2,%d3,1
800288ee:	91 10 00 67 	movh.a %a6,28673
800288f2:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
800288f6:	d9 66 38 9a 	lea %a6,[%a6]-23944 <7000a278 <__malloc_av_>>
800288fa:	99 64 08 00 	ld.a %a4,[%a6]8 <70010008 <ram_heap+0x4f74>>
800288fe:	19 24 04 00 	ld.w %d4,[%a2]4 <70010008 <ram_heap+0x4f74>>
80028902:	8f 34 c0 41 	andn %d4,%d4,3
80028906:	7d 24 ae 00 	jeq.a %a4,%a2,80028a62 <_free_r+0x18c>
8002890a:	59 24 04 00 	st.w [%a2]4,%d4
8002890e:	01 24 00 56 	addsc.a %a5,%a2,%d4,0
80028912:	6f 03 41 80 	jnz.t %d3,0,80028994 <_free_r+0xbe>
80028916:	19 c3 f8 ff 	ld.w %d3,[%a12]-8
8002891a:	60 34       	mov.a %a4,%d3
8002891c:	42 32       	add %d2,%d3
8002891e:	01 43 20 30 	sub.a %a3,%a3,%a4
80028922:	99 34 08 00 	ld.a %a4,[%a3]8
80028926:	19 53 04 00 	ld.w %d3,[%a5]4
8002892a:	d9 65 08 00 	lea %a5,[%a6]8 <70010008 <ram_heap+0x4f74>>
8002892e:	8f 13 00 31 	and %d3,%d3,1
80028932:	7d 54 81 00 	jeq.a %a4,%a5,80028a34 <_free_r+0x15e>
80028936:	99 37 0c 00 	ld.a %a7,[%a3]12
8002893a:	b5 47 0c 00 	st.a [%a4]12,%a7
8002893e:	b5 74 08 00 	st.a [%a7]8,%a4
80028942:	df 03 c7 00 	jeq %d3,0,80028ad0 <_free_r+0x1fa>
80028946:	8f 12 40 31 	or %d3,%d2,1
8002894a:	59 33 04 00 	st.w [%a3]4,%d3
8002894e:	74 22       	st.w [%a2],%d2
80028950:	3b 00 20 30 	mov %d3,512
80028954:	7f 32 44 80 	jge.u %d2,%d3,800289dc <_free_r+0x106>
80028958:	19 64 04 00 	ld.w %d4,[%a6]4 <70010004 <ram_heap+0x4f70>>
8002895c:	8f b2 1f 30 	sh %d3,%d2,-5
80028960:	8f 72 c0 21 	andn %d2,%d2,7
80028964:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
80028968:	1b 82 00 20 	addi %d2,%d2,8
8002896c:	d9 62 04 00 	lea %a2,[%a6]4 <70010004 <ram_heap+0x4f70>>
80028970:	01 62 00 66 	addsc.a %a6,%a6,%d2,0
80028974:	74 23       	st.w [%a2],%d3
80028976:	d4 65       	ld.a %a5,[%a6]
80028978:	40 62       	mov.aa %a2,%a6
8002897a:	b0 82       	add.a %a2,-8
8002897c:	b5 32 0c 00 	st.a [%a3]12,%a2
80028980:	b5 35 08 00 	st.a [%a3]8,%a5
80028984:	f4 63       	st.a [%a6],%a3
80028986:	b5 53 0c 00 	st.a [%a5]12,%a3
8002898a:	60 84       	mov.a %a4,%d8
8002898c:	6d ff cf fc 	call 8002832a <__malloc_unlock>
80028990:	00 90       	ret 
80028992:	00 90       	ret 
80028994:	19 53 04 00 	ld.w %d3,[%a5]4
80028998:	6f 03 19 80 	jnz.t %d3,0,800289ca <_free_r+0xf4>
8002899c:	42 42       	add %d2,%d4
8002899e:	d9 65 08 00 	lea %a5,[%a6]8
800289a2:	99 24 08 00 	ld.a %a4,[%a2]8
800289a6:	01 32 00 76 	addsc.a %a7,%a3,%d2,0
800289aa:	8f 12 40 31 	or %d3,%d2,1
800289ae:	7d 54 9c 00 	jeq.a %a4,%a5,80028ae6 <_free_r+0x210>
800289b2:	d9 22 0c 00 	lea %a2,[%a2]12
800289b6:	d4 22       	ld.a %a2,[%a2]
800289b8:	b5 42 0c 00 	st.a [%a4]12,%a2
800289bc:	b5 24 08 00 	st.a [%a2]8,%a4
800289c0:	59 33 04 00 	st.w [%a3]4,%d3
800289c4:	74 72       	st.w [%a7],%d2
800289c6:	1d ff c5 ff 	j 80028950 <_free_r+0x7a>
800289ca:	8f 12 40 31 	or %d3,%d2,1
800289ce:	59 c3 fc ff 	st.w [%a12]-4,%d3
800289d2:	74 22       	st.w [%a2],%d2
800289d4:	3b 00 20 30 	mov %d3,512
800289d8:	3f 32 c0 ff 	jlt.u %d2,%d3,80028958 <_free_r+0x82>
800289dc:	8f 72 1f 30 	sh %d3,%d2,-9
800289e0:	ff 53 66 80 	jge.u %d3,5,80028aac <_free_r+0x1d6>
800289e4:	8f a2 1f 30 	sh %d3,%d2,-6
800289e8:	1b 83 03 50 	addi %d5,%d3,56
800289ec:	1b 93 03 30 	addi %d3,%d3,57
800289f0:	8f 33 00 40 	sh %d4,%d3,3
800289f4:	01 64 00 56 	addsc.a %a5,%a6,%d4,0
800289f8:	40 52       	mov.aa %a2,%a5
800289fa:	d4 22       	ld.a %a2,[%a2]
800289fc:	b0 85       	add.a %a5,-8
800289fe:	7d 25 81 00 	jeq.a %a5,%a2,80028b00 <_free_r+0x22a>
80028a02:	19 23 04 00 	ld.w %d3,[%a2]4
80028a06:	8f 33 c0 31 	andn %d3,%d3,3
80028a0a:	7f 32 07 80 	jge.u %d2,%d3,80028a18 <_free_r+0x142>
80028a0e:	d9 22 08 00 	lea %a2,[%a2]8
80028a12:	d4 22       	ld.a %a2,[%a2]
80028a14:	7d 25 f7 ff 	jne.a %a5,%a2,80028a02 <_free_r+0x12c>
80028a18:	99 25 0c 00 	ld.a %a5,[%a2]12
80028a1c:	b5 35 0c 00 	st.a [%a3]12,%a5
80028a20:	b5 32 08 00 	st.a [%a3]8,%a2
80028a24:	b5 53 08 00 	st.a [%a5]8,%a3
80028a28:	60 84       	mov.a %a4,%d8
80028a2a:	b5 23 0c 00 	st.a [%a2]12,%a3
80028a2e:	6d ff 7e fc 	call 8002832a <__malloc_unlock>
80028a32:	00 90       	ret 
80028a34:	df 03 91 80 	jne %d3,0,80028b56 <_free_r+0x280>
80028a38:	99 24 0c 00 	ld.a %a4,[%a2]12
80028a3c:	d9 22 08 00 	lea %a2,[%a2]8
80028a40:	d4 22       	ld.a %a2,[%a2]
80028a42:	42 42       	add %d2,%d4
80028a44:	8f 12 40 31 	or %d3,%d2,1
80028a48:	b5 24 0c 00 	st.a [%a2]12,%a4
80028a4c:	b5 42 08 00 	st.a [%a4]8,%a2
80028a50:	59 33 04 00 	st.w [%a3]4,%d3
80028a54:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80028a58:	60 84       	mov.a %a4,%d8
80028a5a:	74 32       	st.w [%a3],%d2
80028a5c:	6d ff 67 fc 	call 8002832a <__malloc_unlock>
80028a60:	00 90       	ret 
80028a62:	42 42       	add %d2,%d4
80028a64:	6f 03 0f 80 	jnz.t %d3,0,80028a82 <_free_r+0x1ac>
80028a68:	54 33       	ld.w %d3,[%a3]
80028a6a:	60 32       	mov.a %a2,%d3
80028a6c:	42 32       	add %d2,%d3
80028a6e:	01 23 20 30 	sub.a %a3,%a3,%a2
80028a72:	99 32 0c 00 	ld.a %a2,[%a3]12
80028a76:	99 34 08 00 	ld.a %a4,[%a3]8
80028a7a:	b5 42 0c 00 	st.a [%a4]12,%a2
80028a7e:	b5 24 08 00 	st.a [%a2]8,%a4
80028a82:	8f 12 40 31 	or %d3,%d2,1
80028a86:	91 10 00 27 	movh.a %a2,28673
80028a8a:	59 33 04 00 	st.w [%a3]4,%d3
80028a8e:	19 23 34 9a 	ld.w %d3,[%a2]-23948 <7000a274 <__malloc_trim_threshold>>
80028a92:	b5 63 08 00 	st.a [%a6]8 <7000a274 <__malloc_trim_threshold>>,%a3
80028a96:	3f 32 7a ff 	jlt.u %d2,%d3,8002898a <_free_r+0xb4>
80028a9a:	91 10 00 27 	movh.a %a2,28673
80028a9e:	19 24 b8 5a 	ld.w %d4,[%a2]-22152 <7000a978 <__malloc_top_pad>>
80028aa2:	60 84       	mov.a %a4,%d8
80028aa4:	6d ff b5 fe 	call 8002880e <_malloc_trim_r>
80028aa8:	1d ff 71 ff 	j 8002898a <_free_r+0xb4>
80028aac:	8b 53 a1 42 	ge.u %d4,%d3,21
80028ab0:	df 04 13 00 	jeq %d4,0,80028ad6 <_free_r+0x200>
80028ab4:	8b 53 a5 42 	ge.u %d4,%d3,85
80028ab8:	df 04 2f 80 	jne %d4,0,80028b16 <_free_r+0x240>
80028abc:	8f 42 1f 30 	sh %d3,%d2,-12
80028ac0:	1b e3 06 50 	addi %d5,%d3,110
80028ac4:	1b f3 06 30 	addi %d3,%d3,111
80028ac8:	8f 33 00 40 	sh %d4,%d3,3
80028acc:	1d ff 94 ff 	j 800289f4 <_free_r+0x11e>
80028ad0:	42 42       	add %d2,%d4
80028ad2:	1d ff 68 ff 	j 800289a2 <_free_r+0xcc>
80028ad6:	1b b3 05 50 	addi %d5,%d3,91
80028ada:	1b c3 05 30 	addi %d3,%d3,92
80028ade:	8f 33 00 40 	sh %d4,%d3,3
80028ae2:	1d ff 89 ff 	j 800289f4 <_free_r+0x11e>
80028ae6:	b5 63 14 00 	st.a [%a6]20,%a3
80028aea:	b5 63 10 00 	st.a [%a6]16,%a3
80028aee:	b5 35 0c 00 	st.a [%a3]12,%a5
80028af2:	b5 35 08 00 	st.a [%a3]8,%a5
80028af6:	59 33 04 00 	st.w [%a3]4,%d3
80028afa:	74 72       	st.w [%a7],%d2
80028afc:	1d ff 47 ff 	j 8002898a <_free_r+0xb4>
80028b00:	19 63 04 00 	ld.w %d3,[%a6]4
80028b04:	8f e5 3f 20 	sha %d2,%d5,-2
80028b08:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
80028b0c:	d9 64 04 00 	lea %a4,[%a6]4
80028b10:	74 42       	st.w [%a4],%d2
80028b12:	1d ff 85 ff 	j 80028a1c <_free_r+0x146>
80028b16:	8b 53 b5 42 	ge.u %d4,%d3,341
80028b1a:	df 04 0c 80 	jne %d4,0,80028b32 <_free_r+0x25c>
80028b1e:	8f 12 1f 30 	sh %d3,%d2,-15
80028b22:	1b 73 07 50 	addi %d5,%d3,119
80028b26:	1b 83 07 30 	addi %d3,%d3,120
80028b2a:	8f 33 00 40 	sh %d4,%d3,3
80028b2e:	1d ff 63 ff 	j 800289f4 <_free_r+0x11e>
80028b32:	3b 50 55 60 	mov %d6,1365
80028b36:	3b 80 3f 40 	mov %d4,1016
80028b3a:	3b e0 07 50 	mov %d5,126
80028b3e:	7f 63 5b ff 	jge.u %d3,%d6,800289f4 <_free_r+0x11e>
80028b42:	8f e2 1e 30 	sh %d3,%d2,-18
80028b46:	1b c3 07 50 	addi %d5,%d3,124
80028b4a:	1b d3 07 30 	addi %d3,%d3,125
80028b4e:	8f 33 00 40 	sh %d4,%d3,3
80028b52:	1d ff 51 ff 	j 800289f4 <_free_r+0x11e>
80028b56:	8f 12 40 31 	or %d3,%d2,1
80028b5a:	59 33 04 00 	st.w [%a3]4,%d3
80028b5e:	74 22       	st.w [%a2],%d2
80028b60:	1d ff 15 ff 	j 8002898a <_free_r+0xb4>

80028b64 <_svfprintf_r>:
80028b64:	d9 aa d0 bf 	lea %sp,[%sp]-304
80028b68:	80 5f       	mov.d %d15,%a5
80028b6a:	40 4f       	mov.aa %a15,%a4
80028b6c:	80 6e       	mov.d %d14,%a6
80028b6e:	b5 a7 20 00 	st.a [%sp]32,%a7
80028b72:	6d 00 e7 12 	call 8002b140 <_localeconv_r>
80028b76:	54 22       	ld.w %d2,[%a2]
80028b78:	59 a2 04 10 	st.w [%sp]68,%d2
80028b7c:	60 24       	mov.a %a4,%d2
80028b7e:	6d ff 60 fd 	call 8002863e <strlen>
80028b82:	60 f2       	mov.a %a2,%d15
80028b84:	59 a2 00 10 	st.w [%sp]64,%d2
80028b88:	c9 23 0c 00 	ld.h %d3,[%a2]12
80028b8c:	6f 73 06 00 	jz.t %d3,7,80028b98 <_svfprintf_r+0x34>
80028b90:	19 22 10 00 	ld.w %d2,[%a2]16
80028b94:	df 02 da 09 	jeq %d2,0,80029f48 <_svfprintf_r+0x13e4>
80028b98:	82 02       	mov %d2,0
80028b9a:	d9 a2 0c 20 	lea %a2,[%sp]140
80028b9e:	60 ed       	mov.a %a13,%d14
80028ba0:	f8 02       	st.a [%sp]8,%a15
80028ba2:	b5 a2 00 20 	st.a [%sp]128,%a2
80028ba6:	59 a2 08 20 	st.w [%sp]136,%d2
80028baa:	59 a2 04 20 	st.w [%sp]132,%d2
80028bae:	59 a2 30 00 	st.w [%sp]48,%d2
80028bb2:	59 a2 38 00 	st.w [%sp]56,%d2
80028bb6:	59 a2 3c 00 	st.w [%sp]60,%d2
80028bba:	59 a2 08 10 	st.w [%sp]72,%d2
80028bbe:	59 a2 0c 10 	st.w [%sp]76,%d2
80028bc2:	59 a2 14 10 	st.w [%sp]84,%d2
80028bc6:	59 a2 18 10 	st.w [%sp]88,%d2
80028bca:	59 a2 10 10 	st.w [%sp]80,%d2
80028bce:	59 a2 10 00 	st.w [%sp]16,%d2
80028bd2:	02 fe       	mov %d14,%d15
80028bd4:	40 2f       	mov.aa %a15,%a2
80028bd6:	79 d3 00 00 	ld.b %d3,[%a13]0
80028bda:	8b 03 20 22 	ne %d2,%d3,0
80028bde:	8b 53 22 24 	and.ne %d2,%d3,37
80028be2:	df 02 f7 00 	jeq %d2,0,80028dd0 <_svfprintf_r+0x26c>
80028be6:	58 02       	ld.w %d15,[%sp]8
80028be8:	d9 d2 01 00 	lea %a2,[%a13]1
80028bec:	79 23 00 00 	ld.b %d3,[%a2]0
80028bf0:	d9 2e ff ff 	lea %a14,[%a2]-1
80028bf4:	8b 53 22 22 	ne %d2,%d3,37
80028bf8:	8b 03 20 24 	and.ne %d2,%d3,0
80028bfc:	40 2c       	mov.aa %a12,%a2
80028bfe:	b0 12       	add.a %a2,1
80028c00:	df 02 f6 ff 	jne %d2,0,80028bec <_svfprintf_r+0x88>
80028c04:	01 dc 20 20 	sub.a %a2,%a12,%a13
80028c08:	78 02       	st.w [%sp]8,%d15
80028c0a:	80 28       	mov.d %d8,%a2
80028c0c:	7d dc 1b 00 	jeq.a %a12,%a13,80028c42 <_svfprintf_r+0xde>
80028c10:	19 a2 08 20 	ld.w %d2,[%sp]136
80028c14:	e8 0d       	st.a [%a15]0,%a13
80028c16:	42 82       	add %d2,%d8
80028c18:	e8 12       	st.a [%a15]4,%a2
80028c1a:	d9 ff 08 00 	lea %a15,[%a15]8
80028c1e:	59 a2 08 20 	st.w [%sp]136,%d2
80028c22:	19 a2 04 20 	ld.w %d2,[%sp]132
80028c26:	c2 12       	add %d2,1
80028c28:	59 a2 04 20 	st.w [%sp]132,%d2
80028c2c:	8b 82 80 22 	ge %d2,%d2,8
80028c30:	df 02 ab 81 	jne %d2,0,80028f86 <_svfprintf_r+0x422>
80028c34:	19 a2 10 00 	ld.w %d2,[%sp]16
80028c38:	79 e3 01 00 	ld.b %d3,[%a14]1
80028c3c:	42 82       	add %d2,%d8
80028c3e:	59 a2 10 00 	st.w [%sp]16,%d2
80028c42:	df 03 86 0a 	jeq %d3,0,8002a14e <_svfprintf_r+0x15ea>
80028c46:	82 f2       	mov %d2,-1
80028c48:	82 0f       	mov %d15,0
80028c4a:	99 ae 08 00 	ld.a %a14,[%sp]8
80028c4e:	59 a2 0c 00 	st.w [%sp]12,%d2
80028c52:	82 02       	mov %d2,0
80028c54:	79 c3 01 00 	ld.b %d3,[%a12]1
80028c58:	d9 cd 01 00 	lea %a13,[%a12]1
80028c5c:	91 30 00 c8 	movh.a %a12,32771
80028c60:	e9 af 25 10 	st.b [%sp]101,%d15
80028c64:	59 a2 18 00 	st.w [%sp]24,%d2
80028c68:	59 a2 04 00 	st.w [%sp]4,%d2
80028c6c:	d9 cc dc 78 	lea %a12,[%a12]-29220 <80028ddc <_svfprintf_r+0x278>>
80028c70:	3b c0 06 90 	mov %d9,108
80028c74:	3b 80 06 80 	mov %d8,104
80028c78:	b0 1d       	add.a %a13,1
80028c7a:	80 ef       	mov.d %d15,%a14
80028c7c:	1b 03 fe 4f 	addi %d4,%d3,-32
80028c80:	8b b4 a5 22 	ge.u %d2,%d4,91
80028c84:	df 02 a9 00 	jeq %d2,0,80028dd6 <_svfprintf_r+0x272>
80028c88:	59 a3 24 00 	st.w [%sp]36,%d3
80028c8c:	78 02       	st.w [%sp]8,%d15
80028c8e:	df 03 60 0a 	jeq %d3,0,8002a14e <_svfprintf_r+0x15ea>
80028c92:	82 0f       	mov %d15,0
80028c94:	e9 a3 0c 30 	st.b [%sp]204,%d3
80028c98:	e9 af 25 10 	st.b [%sp]101,%d15
80028c9c:	d2 02       	mov %e2,0
80028c9e:	82 1d       	mov %d13,1
80028ca0:	d9 ae 0c 30 	lea %a14,[%sp]204
80028ca4:	59 a2 1c 00 	st.w [%sp]28,%d2
80028ca8:	59 ad 14 00 	st.w [%sp]20,%d13
80028cac:	59 a2 0c 00 	st.w [%sp]12,%d2
80028cb0:	59 a2 34 00 	st.w [%sp]52,%d2
80028cb4:	59 a2 2c 00 	st.w [%sp]44,%d2
80028cb8:	59 a2 28 00 	st.w [%sp]40,%d2
80028cbc:	19 a2 04 00 	ld.w %d2,[%sp]4
80028cc0:	19 ab 08 20 	ld.w %d11,[%sp]136
80028cc4:	8f 22 00 51 	and %d5,%d2,2
80028cc8:	8f 42 08 c1 	and %d12,%d2,132
80028ccc:	ab 2d 00 d5 	cadd %d13,%d5,%d13,2
80028cd0:	df 0c 08 80 	jne %d12,0,80028ce0 <_svfprintf_r+0x17c>
80028cd4:	19 a2 18 00 	ld.w %d2,[%sp]24
80028cd8:	0b d2 80 80 	sub %d8,%d2,%d13
80028cdc:	ff 18 c9 01 	jge %d8,1,8002906e <_svfprintf_r+0x50a>
80028ce0:	df 03 15 00 	jeq %d3,0,80028d0a <_svfprintf_r+0x1a6>
80028ce4:	82 13       	mov %d3,1
80028ce6:	19 a2 04 20 	ld.w %d2,[%sp]132
80028cea:	42 3b       	add %d11,%d3
80028cec:	68 13       	st.w [%a15]4,%d3
80028cee:	42 23       	add %d3,%d2
80028cf0:	d9 a3 25 10 	lea %a3,[%sp]101
80028cf4:	e8 03       	st.a [%a15]0,%a3
80028cf6:	59 a3 04 20 	st.w [%sp]132,%d3
80028cfa:	59 ab 08 20 	st.w [%sp]136,%d11
80028cfe:	8b 83 80 32 	ge %d3,%d3,8
80028d02:	d9 ff 08 00 	lea %a15,[%a15]8
80028d06:	df 03 0c 82 	jne %d3,0,8002911e <_svfprintf_r+0x5ba>
80028d0a:	df 05 16 00 	jeq %d5,0,80028d36 <_svfprintf_r+0x1d2>
80028d0e:	82 23       	mov %d3,2
80028d10:	19 a2 04 20 	ld.w %d2,[%sp]132
80028d14:	42 3b       	add %d11,%d3
80028d16:	68 13       	st.w [%a15]4,%d3
80028d18:	1b 12 00 30 	addi %d3,%d2,1
80028d1c:	d9 a3 26 10 	lea %a3,[%sp]102
80028d20:	e8 03       	st.a [%a15]0,%a3
80028d22:	59 a3 04 20 	st.w [%sp]132,%d3
80028d26:	59 ab 08 20 	st.w [%sp]136,%d11
80028d2a:	8b 83 80 32 	ge %d3,%d3,8
80028d2e:	d9 ff 08 00 	lea %a15,[%a15]8
80028d32:	df 03 d0 85 	jne %d3,0,800298d2 <_svfprintf_r+0xd6e>
80028d36:	8b 0c 28 c2 	ne %d12,%d12,128
80028d3a:	df 0c 4f 04 	jeq %d12,0,800295d8 <_svfprintf_r+0xa74>
80028d3e:	19 a8 0c 00 	ld.w %d8,[%sp]12
80028d42:	19 a2 14 00 	ld.w %d2,[%sp]20
80028d46:	a2 28       	sub %d8,%d2
80028d48:	ff 18 ac 04 	jge %d8,1,800296a0 <_svfprintf_r+0xb3c>
80028d4c:	19 a2 04 00 	ld.w %d2,[%sp]4
80028d50:	6f 82 c2 83 	jnz.t %d2,8,800294d4 <_svfprintf_r+0x970>
80028d54:	19 a3 14 00 	ld.w %d3,[%sp]20
80028d58:	19 a2 04 20 	ld.w %d2,[%sp]132
80028d5c:	42 3b       	add %d11,%d3
80028d5e:	c2 12       	add %d2,1
80028d60:	e8 0e       	st.a [%a15]0,%a14
80028d62:	68 13       	st.w [%a15]4,%d3
80028d64:	59 a2 04 20 	st.w [%sp]132,%d2
80028d68:	59 ab 08 20 	st.w [%sp]136,%d11
80028d6c:	8b 82 80 22 	ge %d2,%d2,8
80028d70:	df 02 89 85 	jne %d2,0,80029882 <_svfprintf_r+0xd1e>
80028d74:	d9 ff 08 00 	lea %a15,[%a15]8
80028d78:	19 a2 04 00 	ld.w %d2,[%sp]4
80028d7c:	6f 22 08 00 	jz.t %d2,2,80028d8c <_svfprintf_r+0x228>
80028d80:	19 a2 18 00 	ld.w %d2,[%sp]24
80028d84:	0b d2 80 80 	sub %d8,%d2,%d13
80028d88:	ff 18 ca 05 	jge %d8,1,8002991c <_svfprintf_r+0xdb8>
80028d8c:	19 a2 18 00 	ld.w %d2,[%sp]24
80028d90:	0b d2 a0 d1 	max %d13,%d2,%d13
80028d94:	19 a2 10 00 	ld.w %d2,[%sp]16
80028d98:	42 d2       	add %d2,%d13
80028d9a:	59 a2 10 00 	st.w [%sp]16,%d2
80028d9e:	df 0b 03 85 	jne %d11,0,800297a4 <_svfprintf_r+0xc40>
80028da2:	82 02       	mov %d2,0
80028da4:	59 a2 04 20 	st.w [%sp]132,%d2
80028da8:	19 a2 1c 00 	ld.w %d2,[%sp]28
80028dac:	df 02 08 00 	jeq %d2,0,80028dbc <_svfprintf_r+0x258>
80028db0:	99 a5 1c 00 	ld.a %a5,[%sp]28
80028db4:	99 a4 08 00 	ld.a %a4,[%sp]8
80028db8:	6d ff 8f fd 	call 800288d6 <_free_r>
80028dbc:	79 d3 00 00 	ld.b %d3,[%a13]0
80028dc0:	d9 af 0c 20 	lea %a15,[%sp]140
80028dc4:	8b 03 20 22 	ne %d2,%d3,0
80028dc8:	8b 53 22 24 	and.ne %d2,%d3,37
80028dcc:	df 02 0d ff 	jne %d2,0,80028be6 <_svfprintf_r+0x82>
80028dd0:	40 dc       	mov.aa %a12,%a13
80028dd2:	1d ff 38 ff 	j 80028c42 <_svfprintf_r+0xde>
80028dd6:	01 c4 02 26 	addsc.a %a2,%a12,%d4,2
80028dda:	dc 02       	ji %a2
80028ddc:	1d 00 07 02 	j 800291ea <_svfprintf_r+0x686>
80028de0:	1d ff 54 ff 	j 80028c88 <_svfprintf_r+0x124>
80028de4:	1d ff 52 ff 	j 80028c88 <_svfprintf_r+0x124>
80028de8:	1d 00 38 02 	j 80029258 <_svfprintf_r+0x6f4>
80028dec:	1d ff 4e ff 	j 80028c88 <_svfprintf_r+0x124>
80028df0:	1d ff 4c ff 	j 80028c88 <_svfprintf_r+0x124>
80028df4:	1d ff 4a ff 	j 80028c88 <_svfprintf_r+0x124>
80028df8:	1d 00 05 02 	j 80029202 <_svfprintf_r+0x69e>
80028dfc:	1d ff 46 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e00:	1d ff 44 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e04:	1d 00 59 02 	j 800292b6 <_svfprintf_r+0x752>
80028e08:	1d 00 4f 02 	j 800292a6 <_svfprintf_r+0x742>
80028e0c:	1d ff 3e ff 	j 80028c88 <_svfprintf_r+0x124>
80028e10:	1d 00 23 09 	j 8002a056 <_svfprintf_r+0x14f2>
80028e14:	1d 00 2d 02 	j 8002926e <_svfprintf_r+0x70a>
80028e18:	1d ff 38 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e1c:	1d 00 dc 01 	j 800291d4 <_svfprintf_r+0x670>
80028e20:	1d 00 94 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e24:	1d 00 92 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e28:	1d 00 90 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e2c:	1d 00 8e 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e30:	1d 00 8c 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e34:	1d 00 8a 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e38:	1d 00 88 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e3c:	1d 00 86 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e40:	1d 00 84 00 	j 80028f48 <_svfprintf_r+0x3e4>
80028e44:	1d ff 22 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e48:	1d ff 20 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e4c:	1d ff 1e ff 	j 80028c88 <_svfprintf_r+0x124>
80028e50:	1d ff 1c ff 	j 80028c88 <_svfprintf_r+0x124>
80028e54:	1d ff 1a ff 	j 80028c88 <_svfprintf_r+0x124>
80028e58:	1d ff 18 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e5c:	1d ff 16 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e60:	1d 00 a0 00 	j 80028fa0 <_svfprintf_r+0x43c>
80028e64:	1d ff 12 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e68:	1d 00 a5 01 	j 800291b2 <_svfprintf_r+0x64e>
80028e6c:	1d 00 82 02 	j 80029370 <_svfprintf_r+0x80c>
80028e70:	1d 00 98 00 	j 80028fa0 <_svfprintf_r+0x43c>
80028e74:	1d 00 96 00 	j 80028fa0 <_svfprintf_r+0x43c>
80028e78:	1d 00 94 00 	j 80028fa0 <_svfprintf_r+0x43c>
80028e7c:	1d ff 06 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e80:	1d ff 04 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e84:	1d ff 02 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e88:	1d ff 00 ff 	j 80028c88 <_svfprintf_r+0x124>
80028e8c:	1d 00 e0 02 	j 8002944c <_svfprintf_r+0x8e8>
80028e90:	1d ff fc fe 	j 80028c88 <_svfprintf_r+0x124>
80028e94:	1d ff fa fe 	j 80028c88 <_svfprintf_r+0x124>
80028e98:	1d 00 a0 02 	j 800293d8 <_svfprintf_r+0x874>
80028e9c:	1d ff f6 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ea0:	1d ff f4 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ea4:	1d ff f2 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ea8:	1d 00 4e 01 	j 80029144 <_svfprintf_r+0x5e0>
80028eac:	1d ff ee fe 	j 80028c88 <_svfprintf_r+0x124>
80028eb0:	1d 00 13 02 	j 800292d6 <_svfprintf_r+0x772>
80028eb4:	1d ff ea fe 	j 80028c88 <_svfprintf_r+0x124>
80028eb8:	1d ff e8 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ebc:	1d 00 c2 08 	j 8002a040 <_svfprintf_r+0x14dc>
80028ec0:	1d ff e4 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ec4:	1d ff e2 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ec8:	1d ff e0 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ecc:	1d ff de fe 	j 80028c88 <_svfprintf_r+0x124>
80028ed0:	1d ff dc fe 	j 80028c88 <_svfprintf_r+0x124>
80028ed4:	1d ff da fe 	j 80028c88 <_svfprintf_r+0x124>
80028ed8:	1d ff d8 fe 	j 80028c88 <_svfprintf_r+0x124>
80028edc:	1d ff d6 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ee0:	1d 00 60 00 	j 80028fa0 <_svfprintf_r+0x43c>
80028ee4:	1d ff d2 fe 	j 80028c88 <_svfprintf_r+0x124>
80028ee8:	1d 00 65 01 	j 800291b2 <_svfprintf_r+0x64e>
80028eec:	1d 00 f7 07 	j 80029eda <_svfprintf_r+0x1376>
80028ef0:	1d 00 58 00 	j 80028fa0 <_svfprintf_r+0x43c>
80028ef4:	1d 00 56 00 	j 80028fa0 <_svfprintf_r+0x43c>
80028ef8:	1d 00 54 00 	j 80028fa0 <_svfprintf_r+0x43c>
80028efc:	1d 00 df 02 	j 800294ba <_svfprintf_r+0x956>
80028f00:	1d 00 ed 07 	j 80029eda <_svfprintf_r+0x1376>
80028f04:	1d 00 36 00 	j 80028f70 <_svfprintf_r+0x40c>
80028f08:	1d ff c0 fe 	j 80028c88 <_svfprintf_r+0x124>
80028f0c:	1d 00 ca 02 	j 800294a0 <_svfprintf_r+0x93c>
80028f10:	1d ff bc fe 	j 80028c88 <_svfprintf_r+0x124>
80028f14:	1d 00 a7 02 	j 80029462 <_svfprintf_r+0x8fe>
80028f18:	1d 00 a2 08 	j 8002a05c <_svfprintf_r+0x14f8>
80028f1c:	1d 00 78 02 	j 8002940c <_svfprintf_r+0x8a8>
80028f20:	1d 00 28 00 	j 80028f70 <_svfprintf_r+0x40c>
80028f24:	1d ff b2 fe 	j 80028c88 <_svfprintf_r+0x124>
80028f28:	1d 00 0e 01 	j 80029144 <_svfprintf_r+0x5e0>
80028f2c:	1d 00 1d 00 	j 80028f66 <_svfprintf_r+0x402>
80028f30:	1d 00 81 08 	j 8002a032 <_svfprintf_r+0x14ce>
80028f34:	1d ff aa fe 	j 80028c88 <_svfprintf_r+0x124>
80028f38:	1d ff a8 fe 	j 80028c88 <_svfprintf_r+0x124>
80028f3c:	1d 00 58 08 	j 80029fec <_svfprintf_r+0x1488>
80028f40:	1d ff a4 fe 	j 80028c88 <_svfprintf_r+0x124>
80028f44:	1d 00 11 00 	j 80028f66 <_svfprintf_r+0x402>
80028f48:	82 04       	mov %d4,0
80028f4a:	1b 03 fd 2f 	addi %d2,%d3,-48
80028f4e:	09 d3 01 00 	ld.b %d3,[%a13+]1
80028f52:	13 a4 20 42 	madd %d4,%d2,%d4,10
80028f56:	1b 03 fd 2f 	addi %d2,%d3,-48
80028f5a:	bf a2 fa ff 	jlt.u %d2,10,80028f4e <_svfprintf_r+0x3ea>
80028f5e:	59 a4 18 00 	st.w [%sp]24,%d4
80028f62:	1d ff 8d fe 	j 80028c7c <_svfprintf_r+0x118>
80028f66:	60 fe       	mov.a %a14,%d15
80028f68:	79 d3 00 00 	ld.b %d3,[%a13]0
80028f6c:	1d ff 86 fe 	j 80028c78 <_svfprintf_r+0x114>
80028f70:	19 a2 04 00 	ld.w %d2,[%sp]4
80028f74:	60 fe       	mov.a %a14,%d15
80028f76:	8f 02 42 21 	or %d2,%d2,32
80028f7a:	79 d3 00 00 	ld.b %d3,[%a13]0
80028f7e:	59 a2 04 00 	st.w [%sp]4,%d2
80028f82:	1d ff 7b fe 	j 80028c78 <_svfprintf_r+0x114>
80028f86:	99 a4 08 00 	ld.a %a4,[%sp]8
80028f8a:	60 e5       	mov.a %a5,%d14
80028f8c:	d9 a6 00 20 	lea %a6,[%sp]128
80028f90:	6d 00 cf 20 	call 8002d12e <__ssprint_r>
80028f94:	df 02 d8 8e 	jne %d2,0,8002ad44 <_svfprintf_r+0x21e0>
80028f98:	d9 af 0c 20 	lea %a15,[%sp]140
80028f9c:	1d ff 4c fe 	j 80028c34 <_svfprintf_r+0xd0>
80028fa0:	19 a2 20 00 	ld.w %d2,[%sp]32
80028fa4:	59 a3 24 00 	st.w [%sp]36,%d3
80028fa8:	19 a3 04 00 	ld.w %d3,[%sp]4
80028fac:	78 02       	st.w [%sp]8,%d15
80028fae:	60 22       	mov.a %a2,%d2
80028fb0:	1b 82 00 c0 	addi %d12,%d2,8
80028fb4:	6f 33 8f 07 	jz.t %d3,3,80029ed2 <_svfprintf_r+0x136e>
80028fb8:	54 22       	ld.w %d2,[%a2]
80028fba:	59 a2 38 00 	st.w [%sp]56,%d2
80028fbe:	19 22 04 00 	ld.w %d2,[%a2]4
80028fc2:	59 a2 3c 00 	st.w [%sp]60,%d2
80028fc6:	19 a9 3c 00 	ld.w %d9,[%sp]60
80028fca:	19 aa 38 00 	ld.w %d10,[%sp]56
80028fce:	b7 09 81 8f 	insert %d8,%d9,0,31,1
80028fd2:	7b 00 ff 77 	movh %d7,32752
80028fd6:	82 f6       	mov %d6,-1
80028fd8:	c2 f7       	add %d7,-1
80028fda:	02 a4       	mov %d4,%d10
80028fdc:	02 85       	mov %d5,%d8
80028fde:	6d 00 b4 2f 	call 8002ef46 <__unorddf2>
80028fe2:	df 02 9c 86 	jne %d2,0,80029d1a <_svfprintf_r+0x11b6>
80028fe6:	7b 00 ff 77 	movh %d7,32752
80028fea:	82 f6       	mov %d6,-1
80028fec:	c2 f7       	add %d7,-1
80028fee:	02 a4       	mov %d4,%d10
80028ff0:	02 85       	mov %d5,%d8
80028ff2:	6d 00 8a 2f 	call 8002ef06 <__ledf2>
80028ff6:	bf 12 92 06 	jlt %d2,1,80029d1a <_svfprintf_r+0x11b6>
80028ffa:	d2 06       	mov %e6,0
80028ffc:	02 a4       	mov %d4,%d10
80028ffe:	02 95       	mov %d5,%d9
80029000:	6d 00 63 2f 	call 8002eec6 <__ltdf2>
80029004:	79 a3 25 10 	ld.b %d3,[%sp]101
80029008:	ff 02 07 00 	jge %d2,0,80029016 <_svfprintf_r+0x4b2>
8002900c:	da 2d       	mov %d15,45
8002900e:	3b d0 02 30 	mov %d3,45
80029012:	e9 af 25 10 	st.b [%sp]101,%d15
80029016:	91 00 00 38 	movh.a %a3,32768
8002901a:	80 34       	mov.d %d4,%a3
8002901c:	19 a2 24 00 	ld.w %d2,[%sp]36
80029020:	91 00 00 28 	movh.a %a2,32768
80029024:	1b 54 d1 53 	addi %d5,%d4,15637
80029028:	80 24       	mov.d %d4,%a2
8002902a:	8b 82 44 22 	lt %d2,%d2,72
8002902e:	1b 14 d1 43 	addi %d4,%d4,15633
80029032:	2b 54 40 22 	sel %d2,%d2,%d4,%d5
80029036:	60 2e       	mov.a %a14,%d2
80029038:	19 a2 04 00 	ld.w %d2,[%sp]4
8002903c:	59 ac 20 00 	st.w [%sp]32,%d12
80029040:	8f 02 c8 21 	andn %d2,%d2,128
80029044:	82 3d       	mov %d13,3
80029046:	59 a2 04 00 	st.w [%sp]4,%d2
8002904a:	82 02       	mov %d2,0
8002904c:	59 a2 1c 00 	st.w [%sp]28,%d2
80029050:	59 ad 14 00 	st.w [%sp]20,%d13
80029054:	59 a2 0c 00 	st.w [%sp]12,%d2
80029058:	59 a2 34 00 	st.w [%sp]52,%d2
8002905c:	59 a2 2c 00 	st.w [%sp]44,%d2
80029060:	59 a2 28 00 	st.w [%sp]40,%d2
80029064:	df 03 2c 7e 	jeq %d3,0,80028cbc <_svfprintf_r+0x158>
80029068:	c2 1d       	add %d13,1
8002906a:	1d ff 29 fe 	j 80028cbc <_svfprintf_r+0x158>
8002906e:	8b 18 41 32 	lt %d3,%d8,17
80029072:	19 a4 04 20 	ld.w %d4,[%sp]132
80029076:	df 03 d7 8c 	jne %d3,0,8002aa24 <_svfprintf_r+0x1ec0>
8002907a:	1b f8 fe 3f 	addi %d3,%d8,-17
8002907e:	8f f3 60 31 	nor %d3,%d3,15
80029082:	91 00 00 c8 	movh.a %a12,32768
80029086:	b5 ad 1c 10 	st.a [%sp]92,%a13
8002908a:	58 02       	ld.w %d15,[%sp]8
8002908c:	60 dd       	mov.a %a13,%d13
8002908e:	0b 83 00 90 	add %d9,%d3,%d8
80029092:	d9 cc dc 53 	lea %a12,[%a12]15708 <80003d5c <blanks.1>>
80029096:	3b 00 01 a0 	mov %d10,16
8002909a:	0b 5c 10 c8 	mov %e12,%d12,%d5
8002909e:	1d 00 06 00 	j 800290aa <_svfprintf_r+0x546>
800290a2:	1b 08 ff 8f 	addi %d8,%d8,-16
800290a6:	5f 89 23 00 	jeq %d9,%d8,800290ec <_svfprintf_r+0x588>
800290aa:	c2 14       	add %d4,1
800290ac:	1b 0b 01 b0 	addi %d11,%d11,16
800290b0:	e8 0c       	st.a [%a15]0,%a12
800290b2:	68 1a       	st.w [%a15]4,%d10
800290b4:	59 ab 08 20 	st.w [%sp]136,%d11
800290b8:	59 a4 04 20 	st.w [%sp]132,%d4
800290bc:	8b 84 80 22 	ge %d2,%d4,8
800290c0:	d9 ff 08 00 	lea %a15,[%a15]8
800290c4:	df 02 ef 7f 	jeq %d2,0,800290a2 <_svfprintf_r+0x53e>
800290c8:	60 e5       	mov.a %a5,%d14
800290ca:	60 f4       	mov.a %a4,%d15
800290cc:	d9 a6 00 20 	lea %a6,[%sp]128
800290d0:	6d 00 2f 20 	call 8002d12e <__ssprint_r>
800290d4:	df 02 e6 83 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
800290d8:	1b 08 ff 8f 	addi %d8,%d8,-16
800290dc:	19 ab 08 20 	ld.w %d11,[%sp]136
800290e0:	19 a4 04 20 	ld.w %d4,[%sp]132
800290e4:	d9 af 0c 20 	lea %a15,[%sp]140
800290e8:	5f 89 e1 ff 	jne %d9,%d8,800290aa <_svfprintf_r+0x546>
800290ec:	02 c5       	mov %d5,%d12
800290ee:	02 dc       	mov %d12,%d13
800290f0:	80 dd       	mov.d %d13,%a13
800290f2:	99 ad 1c 10 	ld.a %a13,[%sp]92
800290f6:	78 02       	st.w [%sp]8,%d15
800290f8:	1b 14 00 30 	addi %d3,%d4,1
800290fc:	42 9b       	add %d11,%d9
800290fe:	e8 0c       	st.a [%a15]0,%a12
80029100:	59 a3 04 20 	st.w [%sp]132,%d3
80029104:	68 19       	st.w [%a15]4,%d9
80029106:	59 ab 08 20 	st.w [%sp]136,%d11
8002910a:	8b 83 80 32 	ge %d3,%d3,8
8002910e:	df 03 b0 88 	jne %d3,0,8002a26e <_svfprintf_r+0x170a>
80029112:	79 a3 25 10 	ld.b %d3,[%sp]101
80029116:	d9 ff 08 00 	lea %a15,[%a15]8
8002911a:	1d ff e3 fd 	j 80028ce0 <_svfprintf_r+0x17c>
8002911e:	99 a4 08 00 	ld.a %a4,[%sp]8
80029122:	60 e5       	mov.a %a5,%d14
80029124:	d9 a6 00 20 	lea %a6,[%sp]128
80029128:	59 a5 1c 10 	st.w [%sp]92,%d5
8002912c:	6d 00 01 20 	call 8002d12e <__ssprint_r>
80029130:	df 02 43 83 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
80029134:	19 ab 08 20 	ld.w %d11,[%sp]136
80029138:	19 a5 1c 10 	ld.w %d5,[%sp]92
8002913c:	d9 af 0c 20 	lea %a15,[%sp]140
80029140:	1d ff e5 fd 	j 80028d0a <_svfprintf_r+0x1a6>
80029144:	99 ac 20 00 	ld.a %a12,[%sp]32
80029148:	78 02       	st.w [%sp]8,%d15
8002914a:	82 0f       	mov %d15,0
8002914c:	40 c2       	mov.aa %a2,%a12
8002914e:	d4 2e       	ld.a %a14,[%a2]
80029150:	59 a3 24 00 	st.w [%sp]36,%d3
80029154:	e9 af 25 10 	st.b [%sp]101,%d15
80029158:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002915c:	b0 4c       	add.a %a12,4
8002915e:	bd 0e cc 09 	jz.a %a14,8002a4f6 <_svfprintf_r+0x1992>
80029162:	df f2 04 07 	jeq %d2,-1,80029f6a <_svfprintf_r+0x1406>
80029166:	02 25       	mov %d5,%d2
80029168:	82 04       	mov %d4,0
8002916a:	40 e4       	mov.aa %a4,%a14
8002916c:	6d 00 86 0f 	call 8002b078 <memchr>
80029170:	80 22       	mov.d %d2,%a2
80029172:	b5 a2 1c 00 	st.a [%sp]28,%a2
80029176:	df 02 7d 0c 	jeq %d2,0,8002aa70 <_svfprintf_r+0x1f0c>
8002917a:	99 a2 1c 00 	ld.a %a2,[%sp]28
8002917e:	79 a3 25 10 	ld.b %d3,[%sp]101
80029182:	01 e2 20 20 	sub.a %a2,%a2,%a14
80029186:	b5 a2 14 00 	st.a [%sp]20,%a2
8002918a:	80 22       	mov.d %d2,%a2
8002918c:	8b 02 40 d3 	max %d13,%d2,0
80029190:	82 02       	mov %d2,0
80029192:	b5 ac 20 00 	st.a [%sp]32,%a12
80029196:	59 a2 1c 00 	st.w [%sp]28,%d2
8002919a:	59 a2 0c 00 	st.w [%sp]12,%d2
8002919e:	59 a2 34 00 	st.w [%sp]52,%d2
800291a2:	59 a2 2c 00 	st.w [%sp]44,%d2
800291a6:	59 a2 28 00 	st.w [%sp]40,%d2
800291aa:	df 03 89 7d 	jeq %d3,0,80028cbc <_svfprintf_r+0x158>
800291ae:	1d ff 5d ff 	j 80029068 <_svfprintf_r+0x504>
800291b2:	99 a2 20 00 	ld.a %a2,[%sp]32
800291b6:	78 02       	st.w [%sp]8,%d15
800291b8:	82 0f       	mov %d15,0
800291ba:	40 23       	mov.aa %a3,%a2
800291bc:	54 32       	ld.w %d2,[%a3]
800291be:	b0 42       	add.a %a2,4
800291c0:	59 a3 24 00 	st.w [%sp]36,%d3
800291c4:	e9 a2 0c 30 	st.b [%sp]204,%d2
800291c8:	e9 af 25 10 	st.b [%sp]101,%d15
800291cc:	b5 a2 20 00 	st.a [%sp]32,%a2
800291d0:	1d ff 66 fd 	j 80028c9c <_svfprintf_r+0x138>
800291d4:	19 a2 04 00 	ld.w %d2,[%sp]4
800291d8:	60 fe       	mov.a %a14,%d15
800291da:	8f 02 48 21 	or %d2,%d2,128
800291de:	79 d3 00 00 	ld.b %d3,[%a13]0
800291e2:	59 a2 04 00 	st.w [%sp]4,%d2
800291e6:	1d ff 49 fd 	j 80028c78 <_svfprintf_r+0x114>
800291ea:	79 a2 25 10 	ld.b %d2,[%sp]101
800291ee:	60 fe       	mov.a %a14,%d15
800291f0:	79 d3 00 00 	ld.b %d3,[%a13]0
800291f4:	df 02 42 fd 	jne %d2,0,80028c78 <_svfprintf_r+0x114>
800291f8:	da 20       	mov %d15,32
800291fa:	e9 af 25 10 	st.b [%sp]101,%d15
800291fe:	1d ff 3d fd 	j 80028c78 <_svfprintf_r+0x114>
80029202:	60 fe       	mov.a %a14,%d15
80029204:	60 f4       	mov.a %a4,%d15
80029206:	6d 00 9d 0f 	call 8002b140 <_localeconv_r>
8002920a:	19 22 04 00 	ld.w %d2,[%a2]4
8002920e:	59 a2 10 10 	st.w [%sp]80,%d2
80029212:	60 24       	mov.a %a4,%d2
80029214:	6d ff 15 fa 	call 8002863e <strlen>
80029218:	60 f4       	mov.a %a4,%d15
8002921a:	02 2a       	mov %d10,%d2
8002921c:	59 a2 18 10 	st.w [%sp]88,%d2
80029220:	6d 00 90 0f 	call 8002b140 <_localeconv_r>
80029224:	19 23 08 00 	ld.w %d3,[%a2]8
80029228:	59 a3 14 10 	st.w [%sp]84,%d3
8002922c:	8b 03 20 22 	ne %d2,%d3,0
80029230:	8b 0a 20 24 	and.ne %d2,%d10,0
80029234:	df 02 9a 7e 	jeq %d2,0,80028f68 <_svfprintf_r+0x404>
80029238:	99 a2 14 10 	ld.a %a2,[%sp]84
8002923c:	19 a5 04 00 	ld.w %d5,[%sp]4
80029240:	79 d3 00 00 	ld.b %d3,[%a13]0
80029244:	79 24 00 00 	ld.b %d4,[%a2]0
80029248:	b7 f5 01 25 	insert %d2,%d5,15,10,1
8002924c:	2b 52 40 24 	sel %d2,%d4,%d2,%d5
80029250:	59 a2 04 00 	st.w [%sp]4,%d2
80029254:	1d ff 12 fd 	j 80028c78 <_svfprintf_r+0x114>
80029258:	19 a2 04 00 	ld.w %d2,[%sp]4
8002925c:	60 fe       	mov.a %a14,%d15
8002925e:	8f 12 40 21 	or %d2,%d2,1
80029262:	79 d3 00 00 	ld.b %d3,[%a13]0
80029266:	59 a2 04 00 	st.w [%sp]4,%d2
8002926a:	1d ff 07 fd 	j 80028c78 <_svfprintf_r+0x114>
8002926e:	40 d2       	mov.aa %a2,%a13
80029270:	09 23 01 00 	ld.b %d3,[%a2+]1
80029274:	8b a3 02 22 	eq %d2,%d3,42
80029278:	df 02 96 8d 	jne %d2,0,8002ada4 <_svfprintf_r+0x2240>
8002927c:	82 04       	mov %d4,0
8002927e:	1b 03 fd 2f 	addi %d2,%d3,-48
80029282:	40 2d       	mov.aa %a13,%a2
80029284:	59 a4 0c 00 	st.w [%sp]12,%d4
80029288:	82 04       	mov %d4,0
8002928a:	ff a2 f9 fc 	jge.u %d2,10,80028c7c <_svfprintf_r+0x118>
8002928e:	09 d3 01 00 	ld.b %d3,[%a13+]1
80029292:	13 a4 20 42 	madd %d4,%d2,%d4,10
80029296:	1b 03 fd 2f 	addi %d2,%d3,-48
8002929a:	bf a2 fa ff 	jlt.u %d2,10,8002928e <_svfprintf_r+0x72a>
8002929e:	59 a4 0c 00 	st.w [%sp]12,%d4
800292a2:	1d ff ed fc 	j 80028c7c <_svfprintf_r+0x118>
800292a6:	60 fe       	mov.a %a14,%d15
800292a8:	da 2b       	mov %d15,43
800292aa:	79 d3 00 00 	ld.b %d3,[%a13]0
800292ae:	e9 af 25 10 	st.b [%sp]101,%d15
800292b2:	1d ff e3 fc 	j 80028c78 <_svfprintf_r+0x114>
800292b6:	99 a2 20 00 	ld.a %a2,[%sp]32
800292ba:	60 fe       	mov.a %a14,%d15
800292bc:	40 23       	mov.aa %a3,%a2
800292be:	54 32       	ld.w %d2,[%a3]
800292c0:	59 a2 18 00 	st.w [%sp]24,%d2
800292c4:	b0 42       	add.a %a2,4
800292c6:	bf 02 0f 06 	jlt %d2,0,80029ee4 <_svfprintf_r+0x1380>
800292ca:	79 d3 00 00 	ld.b %d3,[%a13]0
800292ce:	b5 a2 20 00 	st.a [%sp]32,%a2
800292d2:	1d ff d3 fc 	j 80028c78 <_svfprintf_r+0x114>
800292d6:	19 a2 04 00 	ld.w %d2,[%sp]4
800292da:	59 a3 24 00 	st.w [%sp]36,%d3
800292de:	78 02       	st.w [%sp]8,%d15
800292e0:	8f 02 41 11 	or %d1,%d2,16
800292e4:	99 a2 20 00 	ld.a %a2,[%sp]32
800292e8:	6f 51 ba 04 	jz.t %d1,5,80029c5c <_svfprintf_r+0x10f8>
800292ec:	09 2c 48 01 	ld.d %e12,[%a2+]8
800292f0:	82 14       	mov %d4,1
800292f2:	b5 a2 20 00 	st.a [%sp]32,%a2
800292f6:	82 02       	mov %d2,0
800292f8:	19 a3 0c 00 	ld.w %d3,[%sp]12
800292fc:	e9 a2 25 10 	st.b [%sp]101,%d2
80029300:	df f3 2b 02 	jeq %d3,-1,80029756 <_svfprintf_r+0xbf2>
80029304:	8f 01 c8 21 	andn %d2,%d1,128
80029308:	02 35       	mov %d5,%d3
8002930a:	59 a2 04 00 	st.w [%sp]4,%d2
8002930e:	0f dc a0 20 	or %d2,%d12,%d13
80029312:	8b 02 20 32 	ne %d3,%d2,0
80029316:	8b 05 00 35 	or.ne %d3,%d5,0
8002931a:	df 03 1c 82 	jne %d3,0,80029752 <_svfprintf_r+0xbee>
8002931e:	82 02       	mov %d2,0
80029320:	d9 ae 30 40 	lea %a14,[%sp]304
80029324:	59 a2 0c 00 	st.w [%sp]12,%d2
80029328:	59 a2 14 00 	st.w [%sp]20,%d2
8002932c:	df 04 0d 80 	jne %d4,0,80029346 <_svfprintf_r+0x7e2>
80029330:	8f 11 00 21 	and %d2,%d1,1
80029334:	59 a2 14 00 	st.w [%sp]20,%d2
80029338:	6f 01 07 00 	jz.t %d1,0,80029346 <_svfprintf_r+0x7e2>
8002933c:	da 30       	mov %d15,48
8002933e:	d9 ae 2f 40 	lea %a14,[%sp]303
80029342:	e9 af 2f 40 	st.b [%sp]303,%d15
80029346:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002934a:	19 a4 14 00 	ld.w %d4,[%sp]20
8002934e:	79 a3 25 10 	ld.b %d3,[%sp]101
80029352:	0b 42 a0 d1 	max %d13,%d2,%d4
80029356:	82 02       	mov %d2,0
80029358:	59 a2 1c 00 	st.w [%sp]28,%d2
8002935c:	59 a2 34 00 	st.w [%sp]52,%d2
80029360:	59 a2 2c 00 	st.w [%sp]44,%d2
80029364:	59 a2 28 00 	st.w [%sp]40,%d2
80029368:	df 03 aa 7c 	jeq %d3,0,80028cbc <_svfprintf_r+0x158>
8002936c:	1d ff 7e fe 	j 80029068 <_svfprintf_r+0x504>
80029370:	19 a2 04 00 	ld.w %d2,[%sp]4
80029374:	59 a3 24 00 	st.w [%sp]36,%d3
80029378:	8f 02 41 21 	or %d2,%d2,16
8002937c:	78 02       	st.w [%sp]8,%d15
8002937e:	59 a2 04 00 	st.w [%sp]4,%d2
80029382:	19 a2 04 00 	ld.w %d2,[%sp]4
80029386:	99 a2 20 00 	ld.a %a2,[%sp]32
8002938a:	6f 52 49 04 	jz.t %d2,5,80029c1c <_svfprintf_r+0x10b8>
8002938e:	09 22 48 01 	ld.d %e2,[%a2+]8
80029392:	0b 23 10 c8 	mov %e12,%d3,%d2
80029396:	b5 a2 20 00 	st.a [%sp]32,%a2
8002939a:	bf 03 56 04 	jlt %d3,0,80029c46 <_svfprintf_r+0x10e2>
8002939e:	19 a2 0c 00 	ld.w %d2,[%sp]12
800293a2:	df f2 12 03 	jeq %d2,-1,800299c6 <_svfprintf_r+0xe62>
800293a6:	19 a2 04 00 	ld.w %d2,[%sp]4
800293aa:	19 a4 0c 00 	ld.w %d4,[%sp]12
800293ae:	8f 02 c8 21 	andn %d2,%d2,128
800293b2:	8b 04 20 32 	ne %d3,%d4,0
800293b6:	59 a2 04 00 	st.w [%sp]4,%d2
800293ba:	0f dc a0 20 	or %d2,%d12,%d13
800293be:	8b 02 00 35 	or.ne %d3,%d2,0
800293c2:	df 03 02 83 	jne %d3,0,800299c6 <_svfprintf_r+0xe62>
800293c6:	82 02       	mov %d2,0
800293c8:	d9 ae 30 40 	lea %a14,[%sp]304
800293cc:	59 a2 0c 00 	st.w [%sp]12,%d2
800293d0:	59 a2 14 00 	st.w [%sp]20,%d2
800293d4:	1d ff b9 ff 	j 80029346 <_svfprintf_r+0x7e2>
800293d8:	19 a2 04 00 	ld.w %d2,[%sp]4
800293dc:	59 a3 24 00 	st.w [%sp]36,%d3
800293e0:	8f 02 41 21 	or %d2,%d2,16
800293e4:	78 02       	st.w [%sp]8,%d15
800293e6:	59 a2 04 00 	st.w [%sp]4,%d2
800293ea:	19 a2 04 00 	ld.w %d2,[%sp]4
800293ee:	99 a2 20 00 	ld.a %a2,[%sp]32
800293f2:	6f 52 02 04 	jz.t %d2,5,80029bf6 <_svfprintf_r+0x1092>
800293f6:	09 2c 48 01 	ld.d %e12,[%a2+]8
800293fa:	b5 a2 20 00 	st.a [%sp]32,%a2
800293fe:	19 a2 04 00 	ld.w %d2,[%sp]4
80029402:	82 04       	mov %d4,0
80029404:	b7 02 01 15 	insert %d1,%d2,0,10,1
80029408:	1d ff 77 ff 	j 800292f6 <_svfprintf_r+0x792>
8002940c:	99 a2 20 00 	ld.a %a2,[%sp]32
80029410:	78 02       	st.w [%sp]8,%d15
80029412:	da 30       	mov %d15,48
80029414:	40 23       	mov.aa %a3,%a2
80029416:	b0 42       	add.a %a2,4
80029418:	e9 af 26 10 	st.b [%sp]102,%d15
8002941c:	b5 a2 20 00 	st.a [%sp]32,%a2
80029420:	da 78       	mov %d15,120
80029422:	91 00 00 28 	movh.a %a2,32768
80029426:	d9 22 e1 43 	lea %a2,[%a2]15649 <80003d21 <_ctype_b+0x190>>
8002942a:	19 a2 04 00 	ld.w %d2,[%sp]4 <80003d21 <_ctype_b+0x190>>
8002942e:	b5 a2 08 10 	st.a [%sp]72 <80003d21 <_ctype_b+0x190>>,%a2
80029432:	c5 02 38 10 	lea %a2,78 <__TRICORE_DERIVATE_MEMORY_MAP__-0x318>
80029436:	54 3c       	ld.w %d12,[%a3]
80029438:	82 0d       	mov %d13,0
8002943a:	8f 22 40 11 	or %d1,%d2,2
8002943e:	e9 af 27 10 	st.b [%sp]103,%d15
80029442:	82 24       	mov %d4,2
80029444:	b5 a2 24 00 	st.a [%sp]36,%a2
80029448:	1d ff 57 ff 	j 800292f6 <_svfprintf_r+0x792>
8002944c:	19 a2 04 00 	ld.w %d2,[%sp]4
80029450:	60 fe       	mov.a %a14,%d15
80029452:	8f 82 40 21 	or %d2,%d2,8
80029456:	79 d3 00 00 	ld.b %d3,[%a13]0
8002945a:	59 a2 04 00 	st.w [%sp]4,%d2
8002945e:	1d ff 0d fc 	j 80028c78 <_svfprintf_r+0x114>
80029462:	99 a3 20 00 	ld.a %a3,[%sp]32
80029466:	19 a2 04 00 	ld.w %d2,[%sp]4
8002946a:	78 02       	st.w [%sp]8,%d15
8002946c:	d9 32 04 00 	lea %a2,[%a3]4 <80000002 <LCF_STARTPTR_CPU0+0x2>>
80029470:	6f 52 4a 84 	jnz.t %d2,5,80029d04 <_svfprintf_r+0x11a0>
80029474:	19 a2 04 00 	ld.w %d2,[%sp]4
80029478:	6f 42 35 88 	jnz.t %d2,4,8002a4e2 <_svfprintf_r+0x197e>
8002947c:	19 a2 04 00 	ld.w %d2,[%sp]4
80029480:	6f 62 db 89 	jnz.t %d2,6,8002a836 <_svfprintf_r+0x1cd2>
80029484:	19 a2 04 00 	ld.w %d2,[%sp]4
80029488:	6f 92 2d 08 	jz.t %d2,9,8002a4e2 <_svfprintf_r+0x197e>
8002948c:	99 a3 20 00 	ld.a %a3,[%sp]32
80029490:	19 a2 10 00 	ld.w %d2,[%sp]16
80029494:	b5 a2 20 00 	st.a [%sp]32,%a2
80029498:	d4 33       	ld.a %a3,[%a3]
8002949a:	34 32       	st.b [%a3],%d2
8002949c:	1d ff 9d fb 	j 80028bd6 <_svfprintf_r+0x72>
800294a0:	79 d3 00 00 	ld.b %d3,[%a13]0
800294a4:	60 fe       	mov.a %a14,%d15
800294a6:	19 a2 04 00 	ld.w %d2,[%sp]4
800294aa:	5f 93 46 05 	jeq %d3,%d9,80029f36 <_svfprintf_r+0x13d2>
800294ae:	8f 02 41 21 	or %d2,%d2,16
800294b2:	59 a2 04 00 	st.w [%sp]4,%d2
800294b6:	1d ff e1 fb 	j 80028c78 <_svfprintf_r+0x114>
800294ba:	79 d3 00 00 	ld.b %d3,[%a13]0
800294be:	60 fe       	mov.a %a14,%d15
800294c0:	19 a2 04 00 	ld.w %d2,[%sp]4
800294c4:	5f 83 30 05 	jeq %d3,%d8,80029f24 <_svfprintf_r+0x13c0>
800294c8:	8f 02 44 21 	or %d2,%d2,64
800294cc:	59 a2 04 00 	st.w [%sp]4,%d2
800294d0:	1d ff d4 fb 	j 80028c78 <_svfprintf_r+0x114>
800294d4:	19 a2 24 00 	ld.w %d2,[%sp]36
800294d8:	8b 62 46 22 	lt %d2,%d2,102
800294dc:	df 02 71 81 	jne %d2,0,800297be <_svfprintf_r+0xc5a>
800294e0:	99 a3 38 00 	ld.a %a3,[%sp]56
800294e4:	19 a2 3c 00 	ld.w %d2,[%sp]60
800294e8:	d2 06       	mov %e6,0
800294ea:	80 34       	mov.d %d4,%a3
800294ec:	02 25       	mov %d5,%d2
800294ee:	6d 00 8c 2c 	call 8002ee06 <__eqdf2>
800294f2:	df 02 82 82 	jne %d2,0,800299f6 <_svfprintf_r+0xe92>
800294f6:	82 12       	mov %d2,1
800294f8:	42 2b       	add %d11,%d2
800294fa:	91 00 00 38 	movh.a %a3,32768
800294fe:	68 12       	st.w [%a15]4,%d2
80029500:	19 a2 04 20 	ld.w %d2,[%sp]132 <80000001 <LCF_STARTPTR_CPU0+0x1>>
80029504:	d9 33 ca 53 	lea %a3,[%a3]15690 <80003d4a <_ctype_b+0x1b9>>
80029508:	c2 12       	add %d2,1
8002950a:	e8 03       	st.a [%a15]0,%a3
8002950c:	59 ab 08 20 	st.w [%sp]136,%d11
80029510:	59 a2 04 20 	st.w [%sp]132,%d2
80029514:	8b 82 80 22 	ge %d2,%d2,8
80029518:	d9 ff 08 00 	lea %a15,[%a15]8
8002951c:	df 02 1f 87 	jne %d2,0,8002a35a <_svfprintf_r+0x17f6>
80029520:	19 a2 28 10 	ld.w %d2,[%sp]104
80029524:	19 a3 30 00 	ld.w %d3,[%sp]48
80029528:	7f 32 cc 03 	jge %d2,%d3,80029cc0 <_svfprintf_r+0x115c>
8002952c:	19 a2 04 10 	ld.w %d2,[%sp]68
80029530:	19 a3 00 10 	ld.w %d3,[%sp]64
80029534:	68 02       	st.w [%a15]0,%d2
80029536:	19 a2 04 20 	ld.w %d2,[%sp]132 <80000000 <LCF_STARTPTR_CPU0>>
8002953a:	42 3b       	add %d11,%d3
8002953c:	c2 12       	add %d2,1
8002953e:	68 13       	st.w [%a15]4,%d3
80029540:	59 ab 08 20 	st.w [%sp]136,%d11
80029544:	59 a2 04 20 	st.w [%sp]132,%d2
80029548:	8b 82 80 22 	ge %d2,%d2,8
8002954c:	d9 ff 08 00 	lea %a15,[%a15]8
80029550:	df 02 db 84 	jne %d2,0,80029f06 <_svfprintf_r+0x13a2>
80029554:	19 a2 30 00 	ld.w %d2,[%sp]48
80029558:	1b f2 ff 8f 	addi %d8,%d2,-1
8002955c:	bf 18 0e 7c 	jlt %d8,1,80028d78 <_svfprintf_r+0x214>
80029560:	8b 18 41 22 	lt %d2,%d8,17
80029564:	19 a3 04 20 	ld.w %d3,[%sp]132
80029568:	df 02 02 8c 	jne %d2,0,8002ad6c <_svfprintf_r+0x2208>
8002956c:	19 a2 30 00 	ld.w %d2,[%sp]48
80029570:	91 00 00 c8 	movh.a %a12,32768
80029574:	1b e2 fe 9f 	addi %d9,%d2,-18
80029578:	1b f2 fe 5f 	addi %d5,%d2,-17
8002957c:	8f f9 c0 91 	andn %d9,%d9,15
80029580:	58 02       	ld.w %d15,[%sp]8
80029582:	0b 95 80 90 	sub %d9,%d5,%d9
80029586:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
8002958a:	3b 00 01 a0 	mov %d10,16
8002958e:	1d 00 06 00 	j 8002959a <_svfprintf_r+0xa36>
80029592:	1b 08 ff 8f 	addi %d8,%d8,-16
80029596:	5f 98 90 07 	jeq %d8,%d9,8002a4b6 <_svfprintf_r+0x1952>
8002959a:	c2 13       	add %d3,1
8002959c:	1b 0b 01 b0 	addi %d11,%d11,16
800295a0:	e8 0c       	st.a [%a15]0,%a12
800295a2:	68 1a       	st.w [%a15]4,%d10
800295a4:	59 ab 08 20 	st.w [%sp]136,%d11
800295a8:	59 a3 04 20 	st.w [%sp]132,%d3
800295ac:	8b 83 80 22 	ge %d2,%d3,8
800295b0:	d9 ff 08 00 	lea %a15,[%a15]8
800295b4:	df 02 ef 7f 	jeq %d2,0,80029592 <_svfprintf_r+0xa2e>
800295b8:	60 e5       	mov.a %a5,%d14
800295ba:	60 f4       	mov.a %a4,%d15
800295bc:	d9 a6 00 20 	lea %a6,[%sp]128
800295c0:	6d 00 b7 1d 	call 8002d12e <__ssprint_r>
800295c4:	df 02 6e 81 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
800295c8:	19 ab 08 20 	ld.w %d11,[%sp]136
800295cc:	19 a3 04 20 	ld.w %d3,[%sp]132
800295d0:	d9 af 0c 20 	lea %a15,[%sp]140
800295d4:	1d ff df ff 	j 80029592 <_svfprintf_r+0xa2e>
800295d8:	19 a2 18 00 	ld.w %d2,[%sp]24
800295dc:	0b d2 80 80 	sub %d8,%d2,%d13
800295e0:	bf 18 af 7b 	jlt %d8,1,80028d3e <_svfprintf_r+0x1da>
800295e4:	8b 18 41 32 	lt %d3,%d8,17
800295e8:	19 a4 04 20 	ld.w %d4,[%sp]132
800295ec:	df 03 eb 8a 	jne %d3,0,8002abc2 <_svfprintf_r+0x205e>
800295f0:	1b f8 fe 3f 	addi %d3,%d8,-17
800295f4:	8f f3 60 31 	nor %d3,%d3,15
800295f8:	91 00 00 c8 	movh.a %a12,32768
800295fc:	58 02       	ld.w %d15,[%sp]8
800295fe:	0b 83 00 90 	add %d9,%d3,%d8
80029602:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
80029606:	3b 00 01 a0 	mov %d10,16
8002960a:	1d 00 06 00 	j 80029616 <_svfprintf_r+0xab2>
8002960e:	1b 08 ff 8f 	addi %d8,%d8,-16
80029612:	5f 89 23 00 	jeq %d9,%d8,80029658 <_svfprintf_r+0xaf4>
80029616:	c2 14       	add %d4,1
80029618:	1b 0b 01 b0 	addi %d11,%d11,16
8002961c:	e8 0c       	st.a [%a15]0,%a12
8002961e:	68 1a       	st.w [%a15]4,%d10
80029620:	59 ab 08 20 	st.w [%sp]136,%d11
80029624:	59 a4 04 20 	st.w [%sp]132,%d4
80029628:	8b 84 80 22 	ge %d2,%d4,8
8002962c:	d9 ff 08 00 	lea %a15,[%a15]8
80029630:	df 02 ef 7f 	jeq %d2,0,8002960e <_svfprintf_r+0xaaa>
80029634:	60 e5       	mov.a %a5,%d14
80029636:	60 f4       	mov.a %a4,%d15
80029638:	d9 a6 00 20 	lea %a6,[%sp]128
8002963c:	6d 00 79 1d 	call 8002d12e <__ssprint_r>
80029640:	df 02 30 81 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
80029644:	1b 08 ff 8f 	addi %d8,%d8,-16
80029648:	19 ab 08 20 	ld.w %d11,[%sp]136
8002964c:	19 a4 04 20 	ld.w %d4,[%sp]132
80029650:	d9 af 0c 20 	lea %a15,[%sp]140
80029654:	5f 89 e1 ff 	jne %d9,%d8,80029616 <_svfprintf_r+0xab2>
80029658:	78 02       	st.w [%sp]8,%d15
8002965a:	1b 14 00 30 	addi %d3,%d4,1
8002965e:	42 9b       	add %d11,%d9
80029660:	e8 0c       	st.a [%a15]0,%a12
80029662:	68 19       	st.w [%a15]4,%d9
80029664:	59 a3 04 20 	st.w [%sp]132,%d3
80029668:	59 ab 08 20 	st.w [%sp]136,%d11
8002966c:	8b 83 80 32 	ge %d3,%d3,8
80029670:	d9 ff 08 00 	lea %a15,[%a15]8
80029674:	df 03 65 7b 	jeq %d3,0,80028d3e <_svfprintf_r+0x1da>
80029678:	99 a4 08 00 	ld.a %a4,[%sp]8
8002967c:	60 e5       	mov.a %a5,%d14
8002967e:	d9 a6 00 20 	lea %a6,[%sp]128
80029682:	6d 00 56 1d 	call 8002d12e <__ssprint_r>
80029686:	df 02 98 80 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002968a:	19 a8 0c 00 	ld.w %d8,[%sp]12
8002968e:	19 a2 14 00 	ld.w %d2,[%sp]20
80029692:	19 ab 08 20 	ld.w %d11,[%sp]136
80029696:	a2 28       	sub %d8,%d2
80029698:	d9 af 0c 20 	lea %a15,[%sp]140
8002969c:	bf 18 58 7b 	jlt %d8,1,80028d4c <_svfprintf_r+0x1e8>
800296a0:	8b 18 41 32 	lt %d3,%d8,17
800296a4:	19 a4 04 20 	ld.w %d4,[%sp]132
800296a8:	df 03 5a 87 	jne %d3,0,8002a55c <_svfprintf_r+0x19f8>
800296ac:	1b f8 fe 3f 	addi %d3,%d8,-17
800296b0:	8f f3 60 31 	nor %d3,%d3,15
800296b4:	91 00 00 c8 	movh.a %a12,32768
800296b8:	58 02       	ld.w %d15,[%sp]8
800296ba:	0b 83 00 90 	add %d9,%d3,%d8
800296be:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
800296c2:	3b 00 01 a0 	mov %d10,16
800296c6:	1d 00 06 00 	j 800296d2 <_svfprintf_r+0xb6e>
800296ca:	1b 08 ff 8f 	addi %d8,%d8,-16
800296ce:	5f 89 23 00 	jeq %d9,%d8,80029714 <_svfprintf_r+0xbb0>
800296d2:	c2 14       	add %d4,1
800296d4:	1b 0b 01 b0 	addi %d11,%d11,16
800296d8:	e8 0c       	st.a [%a15]0,%a12
800296da:	68 1a       	st.w [%a15]4,%d10
800296dc:	59 ab 08 20 	st.w [%sp]136,%d11
800296e0:	59 a4 04 20 	st.w [%sp]132,%d4
800296e4:	8b 84 80 22 	ge %d2,%d4,8
800296e8:	d9 ff 08 00 	lea %a15,[%a15]8
800296ec:	df 02 ef 7f 	jeq %d2,0,800296ca <_svfprintf_r+0xb66>
800296f0:	60 e5       	mov.a %a5,%d14
800296f2:	60 f4       	mov.a %a4,%d15
800296f4:	d9 a6 00 20 	lea %a6,[%sp]128
800296f8:	6d 00 1b 1d 	call 8002d12e <__ssprint_r>
800296fc:	df 02 d2 80 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
80029700:	1b 08 ff 8f 	addi %d8,%d8,-16
80029704:	19 ab 08 20 	ld.w %d11,[%sp]136
80029708:	19 a4 04 20 	ld.w %d4,[%sp]132
8002970c:	d9 af 0c 20 	lea %a15,[%sp]140
80029710:	5f 89 e1 ff 	jne %d9,%d8,800296d2 <_svfprintf_r+0xb6e>
80029714:	78 02       	st.w [%sp]8,%d15
80029716:	1b 14 00 30 	addi %d3,%d4,1
8002971a:	42 9b       	add %d11,%d9
8002971c:	e8 0c       	st.a [%a15]0,%a12
8002971e:	68 19       	st.w [%a15]4,%d9
80029720:	59 a3 04 20 	st.w [%sp]132,%d3
80029724:	59 ab 08 20 	st.w [%sp]136,%d11
80029728:	8b 83 80 32 	ge %d3,%d3,8
8002972c:	d9 ff 08 00 	lea %a15,[%a15]8
80029730:	df 03 0e 7b 	jeq %d3,0,80028d4c <_svfprintf_r+0x1e8>
80029734:	99 a4 08 00 	ld.a %a4,[%sp]8
80029738:	60 e5       	mov.a %a5,%d14
8002973a:	d9 a6 00 20 	lea %a6,[%sp]128
8002973e:	6d 00 f8 1c 	call 8002d12e <__ssprint_r>
80029742:	df 02 3a 80 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
80029746:	19 ab 08 20 	ld.w %d11,[%sp]136
8002974a:	d9 af 0c 20 	lea %a15,[%sp]140
8002974e:	1d ff ff fa 	j 80028d4c <_svfprintf_r+0x1e8>
80029752:	19 a1 04 00 	ld.w %d1,[%sp]4
80029756:	df 14 3a 01 	jeq %d4,1,800299ca <_svfprintf_r+0xe66>
8002975a:	d9 ae 30 40 	lea %a14,[%sp]304
8002975e:	df 24 c9 00 	jeq %d4,2,800298f0 <_svfprintf_r+0xd8c>
80029762:	58 02       	ld.w %d15,[%sp]8
80029764:	8f 7c 00 31 	and %d3,%d12,7
80029768:	1b 03 03 30 	addi %d3,%d3,48
8002976c:	77 cd 80 ce 	dextr %d12,%d13,%d12,29
80029770:	06 dd       	sh %d13,-3
80029772:	8b 0c 20 22 	ne %d2,%d12,0
80029776:	40 e2       	mov.aa %a2,%a14
80029778:	8b 0d 00 25 	or.ne %d2,%d13,0
8002977c:	89 e3 3f f4 	st.b [+%a14]-1,%d3
80029780:	df 02 f2 ff 	jne %d2,0,80029764 <_svfprintf_r+0xc00>
80029784:	8b 03 23 22 	ne %d2,%d3,48
80029788:	78 02       	st.w [%sp]8,%d15
8002978a:	26 12       	and %d2,%d1
8002978c:	df 02 d8 85 	jne %d2,0,8002a33c <_svfprintf_r+0x17d8>
80029790:	d9 a2 30 40 	lea %a2,[%sp]304
80029794:	01 e2 20 20 	sub.a %a2,%a2,%a14
80029798:	b5 a2 14 00 	st.a [%sp]20,%a2
8002979c:	59 a1 04 00 	st.w [%sp]4,%d1
800297a0:	1d ff d3 fd 	j 80029346 <_svfprintf_r+0x7e2>
800297a4:	99 a4 08 00 	ld.a %a4,[%sp]8
800297a8:	60 e5       	mov.a %a5,%d14
800297aa:	d9 a6 00 20 	lea %a6,[%sp]128
800297ae:	6d 00 c0 1c 	call 8002d12e <__ssprint_r>
800297b2:	df 02 f8 7a 	jeq %d2,0,80028da2 <_svfprintf_r+0x23e>
800297b6:	d8 02       	ld.a %a15,[%sp]8
800297b8:	02 ef       	mov %d15,%d14
800297ba:	1d 00 75 00 	j 800298a4 <_svfprintf_r+0xd40>
800297be:	19 a2 04 20 	ld.w %d2,[%sp]132
800297c2:	1b 1b 00 a0 	addi %d10,%d11,1
800297c6:	1b 12 00 80 	addi %d8,%d2,1
800297ca:	19 a2 30 00 	ld.w %d2,[%sp]48
800297ce:	d9 f6 08 00 	lea %a6,[%a15]8
800297d2:	bf 22 b5 01 	jlt %d2,2,80029b3c <_svfprintf_r+0xfd8>
800297d6:	82 12       	mov %d2,1
800297d8:	e8 0e       	st.a [%a15]0,%a14
800297da:	59 aa 08 20 	st.w [%sp]136,%d10
800297de:	68 12       	st.w [%a15]4,%d2
800297e0:	59 a8 04 20 	st.w [%sp]132,%d8
800297e4:	8b 88 40 22 	lt %d2,%d8,8
800297e8:	df 02 4a 02 	jeq %d2,0,80029c7c <_svfprintf_r+0x1118>
800297ec:	19 a3 00 10 	ld.w %d3,[%sp]64
800297f0:	c2 18       	add %d8,1
800297f2:	42 3a       	add %d10,%d3
800297f4:	19 a2 04 10 	ld.w %d2,[%sp]68
800297f8:	74 62       	st.w [%a6],%d2
800297fa:	59 63 04 00 	st.w [%a6]4,%d3
800297fe:	59 aa 08 20 	st.w [%sp]136,%d10
80029802:	59 a8 04 20 	st.w [%sp]132,%d8
80029806:	8b 88 80 22 	ge %d2,%d8,8
8002980a:	d9 66 08 00 	lea %a6,[%a6]8
8002980e:	df 02 48 82 	jne %d2,0,80029c9e <_svfprintf_r+0x113a>
80029812:	19 a2 30 00 	ld.w %d2,[%sp]48
80029816:	99 a2 38 00 	ld.a %a2,[%sp]56
8002981a:	1b f2 ff 9f 	addi %d9,%d2,-1
8002981e:	19 a2 3c 00 	ld.w %d2,[%sp]60
80029822:	d2 06       	mov %e6,0
80029824:	80 24       	mov.d %d4,%a2
80029826:	02 25       	mov %d5,%d2
80029828:	b5 a6 0c 00 	st.a [%sp]12,%a6
8002982c:	6d 00 0d 2b 	call 8002ee46 <__nedf2>
80029830:	99 a6 0c 00 	ld.a %a6,[%sp]12
80029834:	df 02 a4 01 	jeq %d2,0,80029b7c <_svfprintf_r+0x1018>
80029838:	c2 18       	add %d8,1
8002983a:	42 9a       	add %d10,%d9
8002983c:	b0 1e       	add.a %a14,1
8002983e:	f4 6e       	st.a [%a6],%a14
80029840:	59 69 04 00 	st.w [%a6]4,%d9
80029844:	59 aa 08 20 	st.w [%sp]136,%d10
80029848:	59 a8 04 20 	st.w [%sp]132,%d8
8002984c:	8b 88 80 22 	ge %d2,%d8,8
80029850:	df 02 85 81 	jne %d2,0,80029b5a <_svfprintf_r+0xff6>
80029854:	d9 66 08 00 	lea %a6,[%a6]8
80029858:	19 a3 0c 10 	ld.w %d3,[%sp]76
8002985c:	1b 18 00 20 	addi %d2,%d8,1
80029860:	0b a3 00 b0 	add %d11,%d3,%d10
80029864:	d9 a3 31 10 	lea %a3,[%sp]113
80029868:	59 a2 04 20 	st.w [%sp]132,%d2
8002986c:	f4 63       	st.a [%a6],%a3
8002986e:	59 63 04 00 	st.w [%a6]4,%d3
80029872:	59 ab 08 20 	st.w [%sp]136,%d11
80029876:	8b 82 80 22 	ge %d2,%d2,8
8002987a:	d9 6f 08 00 	lea %a15,[%a6]8
8002987e:	df 02 7d 7a 	jeq %d2,0,80028d78 <_svfprintf_r+0x214>
80029882:	99 a4 08 00 	ld.a %a4,[%sp]8
80029886:	60 e5       	mov.a %a5,%d14
80029888:	d9 a6 00 20 	lea %a6,[%sp]128
8002988c:	6d 00 51 1c 	call 8002d12e <__ssprint_r>
80029890:	df 02 93 ff 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
80029894:	19 ab 08 20 	ld.w %d11,[%sp]136
80029898:	d9 af 0c 20 	lea %a15,[%sp]140
8002989c:	1d ff 6e fa 	j 80028d78 <_svfprintf_r+0x214>
800298a0:	60 ff       	mov.a %a15,%d15
800298a2:	02 ef       	mov %d15,%d14
800298a4:	19 a2 1c 00 	ld.w %d2,[%sp]28
800298a8:	df 02 07 00 	jeq %d2,0,800298b6 <_svfprintf_r+0xd52>
800298ac:	99 a5 1c 00 	ld.a %a5,[%sp]28
800298b0:	40 f4       	mov.aa %a4,%a15
800298b2:	6d ff 12 f8 	call 800288d6 <_free_r>
800298b6:	60 f2       	mov.a %a2,%d15
800298b8:	c9 23 0c 00 	ld.h %d3,[%a2]12
800298bc:	19 a2 10 00 	ld.w %d2,[%sp]16
800298c0:	8f 03 04 31 	and %d3,%d3,64
800298c4:	ab f2 bf 23 	seln %d2,%d3,%d2,-1
800298c8:	59 a2 10 00 	st.w [%sp]16,%d2
800298cc:	19 a2 10 00 	ld.w %d2,[%sp]16
800298d0:	00 90       	ret 
800298d2:	99 a4 08 00 	ld.a %a4,[%sp]8
800298d6:	60 e5       	mov.a %a5,%d14
800298d8:	d9 a6 00 20 	lea %a6,[%sp]128
800298dc:	6d 00 29 1c 	call 8002d12e <__ssprint_r>
800298e0:	df 02 6b ff 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
800298e4:	19 ab 08 20 	ld.w %d11,[%sp]136
800298e8:	d9 af 0c 20 	lea %a15,[%sp]140
800298ec:	1d ff 25 fa 	j 80028d36 <_svfprintf_r+0x1d2>
800298f0:	99 a3 08 10 	ld.a %a3,[%sp]72
800298f4:	58 02       	ld.w %d15,[%sp]8
800298f6:	8f fc 00 21 	and %d2,%d12,15
800298fa:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
800298fe:	77 cd 00 ce 	dextr %d12,%d13,%d12,28
80029902:	14 22       	ld.bu %d2,[%a2]
80029904:	89 e2 3f f4 	st.b [+%a14]-1,%d2
80029908:	06 cd       	sh %d13,-4
8002990a:	8b 0c 20 22 	ne %d2,%d12,0
8002990e:	8b 0d 00 25 	or.ne %d2,%d13,0
80029912:	df 02 f2 ff 	jne %d2,0,800298f6 <_svfprintf_r+0xd92>
80029916:	78 02       	st.w [%sp]8,%d15
80029918:	1d ff 3c ff 	j 80029790 <_svfprintf_r+0xc2c>
8002991c:	8b 18 41 22 	lt %d2,%d8,17
80029920:	19 a3 04 20 	ld.w %d3,[%sp]132
80029924:	df 02 c2 88 	jne %d2,0,8002aaa8 <_svfprintf_r+0x1f44>
80029928:	1b f8 fe 2f 	addi %d2,%d8,-17
8002992c:	8f f2 60 21 	nor %d2,%d2,15
80029930:	91 00 00 c8 	movh.a %a12,32768
80029934:	58 02       	ld.w %d15,[%sp]8
80029936:	0b 82 00 90 	add %d9,%d2,%d8
8002993a:	d9 cc dc 53 	lea %a12,[%a12]15708 <80003d5c <blanks.1>>
8002993e:	3b 00 01 a0 	mov %d10,16
80029942:	1d 00 06 00 	j 8002994e <_svfprintf_r+0xdea>
80029946:	1b 08 ff 8f 	addi %d8,%d8,-16
8002994a:	5f 98 23 00 	jeq %d8,%d9,80029990 <_svfprintf_r+0xe2c>
8002994e:	c2 13       	add %d3,1
80029950:	1b 0b 01 b0 	addi %d11,%d11,16
80029954:	e8 0c       	st.a [%a15]0,%a12
80029956:	68 1a       	st.w [%a15]4,%d10
80029958:	59 ab 08 20 	st.w [%sp]136,%d11
8002995c:	59 a3 04 20 	st.w [%sp]132,%d3
80029960:	8b 83 80 22 	ge %d2,%d3,8
80029964:	d9 ff 08 00 	lea %a15,[%a15]8
80029968:	df 02 ef 7f 	jeq %d2,0,80029946 <_svfprintf_r+0xde2>
8002996c:	60 e5       	mov.a %a5,%d14
8002996e:	60 f4       	mov.a %a4,%d15
80029970:	d9 a6 00 20 	lea %a6,[%sp]128
80029974:	6d 00 dd 1b 	call 8002d12e <__ssprint_r>
80029978:	df 02 94 ff 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
8002997c:	1b 08 ff 8f 	addi %d8,%d8,-16
80029980:	19 ab 08 20 	ld.w %d11,[%sp]136
80029984:	19 a3 04 20 	ld.w %d3,[%sp]132
80029988:	d9 af 0c 20 	lea %a15,[%sp]140
8002998c:	5f 98 e1 ff 	jne %d8,%d9,8002994e <_svfprintf_r+0xdea>
80029990:	78 02       	st.w [%sp]8,%d15
80029992:	1b 13 00 20 	addi %d2,%d3,1
80029996:	42 9b       	add %d11,%d9
80029998:	e8 0c       	st.a [%a15]0,%a12
8002999a:	59 a2 04 20 	st.w [%sp]132,%d2
8002999e:	68 19       	st.w [%a15]4,%d9
800299a0:	59 ab 08 20 	st.w [%sp]136,%d11
800299a4:	8b 82 40 22 	lt %d2,%d2,8
800299a8:	df 02 f2 f9 	jne %d2,0,80028d8c <_svfprintf_r+0x228>
800299ac:	99 a4 08 00 	ld.a %a4,[%sp]8
800299b0:	60 e5       	mov.a %a5,%d14
800299b2:	d9 a6 00 20 	lea %a6,[%sp]128
800299b6:	6d 00 bc 1b 	call 8002d12e <__ssprint_r>
800299ba:	df 02 fe fe 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
800299be:	19 ab 08 20 	ld.w %d11,[%sp]136
800299c2:	1d ff e5 f9 	j 80028d8c <_svfprintf_r+0x228>
800299c6:	19 a1 04 00 	ld.w %d1,[%sp]4
800299ca:	a0 9c       	mov.a %a12,9
800299cc:	8b 0d 00 22 	eq %d2,%d13,0
800299d0:	80 c3       	mov.d %d3,%a12
800299d2:	60 24       	mov.a %a4,%d2
800299d4:	0b c3 50 22 	and.ge.u %d2,%d3,%d12
800299d8:	df 02 d0 04 	jeq %d2,0,8002a378 <_svfprintf_r+0x1814>
800299dc:	1b 0c 03 c0 	addi %d12,%d12,48
800299e0:	82 12       	mov %d2,1
800299e2:	59 a1 04 00 	st.w [%sp]4,%d1
800299e6:	e9 ac 2f 40 	st.b [%sp]303,%d12
800299ea:	59 a2 14 00 	st.w [%sp]20,%d2
800299ee:	d9 ae 2f 40 	lea %a14,[%sp]303
800299f2:	1d ff aa fc 	j 80029346 <_svfprintf_r+0x7e2>
800299f6:	19 a4 28 10 	ld.w %d4,[%sp]104
800299fa:	bf 14 5d 04 	jlt %d4,1,8002a2b4 <_svfprintf_r+0x1750>
800299fe:	19 a2 28 00 	ld.w %d2,[%sp]40
80029a02:	19 a3 30 00 	ld.w %d3,[%sp]48
80029a06:	0b 32 80 81 	min %d8,%d2,%d3
80029a0a:	bf 18 12 00 	jlt %d8,1,80029a2e <_svfprintf_r+0xeca>
80029a0e:	19 a2 04 20 	ld.w %d2,[%sp]132
80029a12:	42 8b       	add %d11,%d8
80029a14:	c2 12       	add %d2,1
80029a16:	e8 0e       	st.a [%a15]0,%a14
80029a18:	68 18       	st.w [%a15]4,%d8
80029a1a:	59 a2 04 20 	st.w [%sp]132,%d2
80029a1e:	59 ab 08 20 	st.w [%sp]136,%d11
80029a22:	8b 82 80 22 	ge %d2,%d2,8
80029a26:	d9 ff 08 00 	lea %a15,[%a15]8
80029a2a:	df 02 d9 86 	jne %d2,0,8002a7dc <_svfprintf_r+0x1c78>
80029a2e:	19 a2 28 00 	ld.w %d2,[%sp]40
80029a32:	8b 08 40 83 	max %d8,%d8,0
80029a36:	0b 82 80 80 	sub %d8,%d2,%d8
80029a3a:	ff 18 a1 02 	jge %d8,1,80029f7c <_svfprintf_r+0x1418>
80029a3e:	19 aa 28 00 	ld.w %d10,[%sp]40
80029a42:	80 e2       	mov.d %d2,%a14
80029a44:	42 2a       	add %d10,%d2
80029a46:	19 a2 04 00 	ld.w %d2,[%sp]4
80029a4a:	6f a2 0e 83 	jnz.t %d2,10,8002a066 <_svfprintf_r+0x1502>
80029a4e:	19 a3 28 10 	ld.w %d3,[%sp]104
80029a52:	19 a2 30 00 	ld.w %d2,[%sp]48
80029a56:	3f 23 06 00 	jlt %d3,%d2,80029a62 <_svfprintf_r+0xefe>
80029a5a:	19 a2 04 00 	ld.w %d2,[%sp]4
80029a5e:	6f 02 e1 06 	jz.t %d2,0,8002a820 <_svfprintf_r+0x1cbc>
80029a62:	19 a2 04 10 	ld.w %d2,[%sp]68
80029a66:	19 a4 00 10 	ld.w %d4,[%sp]64
80029a6a:	68 02       	st.w [%a15]0,%d2
80029a6c:	19 a2 04 20 	ld.w %d2,[%sp]132
80029a70:	42 4b       	add %d11,%d4
80029a72:	c2 12       	add %d2,1
80029a74:	68 14       	st.w [%a15]4,%d4
80029a76:	59 ab 08 20 	st.w [%sp]136,%d11
80029a7a:	59 a2 04 20 	st.w [%sp]132,%d2
80029a7e:	8b 82 80 22 	ge %d2,%d2,8
80029a82:	d9 ff 08 00 	lea %a15,[%a15]8
80029a86:	df 02 be 87 	jne %d2,0,8002aa02 <_svfprintf_r+0x1e9e>
80029a8a:	19 a4 30 00 	ld.w %d4,[%sp]48
80029a8e:	80 e2       	mov.d %d2,%a14
80029a90:	42 42       	add %d2,%d4
80029a92:	0b 34 80 30 	sub %d3,%d4,%d3
80029a96:	a2 a2       	sub %d2,%d10
80029a98:	0b 32 80 81 	min %d8,%d2,%d3
80029a9c:	bf 18 12 00 	jlt %d8,1,80029ac0 <_svfprintf_r+0xf5c>
80029aa0:	19 a2 04 20 	ld.w %d2,[%sp]132
80029aa4:	42 8b       	add %d11,%d8
80029aa6:	c2 12       	add %d2,1
80029aa8:	68 0a       	st.w [%a15]0,%d10
80029aaa:	68 18       	st.w [%a15]4,%d8
80029aac:	59 a2 04 20 	st.w [%sp]132,%d2
80029ab0:	59 ab 08 20 	st.w [%sp]136,%d11
80029ab4:	8b 82 80 22 	ge %d2,%d2,8
80029ab8:	d9 ff 08 00 	lea %a15,[%a15]8
80029abc:	df 02 e2 87 	jne %d2,0,8002aa80 <_svfprintf_r+0x1f1c>
80029ac0:	8b 08 40 83 	max %d8,%d8,0
80029ac4:	0b 83 80 80 	sub %d8,%d3,%d8
80029ac8:	bf 18 58 79 	jlt %d8,1,80028d78 <_svfprintf_r+0x214>
80029acc:	8b 18 41 22 	lt %d2,%d8,17
80029ad0:	19 a3 04 20 	ld.w %d3,[%sp]132
80029ad4:	df 02 4c 89 	jne %d2,0,8002ad6c <_svfprintf_r+0x2208>
80029ad8:	1b f8 fe 2f 	addi %d2,%d8,-17
80029adc:	8f f2 60 21 	nor %d2,%d2,15
80029ae0:	91 00 00 c8 	movh.a %a12,32768
80029ae4:	58 02       	ld.w %d15,[%sp]8
80029ae6:	0b 82 00 90 	add %d9,%d2,%d8
80029aea:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
80029aee:	3b 00 01 a0 	mov %d10,16
80029af2:	1d 00 06 00 	j 80029afe <_svfprintf_r+0xf9a>
80029af6:	1b 08 ff 8f 	addi %d8,%d8,-16
80029afa:	5f 98 de 04 	jeq %d8,%d9,8002a4b6 <_svfprintf_r+0x1952>
80029afe:	c2 13       	add %d3,1
80029b00:	1b 0b 01 b0 	addi %d11,%d11,16
80029b04:	e8 0c       	st.a [%a15]0,%a12
80029b06:	68 1a       	st.w [%a15]4,%d10
80029b08:	59 ab 08 20 	st.w [%sp]136,%d11
80029b0c:	59 a3 04 20 	st.w [%sp]132,%d3
80029b10:	8b 83 80 22 	ge %d2,%d3,8
80029b14:	d9 ff 08 00 	lea %a15,[%a15]8
80029b18:	df 02 ef 7f 	jeq %d2,0,80029af6 <_svfprintf_r+0xf92>
80029b1c:	60 e5       	mov.a %a5,%d14
80029b1e:	60 f4       	mov.a %a4,%d15
80029b20:	d9 a6 00 20 	lea %a6,[%sp]128
80029b24:	6d 00 05 1b 	call 8002d12e <__ssprint_r>
80029b28:	df 02 bc fe 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
80029b2c:	19 ab 08 20 	ld.w %d11,[%sp]136
80029b30:	19 a3 04 20 	ld.w %d3,[%sp]132
80029b34:	d9 af 0c 20 	lea %a15,[%sp]140
80029b38:	1d ff df ff 	j 80029af6 <_svfprintf_r+0xf92>
80029b3c:	19 a2 04 00 	ld.w %d2,[%sp]4
80029b40:	6f 02 4b fe 	jnz.t %d2,0,800297d6 <_svfprintf_r+0xc72>
80029b44:	82 12       	mov %d2,1
80029b46:	e8 0e       	st.a [%a15]0,%a14
80029b48:	59 aa 08 20 	st.w [%sp]136,%d10
80029b4c:	68 12       	st.w [%a15]4,%d2
80029b4e:	59 a8 04 20 	st.w [%sp]132,%d8
80029b52:	8b 88 40 22 	lt %d2,%d8,8
80029b56:	df 02 81 fe 	jne %d2,0,80029858 <_svfprintf_r+0xcf4>
80029b5a:	99 a4 08 00 	ld.a %a4,[%sp]8
80029b5e:	60 e5       	mov.a %a5,%d14
80029b60:	d9 a6 00 20 	lea %a6,[%sp]128
80029b64:	6d 00 e5 1a 	call 8002d12e <__ssprint_r>
80029b68:	df 02 27 fe 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
80029b6c:	19 aa 08 20 	ld.w %d10,[%sp]136
80029b70:	19 a8 04 20 	ld.w %d8,[%sp]132
80029b74:	d9 a6 0c 20 	lea %a6,[%sp]140
80029b78:	1d ff 70 fe 	j 80029858 <_svfprintf_r+0xcf4>
80029b7c:	bf 19 6e 7e 	jlt %d9,1,80029858 <_svfprintf_r+0xcf4>
80029b80:	8b 19 41 22 	lt %d2,%d9,17
80029b84:	df 02 e5 88 	jne %d2,0,8002ad4e <_svfprintf_r+0x21ea>
80029b88:	19 a2 30 00 	ld.w %d2,[%sp]48
80029b8c:	91 00 00 c8 	movh.a %a12,32768
80029b90:	1b e2 fe bf 	addi %d11,%d2,-18
80029b94:	1b f2 fe 4f 	addi %d4,%d2,-17
80029b98:	8f fb c0 b1 	andn %d11,%d11,15
80029b9c:	58 02       	ld.w %d15,[%sp]8
80029b9e:	0b b4 80 b0 	sub %d11,%d4,%d11
80029ba2:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
80029ba6:	3b 00 01 c0 	mov %d12,16
80029baa:	1d 00 06 00 	j 80029bb6 <_svfprintf_r+0x1052>
80029bae:	1b 09 ff 9f 	addi %d9,%d9,-16
80029bb2:	5f 9b ba 04 	jeq %d11,%d9,8002a526 <_svfprintf_r+0x19c2>
80029bb6:	c2 18       	add %d8,1
80029bb8:	1b 0a 01 a0 	addi %d10,%d10,16
80029bbc:	f4 6c       	st.a [%a6],%a12
80029bbe:	59 6c 04 00 	st.w [%a6]4,%d12
80029bc2:	59 aa 08 20 	st.w [%sp]136,%d10
80029bc6:	59 a8 04 20 	st.w [%sp]132,%d8
80029bca:	8b 88 80 22 	ge %d2,%d8,8
80029bce:	d9 66 08 00 	lea %a6,[%a6]8
80029bd2:	df 02 ee 7f 	jeq %d2,0,80029bae <_svfprintf_r+0x104a>
80029bd6:	60 e5       	mov.a %a5,%d14
80029bd8:	60 f4       	mov.a %a4,%d15
80029bda:	d9 a6 00 20 	lea %a6,[%sp]128
80029bde:	6d 00 a8 1a 	call 8002d12e <__ssprint_r>
80029be2:	df 02 5f fe 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
80029be6:	19 aa 08 20 	ld.w %d10,[%sp]136
80029bea:	19 a8 04 20 	ld.w %d8,[%sp]132
80029bee:	d9 a6 0c 20 	lea %a6,[%sp]140
80029bf2:	1d ff de ff 	j 80029bae <_svfprintf_r+0x104a>
80029bf6:	40 23       	mov.aa %a3,%a2
80029bf8:	19 a3 04 00 	ld.w %d3,[%sp]4
80029bfc:	b0 42       	add.a %a2,4
80029bfe:	b5 a2 20 00 	st.a [%sp]32,%a2
80029c02:	54 32       	ld.w %d2,[%a3]
80029c04:	6f 43 7c 80 	jnz.t %d3,4,80029cfc <_svfprintf_r+0x1198>
80029c08:	19 a3 04 00 	ld.w %d3,[%sp]4
80029c0c:	6f 63 70 00 	jz.t %d3,6,80029cec <_svfprintf_r+0x1188>
80029c10:	37 02 70 20 	extr.u %d2,%d2,0,16
80029c14:	53 12 40 c0 	mul.u %e12,%d2,1
80029c18:	1d ff f3 fb 	j 800293fe <_svfprintf_r+0x89a>
80029c1c:	40 23       	mov.aa %a3,%a2
80029c1e:	19 a2 04 00 	ld.w %d2,[%sp]4
80029c22:	b0 42       	add.a %a2,4
80029c24:	b5 a2 20 00 	st.a [%sp]32,%a2
80029c28:	54 34       	ld.w %d4,[%a3]
80029c2a:	6f 42 5b 80 	jnz.t %d2,4,80029ce0 <_svfprintf_r+0x117c>
80029c2e:	19 a2 04 00 	ld.w %d2,[%sp]4
80029c32:	6f 62 4d 00 	jz.t %d2,6,80029ccc <_svfprintf_r+0x1168>
80029c36:	37 04 50 40 	extr %d4,%d4,0,16
80029c3a:	0b 40 00 c8 	mov %e12,%d4
80029c3e:	0b cd 10 28 	mov %e2,%d13,%d12
80029c42:	ff 03 ae 7b 	jge %d3,0,8002939e <_svfprintf_r+0x83a>
80029c46:	32 5d       	rsub %d13
80029c48:	32 5c       	rsub %d12
80029c4a:	19 a1 04 00 	ld.w %d1,[%sp]4
80029c4e:	ab fd 1f dc 	cadd %d13,%d12,%d13,-1
80029c52:	3b d0 02 20 	mov %d2,45
80029c56:	82 14       	mov %d4,1
80029c58:	1d ff 50 fb 	j 800292f8 <_svfprintf_r+0x794>
80029c5c:	40 23       	mov.aa %a3,%a2
80029c5e:	b0 42       	add.a %a2,4
80029c60:	b5 a2 20 00 	st.a [%sp]32,%a2
80029c64:	54 32       	ld.w %d2,[%a3]
80029c66:	6f 41 06 80 	jnz.t %d1,4,80029c72 <_svfprintf_r+0x110e>
80029c6a:	6f 61 6e 04 	jz.t %d1,6,8002a546 <_svfprintf_r+0x19e2>
80029c6e:	37 02 70 20 	extr.u %d2,%d2,0,16
80029c72:	53 12 40 c0 	mul.u %e12,%d2,1
80029c76:	82 14       	mov %d4,1
80029c78:	1d ff 3f fb 	j 800292f6 <_svfprintf_r+0x792>
80029c7c:	99 a4 08 00 	ld.a %a4,[%sp]8
80029c80:	60 e5       	mov.a %a5,%d14
80029c82:	d9 a6 00 20 	lea %a6,[%sp]128
80029c86:	6d 00 54 1a 	call 8002d12e <__ssprint_r>
80029c8a:	df 02 96 fd 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
80029c8e:	19 aa 08 20 	ld.w %d10,[%sp]136
80029c92:	19 a8 04 20 	ld.w %d8,[%sp]132
80029c96:	d9 a6 0c 20 	lea %a6,[%sp]140
80029c9a:	1d ff a9 fd 	j 800297ec <_svfprintf_r+0xc88>
80029c9e:	99 a4 08 00 	ld.a %a4,[%sp]8
80029ca2:	60 e5       	mov.a %a5,%d14
80029ca4:	d9 a6 00 20 	lea %a6,[%sp]128
80029ca8:	6d 00 43 1a 	call 8002d12e <__ssprint_r>
80029cac:	df 02 85 fd 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
80029cb0:	19 aa 08 20 	ld.w %d10,[%sp]136
80029cb4:	19 a8 04 20 	ld.w %d8,[%sp]132
80029cb8:	d9 a6 0c 20 	lea %a6,[%sp]140
80029cbc:	1d ff ab fd 	j 80029812 <_svfprintf_r+0xcae>
80029cc0:	19 a2 04 00 	ld.w %d2,[%sp]4
80029cc4:	6f 02 5a 78 	jz.t %d2,0,80028d78 <_svfprintf_r+0x214>
80029cc8:	1d ff 32 fc 	j 8002952c <_svfprintf_r+0x9c8>
80029ccc:	0b 40 00 c8 	mov %e12,%d4
80029cd0:	19 a5 04 00 	ld.w %d5,[%sp]4
80029cd4:	0b cd 10 28 	mov %e2,%d13,%d12
80029cd8:	6f 95 61 7b 	jz.t %d5,9,8002939a <_svfprintf_r+0x836>
80029cdc:	37 04 48 40 	extr %d4,%d4,0,8
80029ce0:	0b 40 00 c8 	mov %e12,%d4
80029ce4:	0b cd 10 28 	mov %e2,%d13,%d12
80029ce8:	1d ff 59 fb 	j 8002939a <_svfprintf_r+0x836>
80029cec:	19 a3 04 00 	ld.w %d3,[%sp]4
80029cf0:	53 12 40 c0 	mul.u %e12,%d2,1
80029cf4:	6f 93 85 7b 	jz.t %d3,9,800293fe <_svfprintf_r+0x89a>
80029cf8:	8f f2 0f 21 	and %d2,%d2,255
80029cfc:	53 12 40 c0 	mul.u %e12,%d2,1
80029d00:	1d ff 7f fb 	j 800293fe <_svfprintf_r+0x89a>
80029d04:	19 a2 10 00 	ld.w %d2,[%sp]16
80029d08:	d4 33       	ld.a %a3,[%a3]
80029d0a:	0b 20 00 28 	mov %e2,%d2
80029d0e:	b5 a2 20 00 	st.a [%sp]32,%a2
80029d12:	89 32 40 09 	st.d [%a3],%e2
80029d16:	1d ff 60 f7 	j 80028bd6 <_svfprintf_r+0x72>
80029d1a:	19 a3 3c 00 	ld.w %d3,[%sp]60
80029d1e:	19 a4 38 00 	ld.w %d4,[%sp]56
80029d22:	02 37       	mov %d7,%d3
80029d24:	02 46       	mov %d6,%d4
80029d26:	02 35       	mov %d5,%d3
80029d28:	6d 00 0f 29 	call 8002ef46 <__unorddf2>
80029d2c:	df 02 f1 87 	jne %d2,0,8002ad0e <_svfprintf_r+0x21aa>
80029d30:	19 a3 24 00 	ld.w %d3,[%sp]36
80029d34:	8f 03 c2 d1 	andn %d13,%d3,32
80029d38:	8b 1d 24 22 	ne %d2,%d13,65
80029d3c:	df 02 17 84 	jne %d2,0,8002a56a <_svfprintf_r+0x1a06>
80029d40:	8b 13 06 92 	eq %d9,%d3,97
80029d44:	3b 80 07 20 	mov %d2,120
80029d48:	ab 82 85 29 	sel %d2,%d9,%d2,88
80029d4c:	da 30       	mov %d15,48
80029d4e:	82 03       	mov %d3,0
80029d50:	e9 a2 27 10 	st.b [%sp]103,%d2
80029d54:	19 a2 0c 00 	ld.w %d2,[%sp]12
80029d58:	e9 af 26 10 	st.b [%sp]102,%d15
80029d5c:	8b 42 46 22 	lt %d2,%d2,100
80029d60:	59 a3 1c 00 	st.w [%sp]28,%d3
80029d64:	d9 ae 0c 30 	lea %a14,[%sp]204
80029d68:	df 02 b4 05 	jeq %d2,0,8002a8d0 <_svfprintf_r+0x1d6c>
80029d6c:	19 a3 3c 00 	ld.w %d3,[%sp]60
80029d70:	c5 02 2d 00 	lea %a2,2d <__TRICORE_DERIVATE_MEMORY_MAP__-0x363>
80029d74:	80 25       	mov.d %d5,%a2
80029d76:	8b 03 40 22 	lt %d2,%d3,0
80029d7a:	ab 05 80 22 	sel %d2,%d2,%d5,0
80029d7e:	99 a5 38 00 	ld.a %a5,[%sp]56
80029d82:	9b 03 00 48 	addih %d4,%d3,32768
80029d86:	02 35       	mov %d5,%d3
80029d88:	8b 03 80 32 	ge %d3,%d3,0
80029d8c:	59 a2 20 00 	st.w [%sp]32,%d2
80029d90:	2b 45 40 23 	sel %d2,%d3,%d5,%d4
80029d94:	d9 a4 28 10 	lea %a4,[%sp]104
80029d98:	80 54       	mov.d %d4,%a5
80029d9a:	02 25       	mov %d5,%d2
80029d9c:	6d 00 d7 09 	call 8002b14a <frexp>
80029da0:	0b 23 10 48 	mov %e4,%d3,%d2
80029da4:	82 06       	mov %d6,0
80029da6:	7b 00 fc 73 	movh %d7,16320
80029daa:	6d ff ff eb 	call 800275a8 <__muldf3>
80029dae:	d2 06       	mov %e6,0
80029db0:	02 24       	mov %d4,%d2
80029db2:	02 35       	mov %d5,%d3
80029db4:	60 2c       	mov.a %a12,%d2
80029db6:	02 38       	mov %d8,%d3
80029db8:	6d 00 27 28 	call 8002ee06 <__eqdf2>
80029dbc:	df 02 47 05 	jeq %d2,0,8002a84a <_svfprintf_r+0x1ce6>
80029dc0:	91 00 00 28 	movh.a %a2,32768
80029dc4:	80 22       	mov.d %d2,%a2
80029dc6:	7b 00 00 38 	movh %d3,32768
80029dca:	1b 12 d2 23 	addi %d2,%d2,15649
80029dce:	1b 23 d3 33 	addi %d3,%d3,15666
80029dd2:	2b 32 40 29 	sel %d2,%d9,%d2,%d3
80029dd6:	19 ab 0c 00 	ld.w %d11,[%sp]12
80029dda:	b5 ad 28 00 	st.a [%sp]40,%a13
80029dde:	59 ad 2c 00 	st.w [%sp]44,%d13
80029de2:	58 02       	ld.w %d15,[%sp]8
80029de4:	02 cd       	mov %d13,%d12
80029de6:	60 8d       	mov.a %a13,%d8
80029de8:	59 a2 14 00 	st.w [%sp]20,%d2
80029dec:	c2 fb       	add %d11,-1
80029dee:	80 ea       	mov.d %d10,%a14
80029df0:	80 fc       	mov.d %d12,%a15
80029df2:	1d 00 0a 00 	j 80029e06 <_svfprintf_r+0x12a2>
80029df6:	d2 06       	mov %e6,0
80029df8:	02 24       	mov %d4,%d2
80029dfa:	02 35       	mov %d5,%d3
80029dfc:	c2 fb       	add %d11,-1
80029dfe:	6d 00 24 28 	call 8002ee46 <__nedf2>
80029e02:	df 02 25 00 	jeq %d2,0,80029e4c <_svfprintf_r+0x12e8>
80029e06:	82 06       	mov %d6,0
80029e08:	7b 00 03 74 	movh %d7,16432
80029e0c:	80 c4       	mov.d %d4,%a12
80029e0e:	80 d5       	mov.d %d5,%a13
80029e10:	6d ff cc eb 	call 800275a8 <__muldf3>
80029e14:	02 35       	mov %d5,%d3
80029e16:	02 24       	mov %d4,%d2
80029e18:	60 3c       	mov.a %a12,%d3
80029e1a:	60 2d       	mov.a %a13,%d2
80029e1c:	6d ff f8 ec 	call 8002780c <__fixdfsi>
80029e20:	02 24       	mov %d4,%d2
80029e22:	02 29       	mov %d9,%d2
80029e24:	6d 00 ab 28 	call 8002ef7a <__floatsidf>
80029e28:	0b 23 10 68 	mov %e6,%d3,%d2
80029e2c:	80 d4       	mov.d %d4,%a13
80029e2e:	80 c5       	mov.d %d5,%a12
80029e30:	6d ff 99 eb 	call 80027562 <__subdf3>
80029e34:	99 a2 14 00 	ld.a %a2,[%sp]20
80029e38:	40 ef       	mov.aa %a15,%a14
80029e3a:	60 2c       	mov.a %a12,%d2
80029e3c:	01 29 00 26 	addsc.a %a2,%a2,%d9,0
80029e40:	60 3d       	mov.a %a13,%d3
80029e42:	14 24       	ld.bu %d4,[%a2]
80029e44:	24 e4       	st.b [%a14+],%d4
80029e46:	02 b8       	mov %d8,%d11
80029e48:	df fb d7 ff 	jne %d11,-1,80029df6 <_svfprintf_r+0x1292>
80029e4c:	80 e2       	mov.d %d2,%a14
80029e4e:	02 8b       	mov %d11,%d8
80029e50:	60 ae       	mov.a %a14,%d10
80029e52:	80 d8       	mov.d %d8,%a13
80029e54:	82 06       	mov %d6,0
80029e56:	7b 00 fe 73 	movh %d7,16352
80029e5a:	80 c4       	mov.d %d4,%a12
80029e5c:	02 85       	mov %d5,%d8
80029e5e:	f8 03       	st.a [%sp]12,%a15
80029e60:	99 ad 28 00 	ld.a %a13,[%sp]40
80029e64:	60 cf       	mov.a %a15,%d12
80029e66:	78 02       	st.w [%sp]8,%d15
80029e68:	02 dc       	mov %d12,%d13
80029e6a:	02 2a       	mov %d10,%d2
80029e6c:	19 ad 2c 00 	ld.w %d13,[%sp]44
80029e70:	6d 00 0b 28 	call 8002ee86 <__gtdf2>
80029e74:	ff 12 ca 06 	jge %d2,1,8002ac08 <_svfprintf_r+0x20a4>
80029e78:	82 06       	mov %d6,0
80029e7a:	7b 00 fe 73 	movh %d7,16352
80029e7e:	80 c4       	mov.d %d4,%a12
80029e80:	02 85       	mov %d5,%d8
80029e82:	6d 00 c2 27 	call 8002ee06 <__eqdf2>
80029e86:	df 02 04 80 	jne %d2,0,80029e8e <_svfprintf_r+0x132a>
80029e8a:	6f 09 bf 86 	jnz.t %d9,0,8002ac08 <_svfprintf_r+0x20a4>
80029e8e:	60 a2       	mov.a %a2,%d10
80029e90:	1b 1b 00 20 	addi %d2,%d11,1
80029e94:	99 a4 08 00 	ld.a %a4,[%sp]8
80029e98:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80029e9c:	60 a3       	mov.a %a3,%d10
80029e9e:	bf 0b 09 00 	jlt %d11,0,80029eb0 <_svfprintf_r+0x134c>
80029ea2:	da 30       	mov %d15,48
80029ea4:	24 3f       	st.b [%a3+],%d15
80029ea6:	7d 32 fe ff 	jne.a %a2,%a3,80029ea2 <_svfprintf_r+0x133e>
80029eaa:	80 3a       	mov.d %d10,%a3
80029eac:	b5 a4 08 00 	st.a [%sp]8,%a4
80029eb0:	19 a2 04 00 	ld.w %d2,[%sp]4
80029eb4:	8f 22 40 21 	or %d2,%d2,2
80029eb8:	59 a2 04 00 	st.w [%sp]4,%d2
80029ebc:	80 e2       	mov.d %d2,%a14
80029ebe:	0b 2a 80 20 	sub %d2,%d10,%d2
80029ec2:	59 a2 30 00 	st.w [%sp]48,%d2
80029ec6:	19 a2 28 10 	ld.w %d2,[%sp]104
80029eca:	59 a2 28 00 	st.w [%sp]40,%d2
80029ece:	1d 00 c0 03 	j 8002a64e <_svfprintf_r+0x1aea>
80029ed2:	99 a2 20 00 	ld.a %a2,[%sp]32
80029ed6:	1d ff 71 f8 	j 80028fb8 <_svfprintf_r+0x454>
80029eda:	59 a3 24 00 	st.w [%sp]36,%d3
80029ede:	78 02       	st.w [%sp]8,%d15
80029ee0:	1d ff 51 fa 	j 80029382 <_svfprintf_r+0x81e>
80029ee4:	19 a2 18 00 	ld.w %d2,[%sp]24
80029ee8:	b5 a2 20 00 	st.a [%sp]32,%a2
80029eec:	32 52       	rsub %d2
80029eee:	59 a2 18 00 	st.w [%sp]24,%d2
80029ef2:	19 a2 04 00 	ld.w %d2,[%sp]4
80029ef6:	79 d3 00 00 	ld.b %d3,[%a13]0
80029efa:	8f 42 40 21 	or %d2,%d2,4
80029efe:	59 a2 04 00 	st.w [%sp]4,%d2
80029f02:	1d ff bb f6 	j 80028c78 <_svfprintf_r+0x114>
80029f06:	99 a4 08 00 	ld.a %a4,[%sp]8
80029f0a:	60 e5       	mov.a %a5,%d14
80029f0c:	d9 a6 00 20 	lea %a6,[%sp]128
80029f10:	6d 00 0f 19 	call 8002d12e <__ssprint_r>
80029f14:	df 02 51 fc 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
80029f18:	19 ab 08 20 	ld.w %d11,[%sp]136
80029f1c:	d9 af 0c 20 	lea %a15,[%sp]140
80029f20:	1d ff 1a fb 	j 80029554 <_svfprintf_r+0x9f0>
80029f24:	b7 f2 81 24 	insert %d2,%d2,15,9,1
80029f28:	79 d3 01 00 	ld.b %d3,[%a13]1
80029f2c:	b0 1d       	add.a %a13,1
80029f2e:	59 a2 04 00 	st.w [%sp]4,%d2
80029f32:	1d ff a3 f6 	j 80028c78 <_svfprintf_r+0x114>
80029f36:	8f 02 42 21 	or %d2,%d2,32
80029f3a:	79 d3 01 00 	ld.b %d3,[%a13]1
80029f3e:	b0 1d       	add.a %a13,1
80029f40:	59 a2 04 00 	st.w [%sp]4,%d2
80029f44:	1d ff 9a f6 	j 80028c78 <_svfprintf_r+0x114>
80029f48:	3b 00 04 40 	mov %d4,64
80029f4c:	40 f4       	mov.aa %a4,%a15
80029f4e:	6d ff ad ee 	call 80027ca8 <_malloc_r>
80029f52:	60 f3       	mov.a %a3,%d15
80029f54:	f4 32       	st.a [%a3],%a2
80029f56:	b5 32 10 00 	st.a [%a3]16,%a2
80029f5a:	bd 02 57 07 	jz.a %a2,8002ae08 <_svfprintf_r+0x22a4>
80029f5e:	3b 00 04 20 	mov %d2,64
80029f62:	59 32 14 00 	st.w [%a3]20,%d2
80029f66:	1d ff 19 f6 	j 80028b98 <_svfprintf_r+0x34>
80029f6a:	40 e4       	mov.aa %a4,%a14
80029f6c:	6d ff 69 f3 	call 8002863e <strlen>
80029f70:	79 a3 25 10 	ld.b %d3,[%sp]101
80029f74:	59 a2 14 00 	st.w [%sp]20,%d2
80029f78:	1d ff 0a f9 	j 8002918c <_svfprintf_r+0x628>
80029f7c:	8b 18 41 22 	lt %d2,%d8,17
80029f80:	19 a3 04 20 	ld.w %d3,[%sp]132
80029f84:	df 02 21 87 	jne %d2,0,8002adc6 <_svfprintf_r+0x2262>
80029f88:	1b f8 fe 2f 	addi %d2,%d8,-17
80029f8c:	8f f2 60 21 	nor %d2,%d2,15
80029f90:	91 00 00 c8 	movh.a %a12,32768
80029f94:	58 02       	ld.w %d15,[%sp]8
80029f96:	0b 82 00 90 	add %d9,%d2,%d8
80029f9a:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
80029f9e:	3b 00 01 a0 	mov %d10,16
80029fa2:	1d 00 06 00 	j 80029fae <_svfprintf_r+0x144a>
80029fa6:	1b 08 ff 8f 	addi %d8,%d8,-16
80029faa:	5f 89 e9 03 	jeq %d9,%d8,8002a77c <_svfprintf_r+0x1c18>
80029fae:	c2 13       	add %d3,1
80029fb0:	1b 0b 01 b0 	addi %d11,%d11,16
80029fb4:	e8 0c       	st.a [%a15]0,%a12
80029fb6:	68 1a       	st.w [%a15]4,%d10
80029fb8:	59 ab 08 20 	st.w [%sp]136,%d11
80029fbc:	59 a3 04 20 	st.w [%sp]132,%d3
80029fc0:	8b 83 80 22 	ge %d2,%d3,8
80029fc4:	d9 ff 08 00 	lea %a15,[%a15]8
80029fc8:	df 02 ef 7f 	jeq %d2,0,80029fa6 <_svfprintf_r+0x1442>
80029fcc:	60 e5       	mov.a %a5,%d14
80029fce:	60 f4       	mov.a %a4,%d15
80029fd0:	d9 a6 00 20 	lea %a6,[%sp]128
80029fd4:	6d 00 ad 18 	call 8002d12e <__ssprint_r>
80029fd8:	df 02 64 fc 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
80029fdc:	19 ab 08 20 	ld.w %d11,[%sp]136
80029fe0:	19 a3 04 20 	ld.w %d3,[%sp]132
80029fe4:	d9 af 0c 20 	lea %a15,[%sp]140
80029fe8:	1d ff df ff 	j 80029fa6 <_svfprintf_r+0x1442>
80029fec:	91 00 00 28 	movh.a %a2,32768
80029ff0:	d9 22 e1 43 	lea %a2,[%a2]15649 <80003d21 <_ctype_b+0x190>>
80029ff4:	59 a3 24 00 	st.w [%sp]36 <80003d21 <_ctype_b+0x190>>,%d3
80029ff8:	78 02       	st.w [%sp]8,%d15
80029ffa:	b5 a2 08 10 	st.a [%sp]72 <80003d21 <_ctype_b+0x190>>,%a2
80029ffe:	19 a2 04 00 	ld.w %d2,[%sp]4 <80003d21 <_ctype_b+0x190>>
8002a002:	99 a2 20 00 	ld.a %a2,[%sp]32 <80003d21 <_ctype_b+0x190>>
8002a006:	6f 52 b5 00 	jz.t %d2,5,8002a170 <_svfprintf_r+0x160c>
8002a00a:	09 2c 48 01 	ld.d %e12,[%a2+]8
8002a00e:	b5 a2 20 00 	st.a [%sp]32,%a2
8002a012:	19 a3 04 00 	ld.w %d3,[%sp]4
8002a016:	0f dc a0 20 	or %d2,%d12,%d13
8002a01a:	8b 02 20 22 	ne %d2,%d2,0
8002a01e:	26 32       	and %d2,%d3
8002a020:	df 02 d6 80 	jne %d2,0,8002a1cc <_svfprintf_r+0x1668>
8002a024:	19 a2 04 00 	ld.w %d2,[%sp]4
8002a028:	82 24       	mov %d4,2
8002a02a:	b7 02 01 15 	insert %d1,%d2,0,10,1
8002a02e:	1d ff 64 f9 	j 800292f6 <_svfprintf_r+0x792>
8002a032:	19 a1 04 00 	ld.w %d1,[%sp]4
8002a036:	59 a3 24 00 	st.w [%sp]36,%d3
8002a03a:	78 02       	st.w [%sp]8,%d15
8002a03c:	1d ff 54 f9 	j 800292e4 <_svfprintf_r+0x780>
8002a040:	91 00 00 28 	movh.a %a2,32768
8002a044:	d9 22 f2 43 	lea %a2,[%a2]15666 <80003d32 <_ctype_b+0x1a1>>
8002a048:	59 a3 24 00 	st.w [%sp]36 <80003d32 <_ctype_b+0x1a1>>,%d3
8002a04c:	78 02       	st.w [%sp]8,%d15
8002a04e:	b5 a2 08 10 	st.a [%sp]72 <80003d32 <_ctype_b+0x1a1>>,%a2
8002a052:	1d ff d6 ff 	j 80029ffe <_svfprintf_r+0x149a>
8002a056:	60 fe       	mov.a %a14,%d15
8002a058:	1d ff 4d ff 	j 80029ef2 <_svfprintf_r+0x138e>
8002a05c:	59 a3 24 00 	st.w [%sp]36,%d3
8002a060:	78 02       	st.w [%sp]8,%d15
8002a062:	1d ff c4 f9 	j 800293ea <_svfprintf_r+0x886>
8002a066:	19 a3 34 00 	ld.w %d3,[%sp]52
8002a06a:	19 a4 2c 00 	ld.w %d4,[%sp]44
8002a06e:	8b 13 80 22 	ge %d2,%d3,1
8002a072:	8b 14 60 25 	or.ge %d2,%d4,1
8002a076:	df 02 b9 06 	jeq %d2,0,8002ade8 <_svfprintf_r+0x2284>
8002a07a:	19 a4 30 00 	ld.w %d4,[%sp]48
8002a07e:	80 e2       	mov.d %d2,%a14
8002a080:	b5 ad 28 00 	st.a [%sp]40,%a13
8002a084:	99 ad 14 10 	ld.a %a13,[%sp]84
8002a088:	0b 42 00 c0 	add %d12,%d2,%d4
8002a08c:	91 00 00 c8 	movh.a %a12,32768
8002a090:	59 ad 24 00 	st.w [%sp]36,%d13
8002a094:	58 02       	ld.w %d15,[%sp]8
8002a096:	19 ad 18 10 	ld.w %d13,[%sp]88 <80000002 <LCF_STARTPTR_CPU0+0x2>>
8002a09a:	b5 ae 14 00 	st.a [%sp]20 <80000002 <LCF_STARTPTR_CPU0+0x2>>,%a14
8002a09e:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
8002a0a2:	60 ce       	mov.a %a14,%d12
8002a0a4:	3b 00 01 90 	mov %d9,16
8002a0a8:	02 ac       	mov %d12,%d10
8002a0aa:	02 3a       	mov %d10,%d3
8002a0ac:	df 0a 75 00 	jeq %d10,0,8002a196 <_svfprintf_r+0x1632>
8002a0b0:	c2 fa       	add %d10,-1
8002a0b2:	19 a2 10 10 	ld.w %d2,[%sp]80
8002a0b6:	68 02       	st.w [%a15]0,%d2
8002a0b8:	19 a2 04 20 	ld.w %d2,[%sp]132 <80000000 <LCF_STARTPTR_CPU0>>
8002a0bc:	42 db       	add %d11,%d13
8002a0be:	c2 12       	add %d2,1
8002a0c0:	68 1d       	st.w [%a15]4,%d13
8002a0c2:	59 ab 08 20 	st.w [%sp]136 <80000001 <LCF_STARTPTR_CPU0+0x1>>,%d11
8002a0c6:	59 a2 04 20 	st.w [%sp]132 <80000001 <LCF_STARTPTR_CPU0+0x1>>,%d2
8002a0ca:	8b 82 80 22 	ge %d2,%d2,8
8002a0ce:	d9 ff 08 00 	lea %a15,[%a15]8
8002a0d2:	df 02 e3 80 	jne %d2,0,8002a298 <_svfprintf_r+0x1734>
8002a0d6:	79 d3 00 00 	ld.b %d3,[%a13]0
8002a0da:	80 e2       	mov.d %d2,%a14
8002a0dc:	0b c2 80 80 	sub %d8,%d2,%d12
8002a0e0:	b5 ae 0c 00 	st.a [%sp]12,%a14
8002a0e4:	0b 38 80 81 	min %d8,%d8,%d3
8002a0e8:	bf 18 14 00 	jlt %d8,1,8002a110 <_svfprintf_r+0x15ac>
8002a0ec:	19 a2 04 20 	ld.w %d2,[%sp]132
8002a0f0:	42 8b       	add %d11,%d8
8002a0f2:	c2 12       	add %d2,1
8002a0f4:	68 0c       	st.w [%a15]0,%d12
8002a0f6:	68 18       	st.w [%a15]4,%d8
8002a0f8:	59 a2 04 20 	st.w [%sp]132 <80000001 <LCF_STARTPTR_CPU0+0x1>>,%d2
8002a0fc:	59 ab 08 20 	st.w [%sp]136 <80000001 <LCF_STARTPTR_CPU0+0x1>>,%d11
8002a100:	8b 82 80 22 	ge %d2,%d2,8
8002a104:	df 02 df 81 	jne %d2,0,8002a4c2 <_svfprintf_r+0x195e>
8002a108:	79 d3 00 00 	ld.b %d3,[%a13]0
8002a10c:	d9 ff 08 00 	lea %a15,[%a15]8
8002a110:	8b 08 40 83 	max %d8,%d8,0
8002a114:	0b 83 80 80 	sub %d8,%d3,%d8
8002a118:	ff 18 67 00 	jge %d8,1,8002a1e6 <_svfprintf_r+0x1682>
8002a11c:	42 3c       	add %d12,%d3
8002a11e:	19 a3 2c 00 	ld.w %d3,[%sp]44
8002a122:	8b 13 80 22 	ge %d2,%d3,1
8002a126:	8b 1a 60 25 	or.ge %d2,%d10,1
8002a12a:	df 02 c1 ff 	jne %d2,0,8002a0ac <_svfprintf_r+0x1548>
8002a12e:	b5 ad 14 10 	st.a [%sp]84,%a13
8002a132:	99 ae 14 00 	ld.a %a14,[%sp]20
8002a136:	99 ad 28 00 	ld.a %a13,[%sp]40
8002a13a:	19 ad 24 00 	ld.w %d13,[%sp]36
8002a13e:	02 ca       	mov %d10,%d12
8002a140:	78 02       	st.w [%sp]8,%d15
8002a142:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002a146:	0b 2a 90 a1 	min.u %d10,%d10,%d2
8002a14a:	1d ff 82 fc 	j 80029a4e <_svfprintf_r+0xeea>
8002a14e:	19 a2 08 20 	ld.w %d2,[%sp]136
8002a152:	d8 02       	ld.a %a15,[%sp]8
8002a154:	02 ef       	mov %d15,%d14
8002a156:	df 02 b0 7b 	jeq %d2,0,800298b6 <_svfprintf_r+0xd52>
8002a15a:	60 e5       	mov.a %a5,%d14
8002a15c:	d9 a6 00 20 	lea %a6,[%sp]128
8002a160:	40 f4       	mov.aa %a4,%a15
8002a162:	6d 00 e6 17 	call 8002d12e <__ssprint_r>
8002a166:	60 e2       	mov.a %a2,%d14
8002a168:	c9 23 0c 00 	ld.h %d3,[%a2]12
8002a16c:	1d ff a8 fb 	j 800298bc <_svfprintf_r+0xd58>
8002a170:	40 23       	mov.aa %a3,%a2
8002a172:	19 a3 04 00 	ld.w %d3,[%sp]4
8002a176:	b0 42       	add.a %a2,4
8002a178:	b5 a2 20 00 	st.a [%sp]32,%a2
8002a17c:	54 32       	ld.w %d2,[%a3]
8002a17e:	6f 43 1c 80 	jnz.t %d3,4,8002a1b6 <_svfprintf_r+0x1652>
8002a182:	19 a3 04 00 	ld.w %d3,[%sp]4
8002a186:	6f 63 10 00 	jz.t %d3,6,8002a1a6 <_svfprintf_r+0x1642>
8002a18a:	37 02 70 20 	extr.u %d2,%d2,0,16
8002a18e:	53 12 40 c0 	mul.u %e12,%d2,1
8002a192:	1d ff 40 ff 	j 8002a012 <_svfprintf_r+0x14ae>
8002a196:	19 a2 2c 00 	ld.w %d2,[%sp]44
8002a19a:	b0 fd       	add.a %a13,-1
8002a19c:	c2 f2       	add %d2,-1
8002a19e:	59 a2 2c 00 	st.w [%sp]44,%d2
8002a1a2:	1d ff 88 ff 	j 8002a0b2 <_svfprintf_r+0x154e>
8002a1a6:	19 a3 04 00 	ld.w %d3,[%sp]4
8002a1aa:	53 12 40 c0 	mul.u %e12,%d2,1
8002a1ae:	6f 93 32 7f 	jz.t %d3,9,8002a012 <_svfprintf_r+0x14ae>
8002a1b2:	8f f2 0f 21 	and %d2,%d2,255
8002a1b6:	53 12 40 c0 	mul.u %e12,%d2,1
8002a1ba:	19 a3 04 00 	ld.w %d3,[%sp]4
8002a1be:	0f dc a0 20 	or %d2,%d12,%d13
8002a1c2:	8b 02 20 22 	ne %d2,%d2,0
8002a1c6:	26 32       	and %d2,%d3
8002a1c8:	df 02 2e 7f 	jeq %d2,0,8002a024 <_svfprintf_r+0x14c0>
8002a1cc:	19 a2 24 00 	ld.w %d2,[%sp]36
8002a1d0:	da 30       	mov %d15,48
8002a1d2:	e9 a2 27 10 	st.b [%sp]103,%d2
8002a1d6:	8f 23 40 21 	or %d2,%d3,2
8002a1da:	e9 af 26 10 	st.b [%sp]102,%d15
8002a1de:	59 a2 04 00 	st.w [%sp]4,%d2
8002a1e2:	1d ff 21 ff 	j 8002a024 <_svfprintf_r+0x14c0>
8002a1e6:	8b 18 41 22 	lt %d2,%d8,17
8002a1ea:	19 a3 04 20 	ld.w %d3,[%sp]132
8002a1ee:	df 02 0a 00 	jeq %d2,0,8002a202 <_svfprintf_r+0x169e>
8002a1f2:	1d 00 2b 00 	j 8002a248 <_svfprintf_r+0x16e4>
8002a1f6:	1b 08 ff 8f 	addi %d8,%d8,-16
8002a1fa:	8b 18 81 22 	ge %d2,%d8,17
8002a1fe:	df 02 25 00 	jeq %d2,0,8002a248 <_svfprintf_r+0x16e4>
8002a202:	c2 13       	add %d3,1
8002a204:	1b 0b 01 b0 	addi %d11,%d11,16
8002a208:	e8 0c       	st.a [%a15]0,%a12
8002a20a:	68 19       	st.w [%a15]4,%d9
8002a20c:	59 ab 08 20 	st.w [%sp]136,%d11
8002a210:	59 a3 04 20 	st.w [%sp]132,%d3
8002a214:	8b 83 80 22 	ge %d2,%d3,8
8002a218:	d9 ff 08 00 	lea %a15,[%a15]8
8002a21c:	df 02 ed 7f 	jeq %d2,0,8002a1f6 <_svfprintf_r+0x1692>
8002a220:	60 e5       	mov.a %a5,%d14
8002a222:	60 f4       	mov.a %a4,%d15
8002a224:	d9 a6 00 20 	lea %a6,[%sp]128
8002a228:	6d 00 83 17 	call 8002d12e <__ssprint_r>
8002a22c:	df 02 3a fb 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
8002a230:	1b 08 ff 8f 	addi %d8,%d8,-16
8002a234:	8b 18 81 22 	ge %d2,%d8,17
8002a238:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a23c:	19 a3 04 20 	ld.w %d3,[%sp]132
8002a240:	d9 af 0c 20 	lea %a15,[%sp]140
8002a244:	df 02 df ff 	jne %d2,0,8002a202 <_svfprintf_r+0x169e>
8002a248:	1b 13 00 20 	addi %d2,%d3,1
8002a24c:	42 8b       	add %d11,%d8
8002a24e:	e8 0c       	st.a [%a15]0,%a12
8002a250:	59 a2 04 20 	st.w [%sp]132,%d2
8002a254:	68 18       	st.w [%a15]4,%d8
8002a256:	59 ab 08 20 	st.w [%sp]136,%d11
8002a25a:	8b 82 80 22 	ge %d2,%d2,8
8002a25e:	df 02 c2 83 	jne %d2,0,8002a9e2 <_svfprintf_r+0x1e7e>
8002a262:	79 d3 00 00 	ld.b %d3,[%a13]0
8002a266:	d9 ff 08 00 	lea %a15,[%a15]8
8002a26a:	1d ff 59 ff 	j 8002a11c <_svfprintf_r+0x15b8>
8002a26e:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a272:	60 e5       	mov.a %a5,%d14
8002a274:	d9 a6 00 20 	lea %a6,[%sp]128
8002a278:	59 a5 1c 10 	st.w [%sp]92,%d5
8002a27c:	6d 00 59 17 	call 8002d12e <__ssprint_r>
8002a280:	df 02 9b fa 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002a284:	79 a3 25 10 	ld.b %d3,[%sp]101
8002a288:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a28c:	19 a5 1c 10 	ld.w %d5,[%sp]92
8002a290:	d9 af 0c 20 	lea %a15,[%sp]140
8002a294:	1d ff 26 f5 	j 80028ce0 <_svfprintf_r+0x17c>
8002a298:	60 e5       	mov.a %a5,%d14
8002a29a:	60 f4       	mov.a %a4,%d15
8002a29c:	d9 a6 00 20 	lea %a6,[%sp]128
8002a2a0:	6d 00 47 17 	call 8002d12e <__ssprint_r>
8002a2a4:	df 02 fe fa 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
8002a2a8:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a2ac:	d9 af 0c 20 	lea %a15,[%sp]140
8002a2b0:	1d ff 13 ff 	j 8002a0d6 <_svfprintf_r+0x1572>
8002a2b4:	82 12       	mov %d2,1
8002a2b6:	42 2b       	add %d11,%d2
8002a2b8:	91 00 00 28 	movh.a %a2,32768
8002a2bc:	68 12       	st.w [%a15]4,%d2
8002a2be:	19 a2 04 20 	ld.w %d2,[%sp]132 <80000001 <LCF_STARTPTR_CPU0+0x1>>
8002a2c2:	d9 22 ca 53 	lea %a2,[%a2]15690 <80003d4a <_ctype_b+0x1b9>>
8002a2c6:	c2 12       	add %d2,1
8002a2c8:	e8 02       	st.a [%a15]0,%a2
8002a2ca:	59 ab 08 20 	st.w [%sp]136 <80000000 <LCF_STARTPTR_CPU0>>,%d11
8002a2ce:	59 a2 04 20 	st.w [%sp]132 <80000000 <LCF_STARTPTR_CPU0>>,%d2
8002a2d2:	8b 82 80 22 	ge %d2,%d2,8
8002a2d6:	d9 ff 08 00 	lea %a15,[%a15]8
8002a2da:	df 02 70 82 	jne %d2,0,8002a7ba <_svfprintf_r+0x1c56>
8002a2de:	19 a2 30 00 	ld.w %d2,[%sp]48
8002a2e2:	a6 42       	or %d2,%d4
8002a2e4:	df 02 63 03 	jeq %d2,0,8002a9aa <_svfprintf_r+0x1e46>
8002a2e8:	19 a2 04 10 	ld.w %d2,[%sp]68
8002a2ec:	19 a3 00 10 	ld.w %d3,[%sp]64
8002a2f0:	68 02       	st.w [%a15]0,%d2
8002a2f2:	19 a2 04 20 	ld.w %d2,[%sp]132
8002a2f6:	68 13       	st.w [%a15]4,%d3
8002a2f8:	0b b3 00 50 	add %d5,%d3,%d11
8002a2fc:	1b 12 00 30 	addi %d3,%d2,1
8002a300:	8b 83 80 22 	ge %d2,%d3,8
8002a304:	59 a5 08 20 	st.w [%sp]136,%d5
8002a308:	59 a3 04 20 	st.w [%sp]132,%d3
8002a30c:	d9 ff 08 00 	lea %a15,[%a15]8
8002a310:	df 02 75 82 	jne %d2,0,8002a7fa <_svfprintf_r+0x1c96>
8002a314:	bf 04 d1 03 	jlt %d4,0,8002aab6 <_svfprintf_r+0x1f52>
8002a318:	19 a4 30 00 	ld.w %d4,[%sp]48
8002a31c:	e8 0e       	st.a [%a15]0,%a14
8002a31e:	68 14       	st.w [%a15]4,%d4
8002a320:	0b 54 00 b0 	add %d11,%d4,%d5
8002a324:	1b 13 00 20 	addi %d2,%d3,1
8002a328:	59 ab 08 20 	st.w [%sp]136,%d11
8002a32c:	59 a2 04 20 	st.w [%sp]132,%d2
8002a330:	8b 82 80 22 	ge %d2,%d2,8
8002a334:	df 02 20 75 	jeq %d2,0,80028d74 <_svfprintf_r+0x210>
8002a338:	1d ff a5 fa 	j 80029882 <_svfprintf_r+0xd1e>
8002a33c:	da 30       	mov %d15,48
8002a33e:	b0 e2       	add.a %a2,-2
8002a340:	d9 a3 30 40 	lea %a3,[%sp]304
8002a344:	01 23 20 30 	sub.a %a3,%a3,%a2
8002a348:	e9 ef ff ff 	st.b [%a14]-1,%d15
8002a34c:	b5 a3 14 00 	st.a [%sp]20,%a3
8002a350:	59 a1 04 00 	st.w [%sp]4,%d1
8002a354:	40 2e       	mov.aa %a14,%a2
8002a356:	1d ff f8 f7 	j 80029346 <_svfprintf_r+0x7e2>
8002a35a:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a35e:	60 e5       	mov.a %a5,%d14
8002a360:	d9 a6 00 20 	lea %a6,[%sp]128
8002a364:	6d 00 e5 16 	call 8002d12e <__ssprint_r>
8002a368:	df 02 27 fa 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002a36c:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a370:	d9 af 0c 20 	lea %a15,[%sp]140
8002a374:	1d ff d6 f8 	j 80029520 <_svfprintf_r+0x9bc>
8002a378:	3b 00 40 20 	mov %d2,1024
8002a37c:	26 12       	and %d2,%d1
8002a37e:	40 f6       	mov.aa %a6,%a15
8002a380:	59 ae 04 00 	st.w [%sp]4,%d14
8002a384:	b5 ad 14 00 	st.a [%sp]20,%a13
8002a388:	99 a7 08 00 	ld.a %a7,[%sp]8
8002a38c:	99 ad 14 10 	ld.a %a13,[%sp]84
8002a390:	60 2f       	mov.a %a15,%d2
8002a392:	60 13       	mov.a %a3,%d1
8002a394:	82 0f       	mov %d15,0
8002a396:	d9 a2 30 40 	lea %a2,[%sp]304
8002a39a:	80 4e       	mov.d %d14,%a4
8002a39c:	1d 00 31 00 	j 8002a3fe <_svfprintf_r+0x189a>
8002a3a0:	b7 08 04 2e 	insert %d2,%d8,0,28,4
8002a3a4:	7b d0 cc 7c 	movh %d7,52429
8002a3a8:	42 12       	add %d2,%d1
8002a3aa:	42 2b       	add %d11,%d2
8002a3ac:	7b d0 cc 2c 	movh %d2,52429
8002a3b0:	1b d2 cc 2c 	addi %d2,%d2,-13107
8002a3b4:	73 2b 68 20 	mul.u %e2,%d11,%d2
8002a3b8:	1b d7 cc 7c 	addi %d7,%d7,-13107
8002a3bc:	1b f7 ff 0f 	addi %d0,%d7,-1
8002a3c0:	8f e3 1f 20 	sh %d2,%d3,-2
8002a3c4:	13 b2 3f 2b 	madd %d2,%d11,%d2,-5
8002a3c8:	82 03       	mov %d3,0
8002a3ca:	0b 2c c0 80 	subx %d8,%d12,%d2
8002a3ce:	0b 3d d0 90 	subc %d9,%d13,%d3
8002a3d2:	73 78 68 20 	mul.u %e2,%d8,%d7
8002a3d6:	03 08 0a 33 	madd %d3,%d3,%d8,%d0
8002a3da:	03 79 0a 33 	madd %d3,%d3,%d9,%d7
8002a3de:	77 23 80 af 	dextr %d10,%d3,%d2,31
8002a3e2:	80 c2       	mov.d %d2,%a12
8002a3e4:	0b c2 30 e2 	and.lt.u %d14,%d2,%d12
8002a3e8:	8b 0d 00 e5 	or.ne %d14,%d13,0
8002a3ec:	8f f3 1f 90 	sh %d9,%d3,-1
8002a3f0:	df 0e 4f 00 	jeq %d14,0,8002a48e <_svfprintf_r+0x192a>
8002a3f4:	0b a9 10 c8 	mov %e12,%d9,%d10
8002a3f8:	40 e2       	mov.aa %a2,%a14
8002a3fa:	8b 0d 00 e2 	eq %d14,%d13,0
8002a3fe:	77 cd 00 82 	dextr %d8,%d13,%d12,4
8002a402:	b7 0c 04 1e 	insert %d1,%d12,0,28,4
8002a406:	b7 08 04 2e 	insert %d2,%d8,0,28,4
8002a40a:	8f 8d 1e b0 	sh %d11,%d13,-24
8002a40e:	42 12       	add %d2,%d1
8002a410:	0b b2 00 40 	add %d4,%d2,%d11
8002a414:	7b d0 cc 2c 	movh %d2,52429
8002a418:	1b d2 cc 2c 	addi %d2,%d2,-13107
8002a41c:	73 24 68 20 	mul.u %e2,%d4,%d2
8002a420:	7b d0 cc 7c 	movh %d7,52429
8002a424:	1b d7 cc 7c 	addi %d7,%d7,-13107
8002a428:	8f e3 1f 20 	sh %d2,%d3,-2
8002a42c:	13 b2 3f 24 	madd %d2,%d4,%d2,-5
8002a430:	82 03       	mov %d3,0
8002a432:	1b f7 ff 0f 	addi %d0,%d7,-1
8002a436:	0b 2c c0 20 	subx %d2,%d12,%d2
8002a43a:	0b 3d d0 30 	subc %d3,%d13,%d3
8002a43e:	60 24       	mov.a %a4,%d2
8002a440:	60 35       	mov.a %a5,%d3
8002a442:	73 72 68 20 	mul.u %e2,%d2,%d7
8002a446:	80 44       	mov.d %d4,%a4
8002a448:	80 55       	mov.d %d5,%a5
8002a44a:	03 04 0a 33 	madd %d3,%d3,%d4,%d0
8002a44e:	d9 2e ff ff 	lea %a14,[%a2]-1
8002a452:	c2 1f       	add %d15,1
8002a454:	03 75 0a 33 	madd %d3,%d3,%d5,%d7
8002a458:	77 23 80 af 	dextr %d10,%d3,%d2,31
8002a45c:	8f f3 1f 90 	sh %d9,%d3,-1
8002a460:	33 aa 40 2c 	msub.u %e2,%e12,%d10,10
8002a464:	1b 02 03 20 	addi %d2,%d2,48
8002a468:	e9 22 ff ff 	st.b [%a2]-1,%d2
8002a46c:	bd 0f 9a 7f 	jz.a %a15,8002a3a0 <_svfprintf_r+0x183c>
8002a470:	79 d2 00 00 	ld.b %d2,[%a13]0
8002a474:	8b f2 27 32 	ne %d3,%d2,127
8002a478:	0b f2 00 32 	and.eq %d3,%d2,%d15
8002a47c:	df 03 92 7f 	jeq %d3,0,8002a3a0 <_svfprintf_r+0x183c>
8002a480:	80 c2       	mov.d %d2,%a12
8002a482:	0b c2 30 e2 	and.lt.u %d14,%d2,%d12
8002a486:	8b 0d 00 e5 	or.ne %d14,%d13,0
8002a48a:	df 0e d4 82 	jne %d14,0,8002aa32 <_svfprintf_r+0x1ece>
8002a48e:	d9 a2 30 40 	lea %a2,[%sp]304
8002a492:	01 e2 20 20 	sub.a %a2,%a2,%a14
8002a496:	19 ae 04 00 	ld.w %d14,[%sp]4
8002a49a:	b5 ad 14 10 	st.a [%sp]84,%a13
8002a49e:	78 0c       	st.w [%sp]48,%d15
8002a4a0:	99 ad 14 00 	ld.a %a13,[%sp]20
8002a4a4:	40 6f       	mov.aa %a15,%a6
8002a4a6:	b5 a7 08 00 	st.a [%sp]8,%a7
8002a4aa:	b5 a2 14 00 	st.a [%sp]20,%a2
8002a4ae:	b5 a3 04 00 	st.a [%sp]4,%a3
8002a4b2:	1d ff 4a f7 	j 80029346 <_svfprintf_r+0x7e2>
8002a4b6:	78 02       	st.w [%sp]8,%d15
8002a4b8:	e8 0c       	st.a [%a15]0,%a12
8002a4ba:	68 19       	st.w [%a15]4,%d9
8002a4bc:	42 9b       	add %d11,%d9
8002a4be:	1d ff 33 ff 	j 8002a324 <_svfprintf_r+0x17c0>
8002a4c2:	60 e5       	mov.a %a5,%d14
8002a4c4:	60 f4       	mov.a %a4,%d15
8002a4c6:	d9 a6 00 20 	lea %a6,[%sp]128
8002a4ca:	6d 00 32 16 	call 8002d12e <__ssprint_r>
8002a4ce:	df 02 e9 f9 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
8002a4d2:	79 d3 00 00 	ld.b %d3,[%a13]0
8002a4d6:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a4da:	d9 af 0c 20 	lea %a15,[%sp]140
8002a4de:	1d ff 19 fe 	j 8002a110 <_svfprintf_r+0x15ac>
8002a4e2:	99 a3 20 00 	ld.a %a3,[%sp]32
8002a4e6:	19 a2 10 00 	ld.w %d2,[%sp]16
8002a4ea:	d4 33       	ld.a %a3,[%a3]
8002a4ec:	74 32       	st.w [%a3],%d2
8002a4ee:	b5 a2 20 00 	st.a [%sp]32,%a2
8002a4f2:	1d ff 72 f3 	j 80028bd6 <_svfprintf_r+0x72>
8002a4f6:	8b 62 20 d3 	min.u %d13,%d2,6
8002a4fa:	82 02       	mov %d2,0
8002a4fc:	91 00 00 e8 	movh.a %a14,32768
8002a500:	b5 ac 20 00 	st.a [%sp]32,%a12
8002a504:	59 a2 1c 00 	st.w [%sp]28,%d2
8002a508:	59 ad 14 00 	st.w [%sp]20,%d13
8002a50c:	82 03       	mov %d3,0
8002a50e:	59 a2 0c 00 	st.w [%sp]12,%d2
8002a512:	59 a2 34 00 	st.w [%sp]52,%d2
8002a516:	59 a2 2c 00 	st.w [%sp]44,%d2
8002a51a:	59 a2 28 00 	st.w [%sp]40,%d2
8002a51e:	d9 ee c3 53 	lea %a14,[%a14]15683 <80003d43 <_ctype_b+0x1b2>>
8002a522:	1d ff cd f3 	j 80028cbc <_svfprintf_r+0x158>
8002a526:	78 02       	st.w [%sp]8,%d15
8002a528:	c2 18       	add %d8,1
8002a52a:	42 ba       	add %d10,%d11
8002a52c:	f4 6c       	st.a [%a6],%a12
8002a52e:	59 6b 04 00 	st.w [%a6]4,%d11
8002a532:	59 aa 08 20 	st.w [%sp]136,%d10
8002a536:	59 a8 04 20 	st.w [%sp]132,%d8
8002a53a:	8b 88 80 22 	ge %d2,%d8,8
8002a53e:	df 02 8b 79 	jeq %d2,0,80029854 <_svfprintf_r+0xcf0>
8002a542:	1d ff 0c fb 	j 80029b5a <_svfprintf_r+0xff6>
8002a546:	53 12 40 c0 	mul.u %e12,%d2,1
8002a54a:	82 14       	mov %d4,1
8002a54c:	6f 91 d5 76 	jz.t %d1,9,800292f6 <_svfprintf_r+0x792>
8002a550:	8f f2 0f 21 	and %d2,%d2,255
8002a554:	53 12 40 c0 	mul.u %e12,%d2,1
8002a558:	1d ff cf f6 	j 800292f6 <_svfprintf_r+0x792>
8002a55c:	91 00 00 c8 	movh.a %a12,32768
8002a560:	02 89       	mov %d9,%d8
8002a562:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
8002a566:	1d ff d8 f8 	j 80029716 <_svfprintf_r+0xbb2>
8002a56a:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002a56e:	df f2 73 01 	jeq %d2,-1,8002a854 <_svfprintf_r+0x1cf0>
8002a572:	02 23       	mov %d3,%d2
8002a574:	8b 7d 04 22 	eq %d2,%d13,71
8002a578:	8b 03 00 24 	and.eq %d2,%d3,0
8002a57c:	df 02 6f 01 	jeq %d2,0,8002a85a <_svfprintf_r+0x1cf6>
8002a580:	19 a2 04 00 	ld.w %d2,[%sp]4
8002a584:	19 aa 3c 00 	ld.w %d10,[%sp]60
8002a588:	8f 02 50 b1 	or %d11,%d2,256
8002a58c:	bf 0a 6d 03 	jlt %d10,0,8002ac66 <_svfprintf_r+0x2102>
8002a590:	82 02       	mov %d2,0
8002a592:	59 a2 20 00 	st.w [%sp]32,%d2
8002a596:	82 12       	mov %d2,1
8002a598:	02 28       	mov %d8,%d2
8002a59a:	59 a2 0c 00 	st.w [%sp]12,%d2
8002a59e:	99 ac 38 00 	ld.a %a12,[%sp]56
8002a5a2:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a5a6:	d9 a7 38 10 	lea %a7,[%sp]120
8002a5aa:	d9 a6 2c 10 	lea %a6,[%sp]108
8002a5ae:	d9 a5 28 10 	lea %a5,[%sp]104
8002a5b2:	02 87       	mov %d7,%d8
8002a5b4:	82 26       	mov %d6,2
8002a5b6:	80 c4       	mov.d %d4,%a12
8002a5b8:	02 a5       	mov %d5,%d10
8002a5ba:	6d 00 a1 06 	call 8002b2fc <_dtoa_r>
8002a5be:	8b 7d 24 92 	ne %d9,%d13,71
8002a5c2:	40 2e       	mov.aa %a14,%a2
8002a5c4:	df 09 08 80 	jne %d9,0,8002a5d4 <_svfprintf_r+0x1a70>
8002a5c8:	19 a2 04 00 	ld.w %d2,[%sp]4
8002a5cc:	19 a3 38 10 	ld.w %d3,[%sp]120
8002a5d0:	6f 02 21 00 	jz.t %d2,0,8002a612 <_svfprintf_r+0x1aae>
8002a5d4:	80 e2       	mov.d %d2,%a14
8002a5d6:	42 28       	add %d8,%d2
8002a5d8:	99 a5 38 00 	ld.a %a5,[%sp]56
8002a5dc:	d2 06       	mov %e6,0
8002a5de:	02 a5       	mov %d5,%d10
8002a5e0:	80 54       	mov.d %d4,%a5
8002a5e2:	6d 00 12 24 	call 8002ee06 <__eqdf2>
8002a5e6:	02 83       	mov %d3,%d8
8002a5e8:	df 02 15 00 	jeq %d2,0,8002a612 <_svfprintf_r+0x1aae>
8002a5ec:	19 a3 38 10 	ld.w %d3,[%sp]120
8002a5f0:	7f 83 11 80 	jge.u %d3,%d8,8002a612 <_svfprintf_r+0x1aae>
8002a5f4:	99 a3 08 00 	ld.a %a3,[%sp]8
8002a5f8:	1b 13 00 20 	addi %d2,%d3,1
8002a5fc:	da 30       	mov %d15,48
8002a5fe:	60 32       	mov.a %a2,%d3
8002a600:	59 a2 38 10 	st.w [%sp]120,%d2
8002a604:	2c 20       	st.b [%a2]0,%d15
8002a606:	19 a3 38 10 	ld.w %d3,[%sp]120
8002a60a:	3f 83 f7 ff 	jlt.u %d3,%d8,8002a5f8 <_svfprintf_r+0x1a94>
8002a60e:	b5 a3 08 00 	st.a [%sp]8,%a3
8002a612:	80 e2       	mov.d %d2,%a14
8002a614:	0b 23 80 20 	sub %d2,%d3,%d2
8002a618:	59 a2 30 00 	st.w [%sp]48,%d2
8002a61c:	19 a2 28 10 	ld.w %d2,[%sp]104
8002a620:	59 a2 28 00 	st.w [%sp]40,%d2
8002a624:	df 09 65 81 	jne %d9,0,8002a8ee <_svfprintf_r+0x1d8a>
8002a628:	19 a4 0c 00 	ld.w %d4,[%sp]12
8002a62c:	02 23       	mov %d3,%d2
8002a62e:	0b 24 20 21 	lt %d2,%d4,%d2
8002a632:	8b d3 3f 25 	or.lt %d2,%d3,-3
8002a636:	df 02 98 01 	jeq %d2,0,8002a966 <_svfprintf_r+0x1e02>
8002a63a:	19 a2 24 00 	ld.w %d2,[%sp]36
8002a63e:	82 03       	mov %d3,0
8002a640:	c2 e2       	add %d2,-2
8002a642:	8f 02 c2 d1 	andn %d13,%d2,32
8002a646:	59 a3 1c 00 	st.w [%sp]28,%d3
8002a64a:	59 a2 24 00 	st.w [%sp]36,%d2
8002a64e:	19 a2 24 00 	ld.w %d2,[%sp]36
8002a652:	19 a7 28 00 	ld.w %d7,[%sp]40
8002a656:	1b f2 00 50 	addi %d5,%d2,15
8002a65a:	37 05 48 50 	extr %d5,%d5,0,8
8002a65e:	37 02 48 30 	extr %d3,%d2,0,8
8002a662:	8b 1d 24 62 	ne %d6,%d13,65
8002a666:	2b 53 40 26 	sel %d2,%d6,%d3,%d5
8002a66a:	1b f7 ff 4f 	addi %d4,%d7,-1
8002a66e:	e9 a2 31 10 	st.b [%sp]113,%d2
8002a672:	59 a4 28 10 	st.w [%sp]104,%d4
8002a676:	3b b0 02 20 	mov %d2,43
8002a67a:	ff 04 06 00 	jge %d4,0,8002a686 <_svfprintf_r+0x1b22>
8002a67e:	8b 17 00 41 	rsub %d4,%d7,1
8002a682:	3b d0 02 20 	mov %d2,45
8002a686:	e9 a2 32 10 	st.b [%sp]114,%d2
8002a68a:	8b a4 40 22 	lt %d2,%d4,10
8002a68e:	df 02 a1 82 	jne %d2,0,8002abd0 <_svfprintf_r+0x206c>
8002a692:	d9 a5 3f 10 	lea %a5,[%sp]127
8002a696:	58 02       	ld.w %d15,[%sp]8
8002a698:	40 52       	mov.aa %a2,%a5
8002a69a:	3b a0 00 60 	mov %d6,10
8002a69e:	4b 64 01 22 	div %e2,%d4,%d6
8002a6a2:	40 24       	mov.aa %a4,%a2
8002a6a4:	02 45       	mov %d5,%d4
8002a6a6:	1b 03 03 20 	addi %d2,%d3,48
8002a6aa:	8b 45 86 52 	ge %d5,%d5,100
8002a6ae:	b0 f2       	add.a %a2,-1
8002a6b0:	e9 42 ff ff 	st.b [%a4]-1,%d2
8002a6b4:	7b 60 66 26 	movh %d2,26214
8002a6b8:	1b 72 66 26 	addi %d2,%d2,26215
8002a6bc:	73 24 6a 20 	mul %e2,%d4,%d2
8002a6c0:	8f 14 3e 40 	sha %d4,%d4,-31
8002a6c4:	86 e3       	sha %d3,-2
8002a6c6:	0b 43 80 40 	sub %d4,%d3,%d4
8002a6ca:	df 05 ea ff 	jne %d5,0,8002a69e <_svfprintf_r+0x1b3a>
8002a6ce:	1b 04 03 30 	addi %d3,%d4,48
8002a6d2:	82 22       	mov %d2,2
8002a6d4:	37 03 48 30 	extr %d3,%d3,0,8
8002a6d8:	78 02       	st.w [%sp]8,%d15
8002a6da:	59 a2 0c 10 	st.w [%sp]76,%d2
8002a6de:	80 42       	mov.d %d2,%a4
8002a6e0:	e9 23 ff ff 	st.b [%a2]-1,%d3
8002a6e4:	c2 e2       	add %d2,-2
8002a6e6:	80 54       	mov.d %d4,%a5
8002a6e8:	7f 42 19 80 	jge.u %d2,%d4,8002a71a <_svfprintf_r+0x1bb6>
8002a6ec:	d9 a3 33 10 	lea %a3,[%sp]115
8002a6f0:	1d 00 04 00 	j 8002a6f8 <_svfprintf_r+0x1b94>
8002a6f4:	09 23 01 00 	ld.b %d3,[%a2+]1
8002a6f8:	24 33       	st.b [%a3+],%d3
8002a6fa:	7d 25 fd ff 	jne.a %a5,%a2,8002a6f4 <_svfprintf_r+0x1b90>
8002a6fe:	d9 a2 01 20 	lea %a2,[%sp]129
8002a702:	01 42 20 20 	sub.a %a2,%a2,%a4
8002a706:	d9 a3 33 10 	lea %a3,[%sp]115
8002a70a:	30 23       	add.a %a3,%a2
8002a70c:	d9 a2 31 10 	lea %a2,[%sp]113
8002a710:	01 23 20 20 	sub.a %a2,%a3,%a2
8002a714:	78 02       	st.w [%sp]8,%d15
8002a716:	b5 a2 0c 10 	st.a [%sp]76,%a2
8002a71a:	19 a3 0c 10 	ld.w %d3,[%sp]76
8002a71e:	19 a2 30 00 	ld.w %d2,[%sp]48
8002a722:	42 23       	add %d3,%d2
8002a724:	59 a3 14 00 	st.w [%sp]20,%d3
8002a728:	bf 22 6a 02 	jlt %d2,2,8002abfc <_svfprintf_r+0x2098>
8002a72c:	19 a2 14 00 	ld.w %d2,[%sp]20
8002a730:	19 a3 00 10 	ld.w %d3,[%sp]64
8002a734:	42 32       	add %d2,%d3
8002a736:	59 a2 14 00 	st.w [%sp]20,%d2
8002a73a:	19 a2 04 00 	ld.w %d2,[%sp]4
8002a73e:	b7 02 01 25 	insert %d2,%d2,0,10,1
8002a742:	8f 02 50 21 	or %d2,%d2,256
8002a746:	59 a2 04 00 	st.w [%sp]4,%d2
8002a74a:	19 a2 14 00 	ld.w %d2,[%sp]20
8002a74e:	8b 02 40 d3 	max %d13,%d2,0
8002a752:	82 02       	mov %d2,0
8002a754:	59 a2 34 00 	st.w [%sp]52,%d2
8002a758:	59 a2 2c 00 	st.w [%sp]44,%d2
8002a75c:	59 a2 28 00 	st.w [%sp]40,%d2
8002a760:	19 a2 20 00 	ld.w %d2,[%sp]32
8002a764:	df 02 f4 80 	jne %d2,0,8002a94c <_svfprintf_r+0x1de8>
8002a768:	79 a3 25 10 	ld.b %d3,[%sp]101
8002a76c:	59 ac 20 00 	st.w [%sp]32,%d12
8002a770:	59 a2 0c 00 	st.w [%sp]12,%d2
8002a774:	df 03 a4 72 	jeq %d3,0,80028cbc <_svfprintf_r+0x158>
8002a778:	1d ff 78 f4 	j 80029068 <_svfprintf_r+0x504>
8002a77c:	78 02       	st.w [%sp]8,%d15
8002a77e:	1b 13 00 20 	addi %d2,%d3,1
8002a782:	42 9b       	add %d11,%d9
8002a784:	e8 0c       	st.a [%a15]0,%a12
8002a786:	68 19       	st.w [%a15]4,%d9
8002a788:	59 a2 04 20 	st.w [%sp]132,%d2
8002a78c:	59 ab 08 20 	st.w [%sp]136,%d11
8002a790:	8b 82 80 22 	ge %d2,%d2,8
8002a794:	d9 ff 08 00 	lea %a15,[%a15]8
8002a798:	df 02 53 79 	jeq %d2,0,80029a3e <_svfprintf_r+0xeda>
8002a79c:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a7a0:	60 e5       	mov.a %a5,%d14
8002a7a2:	d9 a6 00 20 	lea %a6,[%sp]128
8002a7a6:	6d 00 c4 14 	call 8002d12e <__ssprint_r>
8002a7aa:	df 02 06 f8 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002a7ae:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a7b2:	d9 af 0c 20 	lea %a15,[%sp]140
8002a7b6:	1d ff 44 f9 	j 80029a3e <_svfprintf_r+0xeda>
8002a7ba:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a7be:	60 e5       	mov.a %a5,%d14
8002a7c0:	d9 a6 00 20 	lea %a6,[%sp]128
8002a7c4:	6d 00 b5 14 	call 8002d12e <__ssprint_r>
8002a7c8:	df 02 f7 f7 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002a7cc:	19 a4 28 10 	ld.w %d4,[%sp]104
8002a7d0:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a7d4:	d9 af 0c 20 	lea %a15,[%sp]140
8002a7d8:	1d ff 83 fd 	j 8002a2de <_svfprintf_r+0x177a>
8002a7dc:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a7e0:	60 e5       	mov.a %a5,%d14
8002a7e2:	d9 a6 00 20 	lea %a6,[%sp]128
8002a7e6:	6d 00 a4 14 	call 8002d12e <__ssprint_r>
8002a7ea:	df 02 e6 f7 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002a7ee:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a7f2:	d9 af 0c 20 	lea %a15,[%sp]140
8002a7f6:	1d ff 1c f9 	j 80029a2e <_svfprintf_r+0xeca>
8002a7fa:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a7fe:	60 e5       	mov.a %a5,%d14
8002a800:	d9 a6 00 20 	lea %a6,[%sp]128
8002a804:	6d 00 95 14 	call 8002d12e <__ssprint_r>
8002a808:	df 02 d7 f7 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002a80c:	19 a4 28 10 	ld.w %d4,[%sp]104
8002a810:	19 a5 08 20 	ld.w %d5,[%sp]136
8002a814:	19 a3 04 20 	ld.w %d3,[%sp]132
8002a818:	d9 af 0c 20 	lea %a15,[%sp]140
8002a81c:	1d ff 7c fd 	j 8002a314 <_svfprintf_r+0x17b0>
8002a820:	19 a4 30 00 	ld.w %d4,[%sp]48
8002a824:	80 e2       	mov.d %d2,%a14
8002a826:	42 42       	add %d2,%d4
8002a828:	0b 34 80 30 	sub %d3,%d4,%d3
8002a82c:	a2 a2       	sub %d2,%d10
8002a82e:	0b 32 80 81 	min %d8,%d2,%d3
8002a832:	1d ff 47 f9 	j 80029ac0 <_svfprintf_r+0xf5c>
8002a836:	99 a3 20 00 	ld.a %a3,[%sp]32
8002a83a:	19 a2 10 00 	ld.w %d2,[%sp]16
8002a83e:	b5 a2 20 00 	st.a [%sp]32,%a2
8002a842:	d4 33       	ld.a %a3,[%a3]
8002a844:	b4 32       	st.h [%a3],%d2
8002a846:	1d ff c8 f1 	j 80028bd6 <_svfprintf_r+0x72>
8002a84a:	82 12       	mov %d2,1
8002a84c:	59 a2 28 10 	st.w [%sp]104,%d2
8002a850:	1d ff b8 fa 	j 80029dc0 <_svfprintf_r+0x125c>
8002a854:	82 62       	mov %d2,6
8002a856:	59 a2 0c 00 	st.w [%sp]12,%d2
8002a85a:	19 a2 04 00 	ld.w %d2,[%sp]4
8002a85e:	8f 02 50 b1 	or %d11,%d2,256
8002a862:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002a866:	bf 02 03 02 	jlt %d2,0,8002ac6c <_svfprintf_r+0x2108>
8002a86a:	02 2a       	mov %d10,%d2
8002a86c:	82 02       	mov %d2,0
8002a86e:	59 a2 20 00 	st.w [%sp]32,%d2
8002a872:	8b 6d 04 22 	eq %d2,%d13,70
8002a876:	df 02 54 01 	jeq %d2,0,8002ab1e <_svfprintf_r+0x1fba>
8002a87a:	19 a9 38 00 	ld.w %d9,[%sp]56
8002a87e:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a882:	19 a7 0c 00 	ld.w %d7,[%sp]12
8002a886:	d9 a7 38 10 	lea %a7,[%sp]120
8002a88a:	d9 a6 2c 10 	lea %a6,[%sp]108
8002a88e:	d9 a5 28 10 	lea %a5,[%sp]104
8002a892:	82 36       	mov %d6,3
8002a894:	02 94       	mov %d4,%d9
8002a896:	02 a5       	mov %d5,%d10
8002a898:	6d 00 32 05 	call 8002b2fc <_dtoa_r>
8002a89c:	d2 06       	mov %e6,0
8002a89e:	79 28 00 00 	ld.b %d8,[%a2]0
8002a8a2:	40 2e       	mov.aa %a14,%a2
8002a8a4:	02 94       	mov %d4,%d9
8002a8a6:	02 a5       	mov %d5,%d10
8002a8a8:	6d 00 cf 22 	call 8002ee46 <__nedf2>
8002a8ac:	8b 08 03 82 	eq %d8,%d8,48
8002a8b0:	8b 02 20 22 	ne %d2,%d2,0
8002a8b4:	26 82       	and %d2,%d8
8002a8b6:	df 02 53 82 	jne %d2,0,8002ad5c <_svfprintf_r+0x21f8>
8002a8ba:	19 a2 28 10 	ld.w %d2,[%sp]104
8002a8be:	19 a3 0c 00 	ld.w %d3,[%sp]12
8002a8c2:	82 19       	mov %d9,1
8002a8c4:	42 32       	add %d2,%d3
8002a8c6:	80 e3       	mov.d %d3,%a14
8002a8c8:	0b 23 00 80 	add %d8,%d3,%d2
8002a8cc:	1d ff 86 fe 	j 8002a5d8 <_svfprintf_r+0x1a74>
8002a8d0:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002a8d4:	99 a4 08 00 	ld.a %a4,[%sp]8
8002a8d8:	1b 12 00 40 	addi %d4,%d2,1
8002a8dc:	6d ff e6 e9 	call 80027ca8 <_malloc_r>
8002a8e0:	40 2e       	mov.aa %a14,%a2
8002a8e2:	bd 02 79 02 	jz.a %a2,8002add4 <_svfprintf_r+0x2270>
8002a8e6:	b5 a2 1c 00 	st.a [%sp]28,%a2
8002a8ea:	1d ff 41 fa 	j 80029d6c <_svfprintf_r+0x1208>
8002a8ee:	8b 6d 04 22 	eq %d2,%d13,70
8002a8f2:	df 02 82 02 	jeq %d2,0,8002adf6 <_svfprintf_r+0x2292>
8002a8f6:	19 a2 04 00 	ld.w %d2,[%sp]4
8002a8fa:	19 a5 0c 00 	ld.w %d5,[%sp]12
8002a8fe:	8f 12 00 41 	and %d4,%d2,1
8002a902:	19 a2 28 00 	ld.w %d2,[%sp]40
8002a906:	a6 54       	or %d4,%d5
8002a908:	bf 12 39 02 	jlt %d2,1,8002ad7a <_svfprintf_r+0x2216>
8002a90c:	19 a6 00 10 	ld.w %d6,[%sp]64
8002a910:	02 23       	mov %d3,%d2
8002a912:	42 63       	add %d3,%d6
8002a914:	42 53       	add %d3,%d5
8002a916:	2b 23 40 24 	sel %d2,%d4,%d3,%d2
8002a91a:	c5 02 26 10 	lea %a2,66 <__TRICORE_DERIVATE_MEMORY_MAP__-0x32a>
8002a91e:	b5 a2 24 00 	st.a [%sp]36,%a2
8002a922:	59 a2 14 00 	st.w [%sp]20,%d2
8002a926:	19 a2 04 00 	ld.w %d2,[%sp]4
8002a92a:	6f a2 af 81 	jnz.t %d2,10,8002ac88 <_svfprintf_r+0x2124>
8002a92e:	19 a2 14 00 	ld.w %d2,[%sp]20
8002a932:	8b 02 40 d3 	max %d13,%d2,0
8002a936:	82 02       	mov %d2,0
8002a938:	59 ab 04 00 	st.w [%sp]4,%d11
8002a93c:	59 a2 1c 00 	st.w [%sp]28,%d2
8002a940:	59 a2 34 00 	st.w [%sp]52,%d2
8002a944:	59 a2 2c 00 	st.w [%sp]44,%d2
8002a948:	1d ff 0c ff 	j 8002a760 <_svfprintf_r+0x1bfc>
8002a94c:	da 2d       	mov %d15,45
8002a94e:	82 02       	mov %d2,0
8002a950:	59 ac 20 00 	st.w [%sp]32,%d12
8002a954:	e9 af 25 10 	st.b [%sp]101,%d15
8002a958:	3b d0 02 30 	mov %d3,45
8002a95c:	59 a2 0c 00 	st.w [%sp]12,%d2
8002a960:	c2 1d       	add %d13,1
8002a962:	1d ff ad f1 	j 80028cbc <_svfprintf_r+0x158>
8002a966:	19 a2 28 00 	ld.w %d2,[%sp]40
8002a96a:	19 a3 30 00 	ld.w %d3,[%sp]48
8002a96e:	3f 32 f4 00 	jlt %d2,%d3,8002ab56 <_svfprintf_r+0x1ff2>
8002a972:	19 a3 04 00 	ld.w %d3,[%sp]4
8002a976:	19 a4 28 00 	ld.w %d4,[%sp]40
8002a97a:	19 a5 00 10 	ld.w %d5,[%sp]64
8002a97e:	8f 13 00 21 	and %d2,%d3,1
8002a982:	2b 54 00 22 	cadd %d2,%d2,%d4,%d5
8002a986:	59 a2 14 00 	st.w [%sp]20,%d2
8002a98a:	6f a3 06 00 	jz.t %d3,10,8002a996 <_svfprintf_r+0x1e32>
8002a98e:	19 a2 28 00 	ld.w %d2,[%sp]40
8002a992:	ff 12 77 01 	jge %d2,1,8002ac80 <_svfprintf_r+0x211c>
8002a996:	19 a2 14 00 	ld.w %d2,[%sp]20
8002a99a:	c5 02 27 10 	lea %a2,67 <__TRICORE_DERIVATE_MEMORY_MAP__-0x329>
8002a99e:	8b 02 40 d3 	max %d13,%d2,0
8002a9a2:	b5 a2 24 00 	st.a [%sp]36,%a2
8002a9a6:	1d ff c8 ff 	j 8002a936 <_svfprintf_r+0x1dd2>
8002a9aa:	19 a2 04 00 	ld.w %d2,[%sp]4
8002a9ae:	6f 02 e5 71 	jz.t %d2,0,80028d78 <_svfprintf_r+0x214>
8002a9b2:	19 a2 04 10 	ld.w %d2,[%sp]68
8002a9b6:	19 a3 00 10 	ld.w %d3,[%sp]64
8002a9ba:	68 02       	st.w [%a15]0,%d2
8002a9bc:	19 a2 04 20 	ld.w %d2,[%sp]132
8002a9c0:	0b b3 00 50 	add %d5,%d3,%d11
8002a9c4:	68 13       	st.w [%a15]4,%d3
8002a9c6:	1b 12 00 30 	addi %d3,%d2,1
8002a9ca:	59 a5 08 20 	st.w [%sp]136,%d5
8002a9ce:	8b 83 80 22 	ge %d2,%d3,8
8002a9d2:	59 a3 04 20 	st.w [%sp]132,%d3
8002a9d6:	df 02 12 ff 	jne %d2,0,8002a7fa <_svfprintf_r+0x1c96>
8002a9da:	d9 ff 08 00 	lea %a15,[%a15]8
8002a9de:	1d ff 9d fc 	j 8002a318 <_svfprintf_r+0x17b4>
8002a9e2:	60 e5       	mov.a %a5,%d14
8002a9e4:	60 f4       	mov.a %a4,%d15
8002a9e6:	d9 a6 00 20 	lea %a6,[%sp]128
8002a9ea:	6d 00 a2 13 	call 8002d12e <__ssprint_r>
8002a9ee:	df 02 59 f7 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
8002a9f2:	79 d3 00 00 	ld.b %d3,[%a13]0
8002a9f6:	19 ab 08 20 	ld.w %d11,[%sp]136
8002a9fa:	d9 af 0c 20 	lea %a15,[%sp]140
8002a9fe:	1d ff 8f fb 	j 8002a11c <_svfprintf_r+0x15b8>
8002aa02:	99 a4 08 00 	ld.a %a4,[%sp]8
8002aa06:	60 e5       	mov.a %a5,%d14
8002aa08:	d9 a6 00 20 	lea %a6,[%sp]128
8002aa0c:	6d 00 91 13 	call 8002d12e <__ssprint_r>
8002aa10:	df 02 d3 f6 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002aa14:	19 a3 28 10 	ld.w %d3,[%sp]104
8002aa18:	19 ab 08 20 	ld.w %d11,[%sp]136
8002aa1c:	d9 af 0c 20 	lea %a15,[%sp]140
8002aa20:	1d ff 35 f8 	j 80029a8a <_svfprintf_r+0xf26>
8002aa24:	91 00 00 c8 	movh.a %a12,32768
8002aa28:	02 89       	mov %d9,%d8
8002aa2a:	d9 cc dc 53 	lea %a12,[%a12]15708 <80003d5c <blanks.1>>
8002aa2e:	1d ff 65 f3 	j 800290f8 <_svfprintf_r+0x594>
8002aa32:	99 a2 18 10 	ld.a %a2,[%sp]88
8002aa36:	99 a5 10 10 	ld.a %a5,[%sp]80
8002aa3a:	b5 a7 28 00 	st.a [%sp]40,%a7
8002aa3e:	01 2e 20 e0 	sub.a %a14,%a14,%a2
8002aa42:	80 24       	mov.d %d4,%a2
8002aa44:	40 e4       	mov.aa %a4,%a14
8002aa46:	b5 a6 1c 00 	st.a [%sp]28,%a6
8002aa4a:	b5 a3 08 00 	st.a [%sp]8,%a3
8002aa4e:	6d ff 3c ee 	call 800286c6 <strncpy>
8002aa52:	79 d2 01 00 	ld.b %d2,[%a13]1
8002aa56:	80 d3       	mov.d %d3,%a13
8002aa58:	ab 13 00 22 	cadd %d2,%d2,%d3,1
8002aa5c:	99 a3 08 00 	ld.a %a3,[%sp]8
8002aa60:	99 a6 1c 00 	ld.a %a6,[%sp]28
8002aa64:	99 a7 28 00 	ld.a %a7,[%sp]40
8002aa68:	60 2d       	mov.a %a13,%d2
8002aa6a:	82 0f       	mov %d15,0
8002aa6c:	1d ff c4 fc 	j 8002a3f4 <_svfprintf_r+0x1890>
8002aa70:	79 a3 25 10 	ld.b %d3,[%sp]101
8002aa74:	19 ad 0c 00 	ld.w %d13,[%sp]12
8002aa78:	b5 ac 20 00 	st.a [%sp]32,%a12
8002aa7c:	1d ff ea f2 	j 80029050 <_svfprintf_r+0x4ec>
8002aa80:	99 a4 08 00 	ld.a %a4,[%sp]8
8002aa84:	60 e5       	mov.a %a5,%d14
8002aa86:	d9 a6 00 20 	lea %a6,[%sp]128
8002aa8a:	6d 00 52 13 	call 8002d12e <__ssprint_r>
8002aa8e:	df 02 94 f6 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002aa92:	19 a2 28 10 	ld.w %d2,[%sp]104
8002aa96:	19 a3 30 00 	ld.w %d3,[%sp]48
8002aa9a:	19 ab 08 20 	ld.w %d11,[%sp]136
8002aa9e:	a2 23       	sub %d3,%d2
8002aaa0:	d9 af 0c 20 	lea %a15,[%sp]140
8002aaa4:	1d ff 0e f8 	j 80029ac0 <_svfprintf_r+0xf5c>
8002aaa8:	91 00 00 c8 	movh.a %a12,32768
8002aaac:	02 89       	mov %d9,%d8
8002aaae:	d9 cc dc 53 	lea %a12,[%a12]15708 <80003d5c <blanks.1>>
8002aab2:	1d ff 70 f7 	j 80029992 <_svfprintf_r+0xe2e>
8002aab6:	8b 04 00 81 	rsub %d8,%d4,0
8002aaba:	91 00 00 c8 	movh.a %a12,32768
8002aabe:	8b 04 9f 42 	ge %d4,%d4,-16
8002aac2:	58 02       	ld.w %d15,[%sp]8
8002aac4:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
8002aac8:	3b 00 01 90 	mov %d9,16
8002aacc:	df 04 0a 00 	jeq %d4,0,8002aae0 <_svfprintf_r+0x1f7c>
8002aad0:	1d 00 5c 00 	j 8002ab88 <_svfprintf_r+0x2024>
8002aad4:	1b 08 ff 8f 	addi %d8,%d8,-16
8002aad8:	8b 18 81 22 	ge %d2,%d8,17
8002aadc:	df 02 55 00 	jeq %d2,0,8002ab86 <_svfprintf_r+0x2022>
8002aae0:	c2 13       	add %d3,1
8002aae2:	1b 05 01 50 	addi %d5,%d5,16
8002aae6:	e8 0c       	st.a [%a15]0,%a12
8002aae8:	68 19       	st.w [%a15]4,%d9
8002aaea:	59 a5 08 20 	st.w [%sp]136,%d5
8002aaee:	59 a3 04 20 	st.w [%sp]132,%d3
8002aaf2:	8b 83 80 22 	ge %d2,%d3,8
8002aaf6:	d9 ff 08 00 	lea %a15,[%a15]8
8002aafa:	df 02 ed 7f 	jeq %d2,0,8002aad4 <_svfprintf_r+0x1f70>
8002aafe:	60 e5       	mov.a %a5,%d14
8002ab00:	60 f4       	mov.a %a4,%d15
8002ab02:	d9 a6 00 20 	lea %a6,[%sp]128
8002ab06:	6d 00 14 13 	call 8002d12e <__ssprint_r>
8002ab0a:	df 02 cb f6 	jne %d2,0,800298a0 <_svfprintf_r+0xd3c>
8002ab0e:	19 a5 08 20 	ld.w %d5,[%sp]136
8002ab12:	19 a3 04 20 	ld.w %d3,[%sp]132
8002ab16:	d9 af 0c 20 	lea %a15,[%sp]140
8002ab1a:	1d ff dd ff 	j 8002aad4 <_svfprintf_r+0x1f70>
8002ab1e:	8b 5d 24 22 	ne %d2,%d13,69
8002ab22:	df 02 6f 81 	jne %d2,0,8002ae00 <_svfprintf_r+0x229c>
8002ab26:	99 ac 38 00 	ld.a %a12,[%sp]56
8002ab2a:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002ab2e:	99 a4 08 00 	ld.a %a4,[%sp]8
8002ab32:	1b 12 00 80 	addi %d8,%d2,1
8002ab36:	d9 a7 38 10 	lea %a7,[%sp]120
8002ab3a:	d9 a6 2c 10 	lea %a6,[%sp]108
8002ab3e:	d9 a5 28 10 	lea %a5,[%sp]104
8002ab42:	02 87       	mov %d7,%d8
8002ab44:	82 26       	mov %d6,2
8002ab46:	80 c4       	mov.d %d4,%a12
8002ab48:	02 a5       	mov %d5,%d10
8002ab4a:	6d 00 d9 03 	call 8002b2fc <_dtoa_r>
8002ab4e:	40 2e       	mov.aa %a14,%a2
8002ab50:	82 19       	mov %d9,1
8002ab52:	1d ff 41 fd 	j 8002a5d4 <_svfprintf_r+0x1a70>
8002ab56:	19 a2 30 00 	ld.w %d2,[%sp]48
8002ab5a:	19 a3 00 10 	ld.w %d3,[%sp]64
8002ab5e:	c5 02 27 10 	lea %a2,67 <__TRICORE_DERIVATE_MEMORY_MAP__-0x329>
8002ab62:	42 23       	add %d3,%d2
8002ab64:	19 a2 28 00 	ld.w %d2,[%sp]40
8002ab68:	b5 a2 24 00 	st.a [%sp]36,%a2
8002ab6c:	59 a3 14 00 	st.w [%sp]20,%d3
8002ab70:	ff 12 db 7e 	jge %d2,1,8002a926 <_svfprintf_r+0x1dc2>
8002ab74:	8b 12 00 21 	rsub %d2,%d2,1
8002ab78:	42 23       	add %d3,%d2
8002ab7a:	8b 03 40 d3 	max %d13,%d3,0
8002ab7e:	59 a3 14 00 	st.w [%sp]20,%d3
8002ab82:	1d ff da fe 	j 8002a936 <_svfprintf_r+0x1dd2>
8002ab86:	78 02       	st.w [%sp]8,%d15
8002ab88:	c2 13       	add %d3,1
8002ab8a:	42 85       	add %d5,%d8
8002ab8c:	e8 0c       	st.a [%a15]0,%a12
8002ab8e:	68 18       	st.w [%a15]4,%d8
8002ab90:	59 a5 08 20 	st.w [%sp]136,%d5
8002ab94:	59 a3 04 20 	st.w [%sp]132,%d3
8002ab98:	8b 83 80 22 	ge %d2,%d3,8
8002ab9c:	df 02 1f 7f 	jeq %d2,0,8002a9da <_svfprintf_r+0x1e76>
8002aba0:	99 a4 08 00 	ld.a %a4,[%sp]8
8002aba4:	60 e5       	mov.a %a5,%d14
8002aba6:	d9 a6 00 20 	lea %a6,[%sp]128
8002abaa:	6d 00 c2 12 	call 8002d12e <__ssprint_r>
8002abae:	df 02 04 f6 	jne %d2,0,800297b6 <_svfprintf_r+0xc52>
8002abb2:	19 a5 08 20 	ld.w %d5,[%sp]136
8002abb6:	19 a3 04 20 	ld.w %d3,[%sp]132
8002abba:	d9 af 0c 20 	lea %a15,[%sp]140
8002abbe:	1d ff ad fb 	j 8002a318 <_svfprintf_r+0x17b4>
8002abc2:	91 00 00 c8 	movh.a %a12,32768
8002abc6:	02 89       	mov %d9,%d8
8002abc8:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
8002abcc:	1d ff 47 f5 	j 8002965a <_svfprintf_r+0xaf6>
8002abd0:	8b 1d 04 d2 	eq %d13,%d13,65
8002abd4:	d9 a3 33 10 	lea %a3,[%sp]115
8002abd8:	df 0d 07 80 	jne %d13,0,8002abe6 <_svfprintf_r+0x2082>
8002abdc:	da 30       	mov %d15,48
8002abde:	d9 a3 34 10 	lea %a3,[%sp]116
8002abe2:	e9 af 33 10 	st.b [%sp]115,%d15
8002abe6:	1b 04 03 40 	addi %d4,%d4,48
8002abea:	d9 a2 31 10 	lea %a2,[%sp]113
8002abee:	24 34       	st.b [%a3+],%d4
8002abf0:	01 23 20 20 	sub.a %a2,%a3,%a2
8002abf4:	b5 a2 0c 10 	st.a [%sp]76,%a2
8002abf8:	1d ff 91 fd 	j 8002a71a <_svfprintf_r+0x1bb6>
8002abfc:	19 a2 04 00 	ld.w %d2,[%sp]4
8002ac00:	6f 02 9d 7d 	jz.t %d2,0,8002a73a <_svfprintf_r+0x1bd6>
8002ac04:	1d ff 94 fd 	j 8002a72c <_svfprintf_r+0x1bc8>
8002ac08:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002ac0c:	60 a2       	mov.a %a2,%d10
8002ac0e:	59 a2 38 10 	st.w [%sp]120,%d2
8002ac12:	79 22 ff ff 	ld.b %d2,[%a2]-1
8002ac16:	99 a2 14 00 	ld.a %a2,[%sp]20
8002ac1a:	60 a3       	mov.a %a3,%d10
8002ac1c:	79 23 0f 00 	ld.b %d3,[%a2]15
8002ac20:	5f 32 13 80 	jne %d2,%d3,8002ac46 <_svfprintf_r+0x20e2>
8002ac24:	99 a4 08 00 	ld.a %a4,[%sp]8
8002ac28:	da 30       	mov %d15,48
8002ac2a:	e9 3f ff ff 	st.b [%a3]-1,%d15
8002ac2e:	99 a3 38 10 	ld.a %a3,[%sp]120
8002ac32:	d9 32 ff ff 	lea %a2,[%a3]-1
8002ac36:	b5 a2 38 10 	st.a [%sp]120,%a2
8002ac3a:	79 32 ff ff 	ld.b %d2,[%a3]-1
8002ac3e:	5f 23 f5 7f 	jeq %d3,%d2,8002ac28 <_svfprintf_r+0x20c4>
8002ac42:	b5 a4 08 00 	st.a [%sp]8,%a4
8002ac46:	1b 12 00 30 	addi %d3,%d2,1
8002ac4a:	3b 90 03 40 	mov %d4,57
8002ac4e:	37 03 48 30 	extr %d3,%d3,0,8
8002ac52:	5f 42 06 80 	jne %d2,%d4,8002ac5e <_svfprintf_r+0x20fa>
8002ac56:	99 a2 14 00 	ld.a %a2,[%sp]20
8002ac5a:	79 23 0a 00 	ld.b %d3,[%a2]10
8002ac5e:	e9 33 ff ff 	st.b [%a3]-1,%d3
8002ac62:	1d ff 27 f9 	j 80029eb0 <_svfprintf_r+0x134c>
8002ac66:	82 12       	mov %d2,1
8002ac68:	59 a2 0c 00 	st.w [%sp]12,%d2
8002ac6c:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002ac70:	c5 02 2d 00 	lea %a2,2d <__TRICORE_DERIVATE_MEMORY_MAP__-0x363>
8002ac74:	9b 02 00 a8 	addih %d10,%d2,32768
8002ac78:	b5 a2 20 00 	st.a [%sp]32,%a2
8002ac7c:	1d ff fb fd 	j 8002a872 <_svfprintf_r+0x1d0e>
8002ac80:	c5 02 27 10 	lea %a2,67 <__TRICORE_DERIVATE_MEMORY_MAP__-0x329>
8002ac84:	b5 a2 24 00 	st.a [%sp]36,%a2
8002ac88:	99 a2 14 10 	ld.a %a2,[%sp]84
8002ac8c:	82 04       	mov %d4,0
8002ac8e:	3b f0 07 30 	mov %d3,127
8002ac92:	79 22 00 00 	ld.b %d2,[%a2]0
8002ac96:	59 a4 34 00 	st.w [%sp]52,%d4
8002ac9a:	59 a4 2c 00 	st.w [%sp]44,%d4
8002ac9e:	5f 32 19 00 	jeq %d2,%d3,8002acd0 <_svfprintf_r+0x216c>
8002aca2:	19 a4 28 00 	ld.w %d4,[%sp]40
8002aca6:	58 02       	ld.w %d15,[%sp]8
8002aca8:	7f 42 0f 00 	jge %d2,%d4,8002acc6 <_svfprintf_r+0x2162>
8002acac:	a2 24       	sub %d4,%d2
8002acae:	79 22 01 00 	ld.b %d2,[%a2]1
8002acb2:	df 02 25 00 	jeq %d2,0,8002acfc <_svfprintf_r+0x2198>
8002acb6:	19 a5 2c 00 	ld.w %d5,[%sp]44
8002acba:	b0 12       	add.a %a2,1
8002acbc:	c2 15       	add %d5,1
8002acbe:	59 a5 2c 00 	st.w [%sp]44,%d5
8002acc2:	5f 32 f3 ff 	jne %d2,%d3,8002aca8 <_svfprintf_r+0x2144>
8002acc6:	b5 a2 14 10 	st.a [%sp]84,%a2
8002acca:	59 a4 28 00 	st.w [%sp]40,%d4
8002acce:	78 02       	st.w [%sp]8,%d15
8002acd0:	19 a3 34 00 	ld.w %d3,[%sp]52
8002acd4:	19 a2 2c 00 	ld.w %d2,[%sp]44
8002acd8:	19 a4 14 00 	ld.w %d4,[%sp]20
8002acdc:	42 32       	add %d2,%d3
8002acde:	19 a3 18 10 	ld.w %d3,[%sp]88
8002ace2:	59 ab 04 00 	st.w [%sp]4,%d11
8002ace6:	03 32 0a 24 	madd %d2,%d4,%d2,%d3
8002acea:	59 a2 14 00 	st.w [%sp]20,%d2
8002acee:	8b 02 40 d3 	max %d13,%d2,0
8002acf2:	82 02       	mov %d2,0
8002acf4:	59 a2 1c 00 	st.w [%sp]28,%d2
8002acf8:	1d ff 34 fd 	j 8002a760 <_svfprintf_r+0x1bfc>
8002acfc:	19 a2 34 00 	ld.w %d2,[%sp]52
8002ad00:	c2 12       	add %d2,1
8002ad02:	59 a2 34 00 	st.w [%sp]52,%d2
8002ad06:	79 22 00 00 	ld.b %d2,[%a2]0
8002ad0a:	1d ff dc ff 	j 8002acc2 <_svfprintf_r+0x215e>
8002ad0e:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002ad12:	79 a3 25 10 	ld.b %d3,[%sp]101
8002ad16:	ff 02 07 00 	jge %d2,0,8002ad24 <_svfprintf_r+0x21c0>
8002ad1a:	da 2d       	mov %d15,45
8002ad1c:	3b d0 02 30 	mov %d3,45
8002ad20:	e9 af 25 10 	st.b [%sp]101,%d15
8002ad24:	91 00 00 38 	movh.a %a3,32768
8002ad28:	80 34       	mov.d %d4,%a3
8002ad2a:	19 a2 24 00 	ld.w %d2,[%sp]36
8002ad2e:	91 00 00 28 	movh.a %a2,32768
8002ad32:	1b d4 d1 53 	addi %d5,%d4,15645
8002ad36:	80 24       	mov.d %d4,%a2
8002ad38:	8b 82 44 22 	lt %d2,%d2,72
8002ad3c:	1b 94 d1 43 	addi %d4,%d4,15641
8002ad40:	1d ff 79 f1 	j 80029032 <_svfprintf_r+0x4ce>
8002ad44:	60 e2       	mov.a %a2,%d14
8002ad46:	c9 23 0c 00 	ld.h %d3,[%a2]12
8002ad4a:	1d ff b9 f5 	j 800298bc <_svfprintf_r+0xd58>
8002ad4e:	91 00 00 c8 	movh.a %a12,32768
8002ad52:	02 9b       	mov %d11,%d9
8002ad54:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
8002ad58:	1d ff e8 fb 	j 8002a528 <_svfprintf_r+0x19c4>
8002ad5c:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002ad60:	8b 12 00 21 	rsub %d2,%d2,1
8002ad64:	59 a2 28 10 	st.w [%sp]104,%d2
8002ad68:	1d ff ab fd 	j 8002a8be <_svfprintf_r+0x1d5a>
8002ad6c:	91 00 00 c8 	movh.a %a12,32768
8002ad70:	02 89       	mov %d9,%d8
8002ad72:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
8002ad76:	1d ff a1 fb 	j 8002a4b8 <_svfprintf_r+0x1954>
8002ad7a:	82 1d       	mov %d13,1
8002ad7c:	c5 02 26 10 	lea %a2,66 <__TRICORE_DERIVATE_MEMORY_MAP__-0x32a>
8002ad80:	b5 a2 24 00 	st.a [%sp]36,%a2
8002ad84:	59 ad 14 00 	st.w [%sp]20,%d13
8002ad88:	df 04 d7 7d 	jeq %d4,0,8002a936 <_svfprintf_r+0x1dd2>
8002ad8c:	19 a2 00 10 	ld.w %d2,[%sp]64
8002ad90:	19 a3 0c 00 	ld.w %d3,[%sp]12
8002ad94:	42 d2       	add %d2,%d13
8002ad96:	42 23       	add %d3,%d2
8002ad98:	8b 03 40 d3 	max %d13,%d3,0
8002ad9c:	59 a3 14 00 	st.w [%sp]20,%d3
8002ada0:	1d ff cb fd 	j 8002a936 <_svfprintf_r+0x1dd2>
8002ada4:	99 a3 20 00 	ld.a %a3,[%sp]32
8002ada8:	79 d3 01 00 	ld.b %d3,[%a13]1
8002adac:	60 fe       	mov.a %a14,%d15
8002adae:	40 34       	mov.aa %a4,%a3
8002adb0:	54 42       	ld.w %d2,[%a4]
8002adb2:	b0 43       	add.a %a3,4
8002adb4:	8b f2 5f 23 	max %d2,%d2,-1
8002adb8:	b5 a3 20 00 	st.a [%sp]32,%a3
8002adbc:	40 2d       	mov.aa %a13,%a2
8002adbe:	59 a2 0c 00 	st.w [%sp]12,%d2
8002adc2:	1d ff 5b ef 	j 80028c78 <_svfprintf_r+0x114>
8002adc6:	91 00 00 c8 	movh.a %a12,32768
8002adca:	02 89       	mov %d9,%d8
8002adcc:	d9 cc cc 53 	lea %a12,[%a12]15692 <80003d4c <zeroes.0>>
8002add0:	1d ff d7 fc 	j 8002a77e <_svfprintf_r+0x1c1a>
8002add4:	60 e2       	mov.a %a2,%d14
8002add6:	c9 23 0c 00 	ld.h %d3,[%a2]12
8002adda:	8f 03 44 21 	or %d2,%d3,64
8002adde:	02 23       	mov %d3,%d2
8002ade0:	f9 22 0c 00 	st.h [%a2]12,%d2
8002ade4:	1d ff 6c f5 	j 800298bc <_svfprintf_r+0xd58>
8002ade8:	99 a2 30 00 	ld.a %a2,[%sp]48
8002adec:	30 e2       	add.a %a2,%a14
8002adee:	b5 a2 0c 00 	st.a [%sp]12,%a2
8002adf2:	1d ff a8 f9 	j 8002a142 <_svfprintf_r+0x15de>
8002adf6:	82 02       	mov %d2,0
8002adf8:	59 a2 1c 00 	st.w [%sp]28,%d2
8002adfc:	1d ff 29 fc 	j 8002a64e <_svfprintf_r+0x1aea>
8002ae00:	19 a8 0c 00 	ld.w %d8,[%sp]12
8002ae04:	1d ff cd fb 	j 8002a59e <_svfprintf_r+0x1a3a>
8002ae08:	3b c0 00 20 	mov %d2,12
8002ae0c:	68 02       	st.w [%a15]0,%d2
8002ae0e:	82 f2       	mov %d2,-1
8002ae10:	59 a2 10 00 	st.w [%sp]16,%d2
8002ae14:	1d ff 5c f5 	j 800298cc <_svfprintf_r+0xd68>

8002ae18 <_fclose_r>:
8002ae18:	40 4d       	mov.aa %a13,%a4
8002ae1a:	40 5c       	mov.aa %a12,%a5
8002ae1c:	bd 05 0c 00 	jz.a %a5,8002ae34 <_fclose_r+0x1c>
8002ae20:	bd 04 06 00 	jz.a %a4,8002ae2c <_fclose_r+0x14>
8002ae24:	19 42 34 00 	ld.w %d2,[%a4]52
8002ae28:	df 02 40 00 	jeq %d2,0,8002aea8 <_fclose_r+0x90>
8002ae2c:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002ae30:	df 02 05 80 	jne %d2,0,8002ae3a <_fclose_r+0x22>
8002ae34:	82 08       	mov %d8,0
8002ae36:	02 82       	mov %d2,%d8
8002ae38:	00 90       	ret 
8002ae3a:	40 c5       	mov.aa %a5,%a12
8002ae3c:	40 d4       	mov.aa %a4,%a13
8002ae3e:	6d 00 40 00 	call 8002aebe <__sflush_r>
8002ae42:	99 c2 2c 00 	ld.a %a2,[%a12]44
8002ae46:	02 28       	mov %d8,%d2
8002ae48:	bd 02 0b 00 	jz.a %a2,8002ae5e <_fclose_r+0x46>
8002ae4c:	99 c5 1c 00 	ld.a %a5,[%a12]28
8002ae50:	40 d4       	mov.aa %a4,%a13
8002ae52:	2d 02 00 00 	calli %a2
8002ae56:	8b 02 80 22 	ge %d2,%d2,0
8002ae5a:	ab f8 9f 82 	sel %d8,%d2,%d8,-1
8002ae5e:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002ae62:	6f 72 27 80 	jnz.t %d2,7,8002aeb0 <_fclose_r+0x98>
8002ae66:	99 c5 30 00 	ld.a %a5,[%a12]48
8002ae6a:	bd 05 0c 00 	jz.a %a5,8002ae82 <_fclose_r+0x6a>
8002ae6e:	d9 c2 00 10 	lea %a2,[%a12]64
8002ae72:	7d 25 05 00 	jeq.a %a5,%a2,8002ae7c <_fclose_r+0x64>
8002ae76:	40 d4       	mov.aa %a4,%a13
8002ae78:	6d ff 2f ed 	call 800288d6 <_free_r>
8002ae7c:	82 02       	mov %d2,0
8002ae7e:	59 c2 30 00 	st.w [%a12]48,%d2
8002ae82:	99 c5 04 10 	ld.a %a5,[%a12]68
8002ae86:	bd 05 08 00 	jz.a %a5,8002ae96 <_fclose_r+0x7e>
8002ae8a:	40 d4       	mov.aa %a4,%a13
8002ae8c:	6d ff 25 ed 	call 800288d6 <_free_r>
8002ae90:	82 02       	mov %d2,0
8002ae92:	59 c2 04 10 	st.w [%a12]68,%d2
8002ae96:	6d ff 1e eb 	call 800284d2 <__sfp_lock_acquire>
8002ae9a:	82 02       	mov %d2,0
8002ae9c:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002aea0:	6d ff 1a eb 	call 800284d4 <__sfp_lock_release>
8002aea4:	02 82       	mov %d2,%d8
8002aea6:	00 90       	ret 
8002aea8:	6d ff 01 eb 	call 800284aa <__sinit>
8002aeac:	1d ff c0 ff 	j 8002ae2c <_fclose_r+0x14>
8002aeb0:	99 c5 10 00 	ld.a %a5,[%a12]16
8002aeb4:	40 d4       	mov.aa %a4,%a13
8002aeb6:	6d ff 10 ed 	call 800288d6 <_free_r>
8002aeba:	1d ff d6 ff 	j 8002ae66 <_fclose_r+0x4e>

8002aebe <__sflush_r>:
8002aebe:	c9 53 0c 00 	ld.h %d3,[%a5]12
8002aec2:	40 4d       	mov.aa %a13,%a4
8002aec4:	40 5c       	mov.aa %a12,%a5
8002aec6:	6f 33 41 80 	jnz.t %d3,3,8002af48 <__sflush_r+0x8a>
8002aeca:	b7 f3 81 45 	insert %d4,%d3,15,11,1
8002aece:	19 52 04 00 	ld.w %d2,[%a5]4
8002aed2:	f9 54 0c 00 	st.h [%a5]12,%d4
8002aed6:	bf 12 65 00 	jlt %d2,1,8002afa0 <__sflush_r+0xe2>
8002aeda:	99 c2 28 00 	ld.a %a2,[%a12]40
8002aede:	bd 02 65 00 	jz.a %a2,8002afa8 <__sflush_r+0xea>
8002aee2:	82 02       	mov %d2,0
8002aee4:	54 d8       	ld.w %d8,[%a13]
8002aee6:	99 c5 1c 00 	ld.a %a5,[%a12]28
8002aeea:	74 d2       	st.w [%a13],%d2
8002aeec:	6f c3 60 80 	jnz.t %d3,12,8002afac <__sflush_r+0xee>
8002aef0:	82 15       	mov %d5,1
8002aef2:	82 04       	mov %d4,0
8002aef4:	40 d4       	mov.aa %a4,%a13
8002aef6:	2d 02 00 00 	calli %a2
8002aefa:	df f2 95 00 	jeq %d2,-1,8002b024 <__sflush_r+0x166>
8002aefe:	99 c2 28 00 	ld.a %a2,[%a12]40
8002af02:	c9 c4 0c 00 	ld.h %d4,[%a12]12
8002af06:	6f 24 0c 00 	jz.t %d4,2,8002af1e <__sflush_r+0x60>
8002af0a:	19 c3 04 00 	ld.w %d3,[%a12]4
8002af0e:	a2 32       	sub %d2,%d3
8002af10:	19 c3 30 00 	ld.w %d3,[%a12]48
8002af14:	df 03 05 00 	jeq %d3,0,8002af1e <__sflush_r+0x60>
8002af18:	19 c3 3c 00 	ld.w %d3,[%a12]60
8002af1c:	a2 32       	sub %d2,%d3
8002af1e:	99 c5 1c 00 	ld.a %a5,[%a12]28
8002af22:	82 05       	mov %d5,0
8002af24:	02 24       	mov %d4,%d2
8002af26:	40 d4       	mov.aa %a4,%a13
8002af28:	2d 02 00 00 	calli %a2
8002af2c:	df f2 44 80 	jne %d2,-1,8002afb4 <__sflush_r+0xf6>
8002af30:	54 d4       	ld.w %d4,[%a13]
8002af32:	8b e4 61 32 	lt.u %d3,%d4,30
8002af36:	df 03 5f 80 	jne %d3,0,8002aff4 <__sflush_r+0x136>
8002af3a:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002af3e:	8f 03 44 31 	or %d3,%d3,64
8002af42:	f9 c3 0c 00 	st.h [%a12]12,%d3
8002af46:	00 90       	ret 
8002af48:	19 59 10 00 	ld.w %d9,[%a5]16
8002af4c:	df 09 2e 00 	jeq %d9,0,8002afa8 <__sflush_r+0xea>
8002af50:	54 52       	ld.w %d2,[%a5]
8002af52:	74 59       	st.w [%a5],%d9
8002af54:	0b 92 80 80 	sub %d8,%d2,%d9
8002af58:	8f 33 00 21 	and %d2,%d3,3
8002af5c:	82 03       	mov %d3,0
8002af5e:	df 02 04 80 	jne %d2,0,8002af66 <__sflush_r+0xa8>
8002af62:	19 53 14 00 	ld.w %d3,[%a5]20
8002af66:	59 c3 08 00 	st.w [%a12]8,%d3
8002af6a:	ff 18 08 00 	jge %d8,1,8002af7a <__sflush_r+0xbc>
8002af6e:	1d 00 1d 00 	j 8002afa8 <__sflush_r+0xea>
8002af72:	a2 28       	sub %d8,%d2
8002af74:	42 29       	add %d9,%d2
8002af76:	bf 18 19 00 	jlt %d8,1,8002afa8 <__sflush_r+0xea>
8002af7a:	99 c2 24 00 	ld.a %a2,[%a12]36
8002af7e:	99 c5 1c 00 	ld.a %a5,[%a12]28
8002af82:	60 96       	mov.a %a6,%d9
8002af84:	02 84       	mov %d4,%d8
8002af86:	40 d4       	mov.aa %a4,%a13
8002af88:	2d 02 00 00 	calli %a2
8002af8c:	ff 12 f3 7f 	jge %d2,1,8002af72 <__sflush_r+0xb4>
8002af90:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002af94:	8f 02 44 21 	or %d2,%d2,64
8002af98:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002af9c:	82 f2       	mov %d2,-1
8002af9e:	00 90       	ret 
8002afa0:	19 52 3c 00 	ld.w %d2,[%a5]60
8002afa4:	ff 12 9b 7f 	jge %d2,1,8002aeda <__sflush_r+0x1c>
8002afa8:	82 02       	mov %d2,0
8002afaa:	00 90       	ret 
8002afac:	19 c2 10 10 	ld.w %d2,[%a12]80
8002afb0:	1d ff ab ff 	j 8002af06 <__sflush_r+0x48>
8002afb4:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002afb8:	b7 03 81 45 	insert %d4,%d3,0,11,1
8002afbc:	f9 c4 0c 00 	st.h [%a12]12,%d4
8002afc0:	82 04       	mov %d4,0
8002afc2:	59 c4 04 00 	st.w [%a12]4,%d4
8002afc6:	19 c4 10 00 	ld.w %d4,[%a12]16
8002afca:	74 c4       	st.w [%a12],%d4
8002afcc:	6f c3 04 00 	jz.t %d3,12,8002afd4 <__sflush_r+0x116>
8002afd0:	59 c2 10 10 	st.w [%a12]80,%d2
8002afd4:	99 c5 30 00 	ld.a %a5,[%a12]48
8002afd8:	74 d8       	st.w [%a13],%d8
8002afda:	bd 05 e7 7f 	jz.a %a5,8002afa8 <__sflush_r+0xea>
8002afde:	d9 c2 00 10 	lea %a2,[%a12]64
8002afe2:	7d 25 05 00 	jeq.a %a5,%a2,8002afec <__sflush_r+0x12e>
8002afe6:	40 d4       	mov.aa %a4,%a13
8002afe8:	6d ff 77 ec 	call 800288d6 <_free_r>
8002afec:	82 02       	mov %d2,0
8002afee:	59 c2 30 00 	st.w [%a12]48,%d2
8002aff2:	00 90       	ret 
8002aff4:	7b 00 fc 5d 	movh %d5,57280
8002aff8:	c2 e5       	add %d5,-2
8002affa:	57 05 61 54 	extr.u %d5,%d5,%d4,1
8002affe:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002b002:	df 05 9e ff 	jne %d5,0,8002af3e <__sflush_r+0x80>
8002b006:	b7 03 81 65 	insert %d6,%d3,0,11,1
8002b00a:	59 c5 04 00 	st.w [%a12]4,%d5
8002b00e:	19 c5 10 00 	ld.w %d5,[%a12]16
8002b012:	74 c5       	st.w [%a12],%d5
8002b014:	f9 c6 0c 00 	st.h [%a12]12,%d6
8002b018:	6f c3 de 7f 	jz.t %d3,12,8002afd4 <__sflush_r+0x116>
8002b01c:	df 04 dc ff 	jne %d4,0,8002afd4 <__sflush_r+0x116>
8002b020:	1d ff d8 ff 	j 8002afd0 <__sflush_r+0x112>
8002b024:	54 d3       	ld.w %d3,[%a13]
8002b026:	df 03 6c 7f 	jeq %d3,0,8002aefe <__sflush_r+0x40>
8002b02a:	8b d3 01 42 	eq %d4,%d3,29
8002b02e:	8b 63 e1 44 	or.eq %d4,%d3,22
8002b032:	df 04 05 00 	jeq %d4,0,8002b03c <__sflush_r+0x17e>
8002b036:	74 d8       	st.w [%a13],%d8
8002b038:	1d ff b8 ff 	j 8002afa8 <__sflush_r+0xea>
8002b03c:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002b040:	8f 03 44 31 	or %d3,%d3,64
8002b044:	f9 c3 0c 00 	st.h [%a12]12,%d3
8002b048:	00 90       	ret 

8002b04a <_fflush_r>:
8002b04a:	40 4c       	mov.aa %a12,%a4
8002b04c:	40 5d       	mov.aa %a13,%a5
8002b04e:	bd 04 06 00 	jz.a %a4,8002b05a <_fflush_r+0x10>
8002b052:	19 42 34 00 	ld.w %d2,[%a4]52
8002b056:	df 02 0d 00 	jeq %d2,0,8002b070 <_fflush_r+0x26>
8002b05a:	c9 d3 0c 00 	ld.h %d3,[%a13]12
8002b05e:	82 02       	mov %d2,0
8002b060:	df 03 03 80 	jne %d3,0,8002b066 <_fflush_r+0x1c>
8002b064:	00 90       	ret 
8002b066:	40 d5       	mov.aa %a5,%a13
8002b068:	40 c4       	mov.aa %a4,%a12
8002b06a:	6d ff 2a ff 	call 8002aebe <__sflush_r>
8002b06e:	00 90       	ret 
8002b070:	6d ff 1d ea 	call 800284aa <__sinit>
8002b074:	1d ff f3 ff 	j 8002b05a <_fflush_r+0x10>

8002b078 <memchr>:
8002b078:	80 42       	mov.d %d2,%a4
8002b07a:	8f 32 00 21 	and %d2,%d2,3
8002b07e:	8f f4 0f 61 	and %d6,%d4,255
8002b082:	40 43       	mov.aa %a3,%a4
8002b084:	df 02 19 00 	jeq %d2,0,8002b0b6 <memchr+0x3e>
8002b088:	1b f5 ff 2f 	addi %d2,%d5,-1
8002b08c:	a0 02       	mov.a %a2,0
8002b08e:	df 05 0d 80 	jne %d5,0,8002b0a8 <memchr+0x30>
8002b092:	1d 00 4f 00 	j 8002b130 <memchr+0xb8>
8002b096:	80 33       	mov.d %d3,%a3
8002b098:	8f 33 00 31 	and %d3,%d3,3
8002b09c:	40 34       	mov.aa %a4,%a3
8002b09e:	df 03 0d 00 	jeq %d3,0,8002b0b8 <memchr+0x40>
8002b0a2:	c2 f2       	add %d2,-1
8002b0a4:	df f2 07 00 	jeq %d2,-1,8002b0b2 <memchr+0x3a>
8002b0a8:	40 32       	mov.aa %a2,%a3
8002b0aa:	04 33       	ld.bu %d3,[%a3+]
8002b0ac:	5f 63 f5 ff 	jne %d3,%d6,8002b096 <memchr+0x1e>
8002b0b0:	00 90       	ret 
8002b0b2:	a0 02       	mov.a %a2,0
8002b0b4:	00 90       	ret 
8002b0b6:	02 52       	mov %d2,%d5
8002b0b8:	ff 42 11 80 	jge.u %d2,4,8002b0da <memchr+0x62>
8002b0bc:	a0 02       	mov.a %a2,0
8002b0be:	df 02 f9 7f 	jeq %d2,0,8002b0b0 <memchr+0x38>
8002b0c2:	40 43       	mov.aa %a3,%a4
8002b0c4:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
8002b0c8:	1d 00 04 00 	j 8002b0d0 <memchr+0x58>
8002b0cc:	7d 43 f3 7f 	jeq.a %a3,%a4,8002b0b2 <memchr+0x3a>
8002b0d0:	40 32       	mov.aa %a2,%a3
8002b0d2:	04 32       	ld.bu %d2,[%a3+]
8002b0d4:	5f 62 fc ff 	jne %d2,%d6,8002b0cc <memchr+0x54>
8002b0d8:	00 90       	ret 
8002b0da:	8f f4 0f 31 	and %d3,%d4,255
8002b0de:	8f 83 00 40 	sh %d4,%d3,8
8002b0e2:	a6 43       	or %d3,%d4
8002b0e4:	8f 03 01 50 	sh %d5,%d3,16
8002b0e8:	a6 35       	or %d5,%d3
8002b0ea:	80 44       	mov.d %d4,%a4
8002b0ec:	1b c2 ff 3f 	addi %d3,%d2,-4
8002b0f0:	8f 33 c0 31 	andn %d3,%d3,3
8002b0f4:	c2 44       	add %d4,4
8002b0f6:	7b f0 ef 1f 	movh %d1,65279
8002b0fa:	7b 10 08 78 	movh %d7,32897
8002b0fe:	40 42       	mov.aa %a2,%a4
8002b100:	0b 43 00 00 	add %d0,%d3,%d4
8002b104:	1b f1 ef 1f 	addi %d1,%d1,-257
8002b108:	1b 07 08 78 	addi %d7,%d7,-32640
8002b10c:	40 24       	mov.aa %a4,%a2
8002b10e:	54 43       	ld.w %d3,[%a4]
8002b110:	b0 42       	add.a %a2,4
8002b112:	c6 53       	xor %d3,%d5
8002b114:	0b 13 00 40 	add %d4,%d3,%d1
8002b118:	0f 34 e0 30 	andn %d3,%d4,%d3
8002b11c:	26 73       	and %d3,%d7
8002b11e:	df 03 cf ff 	jne %d3,0,8002b0bc <memchr+0x44>
8002b122:	80 23       	mov.d %d3,%a2
8002b124:	c2 c2       	add %d2,-4
8002b126:	40 24       	mov.aa %a4,%a2
8002b128:	5f 03 f2 ff 	jne %d3,%d0,8002b10c <memchr+0x94>
8002b12c:	1d ff c8 ff 	j 8002b0bc <memchr+0x44>
8002b130:	00 90       	ret 

8002b132 <__locale_mb_cur_max>:
8002b132:	91 10 00 27 	movh.a %a2,28673
8002b136:	d9 22 70 ea 	lea %a2,[%a2]-22608 <7000a7b0 <__global_locale>>
8002b13a:	79 22 28 40 	ld.b %d2,[%a2]296 <70010128 <ram_heap+0x5094>>
8002b13e:	00 90       	ret 

8002b140 <_localeconv_r>:
8002b140:	91 10 00 27 	movh.a %a2,28673
8002b144:	d9 22 a0 2a 	lea %a2,[%a2]-22368 <7000a8a0 <__global_locale+0xf0>>
8002b148:	00 90       	ret 

8002b14a <frexp>:
8002b14a:	82 00       	mov %d0,0
8002b14c:	0b 45 10 28 	mov %e2,%d5,%d4
8002b150:	b7 03 81 6f 	insert %d6,%d3,0,31,1
8002b154:	74 40       	st.w [%a4],%d0
8002b156:	7b 00 ff 07 	movh %d0,32752
8002b15a:	40 4c       	mov.aa %a12,%a4
8002b15c:	02 37       	mov %d7,%d3
8002b15e:	7f 06 1f 00 	jge %d6,%d0,8002b19c <frexp+0x52>
8002b162:	0f 26 a0 10 	or %d1,%d6,%d2
8002b166:	df 01 1b 00 	jeq %d1,0,8002b19c <frexp+0x52>
8002b16a:	26 03       	and %d3,%d0
8002b16c:	82 00       	mov %d0,0
8002b16e:	df 03 0c 80 	jne %d3,0,8002b186 <frexp+0x3c>
8002b172:	82 06       	mov %d6,0
8002b174:	7b 00 35 74 	movh %d7,17232
8002b178:	6d ff 18 e2 	call 800275a8 <__muldf3>
8002b17c:	b7 03 81 6f 	insert %d6,%d3,0,31,1
8002b180:	02 37       	mov %d7,%d3
8002b182:	3b a0 fc 0f 	mov %d0,-54
8002b186:	8f c6 3e 30 	sha %d3,%d6,-20
8002b18a:	1b 23 c0 3f 	addi %d3,%d3,-1022
8002b18e:	42 03       	add %d3,%d0
8002b190:	b7 07 0b 7a 	insert %d7,%d7,0,20,11
8002b194:	74 c3       	st.w [%a12],%d3
8002b196:	7b 00 fe 33 	movh %d3,16352
8002b19a:	a6 73       	or %d3,%d7
8002b19c:	00 90       	ret 

8002b19e <quorem>:
8002b19e:	19 57 10 00 	ld.w %d7,[%a5]16
8002b1a2:	19 43 10 00 	ld.w %d3,[%a4]16
8002b1a6:	40 4d       	mov.aa %a13,%a4
8002b1a8:	82 02       	mov %d2,0
8002b1aa:	3f 73 a7 00 	jlt %d3,%d7,8002b2f8 <quorem+0x15a>
8002b1ae:	1b f7 ff 8f 	addi %d8,%d7,-1
8002b1b2:	8f 28 00 20 	sh %d2,%d8,2
8002b1b6:	60 24       	mov.a %a4,%d2
8002b1b8:	80 d2       	mov.d %d2,%a13
8002b1ba:	1b 42 01 b0 	addi %d11,%d2,20
8002b1be:	d9 5c 14 00 	lea %a12,[%a5]20
8002b1c2:	01 4c 10 20 	add.a %a2,%a12,%a4
8002b1c6:	01 4b 00 46 	addsc.a %a4,%a4,%d11,0
8002b1ca:	54 22       	ld.w %d2,[%a2]
8002b1cc:	54 43       	ld.w %d3,[%a4]
8002b1ce:	c2 12       	add %d2,1
8002b1d0:	4b 23 11 c2 	div.u %e12,%d3,%d2
8002b1d4:	80 29       	mov.d %d9,%a2
8002b1d6:	02 ca       	mov %d10,%d12
8002b1d8:	3f 23 49 80 	jlt.u %d3,%d2,8002b26a <quorem+0xcc>
8002b1dc:	60 b2       	mov.a %a2,%d11
8002b1de:	40 c3       	mov.aa %a3,%a12
8002b1e0:	d2 04       	mov %e4,0
8002b1e2:	40 36       	mov.aa %a6,%a3
8002b1e4:	54 62       	ld.w %d2,[%a6]
8002b1e6:	54 26       	ld.w %d6,[%a2]
8002b1e8:	b7 02 10 38 	insert %d3,%d2,0,16,16
8002b1ec:	40 26       	mov.aa %a6,%a2
8002b1ee:	03 a3 0a 34 	madd %d3,%d4,%d3,%d10
8002b1f2:	8f 02 1f 40 	sh %d4,%d2,-16
8002b1f6:	b0 43       	add.a %a3,4
8002b1f8:	8f 03 1f 20 	sh %d2,%d3,-16
8002b1fc:	03 a4 0a 22 	madd %d2,%d2,%d4,%d10
8002b200:	b7 03 10 38 	insert %d3,%d3,0,16,16
8002b204:	b0 42       	add.a %a2,4
8002b206:	a2 35       	sub %d5,%d3
8002b208:	b7 06 10 38 	insert %d3,%d6,0,16,16
8002b20c:	8f 02 1f 40 	sh %d4,%d2,-16
8002b210:	b7 02 10 28 	insert %d2,%d2,0,16,16
8002b214:	42 53       	add %d3,%d5
8002b216:	8f 06 1f 50 	sh %d5,%d6,-16
8002b21a:	a2 25       	sub %d5,%d2
8002b21c:	8f 03 3f 20 	sha %d2,%d3,-16
8002b220:	42 52       	add %d2,%d5
8002b222:	8f 02 3f 50 	sha %d5,%d2,-16
8002b226:	37 23 10 28 	insert %d2,%d3,%d2,16,16
8002b22a:	74 62       	st.w [%a6],%d2
8002b22c:	80 32       	mov.d %d2,%a3
8002b22e:	7f 29 da ff 	jge.u %d9,%d2,8002b1e2 <quorem+0x44>
8002b232:	54 42       	ld.w %d2,[%a4]
8002b234:	df 02 1b 80 	jne %d2,0,8002b26a <quorem+0xcc>
8002b238:	80 42       	mov.d %d2,%a4
8002b23a:	c2 c2       	add %d2,-4
8002b23c:	7f 2b 15 80 	jge.u %d11,%d2,8002b266 <quorem+0xc8>
8002b240:	80 d2       	mov.d %d2,%a13
8002b242:	8b 72 1e 21 	rsub %d2,%d2,-25
8002b246:	80 44       	mov.d %d4,%a4
8002b248:	42 42       	add %d2,%d4
8002b24a:	1b e7 ff 3f 	addi %d3,%d7,-2
8002b24e:	06 e2       	sh %d2,-2
8002b250:	a2 23       	sub %d3,%d2
8002b252:	1d 00 05 00 	j 8002b25c <quorem+0xbe>
8002b256:	c2 f8       	add %d8,-1
8002b258:	5f 38 07 00 	jeq %d8,%d3,8002b266 <quorem+0xc8>
8002b25c:	19 42 fc ff 	ld.w %d2,[%a4]-4
8002b260:	b0 c4       	add.a %a4,-4
8002b262:	df 02 fa 7f 	jeq %d2,0,8002b256 <quorem+0xb8>
8002b266:	59 d8 10 00 	st.w [%a13]16,%d8
8002b26a:	40 d4       	mov.aa %a4,%a13
8002b26c:	6d 00 d7 0b 	call 8002ca1a <__mcmp>
8002b270:	bf 02 43 00 	jlt %d2,0,8002b2f6 <quorem+0x158>
8002b274:	60 b2       	mov.a %a2,%d11
8002b276:	1b 1c 00 a0 	addi %d10,%d12,1
8002b27a:	82 04       	mov %d4,0
8002b27c:	40 c3       	mov.aa %a3,%a12
8002b27e:	54 33       	ld.w %d3,[%a3]
8002b280:	54 25       	ld.w %d5,[%a2]
8002b282:	b7 03 10 28 	insert %d2,%d3,0,16,16
8002b286:	8f 03 1f 30 	sh %d3,%d3,-16
8002b28a:	a2 24       	sub %d4,%d2
8002b28c:	b7 05 10 28 	insert %d2,%d5,0,16,16
8002b290:	40 23       	mov.aa %a3,%a2
8002b292:	42 42       	add %d2,%d4
8002b294:	8f 05 1f 40 	sh %d4,%d5,-16
8002b298:	a2 34       	sub %d4,%d3
8002b29a:	8f 02 3f 30 	sha %d3,%d2,-16
8002b29e:	42 43       	add %d3,%d4
8002b2a0:	37 32 10 28 	insert %d2,%d2,%d3,16,16
8002b2a4:	b0 4c       	add.a %a12,4
8002b2a6:	8f 03 3f 40 	sha %d4,%d3,-16
8002b2aa:	b0 42       	add.a %a2,4
8002b2ac:	74 32       	st.w [%a3],%d2
8002b2ae:	80 c2       	mov.d %d2,%a12
8002b2b0:	7f 29 e6 ff 	jge.u %d9,%d2,8002b27c <quorem+0xde>
8002b2b4:	8f 28 00 20 	sh %d2,%d8,2
8002b2b8:	60 22       	mov.a %a2,%d2
8002b2ba:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
8002b2be:	54 22       	ld.w %d2,[%a2]
8002b2c0:	df 02 1b 80 	jne %d2,0,8002b2f6 <quorem+0x158>
8002b2c4:	80 22       	mov.d %d2,%a2
8002b2c6:	c2 c2       	add %d2,-4
8002b2c8:	7f 2b 15 80 	jge.u %d11,%d2,8002b2f2 <quorem+0x154>
8002b2cc:	80 d2       	mov.d %d2,%a13
8002b2ce:	8b 72 1e 21 	rsub %d2,%d2,-25
8002b2d2:	80 24       	mov.d %d4,%a2
8002b2d4:	42 42       	add %d2,%d4
8002b2d6:	1b f8 ff 3f 	addi %d3,%d8,-1
8002b2da:	06 e2       	sh %d2,-2
8002b2dc:	a2 23       	sub %d3,%d2
8002b2de:	1d 00 05 00 	j 8002b2e8 <quorem+0x14a>
8002b2e2:	c2 f8       	add %d8,-1
8002b2e4:	5f 38 07 00 	jeq %d8,%d3,8002b2f2 <quorem+0x154>
8002b2e8:	19 22 fc ff 	ld.w %d2,[%a2]-4
8002b2ec:	b0 c2       	add.a %a2,-4
8002b2ee:	df 02 fa 7f 	jeq %d2,0,8002b2e2 <quorem+0x144>
8002b2f2:	59 d8 10 00 	st.w [%a13]16,%d8
8002b2f6:	02 a2       	mov %d2,%d10
8002b2f8:	00 90       	ret 
	...

8002b2fc <_dtoa_r>:
8002b2fc:	20 58       	sub.a %sp,88
8002b2fe:	b5 a5 0c 00 	st.a [%sp]12,%a5
8002b302:	99 45 38 00 	ld.a %a5,[%a4]56
8002b306:	74 a6       	st.w [%sp],%d6
8002b308:	59 a7 14 00 	st.w [%sp]20,%d7
8002b30c:	b5 a7 04 00 	st.a [%sp]4,%a7
8002b310:	59 a4 28 00 	st.w [%sp]40,%d4
8002b314:	80 4d       	mov.d %d13,%a4
8002b316:	02 4a       	mov %d10,%d4
8002b318:	02 59       	mov %d9,%d5
8002b31a:	40 6c       	mov.aa %a12,%a6
8002b31c:	02 5b       	mov %d11,%d5
8002b31e:	bd 05 11 00 	jz.a %a5,8002b340 <_dtoa_r+0x44>
8002b322:	19 42 3c 00 	ld.w %d2,[%a4]60
8002b326:	82 13       	mov %d3,1
8002b328:	0f 23 00 30 	sh %d3,%d3,%d2
8002b32c:	59 52 04 00 	st.w [%a5]4,%d2
8002b330:	59 53 08 00 	st.w [%a5]8,%d3
8002b334:	6d 00 8b 08 	call 8002c44a <_Bfree>
8002b338:	82 02       	mov %d2,0
8002b33a:	60 d2       	mov.a %a2,%d13
8002b33c:	59 22 38 00 	st.w [%a2]56,%d2
8002b340:	02 98       	mov %d8,%d9
8002b342:	bf 09 11 01 	jlt %d9,0,8002b564 <_dtoa_r+0x268>
8002b346:	82 02       	mov %d2,0
8002b348:	74 c2       	st.w [%a12],%d2
8002b34a:	7b 00 ff 27 	movh %d2,32752
8002b34e:	0f 28 80 30 	and %d3,%d8,%d2
8002b352:	5f 23 14 01 	jeq %d3,%d2,8002b57a <_dtoa_r+0x27e>
8002b356:	d2 06       	mov %e6,0
8002b358:	02 a4       	mov %d4,%d10
8002b35a:	02 b5       	mov %d5,%d11
8002b35c:	59 aa 20 00 	st.w [%sp]32,%d10
8002b360:	59 ab 24 00 	st.w [%sp]36,%d11
8002b364:	6d 00 51 1d 	call 8002ee06 <__eqdf2>
8002b368:	df 02 14 80 	jne %d2,0,8002b390 <_dtoa_r+0x94>
8002b36c:	82 12       	mov %d2,1
8002b36e:	99 a2 0c 00 	ld.a %a2,[%sp]12
8002b372:	91 00 00 d8 	movh.a %a13,32768
8002b376:	d9 dd c4 63 	lea %a13,[%a13]15748 <80003d84 <blanks.1+0x28>>
8002b37a:	74 22       	st.w [%a2],%d2
8002b37c:	19 a2 04 00 	ld.w %d2,[%sp]4 <80003d84 <blanks.1+0x28>>
8002b380:	df 02 06 00 	jeq %d2,0,8002b38c <_dtoa_r+0x90>
8002b384:	60 23       	mov.a %a3,%d2
8002b386:	d9 d2 01 00 	lea %a2,[%a13]1 <80000001 <LCF_STARTPTR_CPU0+0x1>>
8002b38a:	f4 32       	st.a [%a3],%a2
8002b38c:	40 d2       	mov.aa %a2,%a13
8002b38e:	00 90       	ret 
8002b390:	60 d4       	mov.a %a4,%d13
8002b392:	02 a4       	mov %d4,%d10
8002b394:	d9 a6 10 10 	lea %a6,[%sp]80
8002b398:	d9 a5 14 10 	lea %a5,[%sp]84
8002b39c:	02 b5       	mov %d5,%d11
8002b39e:	6d 00 36 0c 	call 8002cc0a <__d2b>
8002b3a2:	8f c8 1e 40 	sh %d4,%d8,-20
8002b3a6:	80 2e       	mov.d %d14,%a2
8002b3a8:	df 04 02 81 	jne %d4,0,8002b5ac <_dtoa_r+0x2b0>
8002b3ac:	19 a2 14 10 	ld.w %d2,[%sp]84
8002b3b0:	19 a9 10 10 	ld.w %d9,[%sp]80
8002b3b4:	0b 29 00 c0 	add %d12,%d9,%d2
8002b3b8:	1b 2c 43 20 	addi %d2,%d12,1074
8002b3bc:	8b 02 02 41 	rsub %d4,%d2,32
8002b3c0:	8b 12 42 32 	lt %d3,%d2,33
8002b3c4:	0f 4a 00 40 	sh %d4,%d10,%d4
8002b3c8:	df 03 0e 80 	jne %d3,0,8002b3e4 <_dtoa_r+0xe8>
8002b3cc:	8b 02 04 21 	rsub %d2,%d2,64
8002b3d0:	1b 2c 41 40 	addi %d4,%d12,1042
8002b3d4:	0f 28 00 80 	sh %d8,%d8,%d2
8002b3d8:	8b 04 00 21 	rsub %d2,%d4,0
8002b3dc:	0f 2a 00 20 	sh %d2,%d10,%d2
8002b3e0:	0f 28 a0 40 	or %d4,%d8,%d2
8002b3e4:	6d 00 06 1e 	call 8002eff0 <__floatunsidf>
8002b3e8:	82 14       	mov %d4,1
8002b3ea:	9b 03 e1 3f 	addih %d3,%d3,65040
8002b3ee:	1b fc ff 8f 	addi %d8,%d12,-1
8002b3f2:	59 a4 38 00 	st.w [%sp]56,%d4
8002b3f6:	82 06       	mov %d6,0
8002b3f8:	7b 80 ff 73 	movh %d7,16376
8002b3fc:	02 24       	mov %d4,%d2
8002b3fe:	02 35       	mov %d5,%d3
8002b400:	6d ff b1 e0 	call 80027562 <__subdf3>
8002b404:	0b 23 10 48 	mov %e4,%d3,%d2
8002b408:	7b f0 36 66 	movh %d6,25455
8002b40c:	7b 30 fd 73 	movh %d7,16339
8002b410:	1b 16 36 64 	addi %d6,%d6,17249
8002b414:	1b 77 7a 78 	addi %d7,%d7,-30809
8002b418:	6d ff c8 e0 	call 800275a8 <__muldf3>
8002b41c:	0b 23 10 48 	mov %e4,%d3,%d2
8002b420:	7b 10 b6 68 	movh %d6,35681
8002b424:	7b 70 fc 73 	movh %d7,16327
8002b428:	1b 36 8b 6c 	addi %d6,%d6,-14157
8002b42c:	1b 87 a2 78 	addi %d7,%d7,-30168
8002b430:	6d ff 7c e0 	call 80027528 <__adddf3>
8002b434:	02 84       	mov %d4,%d8
8002b436:	60 2d       	mov.a %a13,%d2
8002b438:	60 3c       	mov.a %a12,%d3
8002b43a:	6d 00 a0 1d 	call 8002ef7a <__floatsidf>
8002b43e:	0b 23 10 48 	mov %e4,%d3,%d2
8002b442:	7b f0 09 65 	movh %d6,20639
8002b446:	7b 30 fd 73 	movh %d7,16339
8002b44a:	1b b6 9f 67 	addi %d6,%d6,31227
8002b44e:	1b 37 41 74 	addi %d7,%d7,17427
8002b452:	6d ff ab e0 	call 800275a8 <__muldf3>
8002b456:	0b 23 10 68 	mov %e6,%d3,%d2
8002b45a:	80 d4       	mov.d %d4,%a13
8002b45c:	80 c5       	mov.d %d5,%a12
8002b45e:	6d ff 65 e0 	call 80027528 <__adddf3>
8002b462:	02 24       	mov %d4,%d2
8002b464:	02 35       	mov %d5,%d3
8002b466:	60 2d       	mov.a %a13,%d2
8002b468:	60 3c       	mov.a %a12,%d3
8002b46a:	6d ff d1 e1 	call 8002780c <__fixdfsi>
8002b46e:	d2 06       	mov %e6,0
8002b470:	80 d4       	mov.d %d4,%a13
8002b472:	80 c5       	mov.d %d5,%a12
8002b474:	02 2c       	mov %d12,%d2
8002b476:	6d 00 28 1d 	call 8002eec6 <__ltdf2>
8002b47a:	ff 02 0d 00 	jge %d2,0,8002b494 <_dtoa_r+0x198>
8002b47e:	02 c4       	mov %d4,%d12
8002b480:	6d 00 7d 1d 	call 8002ef7a <__floatsidf>
8002b484:	0b 23 10 48 	mov %e4,%d3,%d2
8002b488:	80 d6       	mov.d %d6,%a13
8002b48a:	80 c7       	mov.d %d7,%a12
8002b48c:	6d 00 dd 1c 	call 8002ee46 <__nedf2>
8002b490:	ab fc 1f c2 	cadd %d12,%d2,%d12,-1
8002b494:	0b 89 80 80 	sub %d8,%d9,%d8
8002b498:	1b f8 ff 2f 	addi %d2,%d8,-1
8002b49c:	59 a2 08 00 	st.w [%sp]8,%d2
8002b4a0:	8b 7c a1 22 	ge.u %d2,%d12,23
8002b4a4:	df 02 41 82 	jne %d2,0,8002b926 <_dtoa_r+0x62a>
8002b4a8:	91 00 00 38 	movh.a %a3,32768
8002b4ac:	8f 3c 00 20 	sh %d2,%d12,3
8002b4b0:	d9 33 cc c3 	lea %a3,[%a3]16140 <80003f0c <__mprec_tens>>
8002b4b4:	99 a6 20 00 	ld.a %a6,[%sp]32 <80003f0c <__mprec_tens>>
8002b4b8:	99 a7 24 00 	ld.a %a7,[%sp]36 <80003f0c <__mprec_tens>>
8002b4bc:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
8002b4c0:	80 64       	mov.d %d4,%a6
8002b4c2:	09 36 40 09 	ld.d %e6,[%a3]
8002b4c6:	80 75       	mov.d %d5,%a7
8002b4c8:	6d 00 ff 1c 	call 8002eec6 <__ltdf2>
8002b4cc:	ff 02 82 00 	jge %d2,0,8002b5d0 <_dtoa_r+0x2d4>
8002b4d0:	82 02       	mov %d2,0
8002b4d2:	c2 fc       	add %d12,-1
8002b4d4:	59 a2 34 00 	st.w [%sp]52,%d2
8002b4d8:	82 02       	mov %d2,0
8002b4da:	59 a2 10 00 	st.w [%sp]16,%d2
8002b4de:	1b f8 ff 2f 	addi %d2,%d8,-1
8002b4e2:	bf 02 80 00 	jlt %d2,0,8002b5e2 <_dtoa_r+0x2e6>
8002b4e6:	ff 0c 87 00 	jge %d12,0,8002b5f4 <_dtoa_r+0x2f8>
8002b4ea:	19 a2 10 00 	ld.w %d2,[%sp]16
8002b4ee:	59 ac 1c 00 	st.w [%sp]28,%d12
8002b4f2:	a2 c2       	sub %d2,%d12
8002b4f4:	82 19       	mov %d9,1
8002b4f6:	59 a2 10 00 	st.w [%sp]16,%d2
8002b4fa:	8b 0c 00 21 	rsub %d2,%d12,0
8002b4fe:	82 0c       	mov %d12,0
8002b500:	59 a2 2c 00 	st.w [%sp]44,%d2
8002b504:	54 a2       	ld.w %d2,[%sp]
8002b506:	ff a2 85 80 	jge.u %d2,10,8002b610 <_dtoa_r+0x314>
8002b50a:	bf 62 05 00 	jlt %d2,6,8002b514 <_dtoa_r+0x218>
8002b50e:	c2 c2       	add %d2,-4
8002b510:	82 09       	mov %d9,0
8002b512:	74 a2       	st.w [%sp],%d2
8002b514:	54 a2       	ld.w %d2,[%sp]
8002b516:	c2 e2       	add %d2,-2
8002b518:	bf 42 15 82 	jlt.u %d2,4,8002b942 <_dtoa_r+0x646>
8002b51c:	82 02       	mov %d2,0
8002b51e:	60 d2       	mov.a %a2,%d13
8002b520:	60 d4       	mov.a %a4,%d13
8002b522:	59 22 3c 00 	st.w [%a2]60,%d2
8002b526:	82 04       	mov %d4,0
8002b528:	6d 00 5b 07 	call 8002c3de <_Balloc>
8002b52c:	80 2f       	mov.d %d15,%a2
8002b52e:	df 0f 24 07 	jeq %d15,0,8002c376 <_dtoa_r+0x107a>
8002b532:	19 a3 14 10 	ld.w %d3,[%sp]84
8002b536:	60 d2       	mov.a %a2,%d13
8002b538:	19 a4 1c 00 	ld.w %d4,[%sp]28
8002b53c:	8b 03 80 22 	ge %d2,%d3,0
8002b540:	6c 2e       	st.w [%a2]56,%d15
8002b542:	8b f4 40 24 	and.lt %d2,%d4,15
8002b546:	df 02 80 85 	jne %d2,0,8002c046 <_dtoa_r+0xd4a>
8002b54a:	82 f2       	mov %d2,-1
8002b54c:	59 a2 18 00 	st.w [%sp]24,%d2
8002b550:	59 a2 3c 00 	st.w [%sp]60,%d2
8002b554:	82 02       	mov %d2,0
8002b556:	59 a2 14 00 	st.w [%sp]20,%d2
8002b55a:	82 12       	mov %d2,1
8002b55c:	59 a2 30 00 	st.w [%sp]48,%d2
8002b560:	1d 00 1d 01 	j 8002b79a <_dtoa_r+0x49e>
8002b564:	82 12       	mov %d2,1
8002b566:	b7 09 81 bf 	insert %d11,%d9,0,31,1
8002b56a:	74 c2       	st.w [%a12],%d2
8002b56c:	02 b8       	mov %d8,%d11
8002b56e:	7b 00 ff 27 	movh %d2,32752
8002b572:	0f 28 80 30 	and %d3,%d8,%d2
8002b576:	5f 23 f0 fe 	jne %d3,%d2,8002b356 <_dtoa_r+0x5a>
8002b57a:	3b f0 70 22 	mov %d2,9999
8002b57e:	99 a2 0c 00 	ld.a %a2,[%sp]12
8002b582:	74 22       	st.w [%a2],%d2
8002b584:	b7 08 0c 2a 	insert %d2,%d8,0,20,12
8002b588:	a6 a2       	or %d2,%d10
8002b58a:	df 02 c2 01 	jeq %d2,0,8002b90e <_dtoa_r+0x612>
8002b58e:	19 a2 04 00 	ld.w %d2,[%sp]4
8002b592:	91 00 00 d8 	movh.a %a13,32768
8002b596:	d9 dd c0 63 	lea %a13,[%a13]15744 <80003d80 <blanks.1+0x24>>
8002b59a:	df 02 f9 7e 	jeq %d2,0,8002b38c <_dtoa_r+0x90>
8002b59e:	d9 d2 03 00 	lea %a2,[%a13]3 <80000003 <LCF_STARTPTR_CPU0+0x3>>
8002b5a2:	99 a3 04 00 	ld.a %a3,[%sp]4 <80000003 <LCF_STARTPTR_CPU0+0x3>>
8002b5a6:	f4 32       	st.a [%a3],%a2
8002b5a8:	40 d2       	mov.aa %a2,%a13
8002b5aa:	00 90       	ret 
8002b5ac:	19 a3 24 00 	ld.w %d3,[%sp]36
8002b5b0:	1b 14 c0 8f 	addi %d8,%d4,-1023
8002b5b4:	82 04       	mov %d4,0
8002b5b6:	b7 03 0c 3a 	insert %d3,%d3,0,20,12
8002b5ba:	7b 00 ff 53 	movh %d5,16368
8002b5be:	19 a2 20 00 	ld.w %d2,[%sp]32
8002b5c2:	19 a9 10 10 	ld.w %d9,[%sp]80
8002b5c6:	a6 53       	or %d3,%d5
8002b5c8:	59 a4 38 00 	st.w [%sp]56,%d4
8002b5cc:	1d ff 15 ff 	j 8002b3f6 <_dtoa_r+0xfa>
8002b5d0:	82 02       	mov %d2,0
8002b5d2:	59 a2 34 00 	st.w [%sp]52,%d2
8002b5d6:	59 a2 10 00 	st.w [%sp]16,%d2
8002b5da:	1b f8 ff 2f 	addi %d2,%d8,-1
8002b5de:	ff 02 0b 00 	jge %d2,0,8002b5f4 <_dtoa_r+0x2f8>
8002b5e2:	8b 18 00 21 	rsub %d2,%d8,1
8002b5e6:	59 a2 10 00 	st.w [%sp]16,%d2
8002b5ea:	82 02       	mov %d2,0
8002b5ec:	59 a2 08 00 	st.w [%sp]8,%d2
8002b5f0:	bf 0c 7d 7f 	jlt %d12,0,8002b4ea <_dtoa_r+0x1ee>
8002b5f4:	19 a2 08 00 	ld.w %d2,[%sp]8
8002b5f8:	59 ac 1c 00 	st.w [%sp]28,%d12
8002b5fc:	42 c2       	add %d2,%d12
8002b5fe:	82 19       	mov %d9,1
8002b600:	59 a2 08 00 	st.w [%sp]8,%d2
8002b604:	82 02       	mov %d2,0
8002b606:	59 a2 2c 00 	st.w [%sp]44,%d2
8002b60a:	54 a2       	ld.w %d2,[%sp]
8002b60c:	bf a2 7f ff 	jlt.u %d2,10,8002b50a <_dtoa_r+0x20e>
8002b610:	82 02       	mov %d2,0
8002b612:	59 a9 30 00 	st.w [%sp]48,%d9
8002b616:	74 a2       	st.w [%sp],%d2
8002b618:	82 f2       	mov %d2,-1
8002b61a:	59 a2 18 00 	st.w [%sp]24,%d2
8002b61e:	82 02       	mov %d2,0
8002b620:	59 a2 14 00 	st.w [%sp]20,%d2
8002b624:	82 02       	mov %d2,0
8002b626:	60 d2       	mov.a %a2,%d13
8002b628:	82 04       	mov %d4,0
8002b62a:	59 22 3c 00 	st.w [%a2]60,%d2
8002b62e:	19 a2 18 00 	ld.w %d2,[%sp]24
8002b632:	59 a2 3c 00 	st.w [%sp]60,%d2
8002b636:	60 d4       	mov.a %a4,%d13
8002b638:	6d 00 d3 06 	call 8002c3de <_Balloc>
8002b63c:	80 2f       	mov.d %d15,%a2
8002b63e:	df 0f 9c 06 	jeq %d15,0,8002c376 <_dtoa_r+0x107a>
8002b642:	19 a2 18 00 	ld.w %d2,[%sp]24
8002b646:	60 d2       	mov.a %a2,%d13
8002b648:	8b f2 60 22 	lt.u %d2,%d2,15
8002b64c:	6c 2e       	st.w [%a2]56,%d15
8002b64e:	26 29       	and %d9,%d2
8002b650:	df 09 92 00 	jeq %d9,0,8002b774 <_dtoa_r+0x478>
8002b654:	19 a3 1c 00 	ld.w %d3,[%sp]28
8002b658:	bf 13 ce 02 	jlt %d3,1,8002bbf4 <_dtoa_r+0x8f8>
8002b65c:	8f f3 00 21 	and %d2,%d3,15
8002b660:	91 00 00 38 	movh.a %a3,32768
8002b664:	06 32       	sh %d2,3
8002b666:	d9 33 cc c3 	lea %a3,[%a3]16140 <80003f0c <__mprec_tens>>
8002b66a:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
8002b66e:	19 a4 20 00 	ld.w %d4,[%sp]32
8002b672:	19 a2 24 00 	ld.w %d2,[%sp]36
8002b676:	d4 3d       	ld.a %a13,[%a3]
8002b678:	99 3e 04 00 	ld.a %a14,[%a3]4
8002b67c:	60 4f       	mov.a %a15,%d4
8002b67e:	8f c3 3f 80 	sha %d8,%d3,-4
8002b682:	02 29       	mov %d9,%d2
8002b684:	82 2a       	mov %d10,2
8002b686:	6f 83 11 00 	jz.t %d3,8,8002b6a8 <_dtoa_r+0x3ac>
8002b68a:	91 00 00 38 	movh.a %a3,32768
8002b68e:	d9 33 e4 b3 	lea %a3,[%a3]16100 <80003ee4 <__mprec_bigtens>>
8002b692:	09 36 60 09 	ld.d %e6,[%a3]32 <80000020 <__IF_CONST>>
8002b696:	80 f4       	mov.d %d4,%a15
8002b698:	02 25       	mov %d5,%d2
8002b69a:	6d 00 0e 1b 	call 8002ecb6 <__divdf3>
8002b69e:	60 2f       	mov.a %a15,%d2
8002b6a0:	8f f8 00 81 	and %d8,%d8,15
8002b6a4:	02 39       	mov %d9,%d3
8002b6a6:	82 3a       	mov %d10,3
8002b6a8:	df 08 16 00 	jeq %d8,0,8002b6d4 <_dtoa_r+0x3d8>
8002b6ac:	91 00 00 c8 	movh.a %a12,32768
8002b6b0:	d9 cc e4 b3 	lea %a12,[%a12]16100 <80003ee4 <__mprec_bigtens>>
8002b6b4:	6f 08 0b 00 	jz.t %d8,0,8002b6ca <_dtoa_r+0x3ce>
8002b6b8:	09 c6 40 09 	ld.d %e6,[%a12]
8002b6bc:	80 d4       	mov.d %d4,%a13
8002b6be:	80 e5       	mov.d %d5,%a14
8002b6c0:	6d ff 74 df 	call 800275a8 <__muldf3>
8002b6c4:	60 2d       	mov.a %a13,%d2
8002b6c6:	60 3e       	mov.a %a14,%d3
8002b6c8:	c2 1a       	add %d10,1
8002b6ca:	86 f8       	sha %d8,-1
8002b6cc:	d9 cc 08 00 	lea %a12,[%a12]8 <80000008 <LCF_STARTPTR_CPU0+0x8>>
8002b6d0:	df 08 f2 ff 	jne %d8,0,8002b6b4 <_dtoa_r+0x3b8>
8002b6d4:	80 e7       	mov.d %d7,%a14
8002b6d6:	80 f4       	mov.d %d4,%a15
8002b6d8:	80 d6       	mov.d %d6,%a13
8002b6da:	02 95       	mov %d5,%d9
8002b6dc:	6d 00 ed 1a 	call 8002ecb6 <__divdf3>
8002b6e0:	60 2e       	mov.a %a14,%d2
8002b6e2:	60 3f       	mov.a %a15,%d3
8002b6e4:	19 a2 34 00 	ld.w %d2,[%sp]52
8002b6e8:	df 02 0b 00 	jeq %d2,0,8002b6fe <_dtoa_r+0x402>
8002b6ec:	82 06       	mov %d6,0
8002b6ee:	7b 00 ff 73 	movh %d7,16368
8002b6f2:	80 e4       	mov.d %d4,%a14
8002b6f4:	80 f5       	mov.d %d5,%a15
8002b6f6:	6d 00 e8 1b 	call 8002eec6 <__ltdf2>
8002b6fa:	bf 02 33 01 	jlt %d2,0,8002b960 <_dtoa_r+0x664>
8002b6fe:	02 a4       	mov %d4,%d10
8002b700:	6d 00 3d 1c 	call 8002ef7a <__floatsidf>
8002b704:	0b 23 10 48 	mov %e4,%d3,%d2
8002b708:	80 e6       	mov.d %d6,%a14
8002b70a:	80 f7       	mov.d %d7,%a15
8002b70c:	6d ff 4e df 	call 800275a8 <__muldf3>
8002b710:	0b 23 10 48 	mov %e4,%d3,%d2
8002b714:	82 06       	mov %d6,0
8002b716:	7b c0 01 74 	movh %d7,16412
8002b71a:	6d ff 07 df 	call 80027528 <__adddf3>
8002b71e:	0b 23 10 48 	mov %e4,%d3,%d2
8002b722:	19 a2 1c 00 	ld.w %d2,[%sp]28
8002b726:	59 a2 04 10 	st.w [%sp]68,%d2
8002b72a:	19 a2 18 00 	ld.w %d2,[%sp]24
8002b72e:	59 a2 00 10 	st.w [%sp]64,%d2
8002b732:	02 48       	mov %d8,%d4
8002b734:	9b 05 cc 9f 	addih %d9,%d5,64704
8002b738:	df 02 42 81 	jne %d2,0,8002b9bc <_dtoa_r+0x6c0>
8002b73c:	82 06       	mov %d6,0
8002b73e:	7b 40 01 74 	movh %d7,16404
8002b742:	80 e4       	mov.d %d4,%a14
8002b744:	80 f5       	mov.d %d5,%a15
8002b746:	6d ff 0e df 	call 80027562 <__subdf3>
8002b74a:	02 86       	mov %d6,%d8
8002b74c:	02 97       	mov %d7,%d9
8002b74e:	02 24       	mov %d4,%d2
8002b750:	02 35       	mov %d5,%d3
8002b752:	60 2d       	mov.a %a13,%d2
8002b754:	60 3c       	mov.a %a12,%d3
8002b756:	6d 00 98 1b 	call 8002ee86 <__gtdf2>
8002b75a:	ff 12 72 04 	jge %d2,1,8002c03e <_dtoa_r+0xd42>
8002b75e:	60 92       	mov.a %a2,%d9
8002b760:	02 86       	mov %d6,%d8
8002b762:	11 02 00 48 	addih.a %a4,%a2,32768
8002b766:	80 47       	mov.d %d7,%a4
8002b768:	80 d4       	mov.d %d4,%a13
8002b76a:	80 c5       	mov.d %d5,%a12
8002b76c:	6d 00 ad 1b 	call 8002eec6 <__ltdf2>
8002b770:	bf 02 d8 03 	jlt %d2,0,8002bf20 <_dtoa_r+0xc24>
8002b774:	19 a4 1c 00 	ld.w %d4,[%sp]28
8002b778:	19 a3 14 10 	ld.w %d3,[%sp]84
8002b77c:	8b f4 40 22 	lt %d2,%d4,15
8002b780:	8b 03 80 24 	and.ge %d2,%d3,0
8002b784:	df 02 79 82 	jne %d2,0,8002bc76 <_dtoa_r+0x97a>
8002b788:	19 a2 30 00 	ld.w %d2,[%sp]48
8002b78c:	19 aa 2c 00 	ld.w %d10,[%sp]44
8002b790:	19 a9 10 00 	ld.w %d9,[%sp]16
8002b794:	82 08       	mov %d8,0
8002b796:	df 02 2b 00 	jeq %d2,0,8002b7ec <_dtoa_r+0x4f0>
8002b79a:	54 a2       	ld.w %d2,[%sp]
8002b79c:	bf 22 3c 04 	jlt %d2,2,8002c014 <_dtoa_r+0xd18>
8002b7a0:	19 a2 18 00 	ld.w %d2,[%sp]24
8002b7a4:	1b f2 ff af 	addi %d10,%d2,-1
8002b7a8:	19 a2 2c 00 	ld.w %d2,[%sp]44
8002b7ac:	7f a2 be 03 	jge %d2,%d10,8002bf28 <_dtoa_r+0xc2c>
8002b7b0:	19 a2 2c 00 	ld.w %d2,[%sp]44
8002b7b4:	59 aa 2c 00 	st.w [%sp]44,%d10
8002b7b8:	0b 2a 80 30 	sub %d3,%d10,%d2
8002b7bc:	42 3c       	add %d12,%d3
8002b7be:	82 0a       	mov %d10,0
8002b7c0:	19 a3 10 00 	ld.w %d3,[%sp]16
8002b7c4:	19 a2 18 00 	ld.w %d2,[%sp]24
8002b7c8:	0b 23 80 90 	sub %d9,%d3,%d2
8002b7cc:	bf 02 0b 00 	jlt %d2,0,8002b7e2 <_dtoa_r+0x4e6>
8002b7d0:	19 a4 08 00 	ld.w %d4,[%sp]8
8002b7d4:	02 39       	mov %d9,%d3
8002b7d6:	42 24       	add %d4,%d2
8002b7d8:	42 23       	add %d3,%d2
8002b7da:	59 a4 08 00 	st.w [%sp]8,%d4
8002b7de:	59 a3 10 00 	st.w [%sp]16,%d3
8002b7e2:	60 d4       	mov.a %a4,%d13
8002b7e4:	82 14       	mov %d4,1
8002b7e6:	6d 00 15 07 	call 8002c610 <__i2b>
8002b7ea:	80 28       	mov.d %d8,%a2
8002b7ec:	19 a3 08 00 	ld.w %d3,[%sp]8
8002b7f0:	8b 13 80 22 	ge %d2,%d3,1
8002b7f4:	8b 19 80 24 	and.ge %d2,%d9,1
8002b7f8:	df 02 0e 00 	jeq %d2,0,8002b814 <_dtoa_r+0x518>
8002b7fc:	19 a4 10 00 	ld.w %d4,[%sp]16
8002b800:	0b 39 80 21 	min %d2,%d9,%d3
8002b804:	a2 24       	sub %d4,%d2
8002b806:	a2 29       	sub %d9,%d2
8002b808:	0b 23 80 20 	sub %d2,%d3,%d2
8002b80c:	59 a4 10 00 	st.w [%sp]16,%d4
8002b810:	59 a2 08 00 	st.w [%sp]8,%d2
8002b814:	19 a2 2c 00 	ld.w %d2,[%sp]44
8002b818:	df 02 0e 00 	jeq %d2,0,8002b834 <_dtoa_r+0x538>
8002b81c:	19 a2 30 00 	ld.w %d2,[%sp]48
8002b820:	df 02 88 00 	jeq %d2,0,8002b930 <_dtoa_r+0x634>
8002b824:	ff 1a 86 03 	jge %d10,1,8002bf30 <_dtoa_r+0xc34>
8002b828:	19 a2 2c 00 	ld.w %d2,[%sp]44
8002b82c:	0b a2 80 40 	sub %d4,%d2,%d10
8002b830:	5f a2 82 80 	jne %d2,%d10,8002b934 <_dtoa_r+0x638>
8002b834:	60 d4       	mov.a %a4,%d13
8002b836:	82 14       	mov %d4,1
8002b838:	6d 00 ec 06 	call 8002c610 <__i2b>
8002b83c:	40 2c       	mov.aa %a12,%a2
8002b83e:	ff 1c 49 02 	jge %d12,1,8002bcd0 <_dtoa_r+0x9d4>
8002b842:	54 a2       	ld.w %d2,[%sp]
8002b844:	a0 0d       	mov.a %a13,0
8002b846:	bf 22 dd 03 	jlt %d2,2,8002c000 <_dtoa_r+0xd04>
8002b84a:	82 12       	mov %d2,1
8002b84c:	df 0c 4c 82 	jne %d12,0,8002bce4 <_dtoa_r+0x9e8>
8002b850:	19 a3 08 00 	ld.w %d3,[%sp]8
8002b854:	42 32       	add %d2,%d3
8002b856:	8f f2 01 21 	and %d2,%d2,31
8002b85a:	df 02 cf 03 	jeq %d2,0,8002bff8 <_dtoa_r+0xcfc>
8002b85e:	8b 02 02 31 	rsub %d3,%d2,32
8002b862:	bf 53 cf 02 	jlt %d3,5,8002be00 <_dtoa_r+0xb04>
8002b866:	8b c2 01 21 	rsub %d2,%d2,28
8002b86a:	19 a3 10 00 	ld.w %d3,[%sp]16
8002b86e:	42 29       	add %d9,%d2
8002b870:	42 23       	add %d3,%d2
8002b872:	59 a3 10 00 	st.w [%sp]16,%d3
8002b876:	19 a3 08 00 	ld.w %d3,[%sp]8
8002b87a:	42 23       	add %d3,%d2
8002b87c:	59 a3 08 00 	st.w [%sp]8,%d3
8002b880:	19 a2 10 00 	ld.w %d2,[%sp]16
8002b884:	bf 12 08 00 	jlt %d2,1,8002b894 <_dtoa_r+0x598>
8002b888:	60 e5       	mov.a %a5,%d14
8002b88a:	60 d4       	mov.a %a4,%d13
8002b88c:	02 24       	mov %d4,%d2
8002b88e:	6d 00 3f 08 	call 8002c90c <__lshift>
8002b892:	80 2e       	mov.d %d14,%a2
8002b894:	19 a2 08 00 	ld.w %d2,[%sp]8
8002b898:	bf 12 08 00 	jlt %d2,1,8002b8a8 <_dtoa_r+0x5ac>
8002b89c:	60 d4       	mov.a %a4,%d13
8002b89e:	40 c5       	mov.aa %a5,%a12
8002b8a0:	02 24       	mov %d4,%d2
8002b8a2:	6d 00 35 08 	call 8002c90c <__lshift>
8002b8a6:	40 2c       	mov.aa %a12,%a2
8002b8a8:	54 a2       	ld.w %d2,[%sp]
8002b8aa:	8b 32 80 a2 	ge %d10,%d2,3
8002b8ae:	19 a2 34 00 	ld.w %d2,[%sp]52
8002b8b2:	df 02 26 82 	jne %d2,0,8002bcfe <_dtoa_r+0xa02>
8002b8b6:	19 a2 18 00 	ld.w %d2,[%sp]24
8002b8ba:	8b 12 40 22 	lt %d2,%d2,1
8002b8be:	26 a2       	and %d2,%d10
8002b8c0:	df 02 2b 01 	jeq %d2,0,8002bb16 <_dtoa_r+0x81a>
8002b8c4:	19 a2 18 00 	ld.w %d2,[%sp]24
8002b8c8:	df 02 a2 02 	jeq %d2,0,8002be0c <_dtoa_r+0xb10>
8002b8cc:	19 ab 14 00 	ld.w %d11,[%sp]20
8002b8d0:	60 fd       	mov.a %a13,%d15
8002b8d2:	46 0b       	not %d11
8002b8d4:	60 d4       	mov.a %a4,%d13
8002b8d6:	40 c5       	mov.aa %a5,%a12
8002b8d8:	6d 00 b9 05 	call 8002c44a <_Bfree>
8002b8dc:	c2 1b       	add %d11,1
8002b8de:	df 08 06 00 	jeq %d8,0,8002b8ea <_dtoa_r+0x5ee>
8002b8e2:	60 85       	mov.a %a5,%d8
8002b8e4:	60 d4       	mov.a %a4,%d13
8002b8e6:	6d 00 b2 05 	call 8002c44a <_Bfree>
8002b8ea:	60 e5       	mov.a %a5,%d14
8002b8ec:	60 d4       	mov.a %a4,%d13
8002b8ee:	6d 00 ae 05 	call 8002c44a <_Bfree>
8002b8f2:	82 02       	mov %d2,0
8002b8f4:	60 f2       	mov.a %a2,%d15
8002b8f6:	34 22       	st.b [%a2],%d2
8002b8f8:	99 a2 0c 00 	ld.a %a2,[%sp]12
8002b8fc:	19 a2 04 00 	ld.w %d2,[%sp]4
8002b900:	74 2b       	st.w [%a2],%d11
8002b902:	df 02 45 7d 	jeq %d2,0,8002b38c <_dtoa_r+0x90>
8002b906:	60 22       	mov.a %a2,%d2
8002b908:	6c 20       	st.w [%a2]0,%d15
8002b90a:	40 d2       	mov.aa %a2,%a13
8002b90c:	00 90       	ret 
8002b90e:	91 00 00 d8 	movh.a %a13,32768
8002b912:	19 a2 04 00 	ld.w %d2,[%sp]4
8002b916:	d9 dd f7 53 	lea %a13,[%a13]15735 <80003d77 <blanks.1+0x1b>>
8002b91a:	d9 d2 08 00 	lea %a2,[%a13]8 <80000008 <LCF_STARTPTR_CPU0+0x8>>
8002b91e:	df 02 42 fe 	jne %d2,0,8002b5a2 <_dtoa_r+0x2a6>
8002b922:	1d ff 35 fd 	j 8002b38c <_dtoa_r+0x90>
8002b926:	82 12       	mov %d2,1
8002b928:	59 a2 34 00 	st.w [%sp]52,%d2
8002b92c:	1d ff d6 fd 	j 8002b4d8 <_dtoa_r+0x1dc>
8002b930:	19 a4 2c 00 	ld.w %d4,[%sp]44
8002b934:	60 e5       	mov.a %a5,%d14
8002b936:	60 d4       	mov.a %a4,%d13
8002b938:	6d 00 7a 07 	call 8002c82c <__pow5mult>
8002b93c:	80 2e       	mov.d %d14,%a2
8002b93e:	1d ff 7b ff 	j 8002b834 <_dtoa_r+0x538>
8002b942:	91 30 00 38 	movh.a %a3,32771
8002b946:	d9 33 90 5b 	lea %a3,[%a3]-18096 <8002b950 <_dtoa_r+0x654>>
8002b94a:	01 32 02 36 	addsc.a %a3,%a3,%d2,2
8002b94e:	dc 03       	ji %a3
8002b950:	1d 00 3b 03 	j 8002bfc6 <_dtoa_r+0xcca>
8002b954:	1d 00 34 03 	j 8002bfbc <_dtoa_r+0xcc0>
8002b958:	1d 00 ff 02 	j 8002bf56 <_dtoa_r+0xc5a>
8002b95c:	1d 00 1f 03 	j 8002bf9a <_dtoa_r+0xc9e>
8002b960:	19 a2 18 00 	ld.w %d2,[%sp]24
8002b964:	df 02 0d 04 	jeq %d2,0,8002c17e <_dtoa_r+0xe82>
8002b968:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002b96c:	bf 12 04 7f 	jlt %d2,1,8002b774 <_dtoa_r+0x478>
8002b970:	19 a3 1c 00 	ld.w %d3,[%sp]28
8002b974:	80 f5       	mov.d %d5,%a15
8002b976:	c2 f3       	add %d3,-1
8002b978:	82 06       	mov %d6,0
8002b97a:	7b 40 02 74 	movh %d7,16420
8002b97e:	80 e4       	mov.d %d4,%a14
8002b980:	59 a3 04 10 	st.w [%sp]68,%d3
8002b984:	6d ff 12 de 	call 800275a8 <__muldf3>
8002b988:	60 2e       	mov.a %a14,%d2
8002b98a:	1b 1a 00 40 	addi %d4,%d10,1
8002b98e:	60 3f       	mov.a %a15,%d3
8002b990:	6d 00 f5 1a 	call 8002ef7a <__floatsidf>
8002b994:	0b 23 10 48 	mov %e4,%d3,%d2
8002b998:	80 e6       	mov.d %d6,%a14
8002b99a:	80 f7       	mov.d %d7,%a15
8002b99c:	6d ff 06 de 	call 800275a8 <__muldf3>
8002b9a0:	0b 23 10 48 	mov %e4,%d3,%d2
8002b9a4:	82 06       	mov %d6,0
8002b9a6:	7b c0 01 74 	movh %d7,16412
8002b9aa:	6d ff bf dd 	call 80027528 <__adddf3>
8002b9ae:	02 28       	mov %d8,%d2
8002b9b0:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002b9b4:	9b 03 cc 9f 	addih %d9,%d3,64704
8002b9b8:	59 a2 00 10 	st.w [%sp]64,%d2
8002b9bc:	80 e4       	mov.d %d4,%a14
8002b9be:	80 f5       	mov.d %d5,%a15
8002b9c0:	6d ff 26 df 	call 8002780c <__fixdfsi>
8002b9c4:	02 24       	mov %d4,%d2
8002b9c6:	19 a2 00 10 	ld.w %d2,[%sp]64
8002b9ca:	91 00 00 38 	movh.a %a3,32768
8002b9ce:	1b f2 ff 5f 	addi %d5,%d2,-1
8002b9d2:	06 35       	sh %d5,3
8002b9d4:	d9 33 cc c3 	lea %a3,[%a3]16140 <80003f0c <__mprec_tens>>
8002b9d8:	01 35 00 36 	addsc.a %a3,%a3,%d5,0
8002b9dc:	02 8a       	mov %d10,%d8
8002b9de:	09 3c c0 09 	ld.da %a12,[%a3]
8002b9e2:	1b 04 03 80 	addi %d8,%d4,48
8002b9e6:	59 a9 08 10 	st.w [%sp]72,%d9
8002b9ea:	6d 00 c8 1a 	call 8002ef7a <__floatsidf>
8002b9ee:	0b 23 10 68 	mov %e6,%d3,%d2
8002b9f2:	80 e4       	mov.d %d4,%a14
8002b9f4:	80 f5       	mov.d %d5,%a15
8002b9f6:	6d ff b6 dd 	call 80027562 <__subdf3>
8002b9fa:	60 2e       	mov.a %a14,%d2
8002b9fc:	19 a2 30 00 	ld.w %d2,[%sp]48
8002ba00:	37 08 48 80 	extr %d8,%d8,0,8
8002ba04:	60 3f       	mov.a %a15,%d3
8002ba06:	92 19       	add %d9,%d15,1
8002ba08:	80 c6       	mov.d %d6,%a12
8002ba0a:	80 d7       	mov.d %d7,%a13
8002ba0c:	df 02 9d 01 	jeq %d2,0,8002bd46 <_dtoa_r+0xa4a>
8002ba10:	82 04       	mov %d4,0
8002ba12:	7b 00 fe 53 	movh %d5,16352
8002ba16:	6d 00 50 19 	call 8002ecb6 <__divdf3>
8002ba1a:	99 a5 08 10 	ld.a %a5,[%sp]72
8002ba1e:	0b 23 10 48 	mov %e4,%d3,%d2
8002ba22:	02 a6       	mov %d6,%d10
8002ba24:	80 57       	mov.d %d7,%a5
8002ba26:	6d ff 9e dd 	call 80027562 <__subdf3>
8002ba2a:	60 f2       	mov.a %a2,%d15
8002ba2c:	80 e6       	mov.d %d6,%a14
8002ba2e:	34 28       	st.b [%a2],%d8
8002ba30:	80 f7       	mov.d %d7,%a15
8002ba32:	02 24       	mov %d4,%d2
8002ba34:	02 35       	mov %d5,%d3
8002ba36:	60 3c       	mov.a %a12,%d3
8002ba38:	02 2a       	mov %d10,%d2
8002ba3a:	6d 00 26 1a 	call 8002ee86 <__gtdf2>
8002ba3e:	ff 12 e8 03 	jge %d2,1,8002c20e <_dtoa_r+0xf12>
8002ba42:	82 02       	mov %d2,0
8002ba44:	59 ac 08 10 	st.w [%sp]72,%d12
8002ba48:	19 ac 00 10 	ld.w %d12,[%sp]64
8002ba4c:	59 ab 00 10 	st.w [%sp]64,%d11
8002ba50:	02 2b       	mov %d11,%d2
8002ba52:	80 c2       	mov.d %d2,%a12
8002ba54:	60 ac       	mov.a %a12,%d10
8002ba56:	02 2a       	mov %d10,%d2
8002ba58:	1d 00 34 00 	j 8002bac0 <_dtoa_r+0x7c4>
8002ba5c:	c2 1b       	add %d11,1
8002ba5e:	7f cb fc 03 	jge %d11,%d12,8002c256 <_dtoa_r+0xf5a>
8002ba62:	80 c4       	mov.d %d4,%a12
8002ba64:	02 a5       	mov %d5,%d10
8002ba66:	82 06       	mov %d6,0
8002ba68:	7b 40 02 74 	movh %d7,16420
8002ba6c:	6d ff 9e dd 	call 800275a8 <__muldf3>
8002ba70:	82 06       	mov %d6,0
8002ba72:	7b 40 02 74 	movh %d7,16420
8002ba76:	80 e4       	mov.d %d4,%a14
8002ba78:	80 f5       	mov.d %d5,%a15
8002ba7a:	60 2c       	mov.a %a12,%d2
8002ba7c:	02 3a       	mov %d10,%d3
8002ba7e:	6d ff 95 dd 	call 800275a8 <__muldf3>
8002ba82:	60 2e       	mov.a %a14,%d2
8002ba84:	02 35       	mov %d5,%d3
8002ba86:	02 24       	mov %d4,%d2
8002ba88:	60 3d       	mov.a %a13,%d3
8002ba8a:	6d ff c1 de 	call 8002780c <__fixdfsi>
8002ba8e:	02 24       	mov %d4,%d2
8002ba90:	02 28       	mov %d8,%d2
8002ba92:	6d 00 74 1a 	call 8002ef7a <__floatsidf>
8002ba96:	0b 23 10 68 	mov %e6,%d3,%d2
8002ba9a:	80 e4       	mov.d %d4,%a14
8002ba9c:	80 d5       	mov.d %d5,%a13
8002ba9e:	6d ff 62 dd 	call 80027562 <__subdf3>
8002baa2:	1b 08 03 80 	addi %d8,%d8,48
8002baa6:	60 92       	mov.a %a2,%d9
8002baa8:	60 2e       	mov.a %a14,%d2
8002baaa:	24 28       	st.b [%a2+],%d8
8002baac:	80 c6       	mov.d %d6,%a12
8002baae:	02 a7       	mov %d7,%d10
8002bab0:	02 24       	mov %d4,%d2
8002bab2:	02 35       	mov %d5,%d3
8002bab4:	60 3f       	mov.a %a15,%d3
8002bab6:	80 29       	mov.d %d9,%a2
8002bab8:	6d 00 07 1a 	call 8002eec6 <__ltdf2>
8002babc:	bf 02 a9 03 	jlt %d2,0,8002c20e <_dtoa_r+0xf12>
8002bac0:	80 e6       	mov.d %d6,%a14
8002bac2:	80 f7       	mov.d %d7,%a15
8002bac4:	82 04       	mov %d4,0
8002bac6:	7b 00 ff 53 	movh %d5,16368
8002baca:	6d ff 4c dd 	call 80027562 <__subdf3>
8002bace:	0b 23 10 48 	mov %e4,%d3,%d2
8002bad2:	80 c6       	mov.d %d6,%a12
8002bad4:	02 a7       	mov %d7,%d10
8002bad6:	6d 00 f8 19 	call 8002eec6 <__ltdf2>
8002bada:	ff 02 c1 7f 	jge %d2,0,8002ba5c <_dtoa_r+0x760>
8002bade:	02 9a       	mov %d10,%d9
8002bae0:	60 a2       	mov.a %a2,%d10
8002bae2:	60 f4       	mov.a %a4,%d15
8002bae4:	3b 90 03 30 	mov %d3,57
8002bae8:	1d 00 04 00 	j 8002baf0 <_dtoa_r+0x7f4>
8002baec:	7d 42 3e 03 	jeq.a %a2,%a4,8002c168 <_dtoa_r+0xe6c>
8002baf0:	40 23       	mov.aa %a3,%a2
8002baf2:	09 22 3f f4 	ld.b %d2,[+%a2]-1
8002baf6:	5f 32 fb 7f 	jeq %d2,%d3,8002baec <_dtoa_r+0x7f0>
8002bafa:	c2 12       	add %d2,1
8002bafc:	37 02 48 20 	extr %d2,%d2,0,8
8002bb00:	80 2a       	mov.d %d10,%a2
8002bb02:	80 4f       	mov.d %d15,%a4
8002bb04:	60 a2       	mov.a %a2,%d10
8002bb06:	34 22       	st.b [%a2],%d2
8002bb08:	19 ab 04 10 	ld.w %d11,[%sp]68
8002bb0c:	60 fd       	mov.a %a13,%d15
8002bb0e:	c2 1b       	add %d11,1
8002bb10:	80 3f       	mov.d %d15,%a3
8002bb12:	1d ff ec fe 	j 8002b8ea <_dtoa_r+0x5ee>
8002bb16:	19 a2 30 00 	ld.w %d2,[%sp]48
8002bb1a:	df 02 90 01 	jeq %d2,0,8002be3a <_dtoa_r+0xb3e>
8002bb1e:	bf 19 08 00 	jlt %d9,1,8002bb2e <_dtoa_r+0x832>
8002bb22:	60 85       	mov.a %a5,%d8
8002bb24:	60 d4       	mov.a %a4,%d13
8002bb26:	02 94       	mov %d4,%d9
8002bb28:	6d 00 f2 06 	call 8002c90c <__lshift>
8002bb2c:	80 28       	mov.d %d8,%a2
8002bb2e:	02 89       	mov %d9,%d8
8002bb30:	bd 0d 76 83 	jnz.a %a13,8002c21c <_dtoa_r+0xf20>
8002bb34:	60 f2       	mov.a %a2,%d15
8002bb36:	99 a3 18 00 	ld.a %a3,[%sp]24
8002bb3a:	19 a2 28 00 	ld.w %d2,[%sp]40
8002bb3e:	b0 f2       	add.a %a2,-1
8002bb40:	30 23       	add.a %a3,%a2
8002bb42:	8f 12 00 21 	and %d2,%d2,1
8002bb46:	54 aa       	ld.w %d10,[%sp]
8002bb48:	60 ff       	mov.a %a15,%d15
8002bb4a:	78 04       	st.w [%sp]16,%d15
8002bb4c:	b5 a3 08 00 	st.a [%sp]8,%a3
8002bb50:	02 2f       	mov %d15,%d2
8002bb52:	60 e4       	mov.a %a4,%d14
8002bb54:	40 c5       	mov.aa %a5,%a12
8002bb56:	6d ff 24 fb 	call 8002b19e <quorem>
8002bb5a:	60 22       	mov.a %a2,%d2
8002bb5c:	60 85       	mov.a %a5,%d8
8002bb5e:	60 e4       	mov.a %a4,%d14
8002bb60:	d9 2e 30 00 	lea %a14,[%a2]48
8002bb64:	74 a2       	st.w [%sp],%d2
8002bb66:	6d 00 5a 07 	call 8002ca1a <__mcmp>
8002bb6a:	60 96       	mov.a %a6,%d9
8002bb6c:	60 d4       	mov.a %a4,%d13
8002bb6e:	40 c5       	mov.aa %a5,%a12
8002bb70:	02 2b       	mov %d11,%d2
8002bb72:	6d 00 7a 07 	call 8002ca66 <__mdiff>
8002bb76:	19 22 0c 00 	ld.w %d2,[%a2]12
8002bb7a:	40 2d       	mov.aa %a13,%a2
8002bb7c:	40 25       	mov.aa %a5,%a2
8002bb7e:	df 02 29 82 	jne %d2,0,8002bfd0 <_dtoa_r+0xcd4>
8002bb82:	60 e4       	mov.a %a4,%d14
8002bb84:	6d 00 4b 07 	call 8002ca1a <__mcmp>
8002bb88:	60 d4       	mov.a %a4,%d13
8002bb8a:	40 d5       	mov.aa %a5,%a13
8002bb8c:	02 2c       	mov %d12,%d2
8002bb8e:	6d 00 5e 04 	call 8002c44a <_Bfree>
8002bb92:	0f ac a0 20 	or %d2,%d12,%d10
8002bb96:	a6 f2       	or %d2,%d15
8002bb98:	df 02 b5 03 	jeq %d2,0,8002c302 <_dtoa_r+0x1006>
8002bb9c:	d9 f2 01 00 	lea %a2,[%a15]1
8002bba0:	40 2d       	mov.aa %a13,%a2
8002bba2:	bf 0b 16 03 	jlt %d11,0,8002c1ce <_dtoa_r+0xed2>
8002bba6:	0f ab a0 20 	or %d2,%d11,%d10
8002bbaa:	a6 f2       	or %d2,%d15
8002bbac:	df 02 11 03 	jeq %d2,0,8002c1ce <_dtoa_r+0xed2>
8002bbb0:	ff 1c 7c 03 	jge %d12,1,8002c2a8 <_dtoa_r+0xfac>
8002bbb4:	99 a3 08 00 	ld.a %a3,[%sp]8
8002bbb8:	80 e2       	mov.d %d2,%a14
8002bbba:	28 02       	st.b [%a15]0,%d2
8002bbbc:	7d f3 86 03 	jeq.a %a3,%a15,8002c2c8 <_dtoa_r+0xfcc>
8002bbc0:	60 e5       	mov.a %a5,%d14
8002bbc2:	60 d4       	mov.a %a4,%d13
8002bbc4:	fb a0 00 40 	mov %e4,10
8002bbc8:	6d 00 4f 04 	call 8002c466 <__multadd>
8002bbcc:	60 85       	mov.a %a5,%d8
8002bbce:	60 d4       	mov.a %a4,%d13
8002bbd0:	80 2e       	mov.d %d14,%a2
8002bbd2:	fb a0 00 40 	mov %e4,10
8002bbd6:	5f 98 03 02 	jeq %d8,%d9,8002bfdc <_dtoa_r+0xce0>
8002bbda:	6d 00 46 04 	call 8002c466 <__multadd>
8002bbde:	60 95       	mov.a %a5,%d9
8002bbe0:	60 d4       	mov.a %a4,%d13
8002bbe2:	fb a0 00 40 	mov %e4,10
8002bbe6:	80 28       	mov.d %d8,%a2
8002bbe8:	6d 00 3f 04 	call 8002c466 <__multadd>
8002bbec:	80 29       	mov.d %d9,%a2
8002bbee:	40 df       	mov.aa %a15,%a13
8002bbf0:	1d ff b1 ff 	j 8002bb52 <_dtoa_r+0x856>
8002bbf4:	19 a4 20 00 	ld.w %d4,[%sp]32
8002bbf8:	19 a3 24 00 	ld.w %d3,[%sp]36
8002bbfc:	19 a2 1c 00 	ld.w %d2,[%sp]28
8002bc00:	60 4e       	mov.a %a14,%d4
8002bc02:	60 3f       	mov.a %a15,%d3
8002bc04:	82 2a       	mov %d10,2
8002bc06:	df 02 6f 7d 	jeq %d2,0,8002b6e4 <_dtoa_r+0x3e8>
8002bc0a:	8b 02 00 81 	rsub %d8,%d2,0
8002bc0e:	8f f8 00 21 	and %d2,%d8,15
8002bc12:	91 00 00 38 	movh.a %a3,32768
8002bc16:	06 32       	sh %d2,3
8002bc18:	d9 33 cc c3 	lea %a3,[%a3]16140 <80003f0c <__mprec_tens>>
8002bc1c:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
8002bc20:	80 e4       	mov.d %d4,%a14
8002bc22:	09 36 40 09 	ld.d %e6,[%a3]
8002bc26:	80 f5       	mov.d %d5,%a15
8002bc28:	6d ff c0 dc 	call 800275a8 <__muldf3>
8002bc2c:	59 a2 00 10 	st.w [%sp]64,%d2
8002bc30:	86 c8       	sha %d8,-4
8002bc32:	60 3d       	mov.a %a13,%d3
8002bc34:	60 2e       	mov.a %a14,%d2
8002bc36:	60 3f       	mov.a %a15,%d3
8002bc38:	df 08 56 7d 	jeq %d8,0,8002b6e4 <_dtoa_r+0x3e8>
8002bc3c:	91 00 00 c8 	movh.a %a12,32768
8002bc40:	d9 cc e4 b3 	lea %a12,[%a12]16100 <80003ee4 <__mprec_bigtens>>
8002bc44:	82 02       	mov %d2,0
8002bc46:	6f 08 0c 00 	jz.t %d8,0,8002bc5e <_dtoa_r+0x962>
8002bc4a:	09 c6 40 09 	ld.d %e6,[%a12]
8002bc4e:	80 e4       	mov.d %d4,%a14
8002bc50:	80 f5       	mov.d %d5,%a15
8002bc52:	6d ff ab dc 	call 800275a8 <__muldf3>
8002bc56:	60 3f       	mov.a %a15,%d3
8002bc58:	60 2e       	mov.a %a14,%d2
8002bc5a:	c2 1a       	add %d10,1
8002bc5c:	02 92       	mov %d2,%d9
8002bc5e:	86 f8       	sha %d8,-1
8002bc60:	d9 cc 08 00 	lea %a12,[%a12]8 <80000008 <LCF_STARTPTR_CPU0+0x8>>
8002bc64:	df 08 f1 ff 	jne %d8,0,8002bc46 <_dtoa_r+0x94a>
8002bc68:	df 02 3e fd 	jne %d2,0,8002b6e4 <_dtoa_r+0x3e8>
8002bc6c:	99 ae 00 10 	ld.a %a14,[%sp]64
8002bc70:	40 df       	mov.aa %a15,%a13
8002bc72:	1d ff 39 fd 	j 8002b6e4 <_dtoa_r+0x3e8>
8002bc76:	02 42       	mov %d2,%d4
8002bc78:	19 a3 18 00 	ld.w %d3,[%sp]24
8002bc7c:	91 00 00 38 	movh.a %a3,32768
8002bc80:	06 32       	sh %d2,3
8002bc82:	19 a4 14 00 	ld.w %d4,[%sp]20
8002bc86:	d9 33 cc c3 	lea %a3,[%a3]16140 <80003f0c <__mprec_tens>>
8002bc8a:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
8002bc8e:	8b 13 40 22 	lt %d2,%d3,1
8002bc92:	87 24 1f 20 	and.t %d2,%d4,31,%d2,0
8002bc96:	09 3c c0 09 	ld.da %a12,[%a3]
8002bc9a:	df 02 e4 01 	jeq %d2,0,8002c062 <_dtoa_r+0xd66>
8002bc9e:	df 03 41 81 	jne %d3,0,8002bf20 <_dtoa_r+0xc24>
8002bca2:	80 c4       	mov.d %d4,%a12
8002bca4:	82 06       	mov %d6,0
8002bca6:	7b 40 01 74 	movh %d7,16404
8002bcaa:	80 d5       	mov.d %d5,%a13
8002bcac:	6d ff 7e dc 	call 800275a8 <__muldf3>
8002bcb0:	99 a6 20 00 	ld.a %a6,[%sp]32
8002bcb4:	99 a7 24 00 	ld.a %a7,[%sp]36
8002bcb8:	0b 23 10 68 	mov %e6,%d3,%d2
8002bcbc:	80 64       	mov.d %d4,%a6
8002bcbe:	80 75       	mov.d %d5,%a7
8002bcc0:	6d 00 23 19 	call 8002ef06 <__ledf2>
8002bcc4:	a0 0c       	mov.a %a12,0
8002bcc6:	82 08       	mov %d8,0
8002bcc8:	bf 12 02 7e 	jlt %d2,1,8002b8cc <_dtoa_r+0x5d0>
8002bccc:	1d 00 ac 00 	j 8002be24 <_dtoa_r+0xb28>
8002bcd0:	60 d4       	mov.a %a4,%d13
8002bcd2:	02 c4       	mov %d4,%d12
8002bcd4:	40 25       	mov.aa %a5,%a2
8002bcd6:	6d 00 ab 05 	call 8002c82c <__pow5mult>
8002bcda:	54 a2       	ld.w %d2,[%sp]
8002bcdc:	40 2c       	mov.aa %a12,%a2
8002bcde:	bf 22 06 01 	jlt %d2,2,8002beea <_dtoa_r+0xbee>
8002bce2:	a0 0d       	mov.a %a13,0
8002bce4:	19 c2 10 00 	ld.w %d2,[%a12]16
8002bce8:	c2 42       	add %d2,4
8002bcea:	06 22       	sh %d2,2
8002bcec:	01 c2 00 36 	addsc.a %a3,%a12,%d2,0
8002bcf0:	54 34       	ld.w %d4,[%a3]
8002bcf2:	6d 00 1b 04 	call 8002c528 <__hi0bits>
8002bcf6:	8b 02 02 21 	rsub %d2,%d2,32
8002bcfa:	1d ff ab fd 	j 8002b850 <_dtoa_r+0x554>
8002bcfe:	60 e4       	mov.a %a4,%d14
8002bd00:	40 c5       	mov.aa %a5,%a12
8002bd02:	6d 00 8c 06 	call 8002ca1a <__mcmp>
8002bd06:	ff 02 d8 7d 	jge %d2,0,8002b8b6 <_dtoa_r+0x5ba>
8002bd0a:	19 a2 1c 00 	ld.w %d2,[%sp]28
8002bd0e:	60 e5       	mov.a %a5,%d14
8002bd10:	60 d4       	mov.a %a4,%d13
8002bd12:	fb a0 00 40 	mov %e4,10
8002bd16:	1b f2 ff cf 	addi %d12,%d2,-1
8002bd1a:	6d 00 a6 03 	call 8002c466 <__multadd>
8002bd1e:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002bd22:	80 2e       	mov.d %d14,%a2
8002bd24:	8b 12 40 22 	lt %d2,%d2,1
8002bd28:	26 2a       	and %d10,%d2
8002bd2a:	19 a2 30 00 	ld.w %d2,[%sp]48
8002bd2e:	df 02 0d 83 	jne %d2,0,8002c348 <_dtoa_r+0x104c>
8002bd32:	df 0a 03 83 	jne %d10,0,8002c338 <_dtoa_r+0x103c>
8002bd36:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002bd3a:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002bd3e:	59 a2 18 00 	st.w [%sp]24,%d2
8002bd42:	1d 00 7f 00 	j 8002be40 <_dtoa_r+0xb44>
8002bd46:	99 a5 08 10 	ld.a %a5,[%sp]72
8002bd4a:	02 a4       	mov %d4,%d10
8002bd4c:	80 55       	mov.d %d5,%a5
8002bd4e:	6d ff 2d dc 	call 800275a8 <__muldf3>
8002bd52:	60 f2       	mov.a %a2,%d15
8002bd54:	59 a2 08 10 	st.w [%sp]72,%d2
8002bd58:	19 a2 00 10 	ld.w %d2,[%sp]64
8002bd5c:	59 a3 0c 10 	st.w [%sp]76,%d3
8002bd60:	34 28       	st.b [%a2],%d8
8002bd62:	12 2a       	add %d10,%d15,%d2
8002bd64:	df 12 e7 02 	jeq %d2,1,8002c332 <_dtoa_r+0x1036>
8002bd68:	82 06       	mov %d6,0
8002bd6a:	7b 40 02 74 	movh %d7,16420
8002bd6e:	80 e4       	mov.d %d4,%a14
8002bd70:	80 f5       	mov.d %d5,%a15
8002bd72:	6d ff 1b dc 	call 800275a8 <__muldf3>
8002bd76:	02 35       	mov %d5,%d3
8002bd78:	02 24       	mov %d4,%d2
8002bd7a:	60 3c       	mov.a %a12,%d3
8002bd7c:	60 2d       	mov.a %a13,%d2
8002bd7e:	6d ff 47 dd 	call 8002780c <__fixdfsi>
8002bd82:	02 24       	mov %d4,%d2
8002bd84:	02 28       	mov %d8,%d2
8002bd86:	6d 00 fa 18 	call 8002ef7a <__floatsidf>
8002bd8a:	0b 23 10 68 	mov %e6,%d3,%d2
8002bd8e:	80 d4       	mov.d %d4,%a13
8002bd90:	80 c5       	mov.d %d5,%a12
8002bd92:	6d ff e8 db 	call 80027562 <__subdf3>
8002bd96:	1b 08 03 80 	addi %d8,%d8,48
8002bd9a:	60 92       	mov.a %a2,%d9
8002bd9c:	60 2e       	mov.a %a14,%d2
8002bd9e:	24 28       	st.b [%a2+],%d8
8002bda0:	80 29       	mov.d %d9,%a2
8002bda2:	60 3f       	mov.a %a15,%d3
8002bda4:	5f a9 e2 ff 	jne %d9,%d10,8002bd68 <_dtoa_r+0xa6c>
8002bda8:	19 a9 08 10 	ld.w %d9,[%sp]72
8002bdac:	19 a8 0c 10 	ld.w %d8,[%sp]76
8002bdb0:	82 06       	mov %d6,0
8002bdb2:	7b 00 fe 73 	movh %d7,16352
8002bdb6:	02 94       	mov %d4,%d9
8002bdb8:	02 85       	mov %d5,%d8
8002bdba:	6d ff b7 db 	call 80027528 <__adddf3>
8002bdbe:	0b 23 10 48 	mov %e4,%d3,%d2
8002bdc2:	80 e6       	mov.d %d6,%a14
8002bdc4:	80 f7       	mov.d %d7,%a15
8002bdc6:	6d 00 80 18 	call 8002eec6 <__ltdf2>
8002bdca:	bf 02 8b 7e 	jlt %d2,0,8002bae0 <_dtoa_r+0x7e4>
8002bdce:	02 96       	mov %d6,%d9
8002bdd0:	02 87       	mov %d7,%d8
8002bdd2:	82 04       	mov %d4,0
8002bdd4:	7b 00 fe 53 	movh %d5,16352
8002bdd8:	6d ff c5 db 	call 80027562 <__subdf3>
8002bddc:	0b 23 10 48 	mov %e4,%d3,%d2
8002bde0:	80 e6       	mov.d %d6,%a14
8002bde2:	80 f7       	mov.d %d7,%a15
8002bde4:	6d 00 51 18 	call 8002ee86 <__gtdf2>
8002bde8:	bf 12 c6 7c 	jlt %d2,1,8002b774 <_dtoa_r+0x478>
8002bdec:	60 a2       	mov.a %a2,%d10
8002bdee:	3b 00 03 30 	mov %d3,48
8002bdf2:	40 23       	mov.aa %a3,%a2
8002bdf4:	09 22 3f f4 	ld.b %d2,[+%a2]-1
8002bdf8:	5f 32 fd 7f 	jeq %d2,%d3,8002bdf2 <_dtoa_r+0xaf6>
8002bdfc:	1d ff 86 fe 	j 8002bb08 <_dtoa_r+0x80c>
8002be00:	df 43 40 7d 	jeq %d3,4,8002b880 <_dtoa_r+0x584>
8002be04:	8b c2 03 21 	rsub %d2,%d2,60
8002be08:	1d ff 31 fd 	j 8002b86a <_dtoa_r+0x56e>
8002be0c:	60 d4       	mov.a %a4,%d13
8002be0e:	40 c5       	mov.aa %a5,%a12
8002be10:	d2 54       	mov %e4,5
8002be12:	6d 00 2a 03 	call 8002c466 <__multadd>
8002be16:	60 e4       	mov.a %a4,%d14
8002be18:	40 25       	mov.aa %a5,%a2
8002be1a:	40 2c       	mov.aa %a12,%a2
8002be1c:	6d 00 ff 05 	call 8002ca1a <__mcmp>
8002be20:	bf 12 56 7d 	jlt %d2,1,8002b8cc <_dtoa_r+0x5d0>
8002be24:	3b 10 03 20 	mov %d2,49
8002be28:	60 f3       	mov.a %a3,%d15
8002be2a:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002be2e:	24 32       	st.b [%a3+],%d2
8002be30:	60 fd       	mov.a %a13,%d15
8002be32:	c2 1b       	add %d11,1
8002be34:	80 3f       	mov.d %d15,%a3
8002be36:	1d ff 4f fd 	j 8002b8d4 <_dtoa_r+0x5d8>
8002be3a:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002be3e:	c2 1b       	add %d11,1
8002be40:	60 fd       	mov.a %a13,%d15
8002be42:	19 ac 18 00 	ld.w %d12,[%sp]24
8002be46:	82 19       	mov %d9,1
8002be48:	1d 00 0a 00 	j 8002be5c <_dtoa_r+0xb60>
8002be4c:	60 e5       	mov.a %a5,%d14
8002be4e:	60 d4       	mov.a %a4,%d13
8002be50:	fb a0 00 40 	mov %e4,10
8002be54:	6d 00 09 03 	call 8002c466 <__multadd>
8002be58:	80 2e       	mov.d %d14,%a2
8002be5a:	c2 19       	add %d9,1
8002be5c:	60 e4       	mov.a %a4,%d14
8002be5e:	40 c5       	mov.aa %a5,%a12
8002be60:	6d ff 9f f9 	call 8002b19e <quorem>
8002be64:	1b 02 03 20 	addi %d2,%d2,48
8002be68:	24 d2       	st.b [%a13+],%d2
8002be6a:	3f c9 f1 7f 	jlt %d9,%d12,8002be4c <_dtoa_r+0xb50>
8002be6e:	19 a3 18 00 	ld.w %d3,[%sp]24
8002be72:	60 f2       	mov.a %a2,%d15
8002be74:	02 2a       	mov %d10,%d2
8002be76:	8b 13 80 22 	ge %d2,%d3,1
8002be7a:	ab 13 80 22 	sel %d2,%d2,%d3,1
8002be7e:	01 22 00 e6 	addsc.a %a14,%a2,%d2,0
8002be82:	82 0c       	mov %d12,0
8002be84:	60 e5       	mov.a %a5,%d14
8002be86:	60 d4       	mov.a %a4,%d13
8002be88:	82 14       	mov %d4,1
8002be8a:	6d 00 41 05 	call 8002c90c <__lshift>
8002be8e:	40 c5       	mov.aa %a5,%a12
8002be90:	40 24       	mov.aa %a4,%a2
8002be92:	80 2e       	mov.d %d14,%a2
8002be94:	6d 00 c3 05 	call 8002ca1a <__mcmp>
8002be98:	bf 12 56 01 	jlt %d2,1,8002c144 <_dtoa_r+0xe48>
8002be9c:	79 e2 ff ff 	ld.b %d2,[%a14]-1
8002bea0:	60 f2       	mov.a %a2,%d15
8002bea2:	3b 90 03 30 	mov %d3,57
8002bea6:	1d 00 07 00 	j 8002beb4 <_dtoa_r+0xbb8>
8002beaa:	7d 23 46 01 	jeq.a %a3,%a2,8002c136 <_dtoa_r+0xe3a>
8002beae:	79 32 ff ff 	ld.b %d2,[%a3]-1
8002beb2:	40 3e       	mov.aa %a14,%a3
8002beb4:	d9 e3 ff ff 	lea %a3,[%a14]-1
8002beb8:	5f 32 f9 7f 	jeq %d2,%d3,8002beaa <_dtoa_r+0xbae>
8002bebc:	c2 12       	add %d2,1
8002bebe:	80 2f       	mov.d %d15,%a2
8002bec0:	34 32       	st.b [%a3],%d2
8002bec2:	60 d4       	mov.a %a4,%d13
8002bec4:	40 c5       	mov.aa %a5,%a12
8002bec6:	6d 00 c2 02 	call 8002c44a <_Bfree>
8002beca:	df 08 4b 01 	jeq %d8,0,8002c160 <_dtoa_r+0xe64>
8002bece:	0b 8c 10 21 	ne %d2,%d12,%d8
8002bed2:	8b 0c 20 24 	and.ne %d2,%d12,0
8002bed6:	df 02 5d 02 	jeq %d2,0,8002c390 <_dtoa_r+0x1094>
8002beda:	60 c5       	mov.a %a5,%d12
8002bedc:	60 d4       	mov.a %a4,%d13
8002bede:	60 fd       	mov.a %a13,%d15
8002bee0:	6d 00 b5 02 	call 8002c44a <_Bfree>
8002bee4:	80 ef       	mov.d %d15,%a14
8002bee6:	1d ff fe fc 	j 8002b8e2 <_dtoa_r+0x5e6>
8002beea:	19 a2 28 00 	ld.w %d2,[%sp]40
8002beee:	df 02 fa fe 	jne %d2,0,8002bce2 <_dtoa_r+0x9e6>
8002bef2:	b7 0b 0c 2a 	insert %d2,%d11,0,20,12
8002bef6:	df 02 f6 fe 	jne %d2,0,8002bce2 <_dtoa_r+0x9e6>
8002befa:	7b 00 ff 27 	movh %d2,32752
8002befe:	26 b2       	and %d2,%d11
8002bf00:	a0 0d       	mov.a %a13,0
8002bf02:	df 02 a4 7c 	jeq %d2,0,8002b84a <_dtoa_r+0x54e>
8002bf06:	19 a2 10 00 	ld.w %d2,[%sp]16
8002bf0a:	a0 1d       	mov.a %a13,1
8002bf0c:	c2 12       	add %d2,1
8002bf0e:	59 a2 10 00 	st.w [%sp]16,%d2
8002bf12:	19 a2 08 00 	ld.w %d2,[%sp]8
8002bf16:	c2 12       	add %d2,1
8002bf18:	59 a2 08 00 	st.w [%sp]8,%d2
8002bf1c:	1d ff 97 fc 	j 8002b84a <_dtoa_r+0x54e>
8002bf20:	a0 0c       	mov.a %a12,0
8002bf22:	82 08       	mov %d8,0
8002bf24:	1d ff d4 fc 	j 8002b8cc <_dtoa_r+0x5d0>
8002bf28:	0b a2 80 a0 	sub %d10,%d2,%d10
8002bf2c:	1d ff 4a fc 	j 8002b7c0 <_dtoa_r+0x4c4>
8002bf30:	60 85       	mov.a %a5,%d8
8002bf32:	60 d4       	mov.a %a4,%d13
8002bf34:	02 a4       	mov %d4,%d10
8002bf36:	6d 00 7b 04 	call 8002c82c <__pow5mult>
8002bf3a:	60 e6       	mov.a %a6,%d14
8002bf3c:	60 d4       	mov.a %a4,%d13
8002bf3e:	40 25       	mov.aa %a5,%a2
8002bf40:	80 28       	mov.d %d8,%a2
8002bf42:	6d 00 a4 03 	call 8002c68a <__multiply>
8002bf46:	60 e5       	mov.a %a5,%d14
8002bf48:	60 d4       	mov.a %a4,%d13
8002bf4a:	40 2c       	mov.aa %a12,%a2
8002bf4c:	80 ce       	mov.d %d14,%a12
8002bf4e:	6d 00 7e 02 	call 8002c44a <_Bfree>
8002bf52:	1d ff 6b fc 	j 8002b828 <_dtoa_r+0x52c>
8002bf56:	82 12       	mov %d2,1
8002bf58:	59 a2 30 00 	st.w [%sp]48,%d2
8002bf5c:	19 a5 14 00 	ld.w %d5,[%sp]20
8002bf60:	bf 15 45 00 	jlt %d5,1,8002bfea <_dtoa_r+0xcee>
8002bf64:	59 a5 3c 00 	st.w [%sp]60,%d5
8002bf68:	59 a5 18 00 	st.w [%sp]24,%d5
8002bf6c:	82 02       	mov %d2,0
8002bf6e:	60 d2       	mov.a %a2,%d13
8002bf70:	82 04       	mov %d4,0
8002bf72:	59 22 3c 00 	st.w [%a2]60,%d2
8002bf76:	8b 85 41 22 	lt %d2,%d5,24
8002bf7a:	df 02 5e fb 	jne %d2,0,8002b636 <_dtoa_r+0x33a>
8002bf7e:	82 11       	mov %d1,1
8002bf80:	82 43       	mov %d3,4
8002bf82:	06 13       	sh %d3,1
8002bf84:	1b 43 01 20 	addi %d2,%d3,20
8002bf88:	02 14       	mov %d4,%d1
8002bf8a:	c2 11       	add %d1,1
8002bf8c:	7f 25 fb ff 	jge.u %d5,%d2,8002bf82 <_dtoa_r+0xc86>
8002bf90:	60 d2       	mov.a %a2,%d13
8002bf92:	59 24 3c 00 	st.w [%a2]60,%d4
8002bf96:	1d ff 50 fb 	j 8002b636 <_dtoa_r+0x33a>
8002bf9a:	82 12       	mov %d2,1
8002bf9c:	59 a2 30 00 	st.w [%sp]48,%d2
8002bfa0:	19 a2 14 00 	ld.w %d2,[%sp]20
8002bfa4:	19 a3 1c 00 	ld.w %d3,[%sp]28
8002bfa8:	42 32       	add %d2,%d3
8002bfaa:	59 a2 3c 00 	st.w [%sp]60,%d2
8002bfae:	c2 12       	add %d2,1
8002bfb0:	8b 12 40 53 	max %d5,%d2,1
8002bfb4:	59 a2 18 00 	st.w [%sp]24,%d2
8002bfb8:	1d ff da ff 	j 8002bf6c <_dtoa_r+0xc70>
8002bfbc:	82 02       	mov %d2,0
8002bfbe:	59 a2 30 00 	st.w [%sp]48,%d2
8002bfc2:	1d ff ef ff 	j 8002bfa0 <_dtoa_r+0xca4>
8002bfc6:	82 02       	mov %d2,0
8002bfc8:	59 a2 30 00 	st.w [%sp]48,%d2
8002bfcc:	1d ff c8 ff 	j 8002bf5c <_dtoa_r+0xc60>
8002bfd0:	60 d4       	mov.a %a4,%d13
8002bfd2:	82 1c       	mov %d12,1
8002bfd4:	6d 00 3b 02 	call 8002c44a <_Bfree>
8002bfd8:	1d ff e2 fd 	j 8002bb9c <_dtoa_r+0x8a0>
8002bfdc:	6d 00 45 02 	call 8002c466 <__multadd>
8002bfe0:	80 28       	mov.d %d8,%a2
8002bfe2:	80 29       	mov.d %d9,%a2
8002bfe4:	40 df       	mov.aa %a15,%a13
8002bfe6:	1d ff b6 fd 	j 8002bb52 <_dtoa_r+0x856>
8002bfea:	82 12       	mov %d2,1
8002bfec:	59 a2 14 00 	st.w [%sp]20,%d2
8002bff0:	59 a2 18 00 	st.w [%sp]24,%d2
8002bff4:	1d ff 18 fb 	j 8002b624 <_dtoa_r+0x328>
8002bff8:	3b c0 01 20 	mov %d2,28
8002bffc:	1d ff 37 fc 	j 8002b86a <_dtoa_r+0x56e>
8002c000:	19 a2 28 00 	ld.w %d2,[%sp]40
8002c004:	df 02 23 fc 	jne %d2,0,8002b84a <_dtoa_r+0x54e>
8002c008:	b7 0b 0c 2a 	insert %d2,%d11,0,20,12
8002c00c:	df 02 1f fc 	jne %d2,0,8002b84a <_dtoa_r+0x54e>
8002c010:	1d ff 75 ff 	j 8002befa <_dtoa_r+0xbfe>
8002c014:	19 a2 38 00 	ld.w %d2,[%sp]56
8002c018:	df 02 c8 00 	jeq %d2,0,8002c1a8 <_dtoa_r+0xeac>
8002c01c:	19 a2 08 00 	ld.w %d2,[%sp]8
8002c020:	1b 33 43 30 	addi %d3,%d3,1075
8002c024:	42 32       	add %d2,%d3
8002c026:	19 aa 2c 00 	ld.w %d10,[%sp]44
8002c02a:	59 a2 08 00 	st.w [%sp]8,%d2
8002c02e:	19 a2 10 00 	ld.w %d2,[%sp]16
8002c032:	02 29       	mov %d9,%d2
8002c034:	42 32       	add %d2,%d3
8002c036:	59 a2 10 00 	st.w [%sp]16,%d2
8002c03a:	1d ff d4 fb 	j 8002b7e2 <_dtoa_r+0x4e6>
8002c03e:	a0 0c       	mov.a %a12,0
8002c040:	82 08       	mov %d8,0
8002c042:	1d ff f1 fe 	j 8002be24 <_dtoa_r+0xb28>
8002c046:	19 a2 1c 00 	ld.w %d2,[%sp]28
8002c04a:	91 00 00 28 	movh.a %a2,32768
8002c04e:	06 32       	sh %d2,3
8002c050:	d9 22 cc c3 	lea %a2,[%a2]16140 <80003f0c <__mprec_tens>>
8002c054:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8002c058:	82 f2       	mov %d2,-1
8002c05a:	09 2c c0 09 	ld.da %a12,[%a2]
8002c05e:	59 a2 18 00 	st.w [%sp]24,%d2
8002c062:	19 aa 20 00 	ld.w %d10,[%sp]32
8002c066:	19 a9 24 00 	ld.w %d9,[%sp]36
8002c06a:	80 c6       	mov.d %d6,%a12
8002c06c:	80 d7       	mov.d %d7,%a13
8002c06e:	02 a4       	mov %d4,%d10
8002c070:	02 95       	mov %d5,%d9
8002c072:	6d 00 22 16 	call 8002ecb6 <__divdf3>
8002c076:	0b 23 10 48 	mov %e4,%d3,%d2
8002c07a:	6d ff c9 db 	call 8002780c <__fixdfsi>
8002c07e:	02 24       	mov %d4,%d2
8002c080:	02 28       	mov %d8,%d2
8002c082:	6d 00 7c 17 	call 8002ef7a <__floatsidf>
8002c086:	0b 23 10 48 	mov %e4,%d3,%d2
8002c08a:	80 c6       	mov.d %d6,%a12
8002c08c:	80 d7       	mov.d %d7,%a13
8002c08e:	6d ff 8d da 	call 800275a8 <__muldf3>
8002c092:	0b 23 10 68 	mov %e6,%d3,%d2
8002c096:	02 a4       	mov %d4,%d10
8002c098:	02 95       	mov %d5,%d9
8002c09a:	6d ff 64 da 	call 80027562 <__subdf3>
8002c09e:	60 23       	mov.a %a3,%d2
8002c0a0:	1b 08 03 20 	addi %d2,%d8,48
8002c0a4:	60 f2       	mov.a %a2,%d15
8002c0a6:	82 19       	mov %d9,1
8002c0a8:	24 22       	st.b [%a2+],%d2
8002c0aa:	19 a2 18 00 	ld.w %d2,[%sp]24
8002c0ae:	60 3e       	mov.a %a14,%d3
8002c0b0:	19 ab 18 00 	ld.w %d11,[%sp]24
8002c0b4:	80 2a       	mov.d %d10,%a2
8002c0b6:	40 34       	mov.aa %a4,%a3
8002c0b8:	5f 92 28 80 	jne %d2,%d9,8002c108 <_dtoa_r+0xe0c>
8002c0bc:	1d 00 d4 00 	j 8002c264 <_dtoa_r+0xf68>
8002c0c0:	80 c6       	mov.d %d6,%a12
8002c0c2:	80 d7       	mov.d %d7,%a13
8002c0c4:	80 e5       	mov.d %d5,%a14
8002c0c6:	80 f4       	mov.d %d4,%a15
8002c0c8:	6d 00 f7 15 	call 8002ecb6 <__divdf3>
8002c0cc:	0b 23 10 48 	mov %e4,%d3,%d2
8002c0d0:	c2 19       	add %d9,1
8002c0d2:	6d ff 9d db 	call 8002780c <__fixdfsi>
8002c0d6:	02 24       	mov %d4,%d2
8002c0d8:	02 28       	mov %d8,%d2
8002c0da:	6d 00 50 17 	call 8002ef7a <__floatsidf>
8002c0de:	0b 23 10 48 	mov %e4,%d3,%d2
8002c0e2:	80 c6       	mov.d %d6,%a12
8002c0e4:	80 d7       	mov.d %d7,%a13
8002c0e6:	6d ff 61 da 	call 800275a8 <__muldf3>
8002c0ea:	0b 23 10 68 	mov %e6,%d3,%d2
8002c0ee:	80 e5       	mov.d %d5,%a14
8002c0f0:	80 f4       	mov.d %d4,%a15
8002c0f2:	6d ff 38 da 	call 80027562 <__subdf3>
8002c0f6:	60 24       	mov.a %a4,%d2
8002c0f8:	1b 08 03 20 	addi %d2,%d8,48
8002c0fc:	60 a2       	mov.a %a2,%d10
8002c0fe:	60 3e       	mov.a %a14,%d3
8002c100:	24 22       	st.b [%a2+],%d2
8002c102:	80 2a       	mov.d %d10,%a2
8002c104:	5f b9 af 00 	jeq %d9,%d11,8002c262 <_dtoa_r+0xf66>
8002c108:	80 e5       	mov.d %d5,%a14
8002c10a:	82 06       	mov %d6,0
8002c10c:	7b 40 02 74 	movh %d7,16420
8002c110:	80 44       	mov.d %d4,%a4
8002c112:	6d ff 4b da 	call 800275a8 <__muldf3>
8002c116:	60 3e       	mov.a %a14,%d3
8002c118:	d2 06       	mov %e6,0
8002c11a:	02 24       	mov %d4,%d2
8002c11c:	02 35       	mov %d5,%d3
8002c11e:	60 2f       	mov.a %a15,%d2
8002c120:	6d 00 73 16 	call 8002ee06 <__eqdf2>
8002c124:	df 02 ce ff 	jne %d2,0,8002c0c0 <_dtoa_r+0xdc4>
8002c128:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002c12c:	60 fd       	mov.a %a13,%d15
8002c12e:	c2 1b       	add %d11,1
8002c130:	02 af       	mov %d15,%d10
8002c132:	1d ff dc fb 	j 8002b8ea <_dtoa_r+0x5ee>
8002c136:	3b 10 03 20 	mov %d2,49
8002c13a:	80 2f       	mov.d %d15,%a2
8002c13c:	c2 1b       	add %d11,1
8002c13e:	34 22       	st.b [%a2],%d2
8002c140:	1d ff c1 fe 	j 8002bec2 <_dtoa_r+0xbc6>
8002c144:	df 02 04 80 	jne %d2,0,8002c14c <_dtoa_r+0xe50>
8002c148:	6f 0a aa fe 	jnz.t %d10,0,8002be9c <_dtoa_r+0xba0>
8002c14c:	3b 00 03 30 	mov %d3,48
8002c150:	40 e3       	mov.aa %a3,%a14
8002c152:	09 e2 3f f4 	ld.b %d2,[+%a14]-1
8002c156:	5f 32 fd 7f 	jeq %d2,%d3,8002c150 <_dtoa_r+0xe54>
8002c15a:	40 3e       	mov.aa %a14,%a3
8002c15c:	1d ff b3 fe 	j 8002bec2 <_dtoa_r+0xbc6>
8002c160:	60 fd       	mov.a %a13,%d15
8002c162:	80 ef       	mov.d %d15,%a14
8002c164:	1d ff c3 fb 	j 8002b8ea <_dtoa_r+0x5ee>
8002c168:	19 a2 04 10 	ld.w %d2,[%sp]68
8002c16c:	80 2a       	mov.d %d10,%a2
8002c16e:	c2 12       	add %d2,1
8002c170:	80 4f       	mov.d %d15,%a4
8002c172:	59 a2 04 10 	st.w [%sp]68,%d2
8002c176:	3b 10 03 20 	mov %d2,49
8002c17a:	1d ff c5 fc 	j 8002bb04 <_dtoa_r+0x808>
8002c17e:	02 a4       	mov %d4,%d10
8002c180:	6d 00 fd 16 	call 8002ef7a <__floatsidf>
8002c184:	0b 23 10 48 	mov %e4,%d3,%d2
8002c188:	80 e6       	mov.d %d6,%a14
8002c18a:	80 f7       	mov.d %d7,%a15
8002c18c:	6d ff 0e da 	call 800275a8 <__muldf3>
8002c190:	0b 23 10 48 	mov %e4,%d3,%d2
8002c194:	82 06       	mov %d6,0
8002c196:	7b c0 01 74 	movh %d7,16412
8002c19a:	6d ff c7 d9 	call 80027528 <__adddf3>
8002c19e:	02 28       	mov %d8,%d2
8002c1a0:	9b 03 cc 9f 	addih %d9,%d3,64704
8002c1a4:	1d ff cc fa 	j 8002b73c <_dtoa_r+0x440>
8002c1a8:	19 a2 10 10 	ld.w %d2,[%sp]80
8002c1ac:	19 a3 08 00 	ld.w %d3,[%sp]8
8002c1b0:	8b 62 03 21 	rsub %d2,%d2,54
8002c1b4:	42 23       	add %d3,%d2
8002c1b6:	19 aa 2c 00 	ld.w %d10,[%sp]44
8002c1ba:	59 a3 08 00 	st.w [%sp]8,%d3
8002c1be:	19 a3 10 00 	ld.w %d3,[%sp]16
8002c1c2:	02 39       	mov %d9,%d3
8002c1c4:	42 23       	add %d3,%d2
8002c1c6:	59 a3 10 00 	st.w [%sp]16,%d3
8002c1ca:	1d ff 0c fb 	j 8002b7e2 <_dtoa_r+0x4e6>
8002c1ce:	80 ea       	mov.d %d10,%a14
8002c1d0:	58 04       	ld.w %d15,[%sp]16
8002c1d2:	40 2e       	mov.aa %a14,%a2
8002c1d4:	bf 1c 15 00 	jlt %d12,1,8002c1fe <_dtoa_r+0xf02>
8002c1d8:	60 e5       	mov.a %a5,%d14
8002c1da:	60 d4       	mov.a %a4,%d13
8002c1dc:	82 14       	mov %d4,1
8002c1de:	6d 00 97 03 	call 8002c90c <__lshift>
8002c1e2:	40 c5       	mov.aa %a5,%a12
8002c1e4:	40 24       	mov.aa %a4,%a2
8002c1e6:	80 2e       	mov.d %d14,%a2
8002c1e8:	6d 00 19 04 	call 8002ca1a <__mcmp>
8002c1ec:	bf 12 bf 00 	jlt %d2,1,8002c36a <_dtoa_r+0x106e>
8002c1f0:	8b 9a 03 a2 	eq %d10,%d10,57
8002c1f4:	df 0a 74 80 	jne %d10,0,8002c2dc <_dtoa_r+0xfe0>
8002c1f8:	54 a2       	ld.w %d2,[%sp]
8002c1fa:	1b 12 03 a0 	addi %d10,%d2,49
8002c1fe:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002c202:	02 8c       	mov %d12,%d8
8002c204:	28 0a       	st.b [%a15]0,%d10
8002c206:	c2 1b       	add %d11,1
8002c208:	02 98       	mov %d8,%d9
8002c20a:	1d ff 5c fe 	j 8002bec2 <_dtoa_r+0xbc6>
8002c20e:	19 ab 04 10 	ld.w %d11,[%sp]68
8002c212:	60 fd       	mov.a %a13,%d15
8002c214:	c2 1b       	add %d11,1
8002c216:	02 9f       	mov %d15,%d9
8002c218:	1d ff 69 fb 	j 8002b8ea <_dtoa_r+0x5ee>
8002c21c:	60 82       	mov.a %a2,%d8
8002c21e:	60 d4       	mov.a %a4,%d13
8002c220:	19 24 04 00 	ld.w %d4,[%a2]4
8002c224:	6d 00 dd 00 	call 8002c3de <_Balloc>
8002c228:	40 2d       	mov.aa %a13,%a2
8002c22a:	bd 02 b7 00 	jz.a %a2,8002c398 <_dtoa_r+0x109c>
8002c22e:	60 82       	mov.a %a2,%d8
8002c230:	d9 d4 0c 00 	lea %a4,[%a13]12
8002c234:	19 22 10 00 	ld.w %d2,[%a2]16
8002c238:	d9 25 0c 00 	lea %a5,[%a2]12
8002c23c:	1b 22 00 40 	addi %d4,%d2,2
8002c240:	06 24       	sh %d4,2
8002c242:	6d ff ed d7 	call 8002721c <memcpy>
8002c246:	60 d4       	mov.a %a4,%d13
8002c248:	82 14       	mov %d4,1
8002c24a:	40 d5       	mov.aa %a5,%a13
8002c24c:	6d 00 60 03 	call 8002c90c <__lshift>
8002c250:	80 29       	mov.d %d9,%a2
8002c252:	1d ff 71 fc 	j 8002bb34 <_dtoa_r+0x838>
8002c256:	19 ac 08 10 	ld.w %d12,[%sp]72
8002c25a:	19 ab 00 10 	ld.w %d11,[%sp]64
8002c25e:	1d ff 8b fa 	j 8002b774 <_dtoa_r+0x478>
8002c262:	40 43       	mov.aa %a3,%a4
8002c264:	80 e7       	mov.d %d7,%a14
8002c266:	80 e5       	mov.d %d5,%a14
8002c268:	80 36       	mov.d %d6,%a3
8002c26a:	80 34       	mov.d %d4,%a3
8002c26c:	6d ff 5e d9 	call 80027528 <__adddf3>
8002c270:	60 2f       	mov.a %a15,%d2
8002c272:	60 3e       	mov.a %a14,%d3
8002c274:	19 a2 1c 00 	ld.w %d2,[%sp]28
8002c278:	80 c6       	mov.d %d6,%a12
8002c27a:	80 d7       	mov.d %d7,%a13
8002c27c:	80 f4       	mov.d %d4,%a15
8002c27e:	02 35       	mov %d5,%d3
8002c280:	1b 12 00 b0 	addi %d11,%d2,1
8002c284:	6d 00 01 16 	call 8002ee86 <__gtdf2>
8002c288:	ff 12 37 00 	jge %d2,1,8002c2f6 <_dtoa_r+0xffa>
8002c28c:	80 c6       	mov.d %d6,%a12
8002c28e:	80 d7       	mov.d %d7,%a13
8002c290:	80 f4       	mov.d %d4,%a15
8002c292:	80 e5       	mov.d %d5,%a14
8002c294:	6d 00 b9 15 	call 8002ee06 <__eqdf2>
8002c298:	df 02 04 80 	jne %d2,0,8002c2a0 <_dtoa_r+0xfa4>
8002c29c:	6f 08 2d 80 	jnz.t %d8,0,8002c2f6 <_dtoa_r+0xffa>
8002c2a0:	60 fd       	mov.a %a13,%d15
8002c2a2:	02 af       	mov %d15,%d10
8002c2a4:	1d ff 23 fb 	j 8002b8ea <_dtoa_r+0x5ee>
8002c2a8:	80 ea       	mov.d %d10,%a14
8002c2aa:	8b 9a 23 22 	ne %d2,%d10,57
8002c2ae:	58 04       	ld.w %d15,[%sp]16
8002c2b0:	40 2e       	mov.aa %a14,%a2
8002c2b2:	df 02 15 00 	jeq %d2,0,8002c2dc <_dtoa_r+0xfe0>
8002c2b6:	c2 1a       	add %d10,1
8002c2b8:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002c2bc:	02 8c       	mov %d12,%d8
8002c2be:	c2 1b       	add %d11,1
8002c2c0:	28 0a       	st.b [%a15]0,%d10
8002c2c2:	02 98       	mov %d8,%d9
8002c2c4:	1d ff ff fd 	j 8002bec2 <_dtoa_r+0xbc6>
8002c2c8:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002c2cc:	80 ea       	mov.d %d10,%a14
8002c2ce:	02 8c       	mov %d12,%d8
8002c2d0:	58 04       	ld.w %d15,[%sp]16
8002c2d2:	40 2e       	mov.aa %a14,%a2
8002c2d4:	c2 1b       	add %d11,1
8002c2d6:	02 98       	mov %d8,%d9
8002c2d8:	1d ff d6 fd 	j 8002be84 <_dtoa_r+0xb88>
8002c2dc:	3b 90 03 20 	mov %d2,57
8002c2e0:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002c2e4:	02 8c       	mov %d12,%d8
8002c2e6:	28 02       	st.b [%a15]0,%d2
8002c2e8:	40 de       	mov.aa %a14,%a13
8002c2ea:	c2 1b       	add %d11,1
8002c2ec:	02 98       	mov %d8,%d9
8002c2ee:	3b 90 03 20 	mov %d2,57
8002c2f2:	1d ff d7 fd 	j 8002bea0 <_dtoa_r+0xba4>
8002c2f6:	19 a2 1c 00 	ld.w %d2,[%sp]28
8002c2fa:	59 a2 04 10 	st.w [%sp]68,%d2
8002c2fe:	1d ff f1 fb 	j 8002bae0 <_dtoa_r+0x7e4>
8002c302:	80 ea       	mov.d %d10,%a14
8002c304:	8b 9a 03 22 	eq %d2,%d10,57
8002c308:	58 04       	ld.w %d15,[%sp]16
8002c30a:	d9 fd 01 00 	lea %a13,[%a15]1
8002c30e:	df 02 e7 ff 	jne %d2,0,8002c2dc <_dtoa_r+0xfe0>
8002c312:	54 a2       	ld.w %d2,[%sp]
8002c314:	8b 1b 80 b2 	ge %d11,%d11,1
8002c318:	1b 12 03 20 	addi %d2,%d2,49
8002c31c:	2b a2 40 ab 	sel %d10,%d11,%d2,%d10
8002c320:	19 ab 1c 00 	ld.w %d11,[%sp]28
8002c324:	40 fe       	mov.aa %a14,%a15
8002c326:	02 8c       	mov %d12,%d8
8002c328:	24 ea       	st.b [%a14+],%d10
8002c32a:	c2 1b       	add %d11,1
8002c32c:	02 98       	mov %d8,%d9
8002c32e:	1d ff ca fd 	j 8002bec2 <_dtoa_r+0xbc6>
8002c332:	02 9a       	mov %d10,%d9
8002c334:	1d ff 3a fd 	j 8002bda8 <_dtoa_r+0xaac>
8002c338:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002c33c:	59 ac 1c 00 	st.w [%sp]28,%d12
8002c340:	59 a2 18 00 	st.w [%sp]24,%d2
8002c344:	1d ff c0 fa 	j 8002b8c4 <_dtoa_r+0x5c8>
8002c348:	60 85       	mov.a %a5,%d8
8002c34a:	60 d4       	mov.a %a4,%d13
8002c34c:	fb a0 00 40 	mov %e4,10
8002c350:	6d 00 8b 00 	call 8002c466 <__multadd>
8002c354:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002c358:	59 ac 1c 00 	st.w [%sp]28,%d12
8002c35c:	59 a2 18 00 	st.w [%sp]24,%d2
8002c360:	80 28       	mov.d %d8,%a2
8002c362:	df 0a de 7b 	jeq %d10,0,8002bb1e <_dtoa_r+0x822>
8002c366:	1d ff af fa 	j 8002b8c4 <_dtoa_r+0x5c8>
8002c36a:	df 02 4a ff 	jne %d2,0,8002c1fe <_dtoa_r+0xf02>
8002c36e:	6f 0a 41 ff 	jnz.t %d10,0,8002c1f0 <_dtoa_r+0xef4>
8002c372:	1d ff 46 ff 	j 8002c1fe <_dtoa_r+0xf02>
8002c376:	91 00 00 68 	movh.a %a6,32768
8002c37a:	91 00 00 48 	movh.a %a4,32768
8002c37e:	d9 66 c6 63 	lea %a6,[%a6]15750 <80003d86 <blanks.1+0x2a>>
8002c382:	a0 05       	mov.a %a5,0
8002c384:	3b f0 1a 40 	mov %d4,431
8002c388:	d9 44 d7 63 	lea %a4,[%a4]15767 <80003d97 <blanks.1+0x3b>>
8002c38c:	1d 00 68 07 	j 8002d25c <__assert_func>
8002c390:	60 fd       	mov.a %a13,%d15
8002c392:	80 ef       	mov.d %d15,%a14
8002c394:	1d ff a7 fa 	j 8002b8e2 <_dtoa_r+0x5e6>
8002c398:	91 00 00 68 	movh.a %a6,32768
8002c39c:	91 00 00 48 	movh.a %a4,32768
8002c3a0:	d9 66 c6 63 	lea %a6,[%a6]15750 <80003d86 <blanks.1+0x2a>>
8002c3a4:	a0 05       	mov.a %a5,0
8002c3a6:	3b f0 2e 40 	mov %d4,751
8002c3aa:	d9 44 d7 63 	lea %a4,[%a4]15767 <80003d97 <blanks.1+0x3b>>
8002c3ae:	1d 00 57 07 	j 8002d25c <__assert_func>

8002c3b2 <_dtoa_r_end>:
	...

8002c3b4 <__ascii_mbtowc>:
8002c3b4:	20 08       	sub.a %sp,8
8002c3b6:	d9 a2 04 00 	lea %a2,[%sp]4
8002c3ba:	80 52       	mov.d %d2,%a5
8002c3bc:	02 43       	mov %d3,%d4
8002c3be:	80 24       	mov.d %d4,%a2
8002c3c0:	2b 42 40 42 	sel %d4,%d2,%d2,%d4
8002c3c4:	82 02       	mov %d2,0
8002c3c6:	bd 06 0b 00 	jz.a %a6,8002c3dc <__ascii_mbtowc+0x28>
8002c3ca:	82 e2       	mov %d2,-2
8002c3cc:	df 03 08 00 	jeq %d3,0,8002c3dc <__ascii_mbtowc+0x28>
8002c3d0:	60 42       	mov.a %a2,%d4
8002c3d2:	14 62       	ld.bu %d2,[%a6]
8002c3d4:	74 22       	st.w [%a2],%d2
8002c3d6:	14 62       	ld.bu %d2,[%a6]
8002c3d8:	8b 02 20 22 	ne %d2,%d2,0
8002c3dc:	00 90       	ret 

8002c3de <_Balloc>:
8002c3de:	99 42 04 10 	ld.a %a2,[%a4]68
8002c3e2:	40 4c       	mov.aa %a12,%a4
8002c3e4:	02 48       	mov %d8,%d4
8002c3e6:	bd 02 11 00 	jz.a %a2,8002c408 <_Balloc+0x2a>
8002c3ea:	8f 28 00 20 	sh %d2,%d8,2
8002c3ee:	01 22 00 36 	addsc.a %a3,%a2,%d2,0
8002c3f2:	d4 32       	ld.a %a2,[%a3]
8002c3f4:	bd 02 15 00 	jz.a %a2,8002c41e <_Balloc+0x40>
8002c3f8:	54 22       	ld.w %d2,[%a2]
8002c3fa:	74 32       	st.w [%a3],%d2
8002c3fc:	82 02       	mov %d2,0
8002c3fe:	59 22 10 00 	st.w [%a2]16,%d2
8002c402:	59 22 0c 00 	st.w [%a2]12,%d2
8002c406:	00 90       	ret 
8002c408:	3b 10 02 50 	mov %d5,33
8002c40c:	82 44       	mov %d4,4
8002c40e:	6d 00 4e 07 	call 8002d2aa <_calloc_r>
8002c412:	b5 c2 04 10 	st.a [%a12]68,%a2
8002c416:	bd 02 ea ff 	jnz.a %a2,8002c3ea <_Balloc+0xc>
8002c41a:	a0 02       	mov.a %a2,0
8002c41c:	00 90       	ret 
8002c41e:	82 19       	mov %d9,1
8002c420:	0f 89 00 90 	sh %d9,%d9,%d8
8002c424:	1b 59 00 50 	addi %d5,%d9,5
8002c428:	06 25       	sh %d5,2
8002c42a:	82 14       	mov %d4,1
8002c42c:	40 c4       	mov.aa %a4,%a12
8002c42e:	6d 00 3e 07 	call 8002d2aa <_calloc_r>
8002c432:	bd 02 f4 7f 	jz.a %a2,8002c41a <_Balloc+0x3c>
8002c436:	82 02       	mov %d2,0
8002c438:	59 28 04 00 	st.w [%a2]4,%d8
8002c43c:	59 29 08 00 	st.w [%a2]8,%d9
8002c440:	59 22 10 00 	st.w [%a2]16,%d2
8002c444:	59 22 0c 00 	st.w [%a2]12,%d2
8002c448:	00 90       	ret 

8002c44a <_Bfree>:
8002c44a:	bd 05 0d 00 	jz.a %a5,8002c464 <_Bfree+0x1a>
8002c44e:	19 43 04 10 	ld.w %d3,[%a4]68
8002c452:	19 52 04 00 	ld.w %d2,[%a5]4
8002c456:	60 32       	mov.a %a2,%d3
8002c458:	06 22       	sh %d2,2
8002c45a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8002c45e:	54 22       	ld.w %d2,[%a2]
8002c460:	74 52       	st.w [%a5],%d2
8002c462:	f4 25       	st.a [%a2],%a5
8002c464:	00 90       	ret 

8002c466 <__multadd>:
8002c466:	19 59 10 00 	ld.w %d9,[%a5]16
8002c46a:	02 58       	mov %d8,%d5
8002c46c:	40 4d       	mov.aa %a13,%a4
8002c46e:	40 5c       	mov.aa %a12,%a5
8002c470:	d9 53 14 00 	lea %a3,[%a5]20
8002c474:	82 05       	mov %d5,0
8002c476:	54 36       	ld.w %d6,[%a3]
8002c478:	40 32       	mov.aa %a2,%a3
8002c47a:	b7 06 10 28 	insert %d2,%d6,0,16,16
8002c47e:	8f 06 1f 60 	sh %d6,%d6,-16
8002c482:	03 42 0a 28 	madd %d2,%d8,%d2,%d4
8002c486:	c2 15       	add %d5,1
8002c488:	b0 43       	add.a %a3,4
8002c48a:	8f 02 1f 30 	sh %d3,%d2,-16
8002c48e:	03 46 0a 33 	madd %d3,%d3,%d6,%d4
8002c492:	b7 02 10 28 	insert %d2,%d2,0,16,16
8002c496:	8f 03 1f 80 	sh %d8,%d3,-16
8002c49a:	8f 03 01 30 	sh %d3,%d3,16
8002c49e:	42 32       	add %d2,%d3
8002c4a0:	74 22       	st.w [%a2],%d2
8002c4a2:	3f 95 ea 7f 	jlt %d5,%d9,8002c476 <__multadd+0x10>
8002c4a6:	df 08 0f 00 	jeq %d8,0,8002c4c4 <__multadd+0x5e>
8002c4aa:	19 c2 08 00 	ld.w %d2,[%a12]8
8002c4ae:	7f 29 0d 00 	jge %d9,%d2,8002c4c8 <__multadd+0x62>
8002c4b2:	1b 59 00 20 	addi %d2,%d9,5
8002c4b6:	06 22       	sh %d2,2
8002c4b8:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
8002c4bc:	c2 19       	add %d9,1
8002c4be:	74 28       	st.w [%a2],%d8
8002c4c0:	59 c9 10 00 	st.w [%a12]16,%d9
8002c4c4:	40 c2       	mov.aa %a2,%a12
8002c4c6:	00 90       	ret 
8002c4c8:	19 c2 04 00 	ld.w %d2,[%a12]4
8002c4cc:	40 d4       	mov.aa %a4,%a13
8002c4ce:	1b 12 00 40 	addi %d4,%d2,1
8002c4d2:	6d ff 86 ff 	call 8002c3de <_Balloc>
8002c4d6:	40 2e       	mov.aa %a14,%a2
8002c4d8:	bd 02 1b 00 	jz.a %a2,8002c50e <__multadd+0xa8>
8002c4dc:	19 c2 10 00 	ld.w %d2,[%a12]16
8002c4e0:	d9 c5 0c 00 	lea %a5,[%a12]12
8002c4e4:	1b 22 00 40 	addi %d4,%d2,2
8002c4e8:	06 24       	sh %d4,2
8002c4ea:	d9 24 0c 00 	lea %a4,[%a2]12
8002c4ee:	6d ff 97 d6 	call 8002721c <memcpy>
8002c4f2:	19 d3 04 10 	ld.w %d3,[%a13]68
8002c4f6:	19 c2 04 00 	ld.w %d2,[%a12]4
8002c4fa:	60 32       	mov.a %a2,%d3
8002c4fc:	06 22       	sh %d2,2
8002c4fe:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8002c502:	54 22       	ld.w %d2,[%a2]
8002c504:	74 c2       	st.w [%a12],%d2
8002c506:	f4 2c       	st.a [%a2],%a12
8002c508:	40 ec       	mov.aa %a12,%a14
8002c50a:	1d ff d4 ff 	j 8002c4b2 <__multadd+0x4c>
8002c50e:	91 00 00 68 	movh.a %a6,32768
8002c512:	91 00 00 48 	movh.a %a4,32768
8002c516:	d9 66 dc 83 	lea %a6,[%a6]15900 <80003e1c <blanks.1+0xc0>>
8002c51a:	a0 05       	mov.a %a5,0
8002c51c:	3b a0 0b 40 	mov %d4,186
8002c520:	d9 44 ed 83 	lea %a4,[%a4]15917 <80003e2d <blanks.1+0xd1>>
8002c524:	1d 00 9c 06 	j 8002d25c <__assert_func>

8002c528 <__hi0bits>:
8002c528:	b7 04 10 30 	insert %d3,%d4,0,0,16
8002c52c:	82 02       	mov %d2,0
8002c52e:	df 03 06 80 	jne %d3,0,8002c53a <__hi0bits+0x12>
8002c532:	8f 04 01 40 	sh %d4,%d4,16
8002c536:	3b 00 01 20 	mov %d2,16
8002c53a:	b7 04 18 30 	insert %d3,%d4,0,0,24
8002c53e:	df 03 06 80 	jne %d3,0,8002c54a <__hi0bits+0x22>
8002c542:	1b 82 00 20 	addi %d2,%d2,8
8002c546:	8f 84 00 40 	sh %d4,%d4,8
8002c54a:	b7 04 1c 30 	insert %d3,%d4,0,0,28
8002c54e:	df 03 04 80 	jne %d3,0,8002c556 <__hi0bits+0x2e>
8002c552:	c2 42       	add %d2,4
8002c554:	06 44       	sh %d4,4
8002c556:	b7 04 1e 30 	insert %d3,%d4,0,0,30
8002c55a:	df 03 04 80 	jne %d3,0,8002c562 <__hi0bits+0x3a>
8002c55e:	c2 22       	add %d2,2
8002c560:	06 24       	sh %d4,2
8002c562:	bf 04 07 00 	jlt %d4,0,8002c570 <__hi0bits+0x48>
8002c566:	37 04 61 4f 	extr.u %d4,%d4,30,1
8002c56a:	c2 12       	add %d2,1
8002c56c:	ab 02 82 24 	sel %d2,%d4,%d2,32
8002c570:	00 90       	ret 

8002c572 <__lo0bits>:
8002c572:	54 43       	ld.w %d3,[%a4]
8002c574:	8f 73 00 21 	and %d2,%d3,7
8002c578:	df 02 0b 00 	jeq %d2,0,8002c58e <__lo0bits+0x1c>
8002c57c:	82 02       	mov %d2,0
8002c57e:	6f 03 21 80 	jnz.t %d3,0,8002c5c0 <__lo0bits+0x4e>
8002c582:	6f 13 43 00 	jz.t %d3,1,8002c608 <__lo0bits+0x96>
8002c586:	06 f3       	sh %d3,-1
8002c588:	82 12       	mov %d2,1
8002c58a:	74 43       	st.w [%a4],%d3
8002c58c:	00 90       	ret 
8002c58e:	b7 03 10 48 	insert %d4,%d3,0,16,16
8002c592:	82 02       	mov %d2,0
8002c594:	df 04 30 00 	jeq %d4,0,8002c5f4 <__lo0bits+0x82>
8002c598:	8f f3 0f 41 	and %d4,%d3,255
8002c59c:	df 04 23 00 	jeq %d4,0,8002c5e2 <__lo0bits+0x70>
8002c5a0:	8f f3 00 41 	and %d4,%d3,15
8002c5a4:	df 04 17 00 	jeq %d4,0,8002c5d2 <__lo0bits+0x60>
8002c5a8:	8f 33 00 41 	and %d4,%d3,3
8002c5ac:	df 04 0d 00 	jeq %d4,0,8002c5c6 <__lo0bits+0x54>
8002c5b0:	6f 03 09 80 	jnz.t %d3,0,8002c5c2 <__lo0bits+0x50>
8002c5b4:	06 f3       	sh %d3,-1
8002c5b6:	c2 12       	add %d2,1
8002c5b8:	df 03 05 80 	jne %d3,0,8002c5c2 <__lo0bits+0x50>
8002c5bc:	3b 00 02 20 	mov %d2,32
8002c5c0:	00 90       	ret 
8002c5c2:	74 43       	st.w [%a4],%d3
8002c5c4:	00 90       	ret 
8002c5c6:	06 e3       	sh %d3,-2
8002c5c8:	c2 22       	add %d2,2
8002c5ca:	6f 03 fc ff 	jnz.t %d3,0,8002c5c2 <__lo0bits+0x50>
8002c5ce:	1d ff f3 ff 	j 8002c5b4 <__lo0bits+0x42>
8002c5d2:	06 c3       	sh %d3,-4
8002c5d4:	8f 33 00 41 	and %d4,%d3,3
8002c5d8:	c2 42       	add %d2,4
8002c5da:	df 04 eb ff 	jne %d4,0,8002c5b0 <__lo0bits+0x3e>
8002c5de:	1d ff f4 ff 	j 8002c5c6 <__lo0bits+0x54>
8002c5e2:	06 83       	sh %d3,-8
8002c5e4:	8f f3 00 41 	and %d4,%d3,15
8002c5e8:	1b 82 00 20 	addi %d2,%d2,8
8002c5ec:	df 04 de ff 	jne %d4,0,8002c5a8 <__lo0bits+0x36>
8002c5f0:	1d ff f1 ff 	j 8002c5d2 <__lo0bits+0x60>
8002c5f4:	8f 03 1f 30 	sh %d3,%d3,-16
8002c5f8:	8f f3 0f 41 	and %d4,%d3,255
8002c5fc:	3b 00 01 20 	mov %d2,16
8002c600:	df 04 d0 ff 	jne %d4,0,8002c5a0 <__lo0bits+0x2e>
8002c604:	1d ff ef ff 	j 8002c5e2 <__lo0bits+0x70>
8002c608:	06 e3       	sh %d3,-2
8002c60a:	82 22       	mov %d2,2
8002c60c:	74 43       	st.w [%a4],%d3
8002c60e:	00 90       	ret 

8002c610 <__i2b>:
8002c610:	99 43 04 10 	ld.a %a3,[%a4]68
8002c614:	40 4c       	mov.aa %a12,%a4
8002c616:	02 48       	mov %d8,%d4
8002c618:	bd 03 12 00 	jz.a %a3,8002c63c <__i2b+0x2c>
8002c61c:	99 32 04 00 	ld.a %a2,[%a3]4
8002c620:	bd 02 25 00 	jz.a %a2,8002c66a <__i2b+0x5a>
8002c624:	54 22       	ld.w %d2,[%a2]
8002c626:	59 32 04 00 	st.w [%a3]4,%d2
8002c62a:	82 02       	mov %d2,0
8002c62c:	59 28 14 00 	st.w [%a2]20,%d8
8002c630:	59 22 0c 00 	st.w [%a2]12,%d2
8002c634:	82 12       	mov %d2,1
8002c636:	59 22 10 00 	st.w [%a2]16,%d2
8002c63a:	00 90       	ret 
8002c63c:	3b 10 02 50 	mov %d5,33
8002c640:	82 44       	mov %d4,4
8002c642:	6d 00 34 06 	call 8002d2aa <_calloc_r>
8002c646:	b5 c2 04 10 	st.a [%a12]68,%a2
8002c64a:	40 23       	mov.aa %a3,%a2
8002c64c:	bd 02 e8 ff 	jnz.a %a2,8002c61c <__i2b+0xc>
8002c650:	91 00 00 68 	movh.a %a6,32768
8002c654:	91 00 00 48 	movh.a %a4,32768
8002c658:	d9 66 dc 83 	lea %a6,[%a6]15900 <80003e1c <blanks.1+0xc0>>
8002c65c:	a0 05       	mov.a %a5,0
8002c65e:	3b 50 14 40 	mov %d4,325
8002c662:	d9 44 ed 83 	lea %a4,[%a4]15917 <80003e2d <blanks.1+0xd1>>
8002c666:	1d 00 fb 05 	j 8002d25c <__assert_func>
8002c66a:	3b c0 01 50 	mov %d5,28
8002c66e:	82 14       	mov %d4,1
8002c670:	40 c4       	mov.aa %a4,%a12
8002c672:	6d 00 1c 06 	call 8002d2aa <_calloc_r>
8002c676:	bd 02 ed 7f 	jz.a %a2,8002c650 <__i2b+0x40>
8002c67a:	82 12       	mov %d2,1
8002c67c:	59 22 04 00 	st.w [%a2]4,%d2
8002c680:	82 22       	mov %d2,2
8002c682:	59 22 08 00 	st.w [%a2]8,%d2
8002c686:	1d ff d2 ff 	j 8002c62a <__i2b+0x1a>

8002c68a <__multiply>:
8002c68a:	19 59 10 00 	ld.w %d9,[%a5]16
8002c68e:	19 6a 10 00 	ld.w %d10,[%a6]16
8002c692:	40 5f       	mov.aa %a15,%a5
8002c694:	40 6d       	mov.aa %a13,%a6
8002c696:	3f a9 07 00 	jlt %d9,%d10,8002c6a4 <__multiply+0x1a>
8002c69a:	02 a2       	mov %d2,%d10
8002c69c:	40 5d       	mov.aa %a13,%a5
8002c69e:	02 9a       	mov %d10,%d9
8002c6a0:	40 6f       	mov.aa %a15,%a6
8002c6a2:	02 29       	mov %d9,%d2
8002c6a4:	19 d2 08 00 	ld.w %d2,[%a13]8
8002c6a8:	0b 9a 00 80 	add %d8,%d10,%d9
8002c6ac:	0b 82 20 41 	lt %d4,%d2,%d8
8002c6b0:	19 d2 04 00 	ld.w %d2,[%a13]4
8002c6b4:	42 24       	add %d4,%d2
8002c6b6:	6d ff 94 fe 	call 8002c3de <_Balloc>
8002c6ba:	bd 02 ac 00 	jz.a %a2,8002c812 <__multiply+0x188>
8002c6be:	d9 2c 14 00 	lea %a12,[%a2]20
8002c6c2:	8f 28 00 20 	sh %d2,%d8,2
8002c6c6:	01 c2 00 76 	addsc.a %a7,%a12,%d2,0
8002c6ca:	80 c3       	mov.d %d3,%a12
8002c6cc:	80 74       	mov.d %d4,%a7
8002c6ce:	40 c3       	mov.aa %a3,%a12
8002c6d0:	82 02       	mov %d2,0
8002c6d2:	7f 43 09 80 	jge.u %d3,%d4,8002c6e4 <__multiply+0x5a>
8002c6d6:	40 34       	mov.aa %a4,%a3
8002c6d8:	b0 43       	add.a %a3,4
8002c6da:	74 42       	st.w [%a4],%d2
8002c6dc:	80 33       	mov.d %d3,%a3
8002c6de:	80 74       	mov.d %d4,%a7
8002c6e0:	3f 43 fb ff 	jlt.u %d3,%d4,8002c6d6 <__multiply+0x4c>
8002c6e4:	d9 de 14 00 	lea %a14,[%a13]20
8002c6e8:	80 e2       	mov.d %d2,%a14
8002c6ea:	d9 f5 14 00 	lea %a5,[%a15]20
8002c6ee:	8f 2a 00 50 	sh %d5,%d10,2
8002c6f2:	42 25       	add %d5,%d2
8002c6f4:	8f 29 00 10 	sh %d1,%d9,2
8002c6f8:	80 52       	mov.d %d2,%a5
8002c6fa:	42 21       	add %d1,%d2
8002c6fc:	80 d2       	mov.d %d2,%a13
8002c6fe:	8b b2 1e 21 	rsub %d2,%d2,-21
8002c702:	42 52       	add %d2,%d5
8002c704:	8f 32 c0 21 	andn %d2,%d2,3
8002c708:	1b 42 00 90 	addi %d9,%d2,4
8002c70c:	80 d2       	mov.d %d2,%a13
8002c70e:	1b 52 01 20 	addi %d2,%d2,21
8002c712:	0b 25 50 21 	ge.u %d2,%d5,%d2
8002c716:	ab 49 80 92 	sel %d9,%d2,%d9,4
8002c71a:	80 52       	mov.d %d2,%a5
8002c71c:	3f 12 0e 80 	jlt.u %d2,%d1,8002c738 <__multiply+0xae>
8002c720:	1d 00 6a 00 	j 8002c7f4 <__multiply+0x16a>
8002c724:	8f 03 1f 20 	sh %d2,%d3,-16
8002c728:	d9 c6 04 00 	lea %a6,[%a12]4
8002c72c:	df 02 39 80 	jne %d2,0,8002c79e <__multiply+0x114>
8002c730:	80 52       	mov.d %d2,%a5
8002c732:	40 6c       	mov.aa %a12,%a6
8002c734:	7f 12 60 80 	jge.u %d2,%d1,8002c7f4 <__multiply+0x16a>
8002c738:	40 53       	mov.aa %a3,%a5
8002c73a:	54 33       	ld.w %d3,[%a3]
8002c73c:	b0 45       	add.a %a5,4
8002c73e:	b7 03 10 28 	insert %d2,%d3,0,16,16
8002c742:	df 02 f1 7f 	jeq %d2,0,8002c724 <__multiply+0x9a>
8002c746:	40 e4       	mov.aa %a4,%a14
8002c748:	40 c3       	mov.aa %a3,%a12
8002c74a:	82 06       	mov %d6,0
8002c74c:	40 46       	mov.aa %a6,%a4
8002c74e:	54 64       	ld.w %d4,[%a6]
8002c750:	54 30       	ld.w %d0,[%a3]
8002c752:	b7 04 10 78 	insert %d7,%d4,0,16,16
8002c756:	b7 00 10 38 	insert %d3,%d0,0,16,16
8002c75a:	8f 00 1f 00 	sh %d0,%d0,-16
8002c75e:	03 27 0a 33 	madd %d3,%d3,%d7,%d2
8002c762:	40 36       	mov.aa %a6,%a3
8002c764:	b0 44       	add.a %a4,4
8002c766:	42 63       	add %d3,%d6
8002c768:	8f 04 1f 60 	sh %d6,%d4,-16
8002c76c:	03 26 0a 60 	madd %d6,%d0,%d6,%d2
8002c770:	8f 03 1f 40 	sh %d4,%d3,-16
8002c774:	b0 43       	add.a %a3,4
8002c776:	42 64       	add %d4,%d6
8002c778:	37 43 10 38 	insert %d3,%d3,%d4,16,16
8002c77c:	8f 04 1f 60 	sh %d6,%d4,-16
8002c780:	74 63       	st.w [%a6],%d3
8002c782:	80 43       	mov.d %d3,%a4
8002c784:	3f 53 e4 ff 	jlt.u %d3,%d5,8002c74c <__multiply+0xc2>
8002c788:	01 c9 00 36 	addsc.a %a3,%a12,%d9,0
8002c78c:	d9 c6 04 00 	lea %a6,[%a12]4
8002c790:	74 36       	st.w [%a3],%d6
8002c792:	19 53 fc ff 	ld.w %d3,[%a5]-4
8002c796:	8f 03 1f 20 	sh %d2,%d3,-16
8002c79a:	df 02 cb 7f 	jeq %d2,0,8002c730 <__multiply+0xa6>
8002c79e:	54 c3       	ld.w %d3,[%a12]
8002c7a0:	40 e3       	mov.aa %a3,%a14
8002c7a2:	40 64       	mov.aa %a4,%a6
8002c7a4:	02 34       	mov %d4,%d3
8002c7a6:	82 07       	mov %d7,0
8002c7a8:	b9 36 00 00 	ld.hu %d6,[%a3]0
8002c7ac:	8f 04 1f 40 	sh %d4,%d4,-16
8002c7b0:	03 26 0a 64 	madd %d6,%d4,%d6,%d2
8002c7b4:	40 4d       	mov.aa %a13,%a4
8002c7b6:	b0 44       	add.a %a4,4
8002c7b8:	42 76       	add %d6,%d7
8002c7ba:	37 63 10 38 	insert %d3,%d3,%d6,16,16
8002c7be:	59 43 f8 ff 	st.w [%a4]-8,%d3
8002c7c2:	54 d4       	ld.w %d4,[%a13]
8002c7c4:	40 3d       	mov.aa %a13,%a3
8002c7c6:	54 d7       	ld.w %d7,[%a13]
8002c7c8:	b7 04 10 38 	insert %d3,%d4,0,16,16
8002c7cc:	8f 07 1f 70 	sh %d7,%d7,-16
8002c7d0:	03 27 0a 73 	madd %d7,%d3,%d7,%d2
8002c7d4:	b0 43       	add.a %a3,4
8002c7d6:	8f 06 1f 30 	sh %d3,%d6,-16
8002c7da:	42 73       	add %d3,%d7
8002c7dc:	80 36       	mov.d %d6,%a3
8002c7de:	8f 03 1f 70 	sh %d7,%d3,-16
8002c7e2:	3f 56 e3 ff 	jlt.u %d6,%d5,8002c7a8 <__multiply+0x11e>
8002c7e6:	01 c9 00 c6 	addsc.a %a12,%a12,%d9,0
8002c7ea:	80 52       	mov.d %d2,%a5
8002c7ec:	74 c3       	st.w [%a12],%d3
8002c7ee:	40 6c       	mov.aa %a12,%a6
8002c7f0:	3f 12 a4 ff 	jlt.u %d2,%d1,8002c738 <__multiply+0xae>
8002c7f4:	ff 18 07 00 	jge %d8,1,8002c802 <__multiply+0x178>
8002c7f8:	1d 00 0a 00 	j 8002c80c <__multiply+0x182>
8002c7fc:	c2 f8       	add %d8,-1
8002c7fe:	df 08 07 00 	jeq %d8,0,8002c80c <__multiply+0x182>
8002c802:	19 72 fc ff 	ld.w %d2,[%a7]-4
8002c806:	b0 c7       	add.a %a7,-4
8002c808:	df 02 fa 7f 	jeq %d2,0,8002c7fc <__multiply+0x172>
8002c80c:	59 28 10 00 	st.w [%a2]16,%d8
8002c810:	00 90       	ret 
8002c812:	91 00 00 68 	movh.a %a6,32768
8002c816:	91 00 00 48 	movh.a %a4,32768
8002c81a:	d9 66 dc 83 	lea %a6,[%a6]15900 <80003e1c <blanks.1+0xc0>>
8002c81e:	a0 05       	mov.a %a5,0
8002c820:	3b 20 16 40 	mov %d4,354
8002c824:	d9 44 ed 83 	lea %a4,[%a4]15917 <80003e2d <blanks.1+0xd1>>
8002c828:	1d 00 1a 05 	j 8002d25c <__assert_func>

8002c82c <__pow5mult>:
8002c82c:	8f 34 00 21 	and %d2,%d4,3
8002c830:	40 4e       	mov.aa %a14,%a4
8002c832:	40 5d       	mov.aa %a13,%a5
8002c834:	02 48       	mov %d8,%d4
8002c836:	df 02 3a 80 	jne %d2,0,8002c8aa <__pow5mult+0x7e>
8002c83a:	86 e8       	sha %d8,-2
8002c83c:	df 08 28 00 	jeq %d8,0,8002c88c <__pow5mult+0x60>
8002c840:	99 ec 00 10 	ld.a %a12,[%a14]64 <80000040 <__IF_CONST+0x20>>
8002c844:	bd 0c 42 00 	jz.a %a12,8002c8c8 <__pow5mult+0x9c>
8002c848:	82 09       	mov %d9,0
8002c84a:	6f 08 0b 80 	jnz.t %d8,0,8002c860 <__pow5mult+0x34>
8002c84e:	86 f8       	sha %d8,-1
8002c850:	df 08 1e 00 	jeq %d8,0,8002c88c <__pow5mult+0x60>
8002c854:	d4 c2       	ld.a %a2,[%a12]
8002c856:	bd 02 1d 00 	jz.a %a2,8002c890 <__pow5mult+0x64>
8002c85a:	40 2c       	mov.aa %a12,%a2
8002c85c:	6f 08 f9 7f 	jz.t %d8,0,8002c84e <__pow5mult+0x22>
8002c860:	40 c6       	mov.aa %a6,%a12
8002c862:	40 d5       	mov.aa %a5,%a13
8002c864:	40 e4       	mov.aa %a4,%a14
8002c866:	6d ff 12 ff 	call 8002c68a <__multiply>
8002c86a:	40 23       	mov.aa %a3,%a2
8002c86c:	bd 0d 1c 00 	jz.a %a13,8002c8a4 <__pow5mult+0x78>
8002c870:	19 d2 04 00 	ld.w %d2,[%a13]4
8002c874:	99 e4 04 10 	ld.a %a4,[%a14]68 <80000044 <__IF_CONST+0x24>>
8002c878:	06 22       	sh %d2,2
8002c87a:	60 22       	mov.a %a2,%d2
8002c87c:	86 f8       	sha %d8,-1
8002c87e:	30 42       	add.a %a2,%a4
8002c880:	54 22       	ld.w %d2,[%a2]
8002c882:	74 d2       	st.w [%a13],%d2
8002c884:	f4 2d       	st.a [%a2],%a13
8002c886:	40 3d       	mov.aa %a13,%a3
8002c888:	df 08 e6 ff 	jne %d8,0,8002c854 <__pow5mult+0x28>
8002c88c:	40 d2       	mov.aa %a2,%a13
8002c88e:	00 90       	ret 
8002c890:	40 c6       	mov.aa %a6,%a12
8002c892:	40 c5       	mov.aa %a5,%a12
8002c894:	40 e4       	mov.aa %a4,%a14
8002c896:	6d ff fa fe 	call 8002c68a <__multiply>
8002c89a:	f4 c2       	st.a [%a12],%a2
8002c89c:	74 29       	st.w [%a2],%d9
8002c89e:	40 2c       	mov.aa %a12,%a2
8002c8a0:	1d ff de ff 	j 8002c85c <__pow5mult+0x30>
8002c8a4:	40 2d       	mov.aa %a13,%a2
8002c8a6:	1d ff d4 ff 	j 8002c84e <__pow5mult+0x22>
8002c8aa:	c2 f2       	add %d2,-1
8002c8ac:	91 00 00 28 	movh.a %a2,32768
8002c8b0:	06 22       	sh %d2,2
8002c8b2:	d9 22 f0 a3 	lea %a2,[%a2]16048 <80003eb0 <p05.0>>
8002c8b6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8002c8ba:	82 05       	mov %d5,0
8002c8bc:	54 24       	ld.w %d4,[%a2]
8002c8be:	6d ff d4 fd 	call 8002c466 <__multadd>
8002c8c2:	40 2d       	mov.aa %a13,%a2
8002c8c4:	1d ff bb ff 	j 8002c83a <__pow5mult+0xe>
8002c8c8:	82 14       	mov %d4,1
8002c8ca:	40 e4       	mov.aa %a4,%a14
8002c8cc:	6d ff 89 fd 	call 8002c3de <_Balloc>
8002c8d0:	40 2c       	mov.aa %a12,%a2
8002c8d2:	bd 02 10 00 	jz.a %a2,8002c8f2 <__pow5mult+0xc6>
8002c8d6:	3b 10 27 20 	mov %d2,625
8002c8da:	82 09       	mov %d9,0
8002c8dc:	59 22 14 00 	st.w [%a2]20,%d2
8002c8e0:	82 12       	mov %d2,1
8002c8e2:	59 22 10 00 	st.w [%a2]16,%d2
8002c8e6:	82 02       	mov %d2,0
8002c8e8:	b5 e2 00 10 	st.a [%a14]64,%a2
8002c8ec:	74 22       	st.w [%a2],%d2
8002c8ee:	1d ff ae ff 	j 8002c84a <__pow5mult+0x1e>
8002c8f2:	91 00 00 68 	movh.a %a6,32768
8002c8f6:	91 00 00 48 	movh.a %a4,32768
8002c8fa:	d9 66 dc 83 	lea %a6,[%a6]15900 <80003e1c <blanks.1+0xc0>>
8002c8fe:	a0 05       	mov.a %a5,0
8002c900:	3b 50 14 40 	mov %d4,325
8002c904:	d9 44 ed 83 	lea %a4,[%a4]15917 <80003e2d <blanks.1+0xd1>>
8002c908:	1d 00 aa 04 	j 8002d25c <__assert_func>

8002c90c <__lshift>:
8002c90c:	19 52 10 00 	ld.w %d2,[%a5]16
8002c910:	8f b4 3f a0 	sha %d10,%d4,-5
8002c914:	0b 2a 00 90 	add %d9,%d10,%d2
8002c918:	19 52 08 00 	ld.w %d2,[%a5]8
8002c91c:	1b 19 00 80 	addi %d8,%d9,1
8002c920:	02 4b       	mov %d11,%d4
8002c922:	40 4d       	mov.aa %a13,%a4
8002c924:	19 54 04 00 	ld.w %d4,[%a5]4
8002c928:	40 5c       	mov.aa %a12,%a5
8002c92a:	7f 82 06 00 	jge %d2,%d8,8002c936 <__lshift+0x2a>
8002c92e:	06 12       	sh %d2,1
8002c930:	c2 14       	add %d4,1
8002c932:	3f 82 fe 7f 	jlt %d2,%d8,8002c92e <__lshift+0x22>
8002c936:	40 d4       	mov.aa %a4,%a13
8002c938:	6d ff 53 fd 	call 8002c3de <_Balloc>
8002c93c:	bd 02 62 00 	jz.a %a2,8002ca00 <__lshift+0xf4>
8002c940:	80 22       	mov.d %d2,%a2
8002c942:	1b 42 01 70 	addi %d7,%d2,20
8002c946:	bf 1a 11 00 	jlt %d10,1,8002c968 <__lshift+0x5c>
8002c94a:	1b 5a 00 30 	addi %d3,%d10,5
8002c94e:	06 23       	sh %d3,2
8002c950:	01 23 00 56 	addsc.a %a5,%a2,%d3,0
8002c954:	60 73       	mov.a %a3,%d7
8002c956:	82 02       	mov %d2,0
8002c958:	40 34       	mov.aa %a4,%a3
8002c95a:	74 42       	st.w [%a4],%d2
8002c95c:	b0 43       	add.a %a3,4
8002c95e:	7d 53 fd ff 	jne.a %a3,%a5,8002c958 <__lshift+0x4c>
8002c962:	1b c3 fe 3f 	addi %d3,%d3,-20
8002c966:	42 37       	add %d7,%d3
8002c968:	19 c2 10 00 	ld.w %d2,[%a12]16
8002c96c:	d9 c3 14 00 	lea %a3,[%a12]20
8002c970:	06 22       	sh %d2,2
8002c972:	80 33       	mov.d %d3,%a3
8002c974:	8f fb 01 b1 	and %d11,%d11,31
8002c978:	42 32       	add %d2,%d3
8002c97a:	df 0b 37 00 	jeq %d11,0,8002c9e8 <__lshift+0xdc>
8002c97e:	60 75       	mov.a %a5,%d7
8002c980:	8b 0b 02 61 	rsub %d6,%d11,32
8002c984:	82 03       	mov %d3,0
8002c986:	54 35       	ld.w %d5,[%a3]
8002c988:	40 54       	mov.aa %a4,%a5
8002c98a:	0f b5 00 50 	sh %d5,%d5,%d11
8002c98e:	a6 53       	or %d3,%d5
8002c990:	b0 45       	add.a %a5,4
8002c992:	74 43       	st.w [%a4],%d3
8002c994:	40 34       	mov.aa %a4,%a3
8002c996:	54 45       	ld.w %d5,[%a4]
8002c998:	b0 43       	add.a %a3,4
8002c99a:	8b 06 00 31 	rsub %d3,%d6,0
8002c99e:	80 34       	mov.d %d4,%a3
8002c9a0:	0f 35 00 30 	sh %d3,%d5,%d3
8002c9a4:	3f 24 f1 ff 	jlt.u %d4,%d2,8002c986 <__lshift+0x7a>
8002c9a8:	80 c4       	mov.d %d4,%a12
8002c9aa:	d9 c3 15 00 	lea %a3,[%a12]21
8002c9ae:	8b b4 1e 41 	rsub %d4,%d4,-21
8002c9b2:	42 24       	add %d4,%d2
8002c9b4:	80 35       	mov.d %d5,%a3
8002c9b6:	8f 34 c0 41 	andn %d4,%d4,3
8002c9ba:	0b 52 50 21 	ge.u %d2,%d2,%d5
8002c9be:	2b 47 00 22 	cadd %d2,%d2,%d7,%d4
8002c9c2:	60 23       	mov.a %a3,%d2
8002c9c4:	2b 89 50 93 	seln %d9,%d3,%d9,%d8
8002c9c8:	59 33 04 00 	st.w [%a3]4,%d3
8002c9cc:	19 d3 04 10 	ld.w %d3,[%a13]68 <80000044 <__IF_CONST+0x24>>
8002c9d0:	19 c2 04 00 	ld.w %d2,[%a12]4 <80000044 <__IF_CONST+0x24>>
8002c9d4:	60 33       	mov.a %a3,%d3
8002c9d6:	06 22       	sh %d2,2
8002c9d8:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
8002c9dc:	59 29 10 00 	st.w [%a2]16,%d9
8002c9e0:	54 32       	ld.w %d2,[%a3]
8002c9e2:	74 c2       	st.w [%a12],%d2
8002c9e4:	f4 3c       	st.a [%a3],%a12
8002c9e6:	00 90       	ret 
8002c9e8:	60 75       	mov.a %a5,%d7
8002c9ea:	40 34       	mov.aa %a4,%a3
8002c9ec:	54 43       	ld.w %d3,[%a4]
8002c9ee:	b0 43       	add.a %a3,4
8002c9f0:	40 54       	mov.aa %a4,%a5
8002c9f2:	74 43       	st.w [%a4],%d3
8002c9f4:	80 33       	mov.d %d3,%a3
8002c9f6:	b0 45       	add.a %a5,4
8002c9f8:	3f 23 f9 ff 	jlt.u %d3,%d2,8002c9ea <__lshift+0xde>
8002c9fc:	1d ff e8 ff 	j 8002c9cc <__lshift+0xc0>
8002ca00:	91 00 00 68 	movh.a %a6,32768
8002ca04:	91 00 00 48 	movh.a %a4,32768
8002ca08:	d9 66 dc 83 	lea %a6,[%a6]15900 <80003e1c <blanks.1+0xc0>>
8002ca0c:	a0 05       	mov.a %a5,0
8002ca0e:	3b e0 1d 40 	mov %d4,478
8002ca12:	d9 44 ed 83 	lea %a4,[%a4]15917 <80003e2d <blanks.1+0xd1>>
8002ca16:	1d 00 23 04 	j 8002d25c <__assert_func>

8002ca1a <__mcmp>:
8002ca1a:	19 44 10 00 	ld.w %d4,[%a4]16 <80000010 <LCF_STARTPTR_CPU0+0x10>>
8002ca1e:	19 53 10 00 	ld.w %d3,[%a5]16 <80000010 <LCF_STARTPTR_CPU0+0x10>>
8002ca22:	0b 34 80 20 	sub %d2,%d4,%d3
8002ca26:	5f 34 1f 80 	jne %d4,%d3,8002ca64 <__mcmp+0x4a>
8002ca2a:	06 23       	sh %d3,2
8002ca2c:	80 44       	mov.d %d4,%a4
8002ca2e:	60 34       	mov.a %a4,%d3
8002ca30:	1b 44 01 50 	addi %d5,%d4,20
8002ca34:	d9 53 14 00 	lea %a3,[%a5]20
8002ca38:	01 45 00 26 	addsc.a %a2,%a4,%d5,0
8002ca3c:	30 43       	add.a %a3,%a4
8002ca3e:	1d 00 05 00 	j 8002ca48 <__mcmp+0x2e>
8002ca42:	80 23       	mov.d %d3,%a2
8002ca44:	7f 35 10 80 	jge.u %d5,%d3,8002ca64 <__mcmp+0x4a>
8002ca48:	19 24 fc ff 	ld.w %d4,[%a2]-4
8002ca4c:	19 33 fc ff 	ld.w %d3,[%a3]-4
8002ca50:	b0 c2       	add.a %a2,-4
8002ca52:	b0 c3       	add.a %a3,-4
8002ca54:	5f 34 f7 7f 	jeq %d4,%d3,8002ca42 <__mcmp+0x28>
8002ca58:	0b 34 30 31 	lt.u %d3,%d4,%d3
8002ca5c:	82 f2       	mov %d2,-1
8002ca5e:	ab 12 80 23 	sel %d2,%d3,%d2,1
8002ca62:	00 90       	ret 
8002ca64:	00 90       	ret 

8002ca66 <__mdiff>:
8002ca66:	19 53 10 00 	ld.w %d3,[%a5]16
8002ca6a:	19 62 10 00 	ld.w %d2,[%a6]16
8002ca6e:	40 5c       	mov.aa %a12,%a5
8002ca70:	40 6d       	mov.aa %a13,%a6
8002ca72:	0b 23 80 80 	sub %d8,%d3,%d2
8002ca76:	5f 23 9f 80 	jne %d3,%d2,8002cbb4 <__mdiff+0x14e>
8002ca7a:	06 22       	sh %d2,2
8002ca7c:	60 23       	mov.a %a3,%d2
8002ca7e:	80 53       	mov.d %d3,%a5
8002ca80:	1b 43 01 40 	addi %d4,%d3,20
8002ca84:	d9 65 14 00 	lea %a5,[%a6]20
8002ca88:	01 34 00 26 	addsc.a %a2,%a3,%d4,0
8002ca8c:	30 53       	add.a %a3,%a5
8002ca8e:	1d 00 05 00 	j 8002ca98 <__mdiff+0x32>
8002ca92:	80 22       	mov.d %d2,%a2
8002ca94:	7f 24 95 80 	jge.u %d4,%d2,8002cbbe <__mdiff+0x158>
8002ca98:	19 23 fc ff 	ld.w %d3,[%a2]-4
8002ca9c:	19 32 fc ff 	ld.w %d2,[%a3]-4
8002caa0:	b0 c2       	add.a %a2,-4
8002caa2:	b0 c3       	add.a %a3,-4
8002caa4:	5f 23 f7 7f 	jeq %d3,%d2,8002ca92 <__mdiff+0x2c>
8002caa8:	3f 23 80 80 	jlt.u %d3,%d2,8002cba8 <__mdiff+0x142>
8002caac:	19 c4 04 00 	ld.w %d4,[%a12]4
8002cab0:	6d ff 97 fc 	call 8002c3de <_Balloc>
8002cab4:	bd 02 91 00 	jz.a %a2,8002cbd6 <__mdiff+0x170>
8002cab8:	80 c2       	mov.d %d2,%a12
8002caba:	19 c1 10 00 	ld.w %d1,[%a12]16
8002cabe:	59 28 0c 00 	st.w [%a2]12,%d8
8002cac2:	1b 42 01 80 	addi %d8,%d2,20
8002cac6:	19 d2 10 00 	ld.w %d2,[%a13]16
8002caca:	d9 d3 14 00 	lea %a3,[%a13]20
8002cace:	80 33       	mov.d %d3,%a3
8002cad0:	8f 21 00 70 	sh %d7,%d1,2
8002cad4:	06 22       	sh %d2,2
8002cad6:	d9 25 14 00 	lea %a5,[%a2]20
8002cada:	60 87       	mov.a %a7,%d8
8002cadc:	0b 23 00 60 	add %d6,%d3,%d2
8002cae0:	42 87       	add %d7,%d8
8002cae2:	40 54       	mov.aa %a4,%a5
8002cae4:	82 03       	mov %d3,0
8002cae6:	40 76       	mov.aa %a6,%a7
8002cae8:	54 65       	ld.w %d5,[%a6]
8002caea:	40 36       	mov.aa %a6,%a3
8002caec:	54 64       	ld.w %d4,[%a6]
8002caee:	b7 05 10 08 	insert %d0,%d5,0,16,16
8002caf2:	b7 04 10 28 	insert %d2,%d4,0,16,16
8002caf6:	8f 05 1f 50 	sh %d5,%d5,-16
8002cafa:	0b 20 80 20 	sub %d2,%d0,%d2
8002cafe:	42 32       	add %d2,%d3
8002cb00:	8f 04 1f 40 	sh %d4,%d4,-16
8002cb04:	8f 02 3f 30 	sha %d3,%d2,-16
8002cb08:	0b 45 80 40 	sub %d4,%d5,%d4
8002cb0c:	42 34       	add %d4,%d3
8002cb0e:	37 42 10 28 	insert %d2,%d2,%d4,16,16
8002cb12:	40 46       	mov.aa %a6,%a4
8002cb14:	b0 43       	add.a %a3,4
8002cb16:	8f 04 3f 30 	sha %d3,%d4,-16
8002cb1a:	74 62       	st.w [%a6],%d2
8002cb1c:	80 34       	mov.d %d4,%a3
8002cb1e:	b0 47       	add.a %a7,4
8002cb20:	b0 44       	add.a %a4,4
8002cb22:	3f 64 e2 ff 	jlt.u %d4,%d6,8002cae6 <__mdiff+0x80>
8002cb26:	80 d4       	mov.d %d4,%a13
8002cb28:	8b b4 1e 51 	rsub %d5,%d4,-21
8002cb2c:	42 65       	add %d5,%d6
8002cb2e:	1b 54 01 00 	addi %d0,%d4,21
8002cb32:	0b 06 50 61 	ge.u %d6,%d6,%d0
8002cb36:	8f 35 c0 41 	andn %d4,%d5,3
8002cb3a:	ab 04 80 46 	sel %d4,%d6,%d4,0
8002cb3e:	01 54 00 36 	addsc.a %a3,%a5,%d4,0
8002cb42:	8f 35 c0 41 	andn %d4,%d5,3
8002cb46:	c2 44       	add %d4,4
8002cb48:	ab 44 80 46 	sel %d4,%d6,%d4,4
8002cb4c:	42 48       	add %d8,%d4
8002cb4e:	01 54 00 56 	addsc.a %a5,%a5,%d4,0
8002cb52:	7f 78 20 80 	jge.u %d8,%d7,8002cb92 <__mdiff+0x12c>
8002cb56:	60 83       	mov.a %a3,%d8
8002cb58:	40 54       	mov.aa %a4,%a5
8002cb5a:	40 36       	mov.aa %a6,%a3
8002cb5c:	54 64       	ld.w %d4,[%a6]
8002cb5e:	b0 43       	add.a %a3,4
8002cb60:	b7 04 10 28 	insert %d2,%d4,0,16,16
8002cb64:	8f 04 1f 40 	sh %d4,%d4,-16
8002cb68:	42 32       	add %d2,%d3
8002cb6a:	8f 02 3f 30 	sha %d3,%d2,-16
8002cb6e:	42 34       	add %d4,%d3
8002cb70:	37 42 10 28 	insert %d2,%d2,%d4,16,16
8002cb74:	40 46       	mov.aa %a6,%a4
8002cb76:	8f 04 3f 30 	sha %d3,%d4,-16
8002cb7a:	80 34       	mov.d %d4,%a3
8002cb7c:	74 62       	st.w [%a6],%d2
8002cb7e:	b0 44       	add.a %a4,4
8002cb80:	3f 74 ed ff 	jlt.u %d4,%d7,8002cb5a <__mdiff+0xf4>
8002cb84:	1b f7 ff 3f 	addi %d3,%d7,-1
8002cb88:	a2 83       	sub %d3,%d8
8002cb8a:	8f 33 c0 31 	andn %d3,%d3,3
8002cb8e:	01 53 00 36 	addsc.a %a3,%a5,%d3,0
8002cb92:	df 02 08 80 	jne %d2,0,8002cba2 <__mdiff+0x13c>
8002cb96:	19 32 fc ff 	ld.w %d2,[%a3]-4
8002cb9a:	b0 c3       	add.a %a3,-4
8002cb9c:	c2 f1       	add %d1,-1
8002cb9e:	df 02 fc 7f 	jeq %d2,0,8002cb96 <__mdiff+0x130>
8002cba2:	59 21 10 00 	st.w [%a2]16,%d1
8002cba6:	00 90       	ret 
8002cba8:	40 c2       	mov.aa %a2,%a12
8002cbaa:	82 18       	mov %d8,1
8002cbac:	40 dc       	mov.aa %a12,%a13
8002cbae:	40 2d       	mov.aa %a13,%a2
8002cbb0:	1d ff 7e ff 	j 8002caac <__mdiff+0x46>
8002cbb4:	bf 08 fa 7f 	jlt %d8,0,8002cba8 <__mdiff+0x142>
8002cbb8:	82 08       	mov %d8,0
8002cbba:	1d ff 79 ff 	j 8002caac <__mdiff+0x46>
8002cbbe:	82 04       	mov %d4,0
8002cbc0:	6d ff 0f fc 	call 8002c3de <_Balloc>
8002cbc4:	bd 02 16 00 	jz.a %a2,8002cbf0 <__mdiff+0x18a>
8002cbc8:	82 12       	mov %d2,1
8002cbca:	59 22 10 00 	st.w [%a2]16,%d2
8002cbce:	82 02       	mov %d2,0
8002cbd0:	59 22 14 00 	st.w [%a2]20,%d2
8002cbd4:	00 90       	ret 
8002cbd6:	91 00 00 68 	movh.a %a6,32768
8002cbda:	91 00 00 48 	movh.a %a4,32768
8002cbde:	d9 66 dc 83 	lea %a6,[%a6]15900 <80003e1c <blanks.1+0xc0>>
8002cbe2:	a0 05       	mov.a %a5,0
8002cbe4:	3b 50 24 40 	mov %d4,581
8002cbe8:	d9 44 ed 83 	lea %a4,[%a4]15917 <80003e2d <blanks.1+0xd1>>
8002cbec:	1d 00 38 03 	j 8002d25c <__assert_func>
8002cbf0:	91 00 00 68 	movh.a %a6,32768
8002cbf4:	91 00 00 48 	movh.a %a4,32768
8002cbf8:	d9 66 dc 83 	lea %a6,[%a6]15900 <80003e1c <blanks.1+0xc0>>
8002cbfc:	a0 05       	mov.a %a5,0
8002cbfe:	3b 70 23 40 	mov %d4,567
8002cc02:	d9 44 ed 83 	lea %a4,[%a4]15917 <80003e2d <blanks.1+0xd1>>
8002cc06:	1d 00 2b 03 	j 8002d25c <__assert_func>

8002cc0a <__d2b>:
8002cc0a:	20 08       	sub.a %sp,8
8002cc0c:	02 4a       	mov %d10,%d4
8002cc0e:	40 5e       	mov.aa %a14,%a5
8002cc10:	82 14       	mov %d4,1
8002cc12:	02 59       	mov %d9,%d5
8002cc14:	40 6d       	mov.aa %a13,%a6
8002cc16:	6d ff e4 fb 	call 8002c3de <_Balloc>
8002cc1a:	40 2c       	mov.aa %a12,%a2
8002cc1c:	bd 02 5a 00 	jz.a %a2,8002ccd0 <__d2b+0xc6>
8002cc20:	37 09 6b 8a 	extr.u %d8,%d9,20,11
8002cc24:	8b 08 20 22 	ne %d2,%d8,0
8002cc28:	37 29 0c 2a 	insert %d2,%d9,%d2,20,12
8002cc2c:	59 a2 04 00 	st.w [%sp]4,%d2
8002cc30:	df 0a 1a 80 	jne %d10,0,8002cc64 <__d2b+0x5a>
8002cc34:	d9 a4 04 00 	lea %a4,[%sp]4
8002cc38:	82 19       	mov %d9,1
8002cc3a:	6d ff 9c fc 	call 8002c572 <__lo0bits>
8002cc3e:	19 a3 04 00 	ld.w %d3,[%sp]4
8002cc42:	59 c3 14 00 	st.w [%a12]20,%d3
8002cc46:	59 c9 10 00 	st.w [%a12]16,%d9
8002cc4a:	1b 02 02 20 	addi %d2,%d2,32
8002cc4e:	df 08 2b 00 	jeq %d8,0,8002cca4 <__d2b+0x9a>
8002cc52:	1b d8 bc 3f 	addi %d3,%d8,-1075
8002cc56:	42 23       	add %d3,%d2
8002cc58:	8b 52 03 21 	rsub %d2,%d2,53
8002cc5c:	40 c2       	mov.aa %a2,%a12
8002cc5e:	74 e3       	st.w [%a14],%d3
8002cc60:	74 d2       	st.w [%a13],%d2
8002cc62:	00 90       	ret 
8002cc64:	40 a4       	mov.aa %a4,%sp
8002cc66:	74 aa       	st.w [%sp],%d10
8002cc68:	6d ff 85 fc 	call 8002c572 <__lo0bits>
8002cc6c:	19 a9 04 00 	ld.w %d9,[%sp]4
8002cc70:	df 02 2b 00 	jeq %d2,0,8002ccc6 <__d2b+0xbc>
8002cc74:	54 a5       	ld.w %d5,[%sp]
8002cc76:	8b 02 02 41 	rsub %d4,%d2,32
8002cc7a:	0f 49 00 40 	sh %d4,%d9,%d4
8002cc7e:	02 93       	mov %d3,%d9
8002cc80:	8b 02 00 91 	rsub %d9,%d2,0
8002cc84:	a6 54       	or %d4,%d5
8002cc86:	0f 93 00 90 	sh %d9,%d3,%d9
8002cc8a:	59 c4 14 00 	st.w [%a12]20,%d4
8002cc8e:	59 a9 04 00 	st.w [%sp]4,%d9
8002cc92:	59 c9 18 00 	st.w [%a12]24,%d9
8002cc96:	8b 09 20 92 	ne %d9,%d9,0
8002cc9a:	c2 19       	add %d9,1
8002cc9c:	59 c9 10 00 	st.w [%a12]16,%d9
8002cca0:	df 08 d9 ff 	jne %d8,0,8002cc52 <__d2b+0x48>
8002cca4:	1b e2 bc 2f 	addi %d2,%d2,-1074
8002cca8:	74 e2       	st.w [%a14],%d2
8002ccaa:	8f 29 00 20 	sh %d2,%d9,2
8002ccae:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
8002ccb2:	06 59       	sh %d9,5
8002ccb4:	19 24 10 00 	ld.w %d4,[%a2]16
8002ccb8:	6d ff 38 fc 	call 8002c528 <__hi0bits>
8002ccbc:	0b 29 80 20 	sub %d2,%d9,%d2
8002ccc0:	40 c2       	mov.aa %a2,%a12
8002ccc2:	74 d2       	st.w [%a13],%d2
8002ccc4:	00 90       	ret 
8002ccc6:	54 a3       	ld.w %d3,[%sp]
8002ccc8:	59 c3 14 00 	st.w [%a12]20,%d3
8002cccc:	1d ff e3 ff 	j 8002cc92 <__d2b+0x88>
8002ccd0:	91 00 00 68 	movh.a %a6,32768
8002ccd4:	91 00 00 48 	movh.a %a4,32768
8002ccd8:	d9 66 dc 83 	lea %a6,[%a6]15900 <80003e1c <blanks.1+0xc0>>
8002ccdc:	a0 05       	mov.a %a5,0
8002ccde:	3b f0 30 40 	mov %d4,783
8002cce2:	d9 44 ed 83 	lea %a4,[%a4]15917 <80003e2d <blanks.1+0xd1>>
8002cce6:	1d 00 bb 02 	j 8002d25c <__assert_func>

8002ccea <_realloc_r>:
8002ccea:	40 4e       	mov.aa %a14,%a4
8002ccec:	40 5c       	mov.aa %a12,%a5
8002ccee:	02 4a       	mov %d10,%d4
8002ccf0:	bd 05 f2 00 	jz.a %a5,8002ced4 <_realloc_r+0x1ea>
8002ccf4:	6d ff 1a db 	call 80028328 <__malloc_lock>
8002ccf8:	19 c3 fc ff 	ld.w %d3,[%a12]-4
8002ccfc:	1b ba 00 50 	addi %d5,%d10,11
8002cd00:	8b 75 61 42 	lt.u %d4,%d5,23
8002cd04:	d9 cf f8 ff 	lea %a15,[%a12]-8
8002cd08:	8f 33 c0 91 	andn %d9,%d3,3
8002cd0c:	82 06       	mov %d6,0
8002cd0e:	3b 00 01 80 	mov %d8,16
8002cd12:	3b 00 01 20 	mov %d2,16
8002cd16:	df 04 b0 00 	jeq %d4,0,8002ce76 <_realloc_r+0x18c>
8002cd1a:	0b a8 a0 62 	or.lt.u %d6,%d8,%d10
8002cd1e:	df 06 b5 80 	jne %d6,0,8002ce88 <_realloc_r+0x19e>
8002cd22:	7f 29 93 00 	jge %d9,%d2,8002ce48 <_realloc_r+0x15e>
8002cd26:	91 10 00 37 	movh.a %a3,28673
8002cd2a:	d9 33 38 9a 	lea %a3,[%a3]-23944 <7000a278 <__malloc_av_>>
8002cd2e:	99 34 08 00 	ld.a %a4,[%a3]8 <70010008 <ram_heap+0x4f74>>
8002cd32:	01 f9 00 26 	addsc.a %a2,%a15,%d9,0
8002cd36:	19 24 04 00 	ld.w %d4,[%a2]4
8002cd3a:	7d 24 11 01 	jeq.a %a4,%a2,8002cf5c <_realloc_r+0x272>
8002cd3e:	8f 14 c0 51 	andn %d5,%d4,1
8002cd42:	01 25 00 36 	addsc.a %a3,%a2,%d5,0
8002cd46:	19 35 04 00 	ld.w %d5,[%a3]4
8002cd4a:	6f 05 b8 80 	jnz.t %d5,0,8002ceba <_realloc_r+0x1d0>
8002cd4e:	8f 34 c0 51 	andn %d5,%d4,3
8002cd52:	0b 59 00 40 	add %d4,%d9,%d5
8002cd56:	7f 24 6f 00 	jge %d4,%d2,8002ce34 <_realloc_r+0x14a>
8002cd5a:	6f 03 14 80 	jnz.t %d3,0,8002cd82 <_realloc_r+0x98>
8002cd5e:	99 c3 f8 ff 	ld.a %a3,[%a12]-8
8002cd62:	01 3f 20 30 	sub.a %a3,%a15,%a3
8002cd66:	19 33 04 00 	ld.w %d3,[%a3]4
8002cd6a:	80 3b       	mov.d %d11,%a3
8002cd6c:	8f 33 c0 31 	andn %d3,%d3,3
8002cd70:	42 35       	add %d5,%d3
8002cd72:	0b 95 00 c0 	add %d12,%d5,%d9
8002cd76:	7f 2c b4 00 	jge %d12,%d2,8002cede <_realloc_r+0x1f4>
8002cd7a:	0b 39 00 c0 	add %d12,%d9,%d3
8002cd7e:	7f 2c b9 00 	jge %d12,%d2,8002cef0 <_realloc_r+0x206>
8002cd82:	02 a4       	mov %d4,%d10
8002cd84:	40 e4       	mov.aa %a4,%a14
8002cd86:	6d ff 91 d7 	call 80027ca8 <_malloc_r>
8002cd8a:	40 2d       	mov.aa %a13,%a2
8002cd8c:	bd 02 4f 00 	jz.a %a2,8002ce2a <_realloc_r+0x140>
8002cd90:	19 c2 fc ff 	ld.w %d2,[%a12]-4
8002cd94:	b0 82       	add.a %a2,-8
8002cd96:	8f 12 c0 21 	andn %d2,%d2,1
8002cd9a:	01 f2 00 36 	addsc.a %a3,%a15,%d2,0
8002cd9e:	7d 23 40 01 	jeq.a %a3,%a2,8002d01e <_realloc_r+0x334>
8002cda2:	1b c9 ff 4f 	addi %d4,%d9,-4
8002cda6:	8b 54 a2 22 	ge.u %d2,%d4,37
8002cdaa:	df 02 41 81 	jne %d2,0,8002d02c <_realloc_r+0x342>
8002cdae:	8b 44 61 22 	lt.u %d2,%d4,20
8002cdb2:	40 d3       	mov.aa %a3,%a13
8002cdb4:	40 c2       	mov.aa %a2,%a12
8002cdb6:	df 02 2c 80 	jne %d2,0,8002ce0e <_realloc_r+0x124>
8002cdba:	54 c2       	ld.w %d2,[%a12]
8002cdbc:	74 d2       	st.w [%a13],%d2
8002cdbe:	19 c2 04 00 	ld.w %d2,[%a12]4
8002cdc2:	59 d2 04 00 	st.w [%a13]4,%d2
8002cdc6:	8b c4 a1 22 	ge.u %d2,%d4,28
8002cdca:	d9 c2 08 00 	lea %a2,[%a12]8
8002cdce:	d9 d3 08 00 	lea %a3,[%a13]8
8002cdd2:	df 02 1e 00 	jeq %d2,0,8002ce0e <_realloc_r+0x124>
8002cdd6:	19 c2 08 00 	ld.w %d2,[%a12]8
8002cdda:	59 d2 08 00 	st.w [%a13]8,%d2
8002cdde:	19 c2 0c 00 	ld.w %d2,[%a12]12
8002cde2:	59 d2 0c 00 	st.w [%a13]12,%d2
8002cde6:	8b 44 02 42 	eq %d4,%d4,36
8002cdea:	d9 c2 10 00 	lea %a2,[%a12]16
8002cdee:	d9 d3 10 00 	lea %a3,[%a13]16
8002cdf2:	df 04 0e 00 	jeq %d4,0,8002ce0e <_realloc_r+0x124>
8002cdf6:	19 c2 10 00 	ld.w %d2,[%a12]16
8002cdfa:	59 d2 10 00 	st.w [%a13]16,%d2
8002cdfe:	19 c2 14 00 	ld.w %d2,[%a12]20
8002ce02:	d9 c2 18 00 	lea %a2,[%a12]24
8002ce06:	d9 d3 18 00 	lea %a3,[%a13]24
8002ce0a:	59 d2 14 00 	st.w [%a13]20,%d2
8002ce0e:	54 22       	ld.w %d2,[%a2]
8002ce10:	74 32       	st.w [%a3],%d2
8002ce12:	19 22 04 00 	ld.w %d2,[%a2]4
8002ce16:	59 32 04 00 	st.w [%a3]4,%d2
8002ce1a:	19 22 08 00 	ld.w %d2,[%a2]8
8002ce1e:	59 32 08 00 	st.w [%a3]8,%d2
8002ce22:	40 c5       	mov.aa %a5,%a12
8002ce24:	40 e4       	mov.aa %a4,%a14
8002ce26:	6d ff 58 dd 	call 800288d6 <_free_r>
8002ce2a:	40 e4       	mov.aa %a4,%a14
8002ce2c:	6d ff 7f da 	call 8002832a <__malloc_unlock>
8002ce30:	40 d2       	mov.aa %a2,%a13
8002ce32:	00 90       	ret 
8002ce34:	99 23 0c 00 	ld.a %a3,[%a2]12
8002ce38:	d9 22 08 00 	lea %a2,[%a2]8
8002ce3c:	d4 22       	ld.a %a2,[%a2]
8002ce3e:	02 49       	mov %d9,%d4
8002ce40:	b5 23 0c 00 	st.a [%a2]12,%a3
8002ce44:	b5 32 08 00 	st.a [%a3]8,%a2
8002ce48:	48 12       	ld.w %d2,[%a15]4
8002ce4a:	0b 89 80 40 	sub %d4,%d9,%d8
8002ce4e:	8f 12 00 31 	and %d3,%d2,1
8002ce52:	8b 04 61 22 	lt.u %d2,%d4,16
8002ce56:	01 f9 00 26 	addsc.a %a2,%a15,%d9,0
8002ce5a:	df 02 1d 00 	jeq %d2,0,8002ce94 <_realloc_r+0x1aa>
8002ce5e:	a6 93       	or %d3,%d9
8002ce60:	68 13       	st.w [%a15]4,%d3
8002ce62:	b7 10 21 20 	imask %e2,1,0,1
8002ce66:	49 22 44 08 	ldmst [%a2]4 <90010000 <_SMALL_DATA4_+0x8000>>,%e2
8002ce6a:	40 e4       	mov.aa %a4,%a14
8002ce6c:	6d ff 5f da 	call 8002832a <__malloc_unlock>
8002ce70:	40 cd       	mov.aa %a13,%a12
8002ce72:	40 d2       	mov.aa %a2,%a13
8002ce74:	00 90       	ret 
8002ce76:	8f 75 c0 81 	andn %d8,%d5,7
8002ce7a:	8f 18 1e 60 	sh %d6,%d8,-31
8002ce7e:	0b a8 a0 62 	or.lt.u %d6,%d8,%d10
8002ce82:	02 82       	mov %d2,%d8
8002ce84:	df 06 4f 7f 	jeq %d6,0,8002cd22 <_realloc_r+0x38>
8002ce88:	3b c0 00 20 	mov %d2,12
8002ce8c:	a0 0d       	mov.a %a13,0
8002ce8e:	40 d2       	mov.aa %a2,%a13
8002ce90:	74 e2       	st.w [%a14],%d2
8002ce92:	00 90       	ret 
8002ce94:	a6 83       	or %d3,%d8
8002ce96:	8f 14 40 41 	or %d4,%d4,1
8002ce9a:	01 f8 00 56 	addsc.a %a5,%a15,%d8,0
8002ce9e:	68 13       	st.w [%a15]4,%d3
8002cea0:	b7 10 21 20 	imask %e2,1,0,1
8002cea4:	59 54 04 00 	st.w [%a5]4,%d4
8002cea8:	40 e4       	mov.aa %a4,%a14
8002ceaa:	d9 55 08 00 	lea %a5,[%a5]8
8002ceae:	49 22 44 08 	ldmst [%a2]4,%e2
8002ceb2:	6d ff 12 dd 	call 800288d6 <_free_r>
8002ceb6:	1d ff da ff 	j 8002ce6a <_realloc_r+0x180>
8002ceba:	6f 03 64 ff 	jnz.t %d3,0,8002cd82 <_realloc_r+0x98>
8002cebe:	99 c2 f8 ff 	ld.a %a2,[%a12]-8
8002cec2:	01 2f 20 20 	sub.a %a2,%a15,%a2
8002cec6:	19 23 04 00 	ld.w %d3,[%a2]4
8002ceca:	80 2b       	mov.d %d11,%a2
8002cecc:	8f 33 c0 31 	andn %d3,%d3,3
8002ced0:	1d ff 55 ff 	j 8002cd7a <_realloc_r+0x90>
8002ced4:	6d ff ea d6 	call 80027ca8 <_malloc_r>
8002ced8:	40 2d       	mov.aa %a13,%a2
8002ceda:	40 d2       	mov.aa %a2,%a13
8002cedc:	00 90       	ret 
8002cede:	99 23 0c 00 	ld.a %a3,[%a2]12
8002cee2:	d9 22 08 00 	lea %a2,[%a2]8
8002cee6:	d4 22       	ld.a %a2,[%a2]
8002cee8:	b5 23 0c 00 	st.a [%a2]12,%a3
8002ceec:	b5 32 08 00 	st.a [%a3]8,%a2
8002cef0:	60 bd       	mov.a %a13,%d11
8002cef2:	60 b2       	mov.a %a2,%d11
8002cef4:	99 d3 08 00 	ld.a %a3,[%a13]8
8002cef8:	d9 22 0c 00 	lea %a2,[%a2]12
8002cefc:	d4 22       	ld.a %a2,[%a2]
8002cefe:	1b c9 ff 4f 	addi %d4,%d9,-4
8002cf02:	8b 54 a2 22 	ge.u %d2,%d4,37
8002cf06:	b5 32 0c 00 	st.a [%a3]12,%a2
8002cf0a:	b5 23 08 00 	st.a [%a2]8,%a3
8002cf0e:	d9 dd 08 00 	lea %a13,[%a13]8
8002cf12:	df 02 93 80 	jne %d2,0,8002d038 <_realloc_r+0x34e>
8002cf16:	8b 44 61 22 	lt.u %d2,%d4,20
8002cf1a:	40 d2       	mov.aa %a2,%a13
8002cf1c:	df 02 11 80 	jne %d2,0,8002cf3e <_realloc_r+0x254>
8002cf20:	54 c2       	ld.w %d2,[%a12]
8002cf22:	74 d2       	st.w [%a13],%d2
8002cf24:	60 b2       	mov.a %a2,%d11
8002cf26:	19 c2 04 00 	ld.w %d2,[%a12]4
8002cf2a:	59 22 0c 00 	st.w [%a2]12,%d2
8002cf2e:	8b c4 a1 22 	ge.u %d2,%d4,28
8002cf32:	df 02 a2 80 	jne %d2,0,8002d076 <_realloc_r+0x38c>
8002cf36:	d9 cc 08 00 	lea %a12,[%a12]8
8002cf3a:	d9 22 10 00 	lea %a2,[%a2]16
8002cf3e:	54 c2       	ld.w %d2,[%a12]
8002cf40:	74 22       	st.w [%a2],%d2
8002cf42:	19 c2 04 00 	ld.w %d2,[%a12]4
8002cf46:	59 22 04 00 	st.w [%a2]4,%d2
8002cf4a:	19 c2 08 00 	ld.w %d2,[%a12]8
8002cf4e:	60 bf       	mov.a %a15,%d11
8002cf50:	59 22 08 00 	st.w [%a2]8,%d2
8002cf54:	40 dc       	mov.aa %a12,%a13
8002cf56:	02 c9       	mov %d9,%d12
8002cf58:	1d ff 78 ff 	j 8002ce48 <_realloc_r+0x15e>
8002cf5c:	8f 34 c0 51 	andn %d5,%d4,3
8002cf60:	0b 59 00 60 	add %d6,%d9,%d5
8002cf64:	1b 08 01 40 	addi %d4,%d8,16
8002cf68:	7f 46 71 00 	jge %d6,%d4,8002d04a <_realloc_r+0x360>
8002cf6c:	6f 03 0b ff 	jnz.t %d3,0,8002cd82 <_realloc_r+0x98>
8002cf70:	99 c2 f8 ff 	ld.a %a2,[%a12]-8
8002cf74:	01 2f 20 20 	sub.a %a2,%a15,%a2
8002cf78:	19 23 04 00 	ld.w %d3,[%a2]4
8002cf7c:	80 2b       	mov.d %d11,%a2
8002cf7e:	8f 33 c0 31 	andn %d3,%d3,3
8002cf82:	42 35       	add %d5,%d3
8002cf84:	0b 95 00 c0 	add %d12,%d5,%d9
8002cf88:	3f 4c f9 7e 	jlt %d12,%d4,8002cd7a <_realloc_r+0x90>
8002cf8c:	60 bd       	mov.a %a13,%d11
8002cf8e:	60 b2       	mov.a %a2,%d11
8002cf90:	99 d4 08 00 	ld.a %a4,[%a13]8
8002cf94:	d9 22 0c 00 	lea %a2,[%a2]12
8002cf98:	d4 22       	ld.a %a2,[%a2]
8002cf9a:	1b c9 ff 4f 	addi %d4,%d9,-4
8002cf9e:	8b 54 a2 22 	ge.u %d2,%d4,37
8002cfa2:	b5 42 0c 00 	st.a [%a4]12,%a2
8002cfa6:	b5 24 08 00 	st.a [%a2]8,%a4
8002cfaa:	d9 dd 08 00 	lea %a13,[%a13]8
8002cfae:	df 02 85 80 	jne %d2,0,8002d0b8 <_realloc_r+0x3ce>
8002cfb2:	8b 44 61 22 	lt.u %d2,%d4,20
8002cfb6:	40 d2       	mov.aa %a2,%a13
8002cfb8:	df 02 11 80 	jne %d2,0,8002cfda <_realloc_r+0x2f0>
8002cfbc:	54 c2       	ld.w %d2,[%a12]
8002cfbe:	74 d2       	st.w [%a13],%d2
8002cfc0:	60 b2       	mov.a %a2,%d11
8002cfc2:	19 c2 04 00 	ld.w %d2,[%a12]4
8002cfc6:	59 22 0c 00 	st.w [%a2]12,%d2
8002cfca:	8b c4 a1 22 	ge.u %d2,%d4,28
8002cfce:	df 02 80 80 	jne %d2,0,8002d0ce <_realloc_r+0x3e4>
8002cfd2:	d9 cc 08 00 	lea %a12,[%a12]8
8002cfd6:	d9 22 10 00 	lea %a2,[%a2]16
8002cfda:	54 c2       	ld.w %d2,[%a12]
8002cfdc:	74 22       	st.w [%a2],%d2
8002cfde:	19 c2 04 00 	ld.w %d2,[%a12]4
8002cfe2:	59 22 04 00 	st.w [%a2]4,%d2
8002cfe6:	19 c2 08 00 	ld.w %d2,[%a12]8
8002cfea:	59 22 08 00 	st.w [%a2]8,%d2
8002cfee:	60 b2       	mov.a %a2,%d11
8002cff0:	0b 8c 80 20 	sub %d2,%d12,%d8
8002cff4:	01 28 00 26 	addsc.a %a2,%a2,%d8,0
8002cff8:	8f 12 40 21 	or %d2,%d2,1
8002cffc:	b5 32 08 00 	st.a [%a3]8,%a2
8002d000:	40 e4       	mov.aa %a4,%a14
8002d002:	59 22 04 00 	st.w [%a2]4,%d2
8002d006:	60 b2       	mov.a %a2,%d11
8002d008:	19 22 04 00 	ld.w %d2,[%a2]4
8002d00c:	8f 12 00 21 	and %d2,%d2,1
8002d010:	a6 82       	or %d2,%d8
8002d012:	59 22 04 00 	st.w [%a2]4,%d2
8002d016:	6d ff 8a d9 	call 8002832a <__malloc_unlock>
8002d01a:	1d ff 2c ff 	j 8002ce72 <_realloc_r+0x188>
8002d01e:	19 d2 fc ff 	ld.w %d2,[%a13]-4
8002d022:	8f 32 c0 21 	andn %d2,%d2,3
8002d026:	42 29       	add %d9,%d2
8002d028:	1d ff 10 ff 	j 8002ce48 <_realloc_r+0x15e>
8002d02c:	40 c5       	mov.aa %a5,%a12
8002d02e:	40 d4       	mov.aa %a4,%a13
8002d030:	6d ff 3c d4 	call 800278a8 <memmove>
8002d034:	1d ff f7 fe 	j 8002ce22 <_realloc_r+0x138>
8002d038:	40 c5       	mov.aa %a5,%a12
8002d03a:	40 d4       	mov.aa %a4,%a13
8002d03c:	60 bf       	mov.a %a15,%d11
8002d03e:	6d ff 35 d4 	call 800278a8 <memmove>
8002d042:	40 dc       	mov.aa %a12,%a13
8002d044:	02 c9       	mov %d9,%d12
8002d046:	1d ff 01 ff 	j 8002ce48 <_realloc_r+0x15e>
8002d04a:	0b 86 80 20 	sub %d2,%d6,%d8
8002d04e:	01 f8 00 f6 	addsc.a %a15,%a15,%d8,0
8002d052:	8f 12 40 21 	or %d2,%d2,1
8002d056:	ec 32       	st.a [%a3]8,%a15
8002d058:	d9 c2 fc ff 	lea %a2,[%a12]-4
8002d05c:	68 12       	st.w [%a15]4,%d2
8002d05e:	19 c2 fc ff 	ld.w %d2,[%a12]-4
8002d062:	40 e4       	mov.aa %a4,%a14
8002d064:	8f 12 00 21 	and %d2,%d2,1
8002d068:	a6 82       	or %d2,%d8
8002d06a:	40 cd       	mov.aa %a13,%a12
8002d06c:	74 22       	st.w [%a2],%d2
8002d06e:	6d ff 5e d9 	call 8002832a <__malloc_unlock>
8002d072:	1d ff 00 ff 	j 8002ce72 <_realloc_r+0x188>
8002d076:	19 c2 08 00 	ld.w %d2,[%a12]8
8002d07a:	59 22 10 00 	st.w [%a2]16,%d2
8002d07e:	19 c2 0c 00 	ld.w %d2,[%a12]12
8002d082:	59 22 14 00 	st.w [%a2]20,%d2
8002d086:	8b 44 02 42 	eq %d4,%d4,36
8002d08a:	df 04 08 80 	jne %d4,0,8002d09a <_realloc_r+0x3b0>
8002d08e:	d9 cc 10 00 	lea %a12,[%a12]16
8002d092:	d9 22 18 00 	lea %a2,[%a2]24
8002d096:	1d ff 54 ff 	j 8002cf3e <_realloc_r+0x254>
8002d09a:	19 c2 10 00 	ld.w %d2,[%a12]16
8002d09e:	59 22 18 00 	st.w [%a2]24,%d2
8002d0a2:	60 b3       	mov.a %a3,%d11
8002d0a4:	19 c2 14 00 	ld.w %d2,[%a12]20
8002d0a8:	d9 22 20 00 	lea %a2,[%a2]32
8002d0ac:	59 32 1c 00 	st.w [%a3]28,%d2
8002d0b0:	d9 cc 18 00 	lea %a12,[%a12]24
8002d0b4:	1d ff 45 ff 	j 8002cf3e <_realloc_r+0x254>
8002d0b8:	40 c5       	mov.aa %a5,%a12
8002d0ba:	40 d4       	mov.aa %a4,%a13
8002d0bc:	6d ff f6 d3 	call 800278a8 <memmove>
8002d0c0:	7b 10 00 27 	movh %d2,28673
8002d0c4:	60 22       	mov.a %a2,%d2
8002d0c6:	d9 23 38 9a 	lea %a3,[%a2]-23944
8002d0ca:	1d ff 92 ff 	j 8002cfee <_realloc_r+0x304>
8002d0ce:	19 c2 08 00 	ld.w %d2,[%a12]8
8002d0d2:	59 22 10 00 	st.w [%a2]16,%d2
8002d0d6:	19 c2 0c 00 	ld.w %d2,[%a12]12
8002d0da:	59 22 14 00 	st.w [%a2]20,%d2
8002d0de:	8b 44 02 42 	eq %d4,%d4,36
8002d0e2:	df 04 08 80 	jne %d4,0,8002d0f2 <_realloc_r+0x408>
8002d0e6:	d9 cc 10 00 	lea %a12,[%a12]16
8002d0ea:	d9 22 18 00 	lea %a2,[%a2]24
8002d0ee:	1d ff 76 ff 	j 8002cfda <_realloc_r+0x2f0>
8002d0f2:	19 c2 10 00 	ld.w %d2,[%a12]16
8002d0f6:	59 22 18 00 	st.w [%a2]24,%d2
8002d0fa:	60 b4       	mov.a %a4,%d11
8002d0fc:	19 c2 14 00 	ld.w %d2,[%a12]20
8002d100:	d9 22 20 00 	lea %a2,[%a2]32
8002d104:	59 42 1c 00 	st.w [%a4]28,%d2
8002d108:	d9 cc 18 00 	lea %a12,[%a12]24
8002d10c:	1d ff 67 ff 	j 8002cfda <_realloc_r+0x2f0>

8002d110 <__ascii_wctomb>:
8002d110:	82 02       	mov %d2,0
8002d112:	bd 05 08 00 	jz.a %a5,8002d122 <__ascii_wctomb+0x12>
8002d116:	8b 04 70 22 	lt.u %d2,%d4,256
8002d11a:	df 02 05 00 	jeq %d2,0,8002d124 <__ascii_wctomb+0x14>
8002d11e:	34 54       	st.b [%a5],%d4
8002d120:	82 12       	mov %d2,1
8002d122:	00 90       	ret 
8002d124:	3b a0 08 20 	mov %d2,138
8002d128:	74 42       	st.w [%a4],%d2
8002d12a:	82 f2       	mov %d2,-1
8002d12c:	00 90       	ret 

8002d12e <__ssprint_r>:
8002d12e:	19 62 08 00 	ld.w %d2,[%a6]8
8002d132:	d4 6e       	ld.a %a14,[%a6]
8002d134:	40 4f       	mov.aa %a15,%a4
8002d136:	40 5c       	mov.aa %a12,%a5
8002d138:	40 6d       	mov.aa %a13,%a6
8002d13a:	df 02 8c 00 	jeq %d2,0,8002d252 <__ssprint_r+0x124>
8002d13e:	19 52 08 00 	ld.w %d2,[%a5]8
8002d142:	54 53       	ld.w %d3,[%a5]
8002d144:	3b 00 48 e0 	mov %d14,1152
8002d148:	3b 00 40 f0 	mov %d15,1024
8002d14c:	1d 00 58 00 	j 8002d1fc <__ssprint_r+0xce>
8002d150:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002d154:	0f e2 80 40 	and %d4,%d2,%d14
8002d158:	df 04 3b 00 	jeq %d4,0,8002d1ce <__ssprint_r+0xa0>
8002d15c:	99 c5 10 00 	ld.a %a5,[%a12]16
8002d160:	26 f2       	and %d2,%d15
8002d162:	40 f4       	mov.aa %a4,%a15
8002d164:	80 54       	mov.d %d4,%a5
8002d166:	0b 43 80 c0 	sub %d12,%d3,%d4
8002d16a:	19 c3 14 00 	ld.w %d3,[%a12]20
8002d16e:	53 33 20 30 	mul %d3,%d3,3
8002d172:	8f 13 1e 40 	sh %d4,%d3,-31
8002d176:	42 43       	add %d3,%d4
8002d178:	1b 1c 00 40 	addi %d4,%d12,1
8002d17c:	42 84       	add %d4,%d8
8002d17e:	86 f3       	sha %d3,-1
8002d180:	0b 43 b0 d1 	max.u %d13,%d3,%d4
8002d184:	02 d4       	mov %d4,%d13
8002d186:	df 02 4b 00 	jeq %d2,0,8002d21c <__ssprint_r+0xee>
8002d18a:	6d ff 8f d5 	call 80027ca8 <_malloc_r>
8002d18e:	80 29       	mov.d %d9,%a2
8002d190:	df 09 50 00 	jeq %d9,0,8002d230 <__ssprint_r+0x102>
8002d194:	99 c5 10 00 	ld.a %a5,[%a12]16
8002d198:	02 c4       	mov %d4,%d12
8002d19a:	40 24       	mov.aa %a4,%a2
8002d19c:	6d ff 40 d0 	call 8002721c <memcpy>
8002d1a0:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002d1a4:	3b f0 b7 3f 	mov %d3,-1153
8002d1a8:	26 32       	and %d2,%d3
8002d1aa:	8f 02 48 21 	or %d2,%d2,128
8002d1ae:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002d1b2:	60 92       	mov.a %a2,%d9
8002d1b4:	59 c9 10 00 	st.w [%a12]16,%d9
8002d1b8:	01 2c 00 46 	addsc.a %a4,%a2,%d12,0
8002d1bc:	0b cd 80 c0 	sub %d12,%d13,%d12
8002d1c0:	f4 c4       	st.a [%a12],%a4
8002d1c2:	59 cd 14 00 	st.w [%a12]20,%d13
8002d1c6:	02 8a       	mov %d10,%d8
8002d1c8:	59 cc 08 00 	st.w [%a12]8,%d12
8002d1cc:	02 89       	mov %d9,%d8
8002d1ce:	60 b5       	mov.a %a5,%d11
8002d1d0:	02 94       	mov %d4,%d9
8002d1d2:	6d ff 6b d3 	call 800278a8 <memmove>
8002d1d6:	19 c2 08 00 	ld.w %d2,[%a12]8
8002d1da:	54 c3       	ld.w %d3,[%a12]
8002d1dc:	19 d4 08 00 	ld.w %d4,[%a13]8
8002d1e0:	a2 a2       	sub %d2,%d10
8002d1e2:	42 93       	add %d3,%d9
8002d1e4:	0b 84 80 80 	sub %d8,%d4,%d8
8002d1e8:	d9 c2 08 00 	lea %a2,[%a12]8
8002d1ec:	74 22       	st.w [%a2],%d2
8002d1ee:	74 c3       	st.w [%a12],%d3
8002d1f0:	59 d8 08 00 	st.w [%a13]8,%d8
8002d1f4:	d9 d2 08 00 	lea %a2,[%a13]8
8002d1f8:	df 08 2d 00 	jeq %d8,0,8002d252 <__ssprint_r+0x124>
8002d1fc:	19 e8 04 00 	ld.w %d8,[%a14]4
8002d200:	54 eb       	ld.w %d11,[%a14]
8002d202:	60 34       	mov.a %a4,%d3
8002d204:	d9 ee 08 00 	lea %a14,[%a14]8
8002d208:	02 2a       	mov %d10,%d2
8002d20a:	02 29       	mov %d9,%d2
8002d20c:	df 08 f8 7f 	jeq %d8,0,8002d1fc <__ssprint_r+0xce>
8002d210:	7f 28 a0 ff 	jge.u %d8,%d2,8002d150 <__ssprint_r+0x22>
8002d214:	02 8a       	mov %d10,%d8
8002d216:	02 89       	mov %d9,%d8
8002d218:	1d ff db ff 	j 8002d1ce <__ssprint_r+0xa0>
8002d21c:	6d ff 67 fd 	call 8002ccea <_realloc_r>
8002d220:	80 29       	mov.d %d9,%a2
8002d222:	df 09 c8 ff 	jne %d9,0,8002d1b2 <__ssprint_r+0x84>
8002d226:	99 c5 10 00 	ld.a %a5,[%a12]16
8002d22a:	40 f4       	mov.aa %a4,%a15
8002d22c:	6d ff 55 db 	call 800288d6 <_free_r>
8002d230:	3b c0 00 20 	mov %d2,12
8002d234:	82 03       	mov %d3,0
8002d236:	68 02       	st.w [%a15]0,%d2
8002d238:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002d23c:	8f 02 44 21 	or %d2,%d2,64
8002d240:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002d244:	82 02       	mov %d2,0
8002d246:	59 d3 04 00 	st.w [%a13]4,%d3
8002d24a:	59 d2 08 00 	st.w [%a13]8,%d2
8002d24e:	82 f2       	mov %d2,-1
8002d250:	00 90       	ret 
8002d252:	82 03       	mov %d3,0
8002d254:	82 02       	mov %d2,0
8002d256:	59 d3 04 00 	st.w [%a13]4,%d3
8002d25a:	00 90       	ret 

8002d25c <__assert_func>:
8002d25c:	91 10 00 27 	movh.a %a2,28673
8002d260:	99 22 50 aa 	ld.a %a2,[%a2]-22896 <7000a690 <_impure_ptr>>
8002d264:	80 43       	mov.d %d3,%a4
8002d266:	20 18       	sub.a %sp,24
8002d268:	99 24 0c 00 	ld.a %a4,[%a2]12
8002d26c:	91 00 00 28 	movh.a %a2,32768
8002d270:	80 62       	mov.d %d2,%a6
8002d272:	d9 22 d4 f3 	lea %a2,[%a2]16340 <80003fd4 <__mprec_tens+0xc8>>
8002d276:	bd 05 13 00 	jz.a %a5,8002d29c <__assert_func+0x40>
8002d27a:	b5 a5 10 00 	st.a [%sp]16,%a5
8002d27e:	91 00 00 58 	movh.a %a5,32768
8002d282:	b5 a2 0c 00 	st.a [%sp]12,%a2
8002d286:	59 a4 08 00 	st.w [%sp]8,%d4
8002d28a:	59 a3 04 00 	st.w [%sp]4,%d3
8002d28e:	d9 55 e2 f3 	lea %a5,[%a5]16354 <80003fe2 <__mprec_tens+0xd6>>
8002d292:	74 a2       	st.w [%sp],%d2
8002d294:	6d 00 54 00 	call 8002d33c <fiprintf>
8002d298:	6d 00 d8 0c 	call 8002ec48 <abort>
8002d29c:	91 00 00 28 	movh.a %a2,32768
8002d2a0:	d9 22 e1 f3 	lea %a2,[%a2]16353 <80003fe1 <__mprec_tens+0xd5>>
8002d2a4:	40 25       	mov.aa %a5,%a2
8002d2a6:	1d ff ea ff 	j 8002d27a <__assert_func+0x1e>

8002d2aa <_calloc_r>:
8002d2aa:	73 54 68 40 	mul.u %e4,%d4,%d5
8002d2ae:	82 08       	mov %d8,0
8002d2b0:	df 05 3e 80 	jne %d5,0,8002d32c <_calloc_r+0x82>
8002d2b4:	6d ff fa d4 	call 80027ca8 <_malloc_r>
8002d2b8:	40 2c       	mov.aa %a12,%a2
8002d2ba:	bd 02 29 00 	jz.a %a2,8002d30c <_calloc_r+0x62>
8002d2be:	19 22 fc ff 	ld.w %d2,[%a2]-4
8002d2c2:	8f 32 c0 21 	andn %d2,%d2,3
8002d2c6:	1b c2 ff 5f 	addi %d5,%d2,-4
8002d2ca:	8b 55 a2 22 	ge.u %d2,%d5,37
8002d2ce:	df 02 21 80 	jne %d2,0,8002d310 <_calloc_r+0x66>
8002d2d2:	8b 45 61 22 	lt.u %d2,%d5,20
8002d2d6:	df 02 15 80 	jne %d2,0,8002d300 <_calloc_r+0x56>
8002d2da:	74 28       	st.w [%a2],%d8
8002d2dc:	59 28 04 00 	st.w [%a2]4,%d8
8002d2e0:	8b c5 a1 22 	ge.u %d2,%d5,28
8002d2e4:	d9 22 08 00 	lea %a2,[%a2]8
8002d2e8:	df 02 0c 00 	jeq %d2,0,8002d300 <_calloc_r+0x56>
8002d2ec:	59 c8 08 00 	st.w [%a12]8,%d8
8002d2f0:	59 c8 0c 00 	st.w [%a12]12,%d8
8002d2f4:	8b 45 02 52 	eq %d5,%d5,36
8002d2f8:	d9 c2 10 00 	lea %a2,[%a12]16
8002d2fc:	df 05 10 80 	jne %d5,0,8002d31c <_calloc_r+0x72>
8002d300:	82 02       	mov %d2,0
8002d302:	74 22       	st.w [%a2],%d2
8002d304:	59 22 04 00 	st.w [%a2]4,%d2
8002d308:	59 22 08 00 	st.w [%a2]8,%d2
8002d30c:	40 c2       	mov.aa %a2,%a12
8002d30e:	00 90       	ret 
8002d310:	82 04       	mov %d4,0
8002d312:	40 24       	mov.aa %a4,%a2
8002d314:	6d ff 8e cf 	call 80027230 <memset>
8002d318:	40 c2       	mov.aa %a2,%a12
8002d31a:	00 90       	ret 
8002d31c:	59 c8 10 00 	st.w [%a12]16,%d8
8002d320:	d9 c2 18 00 	lea %a2,[%a12]24
8002d324:	59 c8 14 00 	st.w [%a12]20,%d8
8002d328:	1d ff ec ff 	j 8002d300 <_calloc_r+0x56>
8002d32c:	6d ff 6c da 	call 80028804 <__errno>
8002d330:	3b c0 00 20 	mov %d2,12
8002d334:	a0 0c       	mov.a %a12,0
8002d336:	74 22       	st.w [%a2],%d2
8002d338:	1d ff ea ff 	j 8002d30c <_calloc_r+0x62>

8002d33c <fiprintf>:
8002d33c:	40 56       	mov.aa %a6,%a5
8002d33e:	40 45       	mov.aa %a5,%a4
8002d340:	91 10 00 47 	movh.a %a4,28673
8002d344:	99 44 50 aa 	ld.a %a4,[%a4]-22896 <7000a690 <_impure_ptr>>
8002d348:	40 a7       	mov.aa %a7,%sp
8002d34a:	6d 00 41 00 	call 8002d3cc <_vfiprintf_r>
8002d34e:	00 90       	ret 

8002d350 <__sprint_r.part.0>:
8002d350:	19 52 24 10 	ld.w %d2,[%a5]100
8002d354:	80 49       	mov.d %d9,%a4
8002d356:	40 5c       	mov.aa %a12,%a5
8002d358:	40 6e       	mov.aa %a14,%a6
8002d35a:	6f d2 30 00 	jz.t %d2,13,8002d3ba <__sprint_r.part.0+0x6a>
8002d35e:	19 62 08 00 	ld.w %d2,[%a6]8
8002d362:	cc 60       	ld.a %a15,[%a6]0
8002d364:	df 02 28 00 	jeq %d2,0,8002d3b4 <__sprint_r.part.0+0x64>
8002d368:	48 1b       	ld.w %d11,[%a15]4
8002d36a:	c8 0d       	ld.a %a13,[%a15]0
8002d36c:	8f eb 1f a0 	sh %d10,%d11,-2
8002d370:	df 0a 19 00 	jeq %d10,0,8002d3a2 <__sprint_r.part.0+0x52>
8002d374:	82 08       	mov %d8,0
8002d376:	1d 00 05 00 	j 8002d380 <__sprint_r.part.0+0x30>
8002d37a:	c2 18       	add %d8,1
8002d37c:	5f 8a 11 00 	jeq %d10,%d8,8002d39e <__sprint_r.part.0+0x4e>
8002d380:	40 d2       	mov.aa %a2,%a13
8002d382:	54 24       	ld.w %d4,[%a2]
8002d384:	60 94       	mov.a %a4,%d9
8002d386:	40 c5       	mov.aa %a5,%a12
8002d388:	b0 4d       	add.a %a13,4
8002d38a:	6d 00 f8 0a 	call 8002e97a <_fputwc_r>
8002d38e:	df f2 f6 ff 	jne %d2,-1,8002d37a <__sprint_r.part.0+0x2a>
8002d392:	82 03       	mov %d3,0
8002d394:	59 e3 08 00 	st.w [%a14]8,%d3
8002d398:	59 e3 04 00 	st.w [%a14]4,%d3
8002d39c:	00 90       	ret 
8002d39e:	19 e2 08 00 	ld.w %d2,[%a14]8
8002d3a2:	8f 3b c0 b1 	andn %d11,%d11,3
8002d3a6:	a2 b2       	sub %d2,%d11
8002d3a8:	d9 ff 08 00 	lea %a15,[%a15]8
8002d3ac:	59 e2 08 00 	st.w [%a14]8,%d2
8002d3b0:	df 02 dc ff 	jne %d2,0,8002d368 <__sprint_r.part.0+0x18>
8002d3b4:	82 02       	mov %d2,0
8002d3b6:	1d ff ee ff 	j 8002d392 <__sprint_r.part.0+0x42>
8002d3ba:	6d 00 75 08 	call 8002e4a4 <__sfvwrite_r>
8002d3be:	82 03       	mov %d3,0
8002d3c0:	59 e3 08 00 	st.w [%a14]8,%d3
8002d3c4:	59 e3 04 00 	st.w [%a14]4,%d3
8002d3c8:	00 90       	ret 
	...

8002d3cc <_vfiprintf_r>:
8002d3cc:	20 e8       	sub.a %sp,232
8002d3ce:	80 4d       	mov.d %d13,%a4
8002d3d0:	b5 a7 10 00 	st.a [%sp]16,%a7
8002d3d4:	40 5f       	mov.aa %a15,%a5
8002d3d6:	80 6f       	mov.d %d15,%a6
8002d3d8:	df 0d 06 00 	jeq %d13,0,8002d3e4 <_vfiprintf_r+0x18>
8002d3dc:	19 42 34 00 	ld.w %d2,[%a4]52
8002d3e0:	df 02 86 07 	jeq %d2,0,8002e2ec <_vfiprintf_r+0xf20>
8002d3e4:	88 62       	ld.h %d2,[%a15]12
8002d3e6:	6f d2 0e 80 	jnz.t %d2,13,8002d402 <_vfiprintf_r+0x36>
8002d3ea:	b7 f2 81 26 	insert %d2,%d2,15,13,1
8002d3ee:	c5 0d 00 02 	lea %a13,2000 <LCF_CSA0_SIZE>
8002d3f2:	a0 0c       	mov.a %a12,0
8002d3f4:	d9 f2 24 10 	lea %a2,[%a15]100
8002d3f8:	a8 62       	st.h [%a15]12,%d2
8002d3fa:	80 c4       	mov.d %d4,%a12
8002d3fc:	80 d5       	mov.d %d5,%a13
8002d3fe:	49 24 40 08 	ldmst [%a2]0,%e4
8002d402:	6f 32 26 01 	jz.t %d2,3,8002d64e <_vfiprintf_r+0x282>
8002d406:	48 43       	ld.w %d3,[%a15]16
8002d408:	df 03 23 01 	jeq %d3,0,8002d64e <_vfiprintf_r+0x282>
8002d40c:	8f a2 01 21 	and %d2,%d2,26
8002d410:	3b a0 00 30 	mov %d3,10
8002d414:	5f 32 2a 01 	jeq %d2,%d3,8002d668 <_vfiprintf_r+0x29c>
8002d418:	82 02       	mov %d2,0
8002d41a:	d9 a2 04 10 	lea %a2,[%sp]68
8002d41e:	40 fd       	mov.aa %a13,%a15
8002d420:	80 2c       	mov.d %d12,%a2
8002d422:	b5 a2 38 00 	st.a [%sp]56,%a2
8002d426:	59 a2 00 10 	st.w [%sp]64,%d2
8002d42a:	59 a2 3c 00 	st.w [%sp]60,%d2
8002d42e:	59 a2 14 00 	st.w [%sp]20,%d2
8002d432:	59 a2 18 00 	st.w [%sp]24,%d2
8002d436:	59 a2 20 00 	st.w [%sp]32,%d2
8002d43a:	59 a2 1c 00 	st.w [%sp]28,%d2
8002d43e:	59 a2 0c 00 	st.w [%sp]12,%d2
8002d442:	40 2f       	mov.aa %a15,%a2
8002d444:	78 02       	st.w [%sp]8,%d15
8002d446:	99 a3 08 00 	ld.a %a3,[%sp]8
8002d44a:	79 32 00 00 	ld.b %d2,[%a3]0
8002d44e:	40 32       	mov.aa %a2,%a3
8002d450:	8b 52 22 32 	ne %d3,%d2,37
8002d454:	8b 02 20 34 	and.ne %d3,%d2,0
8002d458:	df 03 8c 05 	jeq %d3,0,8002df70 <_vfiprintf_r+0xba4>
8002d45c:	b0 12       	add.a %a2,1
8002d45e:	80 3f       	mov.d %d15,%a3
8002d460:	79 22 00 00 	ld.b %d2,[%a2]0
8002d464:	d9 23 ff ff 	lea %a3,[%a2]-1
8002d468:	8b 52 22 32 	ne %d3,%d2,37
8002d46c:	8b 02 20 34 	and.ne %d3,%d2,0
8002d470:	40 2c       	mov.aa %a12,%a2
8002d472:	b0 12       	add.a %a2,1
8002d474:	df 03 f6 ff 	jne %d3,0,8002d460 <_vfiprintf_r+0x94>
8002d478:	60 f4       	mov.a %a4,%d15
8002d47a:	01 4c 20 e0 	sub.a %a14,%a12,%a4
8002d47e:	7d 4c 29 00 	jeq.a %a12,%a4,8002d4d0 <_vfiprintf_r+0x104>
8002d482:	19 a3 00 10 	ld.w %d3,[%sp]64
8002d486:	80 e2       	mov.d %d2,%a14
8002d488:	42 32       	add %d2,%d3
8002d48a:	19 a3 3c 00 	ld.w %d3,[%sp]60
8002d48e:	68 0f       	st.w [%a15]0,%d15
8002d490:	c2 13       	add %d3,1
8002d492:	e8 1e       	st.a [%a15]4,%a14
8002d494:	59 a2 00 10 	st.w [%sp]64,%d2
8002d498:	59 a3 3c 00 	st.w [%sp]60,%d3
8002d49c:	8b 83 80 32 	ge %d3,%d3,8
8002d4a0:	d9 ff 08 00 	lea %a15,[%a15]8
8002d4a4:	df 03 0f 00 	jeq %d3,0,8002d4c2 <_vfiprintf_r+0xf6>
8002d4a8:	df 02 68 05 	jeq %d2,0,8002df78 <_vfiprintf_r+0xbac>
8002d4ac:	60 d4       	mov.a %a4,%d13
8002d4ae:	d9 a6 38 00 	lea %a6,[%sp]56
8002d4b2:	40 d5       	mov.aa %a5,%a13
8002d4b4:	f4 a3       	st.a [%sp],%a3
8002d4b6:	6d ff 4d ff 	call 8002d350 <__sprint_r.part.0>
8002d4ba:	df 02 db 81 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002d4be:	d4 a3       	ld.a %a3,[%sp]
8002d4c0:	60 cf       	mov.a %a15,%d12
8002d4c2:	99 a2 0c 00 	ld.a %a2,[%sp]12
8002d4c6:	79 32 01 00 	ld.b %d2,[%a3]1
8002d4ca:	30 e2       	add.a %a2,%a14
8002d4cc:	b5 a2 0c 00 	st.a [%sp]12,%a2
8002d4d0:	df 02 48 06 	jeq %d2,0,8002e160 <_vfiprintf_r+0xd94>
8002d4d4:	80 c2       	mov.d %d2,%a12
8002d4d6:	82 0f       	mov %d15,0
8002d4d8:	82 03       	mov %d3,0
8002d4da:	1b 12 00 40 	addi %d4,%d2,1
8002d4de:	a0 07       	mov.a %a7,0
8002d4e0:	79 c2 01 00 	ld.b %d2,[%a12]1
8002d4e4:	b0 f7       	add.a %a7,-1
8002d4e6:	91 30 00 c8 	movh.a %a12,32771
8002d4ea:	60 4e       	mov.a %a14,%d4
8002d4ec:	e9 af 35 00 	st.b [%sp]53,%d15
8002d4f0:	74 a3       	st.w [%sp],%d3
8002d4f2:	82 0a       	mov %d10,0
8002d4f4:	d9 cc 4c ad 	lea %a12,[%a12]-10612 <8002d68c <_vfiprintf_r+0x2c0>>
8002d4f8:	3b c0 06 90 	mov %d9,108
8002d4fc:	3b 80 06 80 	mov %d8,104
8002d500:	80 7b       	mov.d %d11,%a7
8002d502:	b0 1e       	add.a %a14,1
8002d504:	1b 02 fe 4f 	addi %d4,%d2,-32
8002d508:	8b b4 a5 32 	ge.u %d3,%d4,91
8002d50c:	df 03 bc 00 	jeq %d3,0,8002d684 <_vfiprintf_r+0x2b8>
8002d510:	b5 ae 08 00 	st.a [%sp]8,%a14
8002d514:	df 02 26 06 	jeq %d2,0,8002e160 <_vfiprintf_r+0xd94>
8002d518:	82 0f       	mov %d15,0
8002d51a:	82 1e       	mov %d14,1
8002d51c:	e9 a2 04 20 	st.b [%sp]132,%d2
8002d520:	e9 af 35 00 	st.b [%sp]53,%d15
8002d524:	59 ae 04 00 	st.w [%sp]4,%d14
8002d528:	d9 ae 04 20 	lea %a14,[%sp]132
8002d52c:	a0 07       	mov.a %a7,0
8002d52e:	19 a0 3c 00 	ld.w %d0,[%sp]60
8002d532:	8f 2a 00 51 	and %d5,%d10,2
8002d536:	1b 10 00 70 	addi %d7,%d0,1
8002d53a:	8f 4a 08 11 	and %d1,%d10,132
8002d53e:	19 a6 00 10 	ld.w %d6,[%sp]64
8002d542:	ab 2e 00 e5 	cadd %d14,%d5,%d14,2
8002d546:	02 74       	mov %d4,%d7
8002d548:	df 01 07 80 	jne %d1,0,8002d556 <_vfiprintf_r+0x18a>
8002d54c:	54 a2       	ld.w %d2,[%sp]
8002d54e:	0b e2 80 80 	sub %d8,%d2,%d14
8002d552:	ff 18 2c 04 	jge %d8,1,8002ddaa <_vfiprintf_r+0x9de>
8002d556:	79 a3 35 00 	ld.b %d3,[%sp]53
8002d55a:	df 03 14 00 	jeq %d3,0,8002d582 <_vfiprintf_r+0x1b6>
8002d55e:	82 17       	mov %d7,1
8002d560:	42 76       	add %d6,%d7
8002d562:	d9 a2 35 00 	lea %a2,[%sp]53
8002d566:	e8 02       	st.a [%a15]0,%a2
8002d568:	68 17       	st.w [%a15]4,%d7
8002d56a:	59 a6 00 10 	st.w [%sp]64,%d6
8002d56e:	59 a4 3c 00 	st.w [%sp]60,%d4
8002d572:	8b 84 80 32 	ge %d3,%d4,8
8002d576:	df 03 c8 83 	jne %d3,0,8002dd06 <_vfiprintf_r+0x93a>
8002d57a:	02 40       	mov %d0,%d4
8002d57c:	d9 ff 08 00 	lea %a15,[%a15]8
8002d580:	c2 14       	add %d4,1
8002d582:	df 05 2b 00 	jeq %d5,0,8002d5d8 <_vfiprintf_r+0x20c>
8002d586:	82 23       	mov %d3,2
8002d588:	42 36       	add %d6,%d3
8002d58a:	d9 a2 36 00 	lea %a2,[%sp]54
8002d58e:	68 13       	st.w [%a15]4,%d3
8002d590:	e8 02       	st.a [%a15]0,%a2
8002d592:	59 a6 00 10 	st.w [%sp]64,%d6
8002d596:	59 a4 3c 00 	st.w [%sp]60,%d4
8002d59a:	8b 84 80 32 	ge %d3,%d4,8
8002d59e:	df 03 ff 03 	jeq %d3,0,8002dd9c <_vfiprintf_r+0x9d0>
8002d5a2:	60 cf       	mov.a %a15,%d12
8002d5a4:	82 14       	mov %d4,1
8002d5a6:	82 00       	mov %d0,0
8002d5a8:	df 06 18 00 	jeq %d6,0,8002d5d8 <_vfiprintf_r+0x20c>
8002d5ac:	60 d4       	mov.a %a4,%d13
8002d5ae:	d9 a6 38 00 	lea %a6,[%sp]56
8002d5b2:	40 d5       	mov.aa %a5,%a13
8002d5b4:	b5 a7 28 00 	st.a [%sp]40,%a7
8002d5b8:	59 a1 24 00 	st.w [%sp]36,%d1
8002d5bc:	6d ff ca fe 	call 8002d350 <__sprint_r.part.0>
8002d5c0:	df 02 58 81 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002d5c4:	19 a0 3c 00 	ld.w %d0,[%sp]60
8002d5c8:	99 a7 28 00 	ld.a %a7,[%sp]40
8002d5cc:	19 a6 00 10 	ld.w %d6,[%sp]64
8002d5d0:	19 a1 24 00 	ld.w %d1,[%sp]36
8002d5d4:	1b 10 00 40 	addi %d4,%d0,1
8002d5d8:	8b 01 28 12 	ne %d1,%d1,128
8002d5dc:	df 01 c2 02 	jeq %d1,0,8002db60 <_vfiprintf_r+0x794>
8002d5e0:	19 a2 04 00 	ld.w %d2,[%sp]4
8002d5e4:	80 78       	mov.d %d8,%a7
8002d5e6:	a2 28       	sub %d8,%d2
8002d5e8:	ff 18 32 03 	jge %d8,1,8002dc4c <_vfiprintf_r+0x880>
8002d5ec:	19 a3 04 00 	ld.w %d3,[%sp]4
8002d5f0:	59 a4 3c 00 	st.w [%sp]60,%d4
8002d5f4:	42 36       	add %d6,%d3
8002d5f6:	e8 0e       	st.a [%a15]0,%a14
8002d5f8:	68 13       	st.w [%a15]4,%d3
8002d5fa:	59 a6 00 10 	st.w [%sp]64,%d6
8002d5fe:	8b 84 80 42 	ge %d4,%d4,8
8002d602:	df 04 84 02 	jeq %d4,0,8002db0a <_vfiprintf_r+0x73e>
8002d606:	df 06 34 04 	jeq %d6,0,8002de6e <_vfiprintf_r+0xaa2>
8002d60a:	60 d4       	mov.a %a4,%d13
8002d60c:	d9 a6 38 00 	lea %a6,[%sp]56
8002d610:	40 d5       	mov.aa %a5,%a13
8002d612:	6d ff 9f fe 	call 8002d350 <__sprint_r.part.0>
8002d616:	df 02 2d 81 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002d61a:	19 a6 00 10 	ld.w %d6,[%sp]64
8002d61e:	60 cf       	mov.a %a15,%d12
8002d620:	6f 2a 07 00 	jz.t %d10,2,8002d62e <_vfiprintf_r+0x262>
8002d624:	54 a2       	ld.w %d2,[%sp]
8002d626:	0b e2 80 80 	sub %d8,%d2,%d14
8002d62a:	ff 18 2c 04 	jge %d8,1,8002de82 <_vfiprintf_r+0xab6>
8002d62e:	54 a2       	ld.w %d2,[%sp]
8002d630:	0b e2 a0 e1 	max %d14,%d2,%d14
8002d634:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002d638:	42 e2       	add %d2,%d14
8002d63a:	59 a2 0c 00 	st.w [%sp]12,%d2
8002d63e:	df 06 11 81 	jne %d6,0,8002d860 <_vfiprintf_r+0x494>
8002d642:	82 02       	mov %d2,0
8002d644:	60 cf       	mov.a %a15,%d12
8002d646:	59 a2 3c 00 	st.w [%sp]60,%d2
8002d64a:	1d ff fe fe 	j 8002d446 <_vfiprintf_r+0x7a>
8002d64e:	60 d4       	mov.a %a4,%d13
8002d650:	40 f5       	mov.aa %a5,%a15
8002d652:	6d 00 c3 08 	call 8002e7d8 <__swsetup_r>
8002d656:	df 02 cb 86 	jne %d2,0,8002e3ec <_vfiprintf_r+0x1020>
8002d65a:	88 62       	ld.h %d2,[%a15]12
8002d65c:	3b a0 00 30 	mov %d3,10
8002d660:	8f a2 01 21 	and %d2,%d2,26
8002d664:	5f 32 da fe 	jne %d2,%d3,8002d418 <_vfiprintf_r+0x4c>
8002d668:	88 72       	ld.h %d2,[%a15]14
8002d66a:	bf 02 d7 7e 	jlt %d2,0,8002d418 <_vfiprintf_r+0x4c>
8002d66e:	99 a7 10 00 	ld.a %a7,[%sp]16
8002d672:	60 f6       	mov.a %a6,%d15
8002d674:	60 d4       	mov.a %a4,%d13
8002d676:	40 f5       	mov.aa %a5,%a15
8002d678:	6d 00 d6 06 	call 8002e424 <__sbprintf>
8002d67c:	59 a2 0c 00 	st.w [%sp]12,%d2
8002d680:	1d 00 fc 00 	j 8002d878 <_vfiprintf_r+0x4ac>
8002d684:	01 c4 02 26 	addsc.a %a2,%a12,%d4,2
8002d688:	dc 02       	ji %a2
8002d68a:	00 00       	nop 
8002d68c:	1d 00 22 02 	j 8002dad0 <_vfiprintf_r+0x704>
8002d690:	1d ff 40 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d694:	1d ff 3e ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d698:	1d 00 27 02 	j 8002dae6 <_vfiprintf_r+0x71a>
8002d69c:	1d ff 3a ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6a0:	1d ff 38 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6a4:	1d ff 36 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6a8:	1d 00 b8 00 	j 8002d818 <_vfiprintf_r+0x44c>
8002d6ac:	1d ff 32 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6b0:	1d ff 30 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6b4:	1d 00 1f 01 	j 8002d8f2 <_vfiprintf_r+0x526>
8002d6b8:	1d 00 ab 01 	j 8002da0e <_vfiprintf_r+0x642>
8002d6bc:	1d ff 2a ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6c0:	1d 00 26 01 	j 8002d90c <_vfiprintf_r+0x540>
8002d6c4:	1d 00 2a 01 	j 8002d918 <_vfiprintf_r+0x54c>
8002d6c8:	1d ff 24 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6cc:	1d 00 ec 01 	j 8002daa4 <_vfiprintf_r+0x6d8>
8002d6d0:	1d 00 94 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6d4:	1d 00 92 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6d8:	1d 00 90 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6dc:	1d 00 8e 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6e0:	1d 00 8c 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6e4:	1d 00 8a 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6e8:	1d 00 88 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6ec:	1d 00 86 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6f0:	1d 00 84 00 	j 8002d7f8 <_vfiprintf_r+0x42c>
8002d6f4:	1d ff 0e ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6f8:	1d ff 0c ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d6fc:	1d ff 0a ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d700:	1d ff 08 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d704:	1d ff 06 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d708:	1d ff 04 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d70c:	1d ff 02 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d710:	1d ff 00 ff 	j 8002d510 <_vfiprintf_r+0x144>
8002d714:	1d ff fe fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d718:	1d 00 d8 00 	j 8002d8c8 <_vfiprintf_r+0x4fc>
8002d71c:	1d 00 54 01 	j 8002d9c4 <_vfiprintf_r+0x5f8>
8002d720:	1d ff f8 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d724:	1d ff f6 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d728:	1d ff f4 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d72c:	1d ff f2 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d730:	1d ff f0 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d734:	1d ff ee fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d738:	1d ff ec fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d73c:	1d ff ea fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d740:	1d ff e8 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d744:	1d ff e6 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d748:	1d 00 ff 00 	j 8002d946 <_vfiprintf_r+0x57a>
8002d74c:	1d ff e2 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d750:	1d ff e0 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d754:	1d ff de fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d758:	1d 00 93 00 	j 8002d87e <_vfiprintf_r+0x4b2>
8002d75c:	1d ff da fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d760:	1d 00 a8 01 	j 8002dab0 <_vfiprintf_r+0x6e4>
8002d764:	1d ff d6 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d768:	1d ff d4 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d76c:	1d 00 d9 04 	j 8002e11e <_vfiprintf_r+0xd52>
8002d770:	1d ff d0 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d774:	1d ff ce fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d778:	1d ff cc fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d77c:	1d ff ca fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d780:	1d ff c8 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d784:	1d ff c6 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d788:	1d ff c4 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d78c:	1d ff c2 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d790:	1d ff c0 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d794:	1d ff be fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d798:	1d 00 98 00 	j 8002d8c8 <_vfiprintf_r+0x4fc>
8002d79c:	1d 00 8f 04 	j 8002e0ba <_vfiprintf_r+0xcee>
8002d7a0:	1d ff b8 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7a4:	1d ff b6 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7a8:	1d ff b4 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7ac:	1d 00 74 01 	j 8002da94 <_vfiprintf_r+0x6c8>
8002d7b0:	1d 00 85 04 	j 8002e0ba <_vfiprintf_r+0xcee>
8002d7b4:	1d 00 50 00 	j 8002d854 <_vfiprintf_r+0x488>
8002d7b8:	1d ff ac fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7bc:	1d 00 64 01 	j 8002da84 <_vfiprintf_r+0x6b8>
8002d7c0:	1d ff a8 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7c4:	1d 00 48 01 	j 8002da54 <_vfiprintf_r+0x688>
8002d7c8:	1d 00 c7 04 	j 8002e156 <_vfiprintf_r+0xd8a>
8002d7cc:	1d 00 28 01 	j 8002da1c <_vfiprintf_r+0x650>
8002d7d0:	1d 00 42 00 	j 8002d854 <_vfiprintf_r+0x488>
8002d7d4:	1d ff 9e fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7d8:	1d 00 53 00 	j 8002d87e <_vfiprintf_r+0x4b2>
8002d7dc:	1d 00 38 00 	j 8002d84c <_vfiprintf_r+0x480>
8002d7e0:	1d 00 7c 04 	j 8002e0d8 <_vfiprintf_r+0xd0c>
8002d7e4:	1d ff 96 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7e8:	1d ff 94 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7ec:	1d 00 7c 04 	j 8002e0e4 <_vfiprintf_r+0xd18>
8002d7f0:	1d ff 90 fe 	j 8002d510 <_vfiprintf_r+0x144>
8002d7f4:	1d 00 2c 00 	j 8002d84c <_vfiprintf_r+0x480>
8002d7f8:	82 03       	mov %d3,0
8002d7fa:	74 a3       	st.w [%sp],%d3
8002d7fc:	1b 02 fd 3f 	addi %d3,%d2,-48
8002d800:	54 a2       	ld.w %d2,[%sp]
8002d802:	13 a2 20 23 	madd %d2,%d3,%d2,10
8002d806:	74 a2       	st.w [%sp],%d2
8002d808:	09 e2 01 00 	ld.b %d2,[%a14+]1
8002d80c:	1b 02 fd 3f 	addi %d3,%d2,-48
8002d810:	bf a3 f8 ff 	jlt.u %d3,10,8002d800 <_vfiprintf_r+0x434>
8002d814:	1d ff 78 fe 	j 8002d504 <_vfiprintf_r+0x138>
8002d818:	60 d4       	mov.a %a4,%d13
8002d81a:	6d ff 93 ec 	call 8002b140 <_localeconv_r>
8002d81e:	19 22 04 00 	ld.w %d2,[%a2]4
8002d822:	59 a2 1c 00 	st.w [%sp]28,%d2
8002d826:	60 24       	mov.a %a4,%d2
8002d828:	6d ff 0b d7 	call 8002863e <strlen>
8002d82c:	60 d4       	mov.a %a4,%d13
8002d82e:	02 2e       	mov %d14,%d2
8002d830:	59 a2 20 00 	st.w [%sp]32,%d2
8002d834:	6d ff 86 ec 	call 8002b140 <_localeconv_r>
8002d838:	19 23 08 00 	ld.w %d3,[%a2]8
8002d83c:	59 a3 18 00 	st.w [%sp]24,%d3
8002d840:	8b 03 20 22 	ne %d2,%d3,0
8002d844:	8b 0e 20 24 	and.ne %d2,%d14,0
8002d848:	df 02 22 84 	jne %d2,0,8002e08c <_vfiprintf_r+0xcc0>
8002d84c:	79 e2 00 00 	ld.b %d2,[%a14]0
8002d850:	1d ff 59 fe 	j 8002d502 <_vfiprintf_r+0x136>
8002d854:	79 e2 00 00 	ld.b %d2,[%a14]0
8002d858:	8f 0a 42 a1 	or %d10,%d10,32
8002d85c:	1d ff 53 fe 	j 8002d502 <_vfiprintf_r+0x136>
8002d860:	60 d4       	mov.a %a4,%d13
8002d862:	d9 a6 38 00 	lea %a6,[%sp]56
8002d866:	40 d5       	mov.aa %a5,%a13
8002d868:	6d ff 74 fd 	call 8002d350 <__sprint_r.part.0>
8002d86c:	df 02 eb 7e 	jeq %d2,0,8002d642 <_vfiprintf_r+0x276>
8002d870:	40 df       	mov.aa %a15,%a13
8002d872:	88 63       	ld.h %d3,[%a15]12
8002d874:	6f 63 bc 85 	jnz.t %d3,6,8002e3ec <_vfiprintf_r+0x1020>
8002d878:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002d87c:	00 90       	ret 
8002d87e:	99 ac 10 00 	ld.a %a12,[%sp]16
8002d882:	82 0f       	mov %d15,0
8002d884:	b5 ae 08 00 	st.a [%sp]8,%a14
8002d888:	40 c2       	mov.aa %a2,%a12
8002d88a:	d4 2e       	ld.a %a14,[%a2]
8002d88c:	e9 af 35 00 	st.b [%sp]53,%d15
8002d890:	b0 4c       	add.a %a12,4
8002d892:	bd 0e 49 05 	jz.a %a14,8002e324 <_vfiprintf_r+0xf58>
8002d896:	df fb 17 04 	jeq %d11,-1,8002e0c4 <_vfiprintf_r+0xcf8>
8002d89a:	82 04       	mov %d4,0
8002d89c:	02 b5       	mov %d5,%d11
8002d89e:	40 e4       	mov.aa %a4,%a14
8002d8a0:	59 ab 04 00 	st.w [%sp]4,%d11
8002d8a4:	6d ff ea eb 	call 8002b078 <memchr>
8002d8a8:	99 a7 04 00 	ld.a %a7,[%sp]4
8002d8ac:	80 23       	mov.d %d3,%a2
8002d8ae:	80 e4       	mov.d %d4,%a14
8002d8b0:	80 72       	mov.d %d2,%a7
8002d8b2:	0b 43 80 40 	sub %d4,%d3,%d4
8002d8b6:	2b 24 40 23 	sel %d2,%d3,%d4,%d2
8002d8ba:	b5 ac 10 00 	st.a [%sp]16,%a12
8002d8be:	a0 07       	mov.a %a7,0
8002d8c0:	59 a2 04 00 	st.w [%sp]4,%d2
8002d8c4:	1d 00 75 00 	j 8002d9ae <_vfiprintf_r+0x5e2>
8002d8c8:	99 a2 10 00 	ld.a %a2,[%sp]16
8002d8cc:	82 0f       	mov %d15,0
8002d8ce:	82 1e       	mov %d14,1
8002d8d0:	40 23       	mov.aa %a3,%a2
8002d8d2:	54 32       	ld.w %d2,[%a3]
8002d8d4:	b0 42       	add.a %a2,4
8002d8d6:	b5 ae 08 00 	st.a [%sp]8,%a14
8002d8da:	e9 a2 04 20 	st.b [%sp]132,%d2
8002d8de:	e9 af 35 00 	st.b [%sp]53,%d15
8002d8e2:	b5 a2 10 00 	st.a [%sp]16,%a2
8002d8e6:	59 ae 04 00 	st.w [%sp]4,%d14
8002d8ea:	d9 ae 04 20 	lea %a14,[%sp]132
8002d8ee:	1d ff 1f fe 	j 8002d52c <_vfiprintf_r+0x160>
8002d8f2:	99 a2 10 00 	ld.a %a2,[%sp]16
8002d8f6:	40 23       	mov.aa %a3,%a2
8002d8f8:	54 32       	ld.w %d2,[%a3]
8002d8fa:	74 a2       	st.w [%sp],%d2
8002d8fc:	b0 42       	add.a %a2,4
8002d8fe:	ff 02 a4 03 	jge %d2,0,8002e046 <_vfiprintf_r+0xc7a>
8002d902:	54 a2       	ld.w %d2,[%sp]
8002d904:	b5 a2 10 00 	st.a [%sp]16,%a2
8002d908:	32 52       	rsub %d2
8002d90a:	74 a2       	st.w [%sp],%d2
8002d90c:	79 e2 00 00 	ld.b %d2,[%a14]0
8002d910:	8f 4a 40 a1 	or %d10,%d10,4
8002d914:	1d ff f7 fd 	j 8002d502 <_vfiprintf_r+0x136>
8002d918:	40 e2       	mov.aa %a2,%a14
8002d91a:	09 22 01 00 	ld.b %d2,[%a2+]1
8002d91e:	8b a2 02 32 	eq %d3,%d2,42
8002d922:	df 03 72 85 	jne %d3,0,8002e406 <_vfiprintf_r+0x103a>
8002d926:	1b 02 fd 3f 	addi %d3,%d2,-48
8002d92a:	40 2e       	mov.aa %a14,%a2
8002d92c:	82 0b       	mov %d11,0
8002d92e:	ff a3 eb fd 	jge.u %d3,10,8002d504 <_vfiprintf_r+0x138>
8002d932:	09 e2 01 00 	ld.b %d2,[%a14+]1
8002d936:	13 ab 20 b3 	madd %d11,%d3,%d11,10
8002d93a:	1b 02 fd 3f 	addi %d3,%d2,-48
8002d93e:	bf a3 fa ff 	jlt.u %d3,10,8002d932 <_vfiprintf_r+0x566>
8002d942:	1d ff e1 fd 	j 8002d504 <_vfiprintf_r+0x138>
8002d946:	60 b7       	mov.a %a7,%d11
8002d948:	b5 ae 08 00 	st.a [%sp]8,%a14
8002d94c:	8f 0a 41 a1 	or %d10,%d10,16
8002d950:	99 a2 10 00 	ld.a %a2,[%sp]16
8002d954:	6f 5a 50 03 	jz.t %d10,5,8002dff4 <_vfiprintf_r+0xc28>
8002d958:	09 26 48 01 	ld.d %e6,[%a2+]8
8002d95c:	b5 a2 10 00 	st.a [%sp]16,%a2
8002d960:	b7 0a 01 e5 	insert %d14,%d10,0,10,1
8002d964:	82 03       	mov %d3,0
8002d966:	82 02       	mov %d2,0
8002d968:	e9 a2 35 00 	st.b [%sp]53,%d2
8002d96c:	80 72       	mov.d %d2,%a7
8002d96e:	df f2 d3 00 	jeq %d2,-1,8002db14 <_vfiprintf_r+0x748>
8002d972:	0f 76 a0 40 	or %d4,%d6,%d7
8002d976:	80 75       	mov.d %d5,%a7
8002d978:	8b 04 20 22 	ne %d2,%d4,0
8002d97c:	8b 05 00 25 	or.ne %d2,%d5,0
8002d980:	8f 0e c8 a1 	andn %d10,%d14,128
8002d984:	df 02 c7 80 	jne %d2,0,8002db12 <_vfiprintf_r+0x746>
8002d988:	82 02       	mov %d2,0
8002d98a:	a0 07       	mov.a %a7,0
8002d98c:	d9 ae 28 30 	lea %a14,[%sp]232
8002d990:	59 a2 04 00 	st.w [%sp]4,%d2
8002d994:	df 03 0d 80 	jne %d3,0,8002d9ae <_vfiprintf_r+0x5e2>
8002d998:	8f 1e 00 21 	and %d2,%d14,1
8002d99c:	59 a2 04 00 	st.w [%sp]4,%d2
8002d9a0:	6f 0e 07 00 	jz.t %d14,0,8002d9ae <_vfiprintf_r+0x5e2>
8002d9a4:	da 30       	mov %d15,48
8002d9a6:	d9 ae 27 30 	lea %a14,[%sp]231
8002d9aa:	e9 af 27 30 	st.b [%sp]231,%d15
8002d9ae:	19 a3 04 00 	ld.w %d3,[%sp]4
8002d9b2:	80 72       	mov.d %d2,%a7
8002d9b4:	0b 32 a0 e1 	max %d14,%d2,%d3
8002d9b8:	79 a3 35 00 	ld.b %d3,[%sp]53
8002d9bc:	ab 1e 00 e3 	cadd %d14,%d3,%d14,1
8002d9c0:	1d ff b7 fd 	j 8002d52e <_vfiprintf_r+0x162>
8002d9c4:	60 b7       	mov.a %a7,%d11
8002d9c6:	b5 ae 08 00 	st.a [%sp]8,%a14
8002d9ca:	8f 0a 41 a1 	or %d10,%d10,16
8002d9ce:	99 a2 10 00 	ld.a %a2,[%sp]16
8002d9d2:	6f 5a e8 02 	jz.t %d10,5,8002dfa2 <_vfiprintf_r+0xbd6>
8002d9d6:	09 22 48 01 	ld.d %e2,[%a2+]8
8002d9da:	0b 23 10 68 	mov %e6,%d3,%d2
8002d9de:	b5 a2 10 00 	st.a [%sp]16,%a2
8002d9e2:	bf 03 f1 02 	jlt %d3,0,8002dfc4 <_vfiprintf_r+0xbf8>
8002d9e6:	80 72       	mov.d %d2,%a7
8002d9e8:	df f2 ae 02 	jeq %d2,-1,8002df44 <_vfiprintf_r+0xb78>
8002d9ec:	0f 76 a0 30 	or %d3,%d6,%d7
8002d9f0:	8b 02 20 22 	ne %d2,%d2,0
8002d9f4:	8b 03 00 25 	or.ne %d2,%d3,0
8002d9f8:	8f 0a c8 a1 	andn %d10,%d10,128
8002d9fc:	df 02 a4 82 	jne %d2,0,8002df44 <_vfiprintf_r+0xb78>
8002da00:	a0 07       	mov.a %a7,0
8002da02:	59 a2 04 00 	st.w [%sp]4,%d2
8002da06:	d9 ae 28 30 	lea %a14,[%sp]232
8002da0a:	1d ff d2 ff 	j 8002d9ae <_vfiprintf_r+0x5e2>
8002da0e:	da 2b       	mov %d15,43
8002da10:	79 e2 00 00 	ld.b %d2,[%a14]0
8002da14:	e9 af 35 00 	st.b [%sp]53,%d15
8002da18:	1d ff 75 fd 	j 8002d502 <_vfiprintf_r+0x136>
8002da1c:	99 a2 10 00 	ld.a %a2,[%sp]16
8002da20:	da 30       	mov %d15,48
8002da22:	60 b7       	mov.a %a7,%d11
8002da24:	40 23       	mov.aa %a3,%a2
8002da26:	e9 af 36 00 	st.b [%sp]54,%d15
8002da2a:	b0 42       	add.a %a2,4
8002da2c:	da 78       	mov %d15,120
8002da2e:	b5 a2 10 00 	st.a [%sp]16,%a2
8002da32:	91 00 00 28 	movh.a %a2,32768
8002da36:	d9 22 22 04 	lea %a2,[%a2]16418 <80004022 <__mprec_tens+0x116>>
8002da3a:	54 36       	ld.w %d6,[%a3]
8002da3c:	b5 ae 08 00 	st.a [%sp]8 <80004022 <__mprec_tens+0x116>>,%a14
8002da40:	82 07       	mov %d7,0
8002da42:	8f 2a 40 e1 	or %d14,%d10,2
8002da46:	e9 af 37 00 	st.b [%sp]55,%d15
8002da4a:	b5 a2 14 00 	st.a [%sp]20,%a2
8002da4e:	82 23       	mov %d3,2
8002da50:	1d ff 8b ff 	j 8002d966 <_vfiprintf_r+0x59a>
8002da54:	99 a3 10 00 	ld.a %a3,[%sp]16
8002da58:	b5 ae 08 00 	st.a [%sp]8,%a14
8002da5c:	d9 32 04 00 	lea %a2,[%a3]4
8002da60:	6f 5a 22 83 	jnz.t %d10,5,8002e0a4 <_vfiprintf_r+0xcd8>
8002da64:	6f 4a 56 84 	jnz.t %d10,4,8002e310 <_vfiprintf_r+0xf44>
8002da68:	6f 6a 88 84 	jnz.t %d10,6,8002e378 <_vfiprintf_r+0xfac>
8002da6c:	6f 9a 52 04 	jz.t %d10,9,8002e310 <_vfiprintf_r+0xf44>
8002da70:	99 a3 10 00 	ld.a %a3,[%sp]16
8002da74:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002da78:	b5 a2 10 00 	st.a [%sp]16,%a2
8002da7c:	d4 33       	ld.a %a3,[%a3]
8002da7e:	34 32       	st.b [%a3],%d2
8002da80:	1d ff e3 fc 	j 8002d446 <_vfiprintf_r+0x7a>
8002da84:	79 e2 00 00 	ld.b %d2,[%a14]0
8002da88:	5f 92 3d 04 	jeq %d2,%d9,8002e302 <_vfiprintf_r+0xf36>
8002da8c:	8f 0a 41 a1 	or %d10,%d10,16
8002da90:	1d ff 39 fd 	j 8002d502 <_vfiprintf_r+0x136>
8002da94:	79 e2 00 00 	ld.b %d2,[%a14]0
8002da98:	5f 82 2e 04 	jeq %d2,%d8,8002e2f4 <_vfiprintf_r+0xf28>
8002da9c:	8f 0a 44 a1 	or %d10,%d10,64
8002daa0:	1d ff 31 fd 	j 8002d502 <_vfiprintf_r+0x136>
8002daa4:	79 e2 00 00 	ld.b %d2,[%a14]0
8002daa8:	8f 0a 48 a1 	or %d10,%d10,128
8002daac:	1d ff 2b fd 	j 8002d502 <_vfiprintf_r+0x136>
8002dab0:	60 b7       	mov.a %a7,%d11
8002dab2:	b5 ae 08 00 	st.a [%sp]8,%a14
8002dab6:	8f 0a 41 e1 	or %d14,%d10,16
8002daba:	99 a2 10 00 	ld.a %a2,[%sp]16
8002dabe:	6f 5e 62 02 	jz.t %d14,5,8002df82 <_vfiprintf_r+0xbb6>
8002dac2:	09 26 48 01 	ld.d %e6,[%a2+]8
8002dac6:	82 13       	mov %d3,1
8002dac8:	b5 a2 10 00 	st.a [%sp]16,%a2
8002dacc:	1d ff 4d ff 	j 8002d966 <_vfiprintf_r+0x59a>
8002dad0:	79 a3 35 00 	ld.b %d3,[%sp]53
8002dad4:	79 e2 00 00 	ld.b %d2,[%a14]0
8002dad8:	df 03 15 fd 	jne %d3,0,8002d502 <_vfiprintf_r+0x136>
8002dadc:	da 20       	mov %d15,32
8002dade:	e9 af 35 00 	st.b [%sp]53,%d15
8002dae2:	1d ff 10 fd 	j 8002d502 <_vfiprintf_r+0x136>
8002dae6:	79 e2 00 00 	ld.b %d2,[%a14]0
8002daea:	8f 1a 40 a1 	or %d10,%d10,1
8002daee:	1d ff 0a fd 	j 8002d502 <_vfiprintf_r+0x136>
8002daf2:	82 13       	mov %d3,1
8002daf4:	19 a6 04 00 	ld.w %d6,[%sp]4
8002daf8:	60 cf       	mov.a %a15,%d12
8002dafa:	b5 ae 04 10 	st.a [%sp]68,%a14
8002dafe:	59 a6 08 10 	st.w [%sp]72,%d6
8002db02:	59 a6 00 10 	st.w [%sp]64,%d6
8002db06:	59 a3 3c 00 	st.w [%sp]60,%d3
8002db0a:	d9 ff 08 00 	lea %a15,[%a15]8
8002db0e:	1d ff 89 fd 	j 8002d620 <_vfiprintf_r+0x254>
8002db12:	02 ae       	mov %d14,%d10
8002db14:	df 13 19 02 	jeq %d3,1,8002df46 <_vfiprintf_r+0xb7a>
8002db18:	d9 ae 28 30 	lea %a14,[%sp]232
8002db1c:	df 23 8c 01 	jeq %d3,2,8002de34 <_vfiprintf_r+0xa68>
8002db20:	58 02       	ld.w %d15,[%sp]8
8002db22:	8f 76 00 31 	and %d3,%d6,7
8002db26:	1b 03 03 30 	addi %d3,%d3,48
8002db2a:	77 67 80 6e 	dextr %d6,%d7,%d6,29
8002db2e:	06 d7       	sh %d7,-3
8002db30:	8b 06 20 22 	ne %d2,%d6,0
8002db34:	40 e2       	mov.aa %a2,%a14
8002db36:	8b 07 00 25 	or.ne %d2,%d7,0
8002db3a:	89 e3 3f f4 	st.b [+%a14]-1,%d3
8002db3e:	df 02 f2 ff 	jne %d2,0,8002db22 <_vfiprintf_r+0x756>
8002db42:	8b 03 23 22 	ne %d2,%d3,48
8002db46:	78 02       	st.w [%sp]8,%d15
8002db48:	26 e2       	and %d2,%d14
8002db4a:	df 02 30 83 	jne %d2,0,8002e1aa <_vfiprintf_r+0xdde>
8002db4e:	d9 a2 28 30 	lea %a2,[%sp]232
8002db52:	01 e2 20 20 	sub.a %a2,%a2,%a14
8002db56:	b5 a2 04 00 	st.a [%sp]4,%a2
8002db5a:	02 ea       	mov %d10,%d14
8002db5c:	1d ff 29 ff 	j 8002d9ae <_vfiprintf_r+0x5e2>
8002db60:	54 a2       	ld.w %d2,[%sp]
8002db62:	0b e2 80 80 	sub %d8,%d2,%d14
8002db66:	bf 18 3d 7d 	jlt %d8,1,8002d5e0 <_vfiprintf_r+0x214>
8002db6a:	8b 18 41 32 	lt %d3,%d8,17
8002db6e:	df 03 44 84 	jne %d3,0,8002e3f6 <_vfiprintf_r+0x102a>
8002db72:	1b f8 fe 3f 	addi %d3,%d8,-17
8002db76:	8f f3 60 31 	nor %d3,%d3,15
8002db7a:	91 00 00 c8 	movh.a %a12,32768
8002db7e:	02 ef       	mov %d15,%d14
8002db80:	0b 83 00 90 	add %d9,%d3,%d8
8002db84:	d9 cc 3a 04 	lea %a12,[%a12]16442 <8000403a <zeroes.0>>
8002db88:	3b 00 01 b0 	mov %d11,16
8002db8c:	80 7e       	mov.d %d14,%a7
8002db8e:	1d 00 0b 00 	j 8002dba4 <_vfiprintf_r+0x7d8>
8002db92:	1b 20 00 20 	addi %d2,%d0,2
8002db96:	d9 ff 08 00 	lea %a15,[%a15]8
8002db9a:	02 30       	mov %d0,%d3
8002db9c:	1b 08 ff 8f 	addi %d8,%d8,-16
8002dba0:	5f 89 27 00 	jeq %d9,%d8,8002dbee <_vfiprintf_r+0x822>
8002dba4:	1b 10 00 30 	addi %d3,%d0,1
8002dba8:	1b 06 01 60 	addi %d6,%d6,16
8002dbac:	e8 0c       	st.a [%a15]0,%a12
8002dbae:	68 1b       	st.w [%a15]4,%d11
8002dbb0:	59 a6 00 10 	st.w [%sp]64,%d6
8002dbb4:	59 a3 3c 00 	st.w [%sp]60,%d3
8002dbb8:	8b 83 80 22 	ge %d2,%d3,8
8002dbbc:	df 02 eb 7f 	jeq %d2,0,8002db92 <_vfiprintf_r+0x7c6>
8002dbc0:	60 cf       	mov.a %a15,%d12
8002dbc2:	82 12       	mov %d2,1
8002dbc4:	82 00       	mov %d0,0
8002dbc6:	df 06 eb 7f 	jeq %d6,0,8002db9c <_vfiprintf_r+0x7d0>
8002dbca:	60 d4       	mov.a %a4,%d13
8002dbcc:	d9 a6 38 00 	lea %a6,[%sp]56
8002dbd0:	40 d5       	mov.aa %a5,%a13
8002dbd2:	6d ff bf fb 	call 8002d350 <__sprint_r.part.0>
8002dbd6:	df 02 4d fe 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002dbda:	19 a0 3c 00 	ld.w %d0,[%sp]60
8002dbde:	1b 08 ff 8f 	addi %d8,%d8,-16
8002dbe2:	19 a6 00 10 	ld.w %d6,[%sp]64
8002dbe6:	1b 10 00 20 	addi %d2,%d0,1
8002dbea:	5f 89 dd ff 	jne %d9,%d8,8002dba4 <_vfiprintf_r+0x7d8>
8002dbee:	60 e7       	mov.a %a7,%d14
8002dbf0:	02 fe       	mov %d14,%d15
8002dbf2:	42 96       	add %d6,%d9
8002dbf4:	e8 0c       	st.a [%a15]0,%a12
8002dbf6:	68 19       	st.w [%a15]4,%d9
8002dbf8:	59 a6 00 10 	st.w [%sp]64,%d6
8002dbfc:	59 a2 3c 00 	st.w [%sp]60,%d2
8002dc00:	8b 82 80 32 	ge %d3,%d2,8
8002dc04:	d9 ff 08 00 	lea %a15,[%a15]8
8002dc08:	1b 12 00 40 	addi %d4,%d2,1
8002dc0c:	02 20       	mov %d0,%d2
8002dc0e:	df 03 e9 7c 	jeq %d3,0,8002d5e0 <_vfiprintf_r+0x214>
8002dc12:	60 cf       	mov.a %a15,%d12
8002dc14:	82 14       	mov %d4,1
8002dc16:	82 00       	mov %d0,0
8002dc18:	df 06 e4 7c 	jeq %d6,0,8002d5e0 <_vfiprintf_r+0x214>
8002dc1c:	60 d4       	mov.a %a4,%d13
8002dc1e:	d9 a6 38 00 	lea %a6,[%sp]56
8002dc22:	40 d5       	mov.aa %a5,%a13
8002dc24:	b5 a7 24 00 	st.a [%sp]36,%a7
8002dc28:	6d ff 94 fb 	call 8002d350 <__sprint_r.part.0>
8002dc2c:	df 02 22 fe 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002dc30:	99 a7 24 00 	ld.a %a7,[%sp]36
8002dc34:	19 a2 04 00 	ld.w %d2,[%sp]4
8002dc38:	19 a0 3c 00 	ld.w %d0,[%sp]60
8002dc3c:	80 78       	mov.d %d8,%a7
8002dc3e:	a2 28       	sub %d8,%d2
8002dc40:	19 a6 00 10 	ld.w %d6,[%sp]64
8002dc44:	1b 10 00 40 	addi %d4,%d0,1
8002dc48:	bf 18 d2 7c 	jlt %d8,1,8002d5ec <_vfiprintf_r+0x220>
8002dc4c:	8b 18 41 32 	lt %d3,%d8,17
8002dc50:	df 03 82 83 	jne %d3,0,8002e354 <_vfiprintf_r+0xf88>
8002dc54:	1b f8 fe 3f 	addi %d3,%d8,-17
8002dc58:	8f f3 60 31 	nor %d3,%d3,15
8002dc5c:	91 00 00 c8 	movh.a %a12,32768
8002dc60:	58 02       	ld.w %d15,[%sp]8
8002dc62:	0b 83 00 90 	add %d9,%d3,%d8
8002dc66:	d9 cc 3a 04 	lea %a12,[%a12]16442 <8000403a <zeroes.0>>
8002dc6a:	3b 00 01 b0 	mov %d11,16
8002dc6e:	1b 10 00 30 	addi %d3,%d0,1
8002dc72:	1b 06 01 60 	addi %d6,%d6,16
8002dc76:	e8 0c       	st.a [%a15]0,%a12
8002dc78:	68 1b       	st.w [%a15]4,%d11
8002dc7a:	59 a6 00 10 	st.w [%sp]64,%d6
8002dc7e:	59 a3 3c 00 	st.w [%sp]60,%d3
8002dc82:	8b 83 80 22 	ge %d2,%d3,8
8002dc86:	1b 20 00 40 	addi %d4,%d0,2
8002dc8a:	d9 ff 08 00 	lea %a15,[%a15]8
8002dc8e:	02 30       	mov %d0,%d3
8002dc90:	df 02 15 00 	jeq %d2,0,8002dcba <_vfiprintf_r+0x8ee>
8002dc94:	60 cf       	mov.a %a15,%d12
8002dc96:	82 14       	mov %d4,1
8002dc98:	82 00       	mov %d0,0
8002dc9a:	df 06 10 00 	jeq %d6,0,8002dcba <_vfiprintf_r+0x8ee>
8002dc9e:	60 d4       	mov.a %a4,%d13
8002dca0:	d9 a6 38 00 	lea %a6,[%sp]56
8002dca4:	40 d5       	mov.aa %a5,%a13
8002dca6:	6d ff 55 fb 	call 8002d350 <__sprint_r.part.0>
8002dcaa:	df 02 e3 fd 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002dcae:	19 a0 3c 00 	ld.w %d0,[%sp]60
8002dcb2:	19 a6 00 10 	ld.w %d6,[%sp]64
8002dcb6:	1b 10 00 40 	addi %d4,%d0,1
8002dcba:	1b 08 ff 8f 	addi %d8,%d8,-16
8002dcbe:	5f 89 d8 ff 	jne %d9,%d8,8002dc6e <_vfiprintf_r+0x8a2>
8002dcc2:	78 02       	st.w [%sp]8,%d15
8002dcc4:	42 96       	add %d6,%d9
8002dcc6:	e8 0c       	st.a [%a15]0,%a12
8002dcc8:	68 19       	st.w [%a15]4,%d9
8002dcca:	59 a4 3c 00 	st.w [%sp]60,%d4
8002dcce:	8b 84 80 32 	ge %d3,%d4,8
8002dcd2:	59 a6 00 10 	st.w [%sp]64,%d6
8002dcd6:	d9 ff 08 00 	lea %a15,[%a15]8
8002dcda:	c2 14       	add %d4,1
8002dcdc:	df 03 88 7c 	jeq %d3,0,8002d5ec <_vfiprintf_r+0x220>
8002dce0:	df 06 09 7f 	jeq %d6,0,8002daf2 <_vfiprintf_r+0x726>
8002dce4:	60 d4       	mov.a %a4,%d13
8002dce6:	d9 a6 38 00 	lea %a6,[%sp]56
8002dcea:	40 d5       	mov.aa %a5,%a13
8002dcec:	6d ff 32 fb 	call 8002d350 <__sprint_r.part.0>
8002dcf0:	df 02 c0 fd 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002dcf4:	19 a2 3c 00 	ld.w %d2,[%sp]60
8002dcf8:	19 a6 00 10 	ld.w %d6,[%sp]64
8002dcfc:	60 cf       	mov.a %a15,%d12
8002dcfe:	1b 12 00 40 	addi %d4,%d2,1
8002dd02:	1d ff 75 fc 	j 8002d5ec <_vfiprintf_r+0x220>
8002dd06:	df 06 90 01 	jeq %d6,0,8002e026 <_vfiprintf_r+0xc5a>
8002dd0a:	60 d4       	mov.a %a4,%d13
8002dd0c:	d9 a6 38 00 	lea %a6,[%sp]56
8002dd10:	40 d5       	mov.aa %a5,%a13
8002dd12:	b5 a7 2c 00 	st.a [%sp]44,%a7
8002dd16:	59 a1 28 00 	st.w [%sp]40,%d1
8002dd1a:	59 a5 24 00 	st.w [%sp]36,%d5
8002dd1e:	6d ff 19 fb 	call 8002d350 <__sprint_r.part.0>
8002dd22:	df 02 a7 fd 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002dd26:	19 a0 3c 00 	ld.w %d0,[%sp]60
8002dd2a:	99 a7 2c 00 	ld.a %a7,[%sp]44
8002dd2e:	19 a6 00 10 	ld.w %d6,[%sp]64
8002dd32:	60 cf       	mov.a %a15,%d12
8002dd34:	19 a1 28 00 	ld.w %d1,[%sp]40
8002dd38:	19 a5 24 00 	ld.w %d5,[%sp]36
8002dd3c:	1b 10 00 40 	addi %d4,%d0,1
8002dd40:	1d ff 21 fc 	j 8002d582 <_vfiprintf_r+0x1b6>
8002dd44:	99 a7 24 00 	ld.a %a7,[%sp]36
8002dd48:	02 e1       	mov %d1,%d14
8002dd4a:	19 ae 28 00 	ld.w %d14,[%sp]40
8002dd4e:	02 a5       	mov %d5,%d10
8002dd50:	02 fa       	mov %d10,%d15
8002dd52:	42 96       	add %d6,%d9
8002dd54:	e8 0c       	st.a [%a15]0,%a12
8002dd56:	68 19       	st.w [%a15]4,%d9
8002dd58:	59 a6 00 10 	st.w [%sp]64,%d6
8002dd5c:	59 a2 3c 00 	st.w [%sp]60,%d2
8002dd60:	8b 82 80 32 	ge %d3,%d2,8
8002dd64:	d9 ff 08 00 	lea %a15,[%a15]8
8002dd68:	1b 12 00 40 	addi %d4,%d2,1
8002dd6c:	02 20       	mov %d0,%d2
8002dd6e:	df 03 f4 7b 	jeq %d3,0,8002d556 <_vfiprintf_r+0x18a>
8002dd72:	df 06 70 81 	jne %d6,0,8002e052 <_vfiprintf_r+0xc86>
8002dd76:	79 a2 35 00 	ld.b %d2,[%sp]53
8002dd7a:	df 02 f4 82 	jne %d2,0,8002e362 <_vfiprintf_r+0xf96>
8002dd7e:	60 cf       	mov.a %a15,%d12
8002dd80:	82 00       	mov %d0,0
8002dd82:	82 14       	mov %d4,1
8002dd84:	df 05 2e 7c 	jeq %d5,0,8002d5e0 <_vfiprintf_r+0x214>
8002dd88:	82 22       	mov %d2,2
8002dd8a:	d9 a2 36 00 	lea %a2,[%sp]54
8002dd8e:	60 cf       	mov.a %a15,%d12
8002dd90:	b5 a2 04 10 	st.a [%sp]68,%a2
8002dd94:	59 a2 08 10 	st.w [%sp]72,%d2
8002dd98:	82 14       	mov %d4,1
8002dd9a:	02 26       	mov %d6,%d2
8002dd9c:	02 40       	mov %d0,%d4
8002dd9e:	d9 ff 08 00 	lea %a15,[%a15]8
8002dda2:	1b 10 00 40 	addi %d4,%d0,1
8002dda6:	1d ff 19 fc 	j 8002d5d8 <_vfiprintf_r+0x20c>
8002ddaa:	8b 18 41 32 	lt %d3,%d8,17
8002ddae:	df 03 0e 83 	jne %d3,0,8002e3ca <_vfiprintf_r+0xffe>
8002ddb2:	1b f8 fe 3f 	addi %d3,%d8,-17
8002ddb6:	8f f3 60 31 	nor %d3,%d3,15
8002ddba:	91 00 00 c8 	movh.a %a12,32768
8002ddbe:	59 ae 28 00 	st.w [%sp]40,%d14
8002ddc2:	0b 83 00 90 	add %d9,%d3,%d8
8002ddc6:	0b 1a 10 e8 	mov %e14,%d10,%d1
8002ddca:	d9 cc 0a 14 	lea %a12,[%a12]16458 <8000404a <blanks.1>>
8002ddce:	3b 00 01 b0 	mov %d11,16
8002ddd2:	b5 a7 24 00 	st.a [%sp]36,%a7
8002ddd6:	02 5a       	mov %d10,%d5
8002ddd8:	1d 00 0d 00 	j 8002ddf2 <_vfiprintf_r+0xa26>
8002dddc:	1b 20 00 20 	addi %d2,%d0,2
8002dde0:	d9 ff 08 00 	lea %a15,[%a15]8
8002dde4:	02 70       	mov %d0,%d7
8002dde6:	1b 08 ff 8f 	addi %d8,%d8,-16
8002ddea:	5f 89 ad 7f 	jeq %d9,%d8,8002dd44 <_vfiprintf_r+0x978>
8002ddee:	1b 10 00 70 	addi %d7,%d0,1
8002ddf2:	1b 06 01 60 	addi %d6,%d6,16
8002ddf6:	e8 0c       	st.a [%a15]0,%a12
8002ddf8:	68 1b       	st.w [%a15]4,%d11
8002ddfa:	59 a6 00 10 	st.w [%sp]64,%d6
8002ddfe:	59 a7 3c 00 	st.w [%sp]60,%d7
8002de02:	8b 87 80 22 	ge %d2,%d7,8
8002de06:	df 02 eb 7f 	jeq %d2,0,8002dddc <_vfiprintf_r+0xa10>
8002de0a:	60 cf       	mov.a %a15,%d12
8002de0c:	82 00       	mov %d0,0
8002de0e:	82 12       	mov %d2,1
8002de10:	df 06 eb 7f 	jeq %d6,0,8002dde6 <_vfiprintf_r+0xa1a>
8002de14:	60 d4       	mov.a %a4,%d13
8002de16:	d9 a6 38 00 	lea %a6,[%sp]56
8002de1a:	40 d5       	mov.aa %a5,%a13
8002de1c:	6d ff 9a fa 	call 8002d350 <__sprint_r.part.0>
8002de20:	df 02 28 fd 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002de24:	19 a0 3c 00 	ld.w %d0,[%sp]60
8002de28:	19 a6 00 10 	ld.w %d6,[%sp]64
8002de2c:	1b 10 00 20 	addi %d2,%d0,1
8002de30:	1d ff db ff 	j 8002dde6 <_vfiprintf_r+0xa1a>
8002de34:	99 a3 14 00 	ld.a %a3,[%sp]20
8002de38:	58 02       	ld.w %d15,[%sp]8
8002de3a:	8f f6 00 21 	and %d2,%d6,15
8002de3e:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
8002de42:	77 67 00 6e 	dextr %d6,%d7,%d6,28
8002de46:	14 22       	ld.bu %d2,[%a2]
8002de48:	89 e2 3f f4 	st.b [+%a14]-1,%d2
8002de4c:	06 c7       	sh %d7,-4
8002de4e:	8b 06 20 22 	ne %d2,%d6,0
8002de52:	8b 07 00 25 	or.ne %d2,%d7,0
8002de56:	df 02 f2 ff 	jne %d2,0,8002de3a <_vfiprintf_r+0xa6e>
8002de5a:	d9 a2 28 30 	lea %a2,[%sp]232
8002de5e:	01 e2 20 20 	sub.a %a2,%a2,%a14
8002de62:	78 02       	st.w [%sp]8,%d15
8002de64:	b5 a2 04 00 	st.a [%sp]4,%a2
8002de68:	02 ea       	mov %d10,%d14
8002de6a:	1d ff a2 fd 	j 8002d9ae <_vfiprintf_r+0x5e2>
8002de6e:	59 a6 3c 00 	st.w [%sp]60,%d6
8002de72:	6f 2a 5f 00 	jz.t %d10,2,8002df30 <_vfiprintf_r+0xb64>
8002de76:	54 a2       	ld.w %d2,[%sp]
8002de78:	0b e2 80 80 	sub %d8,%d2,%d14
8002de7c:	bf 18 5a 00 	jlt %d8,1,8002df30 <_vfiprintf_r+0xb64>
8002de80:	60 cf       	mov.a %a15,%d12
8002de82:	8b 18 41 32 	lt %d3,%d8,17
8002de86:	19 a4 3c 00 	ld.w %d4,[%sp]60
8002de8a:	df 03 a8 82 	jne %d3,0,8002e3da <_vfiprintf_r+0x100e>
8002de8e:	1b f8 fe 3f 	addi %d3,%d8,-17
8002de92:	8f f3 60 31 	nor %d3,%d3,15
8002de96:	91 00 00 c8 	movh.a %a12,32768
8002de9a:	58 02       	ld.w %d15,[%sp]8
8002de9c:	0b 83 00 90 	add %d9,%d3,%d8
8002dea0:	d9 cc 0a 14 	lea %a12,[%a12]16458 <8000404a <blanks.1>>
8002dea4:	3b 00 01 a0 	mov %d10,16
8002dea8:	1b 14 00 20 	addi %d2,%d4,1
8002deac:	1b 06 01 60 	addi %d6,%d6,16
8002deb0:	e8 0c       	st.a [%a15]0,%a12
8002deb2:	68 1a       	st.w [%a15]4,%d10
8002deb4:	59 a6 00 10 	st.w [%sp]64,%d6
8002deb8:	59 a2 3c 00 	st.w [%sp]60,%d2
8002debc:	8b 82 80 32 	ge %d3,%d2,8
8002dec0:	1b 24 00 50 	addi %d5,%d4,2
8002dec4:	d9 ff 08 00 	lea %a15,[%a15]8
8002dec8:	02 24       	mov %d4,%d2
8002deca:	df 03 15 00 	jeq %d3,0,8002def4 <_vfiprintf_r+0xb28>
8002dece:	60 cf       	mov.a %a15,%d12
8002ded0:	82 15       	mov %d5,1
8002ded2:	82 04       	mov %d4,0
8002ded4:	df 06 10 00 	jeq %d6,0,8002def4 <_vfiprintf_r+0xb28>
8002ded8:	60 d4       	mov.a %a4,%d13
8002deda:	d9 a6 38 00 	lea %a6,[%sp]56
8002dede:	40 d5       	mov.aa %a5,%a13
8002dee0:	6d ff 38 fa 	call 8002d350 <__sprint_r.part.0>
8002dee4:	df 02 c6 fc 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002dee8:	19 a4 3c 00 	ld.w %d4,[%sp]60
8002deec:	19 a6 00 10 	ld.w %d6,[%sp]64
8002def0:	1b 14 00 50 	addi %d5,%d4,1
8002def4:	1b 08 ff 8f 	addi %d8,%d8,-16
8002def8:	5f 89 d8 ff 	jne %d9,%d8,8002dea8 <_vfiprintf_r+0xadc>
8002defc:	78 02       	st.w [%sp]8,%d15
8002defe:	42 96       	add %d6,%d9
8002df00:	59 a5 3c 00 	st.w [%sp]60,%d5
8002df04:	e8 0c       	st.a [%a15]0,%a12
8002df06:	68 19       	st.w [%a15]4,%d9
8002df08:	59 a6 00 10 	st.w [%sp]64,%d6
8002df0c:	8b 85 40 52 	lt %d5,%d5,8
8002df10:	df 05 8f fb 	jne %d5,0,8002d62e <_vfiprintf_r+0x262>
8002df14:	df 06 0e 00 	jeq %d6,0,8002df30 <_vfiprintf_r+0xb64>
8002df18:	60 d4       	mov.a %a4,%d13
8002df1a:	d9 a6 38 00 	lea %a6,[%sp]56
8002df1e:	40 d5       	mov.aa %a5,%a13
8002df20:	6d ff 18 fa 	call 8002d350 <__sprint_r.part.0>
8002df24:	df 02 a6 fc 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002df28:	19 a6 00 10 	ld.w %d6,[%sp]64
8002df2c:	1d ff 81 fb 	j 8002d62e <_vfiprintf_r+0x262>
8002df30:	54 a2       	ld.w %d2,[%sp]
8002df32:	0b e2 a0 e1 	max %d14,%d2,%d14
8002df36:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002df3a:	42 e2       	add %d2,%d14
8002df3c:	59 a2 0c 00 	st.w [%sp]12,%d2
8002df40:	1d ff 81 fb 	j 8002d642 <_vfiprintf_r+0x276>
8002df44:	02 ae       	mov %d14,%d10
8002df46:	a0 9c       	mov.a %a12,9
8002df48:	8b 07 00 22 	eq %d2,%d7,0
8002df4c:	80 c3       	mov.d %d3,%a12
8002df4e:	60 23       	mov.a %a3,%d2
8002df50:	0b 63 50 22 	and.ge.u %d2,%d3,%d6
8002df54:	df 02 39 01 	jeq %d2,0,8002e1c6 <_vfiprintf_r+0xdfa>
8002df58:	1b 06 03 60 	addi %d6,%d6,48
8002df5c:	82 12       	mov %d2,1
8002df5e:	02 ea       	mov %d10,%d14
8002df60:	e9 a6 27 30 	st.b [%sp]231,%d6
8002df64:	59 a2 04 00 	st.w [%sp]4,%d2
8002df68:	d9 ae 27 30 	lea %a14,[%sp]231
8002df6c:	1d ff 21 fd 	j 8002d9ae <_vfiprintf_r+0x5e2>
8002df70:	99 ac 08 00 	ld.a %a12,[%sp]8
8002df74:	1d ff ae fa 	j 8002d4d0 <_vfiprintf_r+0x104>
8002df78:	60 cf       	mov.a %a15,%d12
8002df7a:	59 a2 3c 00 	st.w [%sp]60,%d2
8002df7e:	1d ff a2 fa 	j 8002d4c2 <_vfiprintf_r+0xf6>
8002df82:	40 23       	mov.aa %a3,%a2
8002df84:	b0 42       	add.a %a2,4
8002df86:	b5 a2 10 00 	st.a [%sp]16,%a2
8002df8a:	54 32       	ld.w %d2,[%a3]
8002df8c:	6f 4e 06 80 	jnz.t %d14,4,8002df98 <_vfiprintf_r+0xbcc>
8002df90:	6f 6e d7 01 	jz.t %d14,6,8002e33e <_vfiprintf_r+0xf72>
8002df94:	37 02 70 20 	extr.u %d2,%d2,0,16
8002df98:	53 12 40 60 	mul.u %e6,%d2,1
8002df9c:	82 13       	mov %d3,1
8002df9e:	1d ff e4 fc 	j 8002d966 <_vfiprintf_r+0x59a>
8002dfa2:	40 23       	mov.aa %a3,%a2
8002dfa4:	b0 42       	add.a %a2,4
8002dfa6:	b5 a2 10 00 	st.a [%sp]16,%a2
8002dfaa:	54 34       	ld.w %d4,[%a3]
8002dfac:	6f 4a 1e 80 	jnz.t %d10,4,8002dfe8 <_vfiprintf_r+0xc1c>
8002dfb0:	6f 6a 14 00 	jz.t %d10,6,8002dfd8 <_vfiprintf_r+0xc0c>
8002dfb4:	37 04 50 40 	extr %d4,%d4,0,16
8002dfb8:	0b 40 00 68 	mov %e6,%d4
8002dfbc:	0b 67 10 28 	mov %e2,%d7,%d6
8002dfc0:	ff 03 13 7d 	jge %d3,0,8002d9e6 <_vfiprintf_r+0x61a>
8002dfc4:	32 57       	rsub %d7
8002dfc6:	32 56       	rsub %d6
8002dfc8:	ab f7 1f 76 	cadd %d7,%d6,%d7,-1
8002dfcc:	02 ae       	mov %d14,%d10
8002dfce:	3b d0 02 20 	mov %d2,45
8002dfd2:	82 13       	mov %d3,1
8002dfd4:	1d ff ca fc 	j 8002d968 <_vfiprintf_r+0x59c>
8002dfd8:	0b 40 00 68 	mov %e6,%d4
8002dfdc:	0b 67 10 28 	mov %e2,%d7,%d6
8002dfe0:	6f 9a 01 7d 	jz.t %d10,9,8002d9e2 <_vfiprintf_r+0x616>
8002dfe4:	37 04 48 40 	extr %d4,%d4,0,8
8002dfe8:	0b 40 00 68 	mov %e6,%d4
8002dfec:	0b 67 10 28 	mov %e2,%d7,%d6
8002dff0:	1d ff f9 fc 	j 8002d9e2 <_vfiprintf_r+0x616>
8002dff4:	40 23       	mov.aa %a3,%a2
8002dff6:	b0 42       	add.a %a2,4
8002dff8:	b5 a2 10 00 	st.a [%sp]16,%a2
8002dffc:	54 32       	ld.w %d2,[%a3]
8002dffe:	6f 4a 10 80 	jnz.t %d10,4,8002e01e <_vfiprintf_r+0xc52>
8002e002:	6f 6a 08 00 	jz.t %d10,6,8002e012 <_vfiprintf_r+0xc46>
8002e006:	37 02 70 20 	extr.u %d2,%d2,0,16
8002e00a:	53 12 40 60 	mul.u %e6,%d2,1
8002e00e:	1d ff a9 fc 	j 8002d960 <_vfiprintf_r+0x594>
8002e012:	53 12 40 60 	mul.u %e6,%d2,1
8002e016:	6f 9a a5 7c 	jz.t %d10,9,8002d960 <_vfiprintf_r+0x594>
8002e01a:	8f f2 0f 21 	and %d2,%d2,255
8002e01e:	53 12 40 60 	mul.u %e6,%d2,1
8002e022:	1d ff 9f fc 	j 8002d960 <_vfiprintf_r+0x594>
8002e026:	60 cf       	mov.a %a15,%d12
8002e028:	82 00       	mov %d0,0
8002e02a:	02 74       	mov %d4,%d7
8002e02c:	df 05 d6 7a 	jeq %d5,0,8002d5d8 <_vfiprintf_r+0x20c>
8002e030:	82 23       	mov %d3,2
8002e032:	d9 a2 36 00 	lea %a2,[%sp]54
8002e036:	b5 a2 04 10 	st.a [%sp]68,%a2
8002e03a:	59 a3 08 10 	st.w [%sp]72,%d3
8002e03e:	02 70       	mov %d0,%d7
8002e040:	02 36       	mov %d6,%d3
8002e042:	1d ff ae fe 	j 8002dd9e <_vfiprintf_r+0x9d2>
8002e046:	79 e2 00 00 	ld.b %d2,[%a14]0
8002e04a:	b5 a2 10 00 	st.a [%sp]16,%a2
8002e04e:	1d ff 5a fa 	j 8002d502 <_vfiprintf_r+0x136>
8002e052:	60 d4       	mov.a %a4,%d13
8002e054:	d9 a6 38 00 	lea %a6,[%sp]56
8002e058:	40 d5       	mov.aa %a5,%a13
8002e05a:	b5 a7 2c 00 	st.a [%sp]44,%a7
8002e05e:	59 a1 28 00 	st.w [%sp]40,%d1
8002e062:	59 a5 24 00 	st.w [%sp]36,%d5
8002e066:	6d ff 75 f9 	call 8002d350 <__sprint_r.part.0>
8002e06a:	df 02 03 fc 	jne %d2,0,8002d870 <_vfiprintf_r+0x4a4>
8002e06e:	19 a0 3c 00 	ld.w %d0,[%sp]60
8002e072:	99 a7 2c 00 	ld.a %a7,[%sp]44
8002e076:	19 a6 00 10 	ld.w %d6,[%sp]64
8002e07a:	60 cf       	mov.a %a15,%d12
8002e07c:	19 a1 28 00 	ld.w %d1,[%sp]40
8002e080:	19 a5 24 00 	ld.w %d5,[%sp]36
8002e084:	1b 10 00 40 	addi %d4,%d0,1
8002e088:	1d ff 67 fa 	j 8002d556 <_vfiprintf_r+0x18a>
8002e08c:	99 a2 18 00 	ld.a %a2,[%sp]24
8002e090:	b7 fa 01 35 	insert %d3,%d10,15,10,1
8002e094:	79 e2 00 00 	ld.b %d2,[%a14]0
8002e098:	79 24 00 00 	ld.b %d4,[%a2]0
8002e09c:	2b a3 40 a4 	sel %d10,%d4,%d3,%d10
8002e0a0:	1d ff 31 fa 	j 8002d502 <_vfiprintf_r+0x136>
8002e0a4:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002e0a8:	d4 33       	ld.a %a3,[%a3]
8002e0aa:	0b 20 00 28 	mov %e2,%d2
8002e0ae:	b5 a2 10 00 	st.a [%sp]16,%a2
8002e0b2:	89 32 40 09 	st.d [%a3],%e2
8002e0b6:	1d ff c8 f9 	j 8002d446 <_vfiprintf_r+0x7a>
8002e0ba:	60 b7       	mov.a %a7,%d11
8002e0bc:	b5 ae 08 00 	st.a [%sp]8,%a14
8002e0c0:	1d ff 87 fc 	j 8002d9ce <_vfiprintf_r+0x602>
8002e0c4:	40 e4       	mov.aa %a4,%a14
8002e0c6:	6d ff bc d2 	call 8002863e <strlen>
8002e0ca:	59 a2 04 00 	st.w [%sp]4,%d2
8002e0ce:	b5 ac 10 00 	st.a [%sp]16,%a12
8002e0d2:	a0 07       	mov.a %a7,0
8002e0d4:	1d ff 6d fc 	j 8002d9ae <_vfiprintf_r+0x5e2>
8002e0d8:	60 b7       	mov.a %a7,%d11
8002e0da:	b5 ae 08 00 	st.a [%sp]8,%a14
8002e0de:	02 ae       	mov %d14,%d10
8002e0e0:	1d ff ed fc 	j 8002daba <_vfiprintf_r+0x6ee>
8002e0e4:	91 00 00 28 	movh.a %a2,32768
8002e0e8:	d9 22 22 04 	lea %a2,[%a2]16418 <80004022 <__mprec_tens+0x116>>
8002e0ec:	b5 a2 14 00 	st.a [%sp]20 <80004022 <__mprec_tens+0x116>>,%a2
8002e0f0:	b5 ae 08 00 	st.a [%sp]8 <80004022 <__mprec_tens+0x116>>,%a14
8002e0f4:	99 a2 10 00 	ld.a %a2,[%sp]16 <80004022 <__mprec_tens+0x116>>
8002e0f8:	60 b7       	mov.a %a7,%d11
8002e0fa:	6f 5a 1f 00 	jz.t %d10,5,8002e138 <_vfiprintf_r+0xd6c>
8002e0fe:	09 26 48 01 	ld.d %e6,[%a2+]8
8002e102:	b5 a2 10 00 	st.a [%sp]16,%a2
8002e106:	0f 76 a0 30 	or %d3,%d6,%d7
8002e10a:	8b 03 20 32 	ne %d3,%d3,0
8002e10e:	26 a3       	and %d3,%d10
8002e110:	df 03 44 80 	jne %d3,0,8002e198 <_vfiprintf_r+0xdcc>
8002e114:	b7 0a 01 e5 	insert %d14,%d10,0,10,1
8002e118:	82 23       	mov %d3,2
8002e11a:	1d ff 26 fc 	j 8002d966 <_vfiprintf_r+0x59a>
8002e11e:	91 00 00 28 	movh.a %a2,32768
8002e122:	d9 22 11 04 	lea %a2,[%a2]16401 <80004011 <__mprec_tens+0x105>>
8002e126:	b5 a2 14 00 	st.a [%sp]20 <80004011 <__mprec_tens+0x105>>,%a2
8002e12a:	b5 ae 08 00 	st.a [%sp]8 <80004011 <__mprec_tens+0x105>>,%a14
8002e12e:	99 a2 10 00 	ld.a %a2,[%sp]16 <80004011 <__mprec_tens+0x105>>
8002e132:	60 b7       	mov.a %a7,%d11
8002e134:	6f 5a e5 ff 	jnz.t %d10,5,8002e0fe <_vfiprintf_r+0xd32>
8002e138:	40 23       	mov.aa %a3,%a2
8002e13a:	b0 42       	add.a %a2,4
8002e13c:	b5 a2 10 00 	st.a [%sp]16,%a2
8002e140:	54 33       	ld.w %d3,[%a3]
8002e142:	6f 4a 22 80 	jnz.t %d10,4,8002e186 <_vfiprintf_r+0xdba>
8002e146:	6f 6a 1a 00 	jz.t %d10,6,8002e17a <_vfiprintf_r+0xdae>
8002e14a:	37 03 70 30 	extr.u %d3,%d3,0,16
8002e14e:	53 13 40 60 	mul.u %e6,%d3,1
8002e152:	1d ff da ff 	j 8002e106 <_vfiprintf_r+0xd3a>
8002e156:	60 b7       	mov.a %a7,%d11
8002e158:	b5 ae 08 00 	st.a [%sp]8,%a14
8002e15c:	1d ff fa fb 	j 8002d950 <_vfiprintf_r+0x584>
8002e160:	19 a2 00 10 	ld.w %d2,[%sp]64
8002e164:	40 df       	mov.aa %a15,%a13
8002e166:	df 02 86 7b 	jeq %d2,0,8002d872 <_vfiprintf_r+0x4a6>
8002e16a:	60 d4       	mov.a %a4,%d13
8002e16c:	d9 a6 38 00 	lea %a6,[%sp]56
8002e170:	40 d5       	mov.aa %a5,%a13
8002e172:	6d ff ef f8 	call 8002d350 <__sprint_r.part.0>
8002e176:	1d ff 7e fb 	j 8002d872 <_vfiprintf_r+0x4a6>
8002e17a:	53 13 40 60 	mul.u %e6,%d3,1
8002e17e:	6f 9a c4 7f 	jz.t %d10,9,8002e106 <_vfiprintf_r+0xd3a>
8002e182:	8f f3 0f 31 	and %d3,%d3,255
8002e186:	53 13 40 60 	mul.u %e6,%d3,1
8002e18a:	0f 76 a0 30 	or %d3,%d6,%d7
8002e18e:	8b 03 20 32 	ne %d3,%d3,0
8002e192:	26 a3       	and %d3,%d10
8002e194:	df 03 c0 7f 	jeq %d3,0,8002e114 <_vfiprintf_r+0xd48>
8002e198:	da 30       	mov %d15,48
8002e19a:	e9 a2 37 00 	st.b [%sp]55,%d2
8002e19e:	8f 2a 40 a1 	or %d10,%d10,2
8002e1a2:	e9 af 36 00 	st.b [%sp]54,%d15
8002e1a6:	1d ff b7 ff 	j 8002e114 <_vfiprintf_r+0xd48>
8002e1aa:	da 30       	mov %d15,48
8002e1ac:	b0 e2       	add.a %a2,-2
8002e1ae:	d9 a3 28 30 	lea %a3,[%sp]232
8002e1b2:	01 23 20 30 	sub.a %a3,%a3,%a2
8002e1b6:	e9 ef ff ff 	st.b [%a14]-1,%d15
8002e1ba:	b5 a3 04 00 	st.a [%sp]4,%a3
8002e1be:	02 ea       	mov %d10,%d14
8002e1c0:	40 2e       	mov.aa %a14,%a2
8002e1c2:	1d ff f6 fb 	j 8002d9ae <_vfiprintf_r+0x5e2>
8002e1c6:	3b 00 40 20 	mov %d2,1024
8002e1ca:	26 e2       	and %d2,%d14
8002e1cc:	a0 04       	mov.a %a4,0
8002e1ce:	40 f6       	mov.aa %a6,%a15
8002e1d0:	b5 ad 24 00 	st.a [%sp]36,%a13
8002e1d4:	80 3f       	mov.d %d15,%a3
8002e1d6:	99 ad 18 00 	ld.a %a13,[%sp]24
8002e1da:	60 e3       	mov.a %a3,%d14
8002e1dc:	60 2f       	mov.a %a15,%d2
8002e1de:	d9 a2 28 30 	lea %a2,[%sp]232
8002e1e2:	59 ad 04 00 	st.w [%sp]4,%d13
8002e1e6:	80 4e       	mov.d %d14,%a4
8002e1e8:	1d 00 30 00 	j 8002e248 <_vfiprintf_r+0xe7c>
8002e1ec:	b7 0a 04 2e 	insert %d2,%d10,0,28,4
8002e1f0:	7b d0 cc 1c 	movh %d1,52429
8002e1f4:	42 d2       	add %d2,%d13
8002e1f6:	42 2b       	add %d11,%d2
8002e1f8:	7b d0 cc 2c 	movh %d2,52429
8002e1fc:	1b d2 cc 2c 	addi %d2,%d2,-13107
8002e200:	73 2b 68 20 	mul.u %e2,%d11,%d2
8002e204:	1b d1 cc 1c 	addi %d1,%d1,-13107
8002e208:	1b f1 ff 8f 	addi %d8,%d1,-1
8002e20c:	8f e3 1f 20 	sh %d2,%d3,-2
8002e210:	13 b2 3f 2b 	madd %d2,%d11,%d2,-5
8002e214:	82 03       	mov %d3,0
8002e216:	0b 26 c0 a0 	subx %d10,%d6,%d2
8002e21a:	0b 37 d0 b0 	subc %d11,%d7,%d3
8002e21e:	73 1a 68 20 	mul.u %e2,%d10,%d1
8002e222:	03 8a 0a 33 	madd %d3,%d3,%d10,%d8
8002e226:	03 1b 0a 33 	madd %d3,%d3,%d11,%d1
8002e22a:	77 23 80 9f 	dextr %d9,%d3,%d2,31
8002e22e:	80 c2       	mov.d %d2,%a12
8002e230:	0b 62 30 f2 	and.lt.u %d15,%d2,%d6
8002e234:	8b 07 00 f5 	or.ne %d15,%d7,0
8002e238:	8f f3 1f 80 	sh %d8,%d3,-1
8002e23c:	df 0f 4e 00 	jeq %d15,0,8002e2d8 <_vfiprintf_r+0xf0c>
8002e240:	0b 98 10 68 	mov %e6,%d8,%d9
8002e244:	40 e2       	mov.aa %a2,%a14
8002e246:	ba 07       	eq %d15,%d7,0
8002e248:	77 67 00 a2 	dextr %d10,%d7,%d6,4
8002e24c:	b7 06 04 de 	insert %d13,%d6,0,28,4
8002e250:	b7 0a 04 2e 	insert %d2,%d10,0,28,4
8002e254:	8f 87 1e b0 	sh %d11,%d7,-24
8002e258:	42 d2       	add %d2,%d13
8002e25a:	0b b2 00 40 	add %d4,%d2,%d11
8002e25e:	7b d0 cc 2c 	movh %d2,52429
8002e262:	1b d2 cc 2c 	addi %d2,%d2,-13107
8002e266:	73 24 68 20 	mul.u %e2,%d4,%d2
8002e26a:	7b d0 cc 1c 	movh %d1,52429
8002e26e:	1b d1 cc 1c 	addi %d1,%d1,-13107
8002e272:	8f e3 1f 20 	sh %d2,%d3,-2
8002e276:	13 b2 3f 24 	madd %d2,%d4,%d2,-5
8002e27a:	82 03       	mov %d3,0
8002e27c:	1b f1 ff 8f 	addi %d8,%d1,-1
8002e280:	0b 26 c0 20 	subx %d2,%d6,%d2
8002e284:	0b 37 d0 30 	subc %d3,%d7,%d3
8002e288:	60 24       	mov.a %a4,%d2
8002e28a:	60 35       	mov.a %a5,%d3
8002e28c:	73 12 68 20 	mul.u %e2,%d2,%d1
8002e290:	80 44       	mov.d %d4,%a4
8002e292:	80 55       	mov.d %d5,%a5
8002e294:	03 84 0a 33 	madd %d3,%d3,%d4,%d8
8002e298:	d9 2e ff ff 	lea %a14,[%a2]-1
8002e29c:	c2 1e       	add %d14,1
8002e29e:	03 15 0a 33 	madd %d3,%d3,%d5,%d1
8002e2a2:	77 23 80 9f 	dextr %d9,%d3,%d2,31
8002e2a6:	8f f3 1f 80 	sh %d8,%d3,-1
8002e2aa:	33 a9 40 26 	msub.u %e2,%e6,%d9,10
8002e2ae:	1b 02 03 20 	addi %d2,%d2,48
8002e2b2:	e9 22 ff ff 	st.b [%a2]-1,%d2
8002e2b6:	bd 0f 9b 7f 	jz.a %a15,8002e1ec <_vfiprintf_r+0xe20>
8002e2ba:	79 d2 00 00 	ld.b %d2,[%a13]0
8002e2be:	0b e2 00 31 	eq %d3,%d2,%d14
8002e2c2:	8b f2 27 34 	and.ne %d3,%d2,127
8002e2c6:	df 03 93 7f 	jeq %d3,0,8002e1ec <_vfiprintf_r+0xe20>
8002e2ca:	80 c2       	mov.d %d2,%a12
8002e2cc:	0b 62 30 f2 	and.lt.u %d15,%d2,%d6
8002e2d0:	8b 07 00 f5 	or.ne %d15,%d7,0
8002e2d4:	df 0f 5c 80 	jne %d15,0,8002e38c <_vfiprintf_r+0xfc0>
8002e2d8:	b5 ad 18 00 	st.a [%sp]24,%a13
8002e2dc:	19 ad 04 00 	ld.w %d13,[%sp]4
8002e2e0:	99 ad 24 00 	ld.a %a13,[%sp]36
8002e2e4:	80 3e       	mov.d %d14,%a3
8002e2e6:	40 6f       	mov.aa %a15,%a6
8002e2e8:	1d ff 33 fc 	j 8002db4e <_vfiprintf_r+0x782>
8002e2ec:	6d ff df d0 	call 800284aa <__sinit>
8002e2f0:	1d ff 7a f8 	j 8002d3e4 <_vfiprintf_r+0x18>
8002e2f4:	79 e2 01 00 	ld.b %d2,[%a14]1
8002e2f8:	b7 fa 81 a4 	insert %d10,%d10,15,9,1
8002e2fc:	b0 1e       	add.a %a14,1
8002e2fe:	1d ff 02 f9 	j 8002d502 <_vfiprintf_r+0x136>
8002e302:	79 e2 01 00 	ld.b %d2,[%a14]1
8002e306:	8f 0a 42 a1 	or %d10,%d10,32
8002e30a:	b0 1e       	add.a %a14,1
8002e30c:	1d ff fb f8 	j 8002d502 <_vfiprintf_r+0x136>
8002e310:	99 a3 10 00 	ld.a %a3,[%sp]16
8002e314:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002e318:	d4 33       	ld.a %a3,[%a3]
8002e31a:	74 32       	st.w [%a3],%d2
8002e31c:	b5 a2 10 00 	st.a [%sp]16,%a2
8002e320:	1d ff 93 f8 	j 8002d446 <_vfiprintf_r+0x7a>
8002e324:	8b 6b 20 23 	min.u %d2,%d11,6
8002e328:	91 00 00 e8 	movh.a %a14,32768
8002e32c:	02 2e       	mov %d14,%d2
8002e32e:	59 a2 04 00 	st.w [%sp]4,%d2
8002e332:	b5 ac 10 00 	st.a [%sp]16,%a12
8002e336:	d9 ee 33 04 	lea %a14,[%a14]16435 <80004033 <__mprec_tens+0x127>>
8002e33a:	1d ff f9 f8 	j 8002d52c <_vfiprintf_r+0x160>
8002e33e:	53 12 40 60 	mul.u %e6,%d2,1
8002e342:	82 13       	mov %d3,1
8002e344:	6f 9e 11 7b 	jz.t %d14,9,8002d966 <_vfiprintf_r+0x59a>
8002e348:	8f f2 0f 21 	and %d2,%d2,255
8002e34c:	53 12 40 60 	mul.u %e6,%d2,1
8002e350:	1d ff 0b fb 	j 8002d966 <_vfiprintf_r+0x59a>
8002e354:	91 00 00 c8 	movh.a %a12,32768
8002e358:	02 89       	mov %d9,%d8
8002e35a:	d9 cc 3a 04 	lea %a12,[%a12]16442 <8000403a <zeroes.0>>
8002e35e:	1d ff b3 fc 	j 8002dcc4 <_vfiprintf_r+0x8f8>
8002e362:	82 14       	mov %d4,1
8002e364:	d9 a2 35 00 	lea %a2,[%sp]53
8002e368:	60 cf       	mov.a %a15,%d12
8002e36a:	b5 a2 04 10 	st.a [%sp]68,%a2
8002e36e:	59 a4 08 10 	st.w [%sp]72,%d4
8002e372:	02 46       	mov %d6,%d4
8002e374:	1d ff 03 f9 	j 8002d57a <_vfiprintf_r+0x1ae>
8002e378:	99 a3 10 00 	ld.a %a3,[%sp]16
8002e37c:	19 a2 0c 00 	ld.w %d2,[%sp]12
8002e380:	b5 a2 10 00 	st.a [%sp]16,%a2
8002e384:	d4 33       	ld.a %a3,[%a3]
8002e386:	b4 32       	st.h [%a3],%d2
8002e388:	1d ff 5f f8 	j 8002d446 <_vfiprintf_r+0x7a>
8002e38c:	99 a2 20 00 	ld.a %a2,[%sp]32
8002e390:	99 a5 1c 00 	ld.a %a5,[%sp]28
8002e394:	b5 a6 2c 00 	st.a [%sp]44,%a6
8002e398:	01 2e 20 e0 	sub.a %a14,%a14,%a2
8002e39c:	80 24       	mov.d %d4,%a2
8002e39e:	40 e4       	mov.aa %a4,%a14
8002e3a0:	b5 a7 28 00 	st.a [%sp]40,%a7
8002e3a4:	b5 a3 18 00 	st.a [%sp]24,%a3
8002e3a8:	6d ff 8f d1 	call 800286c6 <strncpy>
8002e3ac:	79 d2 01 00 	ld.b %d2,[%a13]1
8002e3b0:	80 d3       	mov.d %d3,%a13
8002e3b2:	ab 13 00 22 	cadd %d2,%d2,%d3,1
8002e3b6:	99 a3 18 00 	ld.a %a3,[%sp]24
8002e3ba:	99 a7 28 00 	ld.a %a7,[%sp]40
8002e3be:	99 a6 2c 00 	ld.a %a6,[%sp]44
8002e3c2:	60 2d       	mov.a %a13,%d2
8002e3c4:	82 0e       	mov %d14,0
8002e3c6:	1d ff 3d ff 	j 8002e240 <_vfiprintf_r+0xe74>
8002e3ca:	91 00 00 c8 	movh.a %a12,32768
8002e3ce:	02 72       	mov %d2,%d7
8002e3d0:	02 89       	mov %d9,%d8
8002e3d2:	d9 cc 0a 14 	lea %a12,[%a12]16458 <8000404a <blanks.1>>
8002e3d6:	1d ff be fc 	j 8002dd52 <_vfiprintf_r+0x986>
8002e3da:	91 00 00 c8 	movh.a %a12,32768
8002e3de:	1b 14 00 50 	addi %d5,%d4,1
8002e3e2:	02 89       	mov %d9,%d8
8002e3e4:	d9 cc 0a 14 	lea %a12,[%a12]16458 <8000404a <blanks.1>>
8002e3e8:	1d ff 8b fd 	j 8002defe <_vfiprintf_r+0xb32>
8002e3ec:	82 f2       	mov %d2,-1
8002e3ee:	59 a2 0c 00 	st.w [%sp]12,%d2
8002e3f2:	1d ff 43 fa 	j 8002d878 <_vfiprintf_r+0x4ac>
8002e3f6:	91 00 00 c8 	movh.a %a12,32768
8002e3fa:	02 42       	mov %d2,%d4
8002e3fc:	02 89       	mov %d9,%d8
8002e3fe:	d9 cc 3a 04 	lea %a12,[%a12]16442 <8000403a <zeroes.0>>
8002e402:	1d ff f8 fb 	j 8002dbf2 <_vfiprintf_r+0x826>
8002e406:	99 a3 10 00 	ld.a %a3,[%sp]16
8002e40a:	79 e2 01 00 	ld.b %d2,[%a14]1
8002e40e:	40 2e       	mov.aa %a14,%a2
8002e410:	40 34       	mov.aa %a4,%a3
8002e412:	54 4b       	ld.w %d11,[%a4]
8002e414:	b0 43       	add.a %a3,4
8002e416:	8b fb 5f b3 	max %d11,%d11,-1
8002e41a:	b5 a3 10 00 	st.a [%sp]16,%a3
8002e41e:	1d ff 72 f8 	j 8002d502 <_vfiprintf_r+0x136>

8002e422 <_vfiprintf_r_end>:
	...

8002e424 <__sbprintf>:
8002e424:	c9 52 0c 00 	ld.h %d2,[%a5]12
8002e428:	d9 aa 98 ef 	lea %sp,[%sp]-1128
8002e42c:	8f 22 c0 21 	andn %d2,%d2,2
8002e430:	d9 a2 28 10 	lea %a2,[%sp]104
8002e434:	40 5c       	mov.aa %a12,%a5
8002e436:	f9 a2 0c 00 	st.h [%sp]12,%d2
8002e43a:	19 52 24 10 	ld.w %d2,[%a5]100
8002e43e:	59 a2 24 10 	st.w [%sp]100,%d2
8002e442:	c9 52 0e 00 	ld.h %d2,[%a5]14
8002e446:	f9 a2 0e 00 	st.h [%sp]14,%d2
8002e44a:	19 52 1c 00 	ld.w %d2,[%a5]28
8002e44e:	59 a2 1c 00 	st.w [%sp]28,%d2
8002e452:	19 52 24 00 	ld.w %d2,[%a5]36
8002e456:	59 a2 24 00 	st.w [%sp]36,%d2
8002e45a:	3b 00 40 20 	mov %d2,1024
8002e45e:	40 a5       	mov.aa %a5,%sp
8002e460:	80 49       	mov.d %d9,%a4
8002e462:	59 a2 08 00 	st.w [%sp]8,%d2
8002e466:	59 a2 14 00 	st.w [%sp]20,%d2
8002e46a:	82 02       	mov %d2,0
8002e46c:	f4 a2       	st.a [%sp],%a2
8002e46e:	b5 a2 10 00 	st.a [%sp]16,%a2
8002e472:	59 a2 18 00 	st.w [%sp]24,%d2
8002e476:	6d ff ab f7 	call 8002d3cc <_vfiprintf_r>
8002e47a:	02 28       	mov %d8,%d2
8002e47c:	bf 02 08 00 	jlt %d2,0,8002e48c <__sbprintf+0x68>
8002e480:	60 94       	mov.a %a4,%d9
8002e482:	40 a5       	mov.aa %a5,%sp
8002e484:	6d ff e3 e5 	call 8002b04a <_fflush_r>
8002e488:	ab f8 bf 82 	seln %d8,%d2,%d8,-1
8002e48c:	c9 a2 0c 00 	ld.h %d2,[%sp]12
8002e490:	6f 62 08 00 	jz.t %d2,6,8002e4a0 <__sbprintf+0x7c>
8002e494:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002e498:	8f 02 44 21 	or %d2,%d2,64
8002e49c:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002e4a0:	02 82       	mov %d2,%d8
8002e4a2:	00 90       	ret 

8002e4a4 <__sfvwrite_r>:
8002e4a4:	19 62 08 00 	ld.w %d2,[%a6]8
8002e4a8:	40 4f       	mov.aa %a15,%a4
8002e4aa:	40 5c       	mov.aa %a12,%a5
8002e4ac:	40 6d       	mov.aa %a13,%a6
8002e4ae:	df 02 2b 00 	jeq %d2,0,8002e504 <__sfvwrite_r+0x60>
8002e4b2:	c9 55 0c 00 	ld.h %d5,[%a5]12
8002e4b6:	6f 35 29 00 	jz.t %d5,3,8002e508 <__sfvwrite_r+0x64>
8002e4ba:	19 52 10 00 	ld.w %d2,[%a5]16
8002e4be:	df 02 25 00 	jeq %d2,0,8002e508 <__sfvwrite_r+0x64>
8002e4c2:	d4 de       	ld.a %a14,[%a13]
8002e4c4:	6f 15 2f 00 	jz.t %d5,1,8002e522 <__sfvwrite_r+0x7e>
8002e4c8:	d2 08       	mov %e8,0
8002e4ca:	99 c2 24 00 	ld.a %a2,[%a12]36
8002e4ce:	99 c5 1c 00 	ld.a %a5,[%a12]28
8002e4d2:	df 08 a9 00 	jeq %d8,0,8002e624 <__sfvwrite_r+0x180>
8002e4d6:	7b 00 00 28 	movh %d2,32768
8002e4da:	1b 02 c0 2f 	addi %d2,%d2,-1024
8002e4de:	60 96       	mov.a %a6,%d9
8002e4e0:	0b 28 90 41 	min.u %d4,%d8,%d2
8002e4e4:	40 f4       	mov.aa %a4,%a15
8002e4e6:	2d 02 00 00 	calli %a2
8002e4ea:	bf 12 aa 00 	jlt %d2,1,8002e63e <__sfvwrite_r+0x19a>
8002e4ee:	19 d3 08 00 	ld.w %d3,[%a13]8
8002e4f2:	42 29       	add %d9,%d2
8002e4f4:	a2 28       	sub %d8,%d2
8002e4f6:	0b 23 80 20 	sub %d2,%d3,%d2
8002e4fa:	d9 d2 08 00 	lea %a2,[%a13]8
8002e4fe:	74 22       	st.w [%a2],%d2
8002e500:	df 02 e5 ff 	jne %d2,0,8002e4ca <__sfvwrite_r+0x26>
8002e504:	82 02       	mov %d2,0
8002e506:	00 90       	ret 
8002e508:	40 c5       	mov.aa %a5,%a12
8002e50a:	40 f4       	mov.aa %a4,%a15
8002e50c:	6d 00 66 01 	call 8002e7d8 <__swsetup_r>
8002e510:	02 23       	mov %d3,%d2
8002e512:	82 f2       	mov %d2,-1
8002e514:	df 03 9c 80 	jne %d3,0,8002e64c <__sfvwrite_r+0x1a8>
8002e518:	c9 c5 0c 00 	ld.h %d5,[%a12]12
8002e51c:	d4 de       	ld.a %a14,[%a13]
8002e51e:	6f 15 d5 ff 	jnz.t %d5,1,8002e4c8 <__sfvwrite_r+0x24>
8002e522:	82 0c       	mov %d12,0
8002e524:	82 02       	mov %d2,0
8002e526:	82 0a       	mov %d10,0
8002e528:	82 09       	mov %d9,0
8002e52a:	6f 05 d8 80 	jnz.t %d5,0,8002e6da <__sfvwrite_r+0x236>
8002e52e:	54 c3       	ld.w %d3,[%a12]
8002e530:	19 c2 08 00 	ld.w %d2,[%a12]8
8002e534:	82 0a       	mov %d10,0
8002e536:	82 08       	mov %d8,0
8002e538:	3b 00 20 c0 	mov %d12,512
8002e53c:	3b 00 48 e0 	mov %d14,1152
8002e540:	3b 00 40 f0 	mov %d15,1024
8002e544:	02 36       	mov %d6,%d3
8002e546:	02 29       	mov %d9,%d2
8002e548:	df 08 67 00 	jeq %d8,0,8002e616 <__sfvwrite_r+0x172>
8002e54c:	0f c5 80 40 	and %d4,%d5,%d12
8002e550:	df 04 ec 00 	jeq %d4,0,8002e728 <__sfvwrite_r+0x284>
8002e554:	02 2b       	mov %d11,%d2
8002e556:	3f 28 21 81 	jlt.u %d8,%d2,8002e798 <__sfvwrite_r+0x2f4>
8002e55a:	0f e5 80 20 	and %d2,%d5,%d14
8002e55e:	df 02 39 00 	jeq %d2,0,8002e5d0 <__sfvwrite_r+0x12c>
8002e562:	19 c2 14 00 	ld.w %d2,[%a12]20
8002e566:	19 c6 10 00 	ld.w %d6,[%a12]16
8002e56a:	53 32 20 20 	mul %d2,%d2,3
8002e56e:	0b 63 80 b0 	sub %d11,%d3,%d6
8002e572:	26 f5       	and %d5,%d15
8002e574:	8f 12 1e 30 	sh %d3,%d2,-31
8002e578:	42 32       	add %d2,%d3
8002e57a:	1b 1b 00 30 	addi %d3,%d11,1
8002e57e:	86 f2       	sha %d2,-1
8002e580:	42 83       	add %d3,%d8
8002e582:	0b 32 b0 d1 	max.u %d13,%d2,%d3
8002e586:	02 d4       	mov %d4,%d13
8002e588:	df 05 0c 01 	jeq %d5,0,8002e7a0 <__sfvwrite_r+0x2fc>
8002e58c:	40 f4       	mov.aa %a4,%a15
8002e58e:	6d ff 8d cb 	call 80027ca8 <_malloc_r>
8002e592:	80 29       	mov.d %d9,%a2
8002e594:	df 09 1b 01 	jeq %d9,0,8002e7ca <__sfvwrite_r+0x326>
8002e598:	99 c5 10 00 	ld.a %a5,[%a12]16
8002e59c:	02 b4       	mov %d4,%d11
8002e59e:	40 24       	mov.aa %a4,%a2
8002e5a0:	6d ff 3e c6 	call 8002721c <memcpy>
8002e5a4:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002e5a8:	3b f0 b7 3f 	mov %d3,-1153
8002e5ac:	26 32       	and %d2,%d3
8002e5ae:	8f 02 48 21 	or %d2,%d2,128
8002e5b2:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002e5b6:	0b b9 00 60 	add %d6,%d9,%d11
8002e5ba:	0b bd 80 b0 	sub %d11,%d13,%d11
8002e5be:	59 c9 10 00 	st.w [%a12]16,%d9
8002e5c2:	74 c6       	st.w [%a12],%d6
8002e5c4:	59 cb 08 00 	st.w [%a12]8,%d11
8002e5c8:	59 cd 14 00 	st.w [%a12]20,%d13
8002e5cc:	02 89       	mov %d9,%d8
8002e5ce:	02 8b       	mov %d11,%d8
8002e5d0:	60 a5       	mov.a %a5,%d10
8002e5d2:	60 64       	mov.a %a4,%d6
8002e5d4:	02 b4       	mov %d4,%d11
8002e5d6:	6d ff 69 c9 	call 800278a8 <memmove>
8002e5da:	19 c2 08 00 	ld.w %d2,[%a12]8
8002e5de:	54 c3       	ld.w %d3,[%a12]
8002e5e0:	a2 92       	sub %d2,%d9
8002e5e2:	42 b3       	add %d3,%d11
8002e5e4:	d9 c2 08 00 	lea %a2,[%a12]8
8002e5e8:	74 22       	st.w [%a2],%d2
8002e5ea:	02 89       	mov %d9,%d8
8002e5ec:	74 c3       	st.w [%a12],%d3
8002e5ee:	82 08       	mov %d8,0
8002e5f0:	19 d2 08 00 	ld.w %d2,[%a13]8
8002e5f4:	42 9a       	add %d10,%d9
8002e5f6:	0b 92 80 90 	sub %d9,%d2,%d9
8002e5fa:	d9 d2 08 00 	lea %a2,[%a13]8
8002e5fe:	74 29       	st.w [%a2],%d9
8002e600:	df 09 82 7f 	jeq %d9,0,8002e504 <__sfvwrite_r+0x60>
8002e604:	54 c3       	ld.w %d3,[%a12]
8002e606:	19 c2 08 00 	ld.w %d2,[%a12]8
8002e60a:	c9 c5 0c 00 	ld.h %d5,[%a12]12
8002e60e:	02 36       	mov %d6,%d3
8002e610:	02 29       	mov %d9,%d2
8002e612:	df 08 9d ff 	jne %d8,0,8002e54c <__sfvwrite_r+0xa8>
8002e616:	54 ea       	ld.w %d10,[%a14]
8002e618:	19 e8 04 00 	ld.w %d8,[%a14]4
8002e61c:	d9 ee 08 00 	lea %a14,[%a14]8
8002e620:	1d ff 92 ff 	j 8002e544 <__sfvwrite_r+0xa0>
8002e624:	54 e9       	ld.w %d9,[%a14]
8002e626:	19 e8 04 00 	ld.w %d8,[%a14]4
8002e62a:	d9 ee 08 00 	lea %a14,[%a14]8
8002e62e:	1d ff 52 ff 	j 8002e4d2 <__sfvwrite_r+0x2e>
8002e632:	40 c5       	mov.aa %a5,%a12
8002e634:	40 f4       	mov.aa %a4,%a15
8002e636:	6d ff 0a e5 	call 8002b04a <_fflush_r>
8002e63a:	df 02 45 00 	jeq %d2,0,8002e6c4 <__sfvwrite_r+0x220>
8002e63e:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002e642:	8f 02 44 21 	or %d2,%d2,64
8002e646:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002e64a:	82 f2       	mov %d2,-1
8002e64c:	00 90       	ret 
8002e64e:	19 e9 04 00 	ld.w %d9,[%a14]4
8002e652:	40 e2       	mov.aa %a2,%a14
8002e654:	d9 ee 08 00 	lea %a14,[%a14]8
8002e658:	df 09 fb 7f 	jeq %d9,0,8002e64e <__sfvwrite_r+0x1aa>
8002e65c:	54 2a       	ld.w %d10,[%a2]
8002e65e:	60 a4       	mov.a %a4,%d10
8002e660:	02 95       	mov %d5,%d9
8002e662:	3b a0 00 40 	mov %d4,10
8002e666:	6d ff 09 e5 	call 8002b078 <memchr>
8002e66a:	1b 19 00 b0 	addi %d11,%d9,1
8002e66e:	80 23       	mov.d %d3,%a2
8002e670:	02 bc       	mov %d12,%d11
8002e672:	df 03 07 00 	jeq %d3,0,8002e680 <__sfvwrite_r+0x1dc>
8002e676:	1b 13 00 20 	addi %d2,%d3,1
8002e67a:	0b a2 80 c0 	sub %d12,%d2,%d10
8002e67e:	02 cb       	mov %d11,%d12
8002e680:	19 c2 08 00 	ld.w %d2,[%a12]8
8002e684:	19 c4 14 00 	ld.w %d4,[%a12]20
8002e688:	19 c5 10 00 	ld.w %d5,[%a12]16
8002e68c:	0b 24 00 80 	add %d8,%d4,%d2
8002e690:	0b 9b 90 b1 	min.u %d11,%d11,%d9
8002e694:	54 c2       	ld.w %d2,[%a12]
8002e696:	0b b8 20 31 	lt %d3,%d8,%d11
8002e69a:	0b 25 30 32 	and.lt.u %d3,%d5,%d2
8002e69e:	df 03 35 80 	jne %d3,0,8002e708 <__sfvwrite_r+0x264>
8002e6a2:	3f 4b 22 00 	jlt %d11,%d4,8002e6e6 <__sfvwrite_r+0x242>
8002e6a6:	99 c2 24 00 	ld.a %a2,[%a12]36
8002e6aa:	99 c5 1c 00 	ld.a %a5,[%a12]28
8002e6ae:	60 a6       	mov.a %a6,%d10
8002e6b0:	40 f4       	mov.aa %a4,%a15
8002e6b2:	2d 02 00 00 	calli %a2
8002e6b6:	02 28       	mov %d8,%d2
8002e6b8:	bf 12 c3 7f 	jlt %d2,1,8002e63e <__sfvwrite_r+0x19a>
8002e6bc:	a2 8c       	sub %d12,%d8
8002e6be:	82 12       	mov %d2,1
8002e6c0:	df 0c b9 7f 	jeq %d12,0,8002e632 <__sfvwrite_r+0x18e>
8002e6c4:	19 d3 08 00 	ld.w %d3,[%a13]8
8002e6c8:	42 8a       	add %d10,%d8
8002e6ca:	a2 89       	sub %d9,%d8
8002e6cc:	0b 83 80 80 	sub %d8,%d3,%d8
8002e6d0:	d9 d2 08 00 	lea %a2,[%a13]8
8002e6d4:	74 28       	st.w [%a2],%d8
8002e6d6:	df 08 17 7f 	jeq %d8,0,8002e504 <__sfvwrite_r+0x60>
8002e6da:	df 09 ba 7f 	jeq %d9,0,8002e64e <__sfvwrite_r+0x1aa>
8002e6de:	df 02 d0 ff 	jne %d2,0,8002e67e <__sfvwrite_r+0x1da>
8002e6e2:	1d ff be ff 	j 8002e65e <__sfvwrite_r+0x1ba>
8002e6e6:	60 24       	mov.a %a4,%d2
8002e6e8:	60 a5       	mov.a %a5,%d10
8002e6ea:	02 b4       	mov %d4,%d11
8002e6ec:	6d ff de c8 	call 800278a8 <memmove>
8002e6f0:	19 c2 08 00 	ld.w %d2,[%a12]8
8002e6f4:	d9 c2 08 00 	lea %a2,[%a12]8
8002e6f8:	a2 b2       	sub %d2,%d11
8002e6fa:	02 b8       	mov %d8,%d11
8002e6fc:	74 22       	st.w [%a2],%d2
8002e6fe:	54 c2       	ld.w %d2,[%a12]
8002e700:	42 b2       	add %d2,%d11
8002e702:	74 c2       	st.w [%a12],%d2
8002e704:	1d ff dc ff 	j 8002e6bc <__sfvwrite_r+0x218>
8002e708:	60 24       	mov.a %a4,%d2
8002e70a:	60 a5       	mov.a %a5,%d10
8002e70c:	02 84       	mov %d4,%d8
8002e70e:	6d ff cd c8 	call 800278a8 <memmove>
8002e712:	54 c2       	ld.w %d2,[%a12]
8002e714:	40 c5       	mov.aa %a5,%a12
8002e716:	42 82       	add %d2,%d8
8002e718:	40 f4       	mov.aa %a4,%a15
8002e71a:	74 c2       	st.w [%a12],%d2
8002e71c:	6d ff 97 e4 	call 8002b04a <_fflush_r>
8002e720:	df 02 ce 7f 	jeq %d2,0,8002e6bc <__sfvwrite_r+0x218>
8002e724:	1d ff 8d ff 	j 8002e63e <__sfvwrite_r+0x19a>
8002e728:	19 c4 10 00 	ld.w %d4,[%a12]16
8002e72c:	3f 34 1b 80 	jlt.u %d4,%d3,8002e762 <__sfvwrite_r+0x2be>
8002e730:	19 c4 14 00 	ld.w %d4,[%a12]20
8002e734:	3f 48 17 80 	jlt.u %d8,%d4,8002e762 <__sfvwrite_r+0x2be>
8002e738:	82 f2       	mov %d2,-1
8002e73a:	06 f2       	sh %d2,-1
8002e73c:	0b 28 90 21 	min.u %d2,%d8,%d2
8002e740:	4b 42 01 22 	div %e2,%d2,%d4
8002e744:	99 c2 24 00 	ld.a %a2,[%a12]36
8002e748:	99 c5 1c 00 	ld.a %a5,[%a12]28
8002e74c:	e2 24       	mul %d4,%d2
8002e74e:	60 a6       	mov.a %a6,%d10
8002e750:	40 f4       	mov.aa %a4,%a15
8002e752:	2d 02 00 00 	calli %a2
8002e756:	bf 12 74 7f 	jlt %d2,1,8002e63e <__sfvwrite_r+0x19a>
8002e75a:	02 29       	mov %d9,%d2
8002e75c:	a2 98       	sub %d8,%d9
8002e75e:	1d ff 49 ff 	j 8002e5f0 <__sfvwrite_r+0x14c>
8002e762:	0b 82 90 91 	min.u %d9,%d2,%d8
8002e766:	60 34       	mov.a %a4,%d3
8002e768:	60 a5       	mov.a %a5,%d10
8002e76a:	02 94       	mov %d4,%d9
8002e76c:	6d ff 9e c8 	call 800278a8 <memmove>
8002e770:	19 c2 08 00 	ld.w %d2,[%a12]8
8002e774:	54 c3       	ld.w %d3,[%a12]
8002e776:	a2 92       	sub %d2,%d9
8002e778:	42 93       	add %d3,%d9
8002e77a:	d9 c2 08 00 	lea %a2,[%a12]8
8002e77e:	74 22       	st.w [%a2],%d2
8002e780:	74 c3       	st.w [%a12],%d3
8002e782:	df 02 ed ff 	jne %d2,0,8002e75c <__sfvwrite_r+0x2b8>
8002e786:	40 c5       	mov.aa %a5,%a12
8002e788:	40 f4       	mov.aa %a4,%a15
8002e78a:	6d ff 60 e4 	call 8002b04a <_fflush_r>
8002e78e:	df 02 58 ff 	jne %d2,0,8002e63e <__sfvwrite_r+0x19a>
8002e792:	a2 98       	sub %d8,%d9
8002e794:	1d ff 2e ff 	j 8002e5f0 <__sfvwrite_r+0x14c>
8002e798:	02 89       	mov %d9,%d8
8002e79a:	02 8b       	mov %d11,%d8
8002e79c:	1d ff 1a ff 	j 8002e5d0 <__sfvwrite_r+0x12c>
8002e7a0:	60 65       	mov.a %a5,%d6
8002e7a2:	40 f4       	mov.aa %a4,%a15
8002e7a4:	6d ff a3 f2 	call 8002ccea <_realloc_r>
8002e7a8:	80 29       	mov.d %d9,%a2
8002e7aa:	df 09 06 ff 	jne %d9,0,8002e5b6 <__sfvwrite_r+0x112>
8002e7ae:	99 c5 10 00 	ld.a %a5,[%a12]16
8002e7b2:	40 f4       	mov.aa %a4,%a15
8002e7b4:	6d ff 91 d0 	call 800288d6 <_free_r>
8002e7b8:	3b c0 00 30 	mov %d3,12
8002e7bc:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002e7c0:	68 03       	st.w [%a15]0,%d3
8002e7c2:	8f 02 c8 21 	andn %d2,%d2,128
8002e7c6:	1d ff 3e ff 	j 8002e642 <__sfvwrite_r+0x19e>
8002e7ca:	3b c0 00 20 	mov %d2,12
8002e7ce:	68 02       	st.w [%a15]0,%d2
8002e7d0:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002e7d4:	1d ff 37 ff 	j 8002e642 <__sfvwrite_r+0x19e>

8002e7d8 <__swsetup_r>:
8002e7d8:	40 4d       	mov.aa %a13,%a4
8002e7da:	91 10 00 47 	movh.a %a4,28673
8002e7de:	99 44 50 aa 	ld.a %a4,[%a4]-22896 <7000a690 <_impure_ptr>>
8002e7e2:	40 5c       	mov.aa %a12,%a5
8002e7e4:	bd 04 06 00 	jz.a %a4,8002e7f0 <__swsetup_r+0x18>
8002e7e8:	19 42 34 00 	ld.w %d2,[%a4]52
8002e7ec:	df 02 60 00 	jeq %d2,0,8002e8ac <__swsetup_r+0xd4>
8002e7f0:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002e7f4:	6f 33 25 00 	jz.t %d3,3,8002e83e <__swsetup_r+0x66>
8002e7f8:	19 c4 10 00 	ld.w %d4,[%a12]16
8002e7fc:	df 04 2d 00 	jeq %d4,0,8002e856 <__swsetup_r+0x7e>
8002e800:	82 02       	mov %d2,0
8002e802:	6f 03 0c 80 	jnz.t %d3,0,8002e81a <__swsetup_r+0x42>
8002e806:	6f 13 04 80 	jnz.t %d3,1,8002e80e <__swsetup_r+0x36>
8002e80a:	19 c2 14 00 	ld.w %d2,[%a12]20
8002e80e:	59 c2 08 00 	st.w [%a12]8,%d2
8002e812:	82 02       	mov %d2,0
8002e814:	df 04 0d 00 	jeq %d4,0,8002e82e <__swsetup_r+0x56>
8002e818:	00 90       	ret 
8002e81a:	59 c2 08 00 	st.w [%a12]8,%d2
8002e81e:	19 c2 14 00 	ld.w %d2,[%a12]20
8002e822:	32 52       	rsub %d2
8002e824:	59 c2 18 00 	st.w [%a12]24,%d2
8002e828:	82 02       	mov %d2,0
8002e82a:	df 04 f7 ff 	jne %d4,0,8002e818 <__swsetup_r+0x40>
8002e82e:	6f 73 f5 7f 	jz.t %d3,7,8002e818 <__swsetup_r+0x40>
8002e832:	8f 03 44 31 	or %d3,%d3,64
8002e836:	82 f2       	mov %d2,-1
8002e838:	f9 c3 0c 00 	st.h [%a12]12,%d3
8002e83c:	00 90       	ret 
8002e83e:	6f 43 3b 00 	jz.t %d3,4,8002e8b4 <__swsetup_r+0xdc>
8002e842:	6f 23 1b 80 	jnz.t %d3,2,8002e878 <__swsetup_r+0xa0>
8002e846:	19 c4 10 00 	ld.w %d4,[%a12]16
8002e84a:	8f 83 40 31 	or %d3,%d3,8
8002e84e:	f9 c3 0c 00 	st.h [%a12]12,%d3
8002e852:	df 04 d7 ff 	jne %d4,0,8002e800 <__swsetup_r+0x28>
8002e856:	3b 00 28 20 	mov %d2,640
8002e85a:	26 32       	and %d2,%d3
8002e85c:	3b 00 20 50 	mov %d5,512
8002e860:	5f 52 d0 7f 	jeq %d2,%d5,8002e800 <__swsetup_r+0x28>
8002e864:	40 c5       	mov.aa %a5,%a12
8002e866:	40 d4       	mov.aa %a4,%a13
8002e868:	6d 00 b5 00 	call 8002e9d2 <__smakebuf_r>
8002e86c:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002e870:	19 c4 10 00 	ld.w %d4,[%a12]16
8002e874:	1d ff c6 ff 	j 8002e800 <__swsetup_r+0x28>
8002e878:	99 c5 30 00 	ld.a %a5,[%a12]48
8002e87c:	bd 05 0e 00 	jz.a %a5,8002e898 <__swsetup_r+0xc0>
8002e880:	d9 c2 00 10 	lea %a2,[%a12]64
8002e884:	7d 25 07 00 	jeq.a %a5,%a2,8002e892 <__swsetup_r+0xba>
8002e888:	40 d4       	mov.aa %a4,%a13
8002e88a:	6d ff 26 d0 	call 800288d6 <_free_r>
8002e88e:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002e892:	82 02       	mov %d2,0
8002e894:	59 c2 30 00 	st.w [%a12]48,%d2
8002e898:	82 02       	mov %d2,0
8002e89a:	19 c4 10 00 	ld.w %d4,[%a12]16
8002e89e:	8f 43 c2 31 	andn %d3,%d3,36
8002e8a2:	59 c2 04 00 	st.w [%a12]4,%d2
8002e8a6:	74 c4       	st.w [%a12],%d4
8002e8a8:	1d ff d1 ff 	j 8002e84a <__swsetup_r+0x72>
8002e8ac:	6d ff ff cd 	call 800284aa <__sinit>
8002e8b0:	1d ff a0 ff 	j 8002e7f0 <__swsetup_r+0x18>
8002e8b4:	3b 90 00 20 	mov %d2,9
8002e8b8:	8f 03 44 31 	or %d3,%d3,64
8002e8bc:	74 d2       	st.w [%a13],%d2
8002e8be:	f9 c3 0c 00 	st.h [%a12]12,%d3
8002e8c2:	82 f2       	mov %d2,-1
8002e8c4:	00 90       	ret 

8002e8c6 <__fputwc>:
8002e8c6:	20 08       	sub.a %sp,8
8002e8c8:	80 4a       	mov.d %d10,%a4
8002e8ca:	02 4b       	mov %d11,%d4
8002e8cc:	40 5c       	mov.aa %a12,%a5
8002e8ce:	6d ff 32 e4 	call 8002b132 <__locale_mb_cur_max>
8002e8d2:	df 12 08 80 	jne %d2,1,8002e8e2 <__fputwc+0x1c>
8002e8d6:	1b fb ff 3f 	addi %d3,%d11,-1
8002e8da:	8b f3 af 32 	ge.u %d3,%d3,255
8002e8de:	df 03 3c 00 	jeq %d3,0,8002e956 <__fputwc+0x90>
8002e8e2:	60 a4       	mov.a %a4,%d10
8002e8e4:	d9 c6 1c 10 	lea %a6,[%a12]92
8002e8e8:	02 b4       	mov %d4,%d11
8002e8ea:	d9 a5 07 00 	lea %a5,[%sp]7
8002e8ee:	6d 00 55 00 	call 8002e998 <_wcrtomb_r>
8002e8f2:	02 28       	mov %d8,%d2
8002e8f4:	df f2 3b 00 	jeq %d2,-1,8002e96a <__fputwc+0xa4>
8002e8f8:	df 02 36 00 	jeq %d2,0,8002e964 <__fputwc+0x9e>
8002e8fc:	79 a5 07 00 	ld.b %d5,[%sp]7
8002e900:	d9 ae 08 00 	lea %a14,[%sp]8
8002e904:	82 09       	mov %d9,0
8002e906:	1d 00 0c 00 	j 8002e91e <__fputwc+0x58>
8002e90a:	d4 c2       	ld.a %a2,[%a12]
8002e90c:	d9 23 01 00 	lea %a3,[%a2]1
8002e910:	f4 c3       	st.a [%a12],%a3
8002e912:	34 24       	st.b [%a2],%d4
8002e914:	c2 19       	add %d9,1
8002e916:	7f 89 27 80 	jge.u %d9,%d8,8002e964 <__fputwc+0x9e>
8002e91a:	09 e5 01 00 	ld.b %d5,[%a14+]1
8002e91e:	19 c2 08 00 	ld.w %d2,[%a12]8
8002e922:	d9 c2 08 00 	lea %a2,[%a12]8
8002e926:	1b f2 ff 3f 	addi %d3,%d2,-1
8002e92a:	8f f5 0f 41 	and %d4,%d5,255
8002e92e:	74 23       	st.w [%a2],%d3
8002e930:	ff 03 ed 7f 	jge %d3,0,8002e90a <__fputwc+0x44>
8002e934:	19 c6 18 00 	ld.w %d6,[%a12]24
8002e938:	8b a5 20 22 	ne %d2,%d5,10
8002e93c:	0b 63 40 22 	and.ge %d2,%d3,%d6
8002e940:	df 02 e5 ff 	jne %d2,0,8002e90a <__fputwc+0x44>
8002e944:	60 a4       	mov.a %a4,%d10
8002e946:	40 c5       	mov.aa %a5,%a12
8002e948:	6d 00 af 00 	call 8002eaa6 <__swbuf_r>
8002e94c:	df f2 e4 ff 	jne %d2,-1,8002e914 <__fputwc+0x4e>
8002e950:	02 28       	mov %d8,%d2
8002e952:	02 82       	mov %d2,%d8
8002e954:	00 90       	ret 
8002e956:	37 0b 48 50 	extr %d5,%d11,0,8
8002e95a:	02 28       	mov %d8,%d2
8002e95c:	e9 a5 07 00 	st.b [%sp]7,%d5
8002e960:	1d ff d0 ff 	j 8002e900 <__fputwc+0x3a>
8002e964:	02 b8       	mov %d8,%d11
8002e966:	02 82       	mov %d2,%d8
8002e968:	00 90       	ret 
8002e96a:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002e96e:	8f 02 44 21 	or %d2,%d2,64
8002e972:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002e976:	1d ff ee ff 	j 8002e952 <__fputwc+0x8c>

8002e97a <_fputwc_r>:
8002e97a:	c9 52 0c 00 	ld.h %d2,[%a5]12
8002e97e:	6f d2 0a 80 	jnz.t %d2,13,8002e992 <_fputwc_r+0x18>
8002e982:	b7 f2 81 26 	insert %d2,%d2,15,13,1
8002e986:	f9 52 0c 00 	st.h [%a5]12,%d2
8002e98a:	b7 10 a1 26 	imask %e2,1,13,1
8002e98e:	49 52 64 18 	ldmst [%a5]100,%e2
8002e992:	6d ff 9a ff 	call 8002e8c6 <__fputwc>
8002e996:	00 90       	ret 

8002e998 <_wcrtomb_r>:
8002e998:	91 10 00 27 	movh.a %a2,28673
8002e99c:	99 22 90 2a 	ld.a %a2,[%a2]-22384 <7000a890 <__global_locale+0xe0>>
8002e9a0:	20 10       	sub.a %sp,16
8002e9a2:	40 4c       	mov.aa %a12,%a4
8002e9a4:	40 6d       	mov.aa %a13,%a6
8002e9a6:	bd 05 0d 00 	jz.a %a5,8002e9c0 <_wcrtomb_r+0x28>
8002e9aa:	2d 02 00 00 	calli %a2
8002e9ae:	df f2 03 00 	jeq %d2,-1,8002e9b4 <_wcrtomb_r+0x1c>
8002e9b2:	00 90       	ret 
8002e9b4:	82 03       	mov %d3,0
8002e9b6:	74 d3       	st.w [%a13],%d3
8002e9b8:	3b a0 08 30 	mov %d3,138
8002e9bc:	74 c3       	st.w [%a12],%d3
8002e9be:	00 90       	ret 
8002e9c0:	82 04       	mov %d4,0
8002e9c2:	d9 a5 06 00 	lea %a5,[%sp]6
8002e9c6:	2d 02 00 00 	calli %a2
8002e9ca:	df f2 f4 ff 	jne %d2,-1,8002e9b2 <_wcrtomb_r+0x1a>
8002e9ce:	1d ff f3 ff 	j 8002e9b4 <_wcrtomb_r+0x1c>

8002e9d2 <__smakebuf_r>:
8002e9d2:	c9 52 0c 00 	ld.h %d2,[%a5]12
8002e9d6:	20 48       	sub.a %sp,72
8002e9d8:	80 49       	mov.d %d9,%a4
8002e9da:	40 5c       	mov.aa %a12,%a5
8002e9dc:	6f 12 0b 00 	jz.t %d2,1,8002e9f2 <__smakebuf_r+0x20>
8002e9e0:	82 12       	mov %d2,1
8002e9e2:	d9 c2 03 10 	lea %a2,[%a12]67
8002e9e6:	f4 c2       	st.a [%a12],%a2
8002e9e8:	b5 c2 10 00 	st.a [%a12]16,%a2
8002e9ec:	59 c2 14 00 	st.w [%a12]20,%d2
8002e9f0:	00 90       	ret 
8002e9f2:	c9 54 0e 00 	ld.h %d4,[%a5]14
8002e9f6:	bf 04 2d 00 	jlt %d4,0,8002ea50 <__smakebuf_r+0x7e>
8002e9fa:	40 a5       	mov.aa %a5,%sp
8002e9fc:	6d 00 d5 00 	call 8002eba6 <_fstat_r>
8002ea00:	19 a4 04 00 	ld.w %d4,[%sp]4
8002ea04:	bb 00 00 3f 	mov.u %d3,61440
8002ea08:	26 43       	and %d3,%d4
8002ea0a:	3b 00 00 b2 	mov %d11,8192
8002ea0e:	0b b3 00 b1 	eq %d11,%d3,%d11
8002ea12:	3b 00 40 80 	mov %d8,1024
8002ea16:	3b 00 80 a0 	mov %d10,2048
8002ea1a:	bf 02 19 00 	jlt %d2,0,8002ea4c <__smakebuf_r+0x7a>
8002ea1e:	60 94       	mov.a %a4,%d9
8002ea20:	02 84       	mov %d4,%d8
8002ea22:	6d ff 43 c9 	call 80027ca8 <_malloc_r>
8002ea26:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002ea2a:	bd 02 23 00 	jz.a %a2,8002ea70 <__smakebuf_r+0x9e>
8002ea2e:	8f 02 48 21 	or %d2,%d2,128
8002ea32:	f4 c2       	st.a [%a12],%a2
8002ea34:	b5 c2 10 00 	st.a [%a12]16,%a2
8002ea38:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002ea3c:	59 c8 14 00 	st.w [%a12]20,%d8
8002ea40:	df 0b 20 80 	jne %d11,0,8002ea80 <__smakebuf_r+0xae>
8002ea44:	a6 a2       	or %d2,%d10
8002ea46:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002ea4a:	00 90       	ret 
8002ea4c:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002ea50:	8f 02 08 21 	and %d2,%d2,128
8002ea54:	3b 00 40 80 	mov %d8,1024
8002ea58:	ab 08 a4 82 	seln %d8,%d2,%d8,64
8002ea5c:	60 94       	mov.a %a4,%d9
8002ea5e:	02 84       	mov %d4,%d8
8002ea60:	6d ff 24 c9 	call 80027ca8 <_malloc_r>
8002ea64:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002ea68:	82 0b       	mov %d11,0
8002ea6a:	82 0a       	mov %d10,0
8002ea6c:	bd 02 e1 ff 	jnz.a %a2,8002ea2e <__smakebuf_r+0x5c>
8002ea70:	6f 92 ed ff 	jnz.t %d2,9,8002ea4a <__smakebuf_r+0x78>
8002ea74:	b7 22 02 20 	insert %d2,%d2,2,0,2
8002ea78:	f9 c2 0c 00 	st.h [%a12]12,%d2
8002ea7c:	1d ff b2 ff 	j 8002e9e0 <__smakebuf_r+0xe>
8002ea80:	c9 c4 0e 00 	ld.h %d4,[%a12]14
8002ea84:	60 94       	mov.a %a4,%d9
8002ea86:	6d 00 a2 00 	call 8002ebca <_isatty_r>
8002ea8a:	df 02 06 80 	jne %d2,0,8002ea96 <__smakebuf_r+0xc4>
8002ea8e:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002ea92:	1d ff d9 ff 	j 8002ea44 <__smakebuf_r+0x72>
8002ea96:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002ea9a:	b7 12 02 20 	insert %d2,%d2,1,0,2
8002ea9e:	37 02 50 20 	extr %d2,%d2,0,16
8002eaa2:	1d ff d1 ff 	j 8002ea44 <__smakebuf_r+0x72>

8002eaa6 <__swbuf_r>:
8002eaa6:	20 08       	sub.a %sp,8
8002eaa8:	40 4d       	mov.aa %a13,%a4
8002eaaa:	02 48       	mov %d8,%d4
8002eaac:	40 5c       	mov.aa %a12,%a5
8002eaae:	bd 04 06 00 	jz.a %a4,8002eaba <__swbuf_r+0x14>
8002eab2:	19 42 34 00 	ld.w %d2,[%a4]52
8002eab6:	df 02 74 00 	jeq %d2,0,8002eb9e <__swbuf_r+0xf8>
8002eaba:	19 c2 18 00 	ld.w %d2,[%a12]24
8002eabe:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002eac2:	59 c2 08 00 	st.w [%a12]8,%d2
8002eac6:	6f 33 2d 00 	jz.t %d3,3,8002eb20 <__swbuf_r+0x7a>
8002eaca:	19 c2 10 00 	ld.w %d2,[%a12]16
8002eace:	df 02 29 00 	jeq %d2,0,8002eb20 <__swbuf_r+0x7a>
8002ead2:	8f f8 0f 91 	and %d9,%d8,255
8002ead6:	8f f8 0f 81 	and %d8,%d8,255
8002eada:	6f d3 33 00 	jz.t %d3,13,8002eb40 <__swbuf_r+0x9a>
8002eade:	d4 c2       	ld.a %a2,[%a12]
8002eae0:	80 23       	mov.d %d3,%a2
8002eae2:	0b 23 80 20 	sub %d2,%d3,%d2
8002eae6:	19 c3 14 00 	ld.w %d3,[%a12]20
8002eaea:	7f 32 47 00 	jge %d2,%d3,8002eb78 <__swbuf_r+0xd2>
8002eaee:	1b 12 00 30 	addi %d3,%d2,1
8002eaf2:	19 c2 08 00 	ld.w %d2,[%a12]8
8002eaf6:	d9 c3 08 00 	lea %a3,[%a12]8
8002eafa:	c2 f2       	add %d2,-1
8002eafc:	74 32       	st.w [%a3],%d2
8002eafe:	d9 23 01 00 	lea %a3,[%a2]1
8002eb02:	f4 c3       	st.a [%a12],%a3
8002eb04:	34 29       	st.b [%a2],%d9
8002eb06:	19 c2 14 00 	ld.w %d2,[%a12]20
8002eb0a:	5f 32 41 00 	jeq %d2,%d3,8002eb8c <__swbuf_r+0xe6>
8002eb0e:	c9 c2 0c 00 	ld.h %d2,[%a12]12
8002eb12:	8b a8 00 32 	eq %d3,%d8,10
8002eb16:	26 32       	and %d2,%d3
8002eb18:	df 02 3a 80 	jne %d2,0,8002eb8c <__swbuf_r+0xe6>
8002eb1c:	02 82       	mov %d2,%d8
8002eb1e:	00 90       	ret 
8002eb20:	40 c5       	mov.aa %a5,%a12
8002eb22:	40 d4       	mov.aa %a4,%a13
8002eb24:	6d ff 5a fe 	call 8002e7d8 <__swsetup_r>
8002eb28:	df 02 38 80 	jne %d2,0,8002eb98 <__swbuf_r+0xf2>
8002eb2c:	c9 c3 0c 00 	ld.h %d3,[%a12]12
8002eb30:	8f f8 0f 91 	and %d9,%d8,255
8002eb34:	19 c2 10 00 	ld.w %d2,[%a12]16
8002eb38:	8f f8 0f 81 	and %d8,%d8,255
8002eb3c:	6f d3 d1 ff 	jnz.t %d3,13,8002eade <__swbuf_r+0x38>
8002eb40:	b7 f3 81 36 	insert %d3,%d3,15,13,1
8002eb44:	89 ae c0 09 	st.da [%sp],%a14
8002eb48:	c5 02 00 02 	lea %a2,2000 <LCF_CSA0_SIZE>
8002eb4c:	b5 a2 04 00 	st.a [%sp]4,%a2
8002eb50:	f9 c3 0c 00 	st.h [%a12]12,%d3
8002eb54:	82 03       	mov %d3,0
8002eb56:	d9 c2 24 10 	lea %a2,[%a12]100
8002eb5a:	74 a3       	st.w [%sp],%d3
8002eb5c:	09 ae c0 09 	ld.da %a14,[%sp]
8002eb60:	80 e4       	mov.d %d4,%a14
8002eb62:	80 f5       	mov.d %d5,%a15
8002eb64:	49 24 40 08 	ldmst [%a2]0,%e4
8002eb68:	d4 c2       	ld.a %a2,[%a12]
8002eb6a:	80 23       	mov.d %d3,%a2
8002eb6c:	0b 23 80 20 	sub %d2,%d3,%d2
8002eb70:	19 c3 14 00 	ld.w %d3,[%a12]20
8002eb74:	3f 32 bd 7f 	jlt %d2,%d3,8002eaee <__swbuf_r+0x48>
8002eb78:	40 c5       	mov.aa %a5,%a12
8002eb7a:	40 d4       	mov.aa %a4,%a13
8002eb7c:	6d ff 67 e2 	call 8002b04a <_fflush_r>
8002eb80:	df 02 0c 80 	jne %d2,0,8002eb98 <__swbuf_r+0xf2>
8002eb84:	d4 c2       	ld.a %a2,[%a12]
8002eb86:	82 13       	mov %d3,1
8002eb88:	1d ff b5 ff 	j 8002eaf2 <__swbuf_r+0x4c>
8002eb8c:	40 c5       	mov.aa %a5,%a12
8002eb8e:	40 d4       	mov.aa %a4,%a13
8002eb90:	6d ff 5d e2 	call 8002b04a <_fflush_r>
8002eb94:	df 02 c4 7f 	jeq %d2,0,8002eb1c <__swbuf_r+0x76>
8002eb98:	82 f8       	mov %d8,-1
8002eb9a:	1d ff c1 ff 	j 8002eb1c <__swbuf_r+0x76>
8002eb9e:	6d ff 86 cc 	call 800284aa <__sinit>
8002eba2:	1d ff 8c ff 	j 8002eaba <__swbuf_r+0x14>

8002eba6 <_fstat_r>:
8002eba6:	82 02       	mov %d2,0
8002eba8:	40 4d       	mov.aa %a13,%a4
8002ebaa:	91 10 00 c7 	movh.a %a12,28673
8002ebae:	40 54       	mov.aa %a4,%a5
8002ebb0:	59 c2 80 ba 	st.w [%a12]-21824 <7000aac0 <errno>>,%d2
8002ebb4:	6d 00 1f 00 	call 8002ebf2 <fstat>
8002ebb8:	df f2 03 00 	jeq %d2,-1,8002ebbe <_fstat_r+0x18>
8002ebbc:	00 90       	ret 
8002ebbe:	19 c3 80 ba 	ld.w %d3,[%a12]-21824
8002ebc2:	df 03 fd 7f 	jeq %d3,0,8002ebbc <_fstat_r+0x16>
8002ebc6:	74 d3       	st.w [%a13],%d3
8002ebc8:	00 90       	ret 

8002ebca <_isatty_r>:
8002ebca:	82 02       	mov %d2,0
8002ebcc:	91 10 00 c7 	movh.a %a12,28673
8002ebd0:	40 4d       	mov.aa %a13,%a4
8002ebd2:	59 c2 80 ba 	st.w [%a12]-21824 <7000aac0 <errno>>,%d2
8002ebd6:	6d 00 0b 00 	call 8002ebec <isatty>
8002ebda:	df f2 03 00 	jeq %d2,-1,8002ebe0 <_isatty_r+0x16>
8002ebde:	00 90       	ret 
8002ebe0:	19 c3 80 ba 	ld.w %d3,[%a12]-21824
8002ebe4:	df 03 fd 7f 	jeq %d3,0,8002ebde <_isatty_r+0x14>
8002ebe8:	74 d3       	st.w [%a13],%d3
8002ebea:	00 90       	ret 

8002ebec <isatty>:
8002ebec:	8b 34 60 22 	lt.u %d2,%d4,3
8002ebf0:	00 90       	ret 

8002ebf2 <fstat>:
8002ebf2:	ff 34 0c 80 	jge.u %d4,3,8002ec0a <fstat+0x18>
8002ebf6:	3b 00 00 22 	mov %d2,8192
8002ebfa:	59 42 04 00 	st.w [%a4]4,%d2
8002ebfe:	3b 00 40 20 	mov %d2,1024
8002ec02:	59 42 38 00 	st.w [%a4]56,%d2
8002ec06:	82 02       	mov %d2,0
8002ec08:	00 90       	ret 
8002ec0a:	6d ff fd cd 	call 80028804 <__errno>
8002ec0e:	3b 90 00 20 	mov %d2,9
8002ec12:	74 22       	st.w [%a2],%d2
8002ec14:	82 f2       	mov %d2,-1
8002ec16:	00 90       	ret 

8002ec18 <close>:
8002ec18:	82 2c       	mov %d12,2
8002ec1a:	1d 00 0d 00 	j 8002ec34 <___virtio>
8002ec1e:	00 90       	ret 

8002ec20 <lseek>:
8002ec20:	82 3c       	mov %d12,3
8002ec22:	1d 00 09 00 	j 8002ec34 <___virtio>
8002ec26:	00 90       	ret 

8002ec28 <read>:
8002ec28:	82 4c       	mov %d12,4
8002ec2a:	1d 00 05 00 	j 8002ec34 <___virtio>
8002ec2e:	00 90       	ret 

8002ec30 <__virtio_dummy_hnd>:
8002ec30:	5f 76 69 6f 	jeq %d6,%d7,8002cb02 <__mdiff+0x9c>

8002ec34 <___virtio>:
8002ec34:	00 a0       	debug 
8002ec36:	6d ff e7 cd 	call 80028804 <__errno>
8002ec3a:	74 2c       	st.w [%a2],%d12
8002ec3c:	02 b2       	mov %d2,%d11
8002ec3e:	00 90       	ret 

8002ec40 <write>:
8002ec40:	82 5c       	mov %d12,5
8002ec42:	1d ff f9 ff 	j 8002ec34 <___virtio>
8002ec46:	00 90       	ret 

8002ec48 <abort>:
8002ec48:	00 a0       	debug 
8002ec4a:	7b e0 ea 2d 	movh %d2,57006
8002ec4e:	1b f2 ee 2b 	addi %d2,%d2,-16657
8002ec52:	60 2e       	mov.a %a14,%d2
8002ec54:	1d 00 04 00 	j 8002ec5c <_exit>
8002ec58:	1d 00 00 00 	j 8002ec58 <abort+0x10>

8002ec5c <_exit>:
8002ec5c:	df 04 06 00 	jeq %d4,0,8002ec68 <_exit+0xc>
8002ec60:	60 4e       	mov.a %a14,%d4
8002ec62:	00 a0       	debug 
8002ec64:	1d 00 00 00 	j 8002ec64 <_exit+0x8>
8002ec68:	bb d0 00 29 	mov.u %d2,36877
8002ec6c:	60 2e       	mov.a %a14,%d2
8002ec6e:	00 a0       	debug 
8002ec70:	1d ff fa ff 	j 8002ec64 <_exit+0x8>

8002ec74 <sbrk>:
8002ec74:	91 10 00 37 	movh.a %a3,28673
8002ec78:	99 32 a0 4a 	ld.a %a2,[%a3]-22240 <7000a920 <heap_top.0>>
8002ec7c:	91 10 00 47 	movh.a %a4,28673
8002ec80:	80 22       	mov.d %d2,%a2
8002ec82:	42 24       	add %d4,%d2
8002ec84:	80 42       	mov.d %d2,%a4
8002ec86:	1b 42 62 25 	addi %d2,%d2,22052
8002ec8a:	3f 42 0c 80 	jlt.u %d2,%d4,8002eca2 <sbrk+0x2e>
8002ec8e:	91 10 00 47 	movh.a %a4,28673
8002ec92:	80 42       	mov.d %d2,%a4
8002ec94:	1b 42 62 24 	addi %d2,%d2,17956
8002ec98:	3f 24 0d 80 	jlt.u %d4,%d2,8002ecb2 <sbrk+0x3e>
8002ec9c:	59 34 a0 4a 	st.w [%a3]-22240 <7000a920 <heap_top.0>>,%d4
8002eca0:	00 90       	ret 
8002eca2:	6d ff b1 cd 	call 80028804 <__errno>
8002eca6:	3b c0 00 20 	mov %d2,12
8002ecaa:	74 22       	st.w [%a2],%d2
8002ecac:	a0 02       	mov.a %a2,0
8002ecae:	b0 f2       	add.a %a2,-1
8002ecb0:	00 90       	ret 
8002ecb2:	6d ff cb ff 	call 8002ec48 <abort>

8002ecb6 <__divdf3>:
8002ecb6:	20 38       	sub.a %sp,56
8002ecb8:	d9 a5 10 00 	lea %a5,[%sp]16
8002ecbc:	40 a4       	mov.aa %a4,%sp
8002ecbe:	89 a4 40 09 	st.d [%sp],%e4
8002ecc2:	89 a6 48 09 	st.d [%sp]8,%e6
8002ecc6:	6d ff 29 c7 	call 80027b18 <__unpack_d>
8002ecca:	d9 a5 24 00 	lea %a5,[%sp]36
8002ecce:	d9 a4 08 00 	lea %a4,[%sp]8
8002ecd2:	6d ff 23 c7 	call 80027b18 <__unpack_d>
8002ecd6:	19 a2 10 00 	ld.w %d2,[%sp]16
8002ecda:	ff 22 07 80 	jge.u %d2,2,8002ece8 <__divdf3+0x32>
8002ecde:	d9 a4 10 00 	lea %a4,[%sp]16
8002ece2:	6d ff 4c c6 	call 8002797a <__pack_d>
8002ece6:	00 90       	ret 
8002ece8:	19 a3 24 00 	ld.w %d3,[%sp]36
8002ecec:	d9 a4 24 00 	lea %a4,[%sp]36
8002ecf0:	bf 23 f9 ff 	jlt.u %d3,2,8002ece2 <__divdf3+0x2c>
8002ecf4:	19 a5 14 00 	ld.w %d5,[%sp]20
8002ecf8:	19 a4 28 00 	ld.w %d4,[%sp]40
8002ecfc:	c6 54       	xor %d4,%d5
8002ecfe:	59 a4 14 00 	st.w [%sp]20,%d4
8002ed02:	1b e2 ff 4f 	addi %d4,%d2,-2
8002ed06:	8f 24 c0 41 	andn %d4,%d4,2
8002ed0a:	df 04 0a 80 	jne %d4,0,8002ed1e <__divdf3+0x68>
8002ed0e:	91 00 00 48 	movh.a %a4,32768
8002ed12:	d9 44 bc 93 	lea %a4,[%a4]14972 <80003a7c <__thenan_df>>
8002ed16:	5f 32 e4 ff 	jne %d2,%d3,8002ecde <__divdf3+0x28>
8002ed1a:	1d ff e4 ff 	j 8002ece2 <__divdf3+0x2c>
8002ed1e:	df 43 51 00 	jeq %d3,4,8002edc0 <__divdf3+0x10a>
8002ed22:	df 23 5a 00 	jeq %d3,2,8002edd6 <__divdf3+0x120>
8002ed26:	19 a3 18 00 	ld.w %d3,[%sp]24
8002ed2a:	19 a2 2c 00 	ld.w %d2,[%sp]44
8002ed2e:	09 a4 70 09 	ld.d %e4,[%sp]48
8002ed32:	0b 23 80 00 	sub %d0,%d3,%d2
8002ed36:	09 a2 5c 09 	ld.d %e2,[%sp]28
8002ed3a:	0b 53 00 61 	eq %d6,%d3,%d5
8002ed3e:	02 67       	mov %d7,%d6
8002ed40:	0b 42 50 72 	and.ge.u %d7,%d2,%d4
8002ed44:	59 a0 18 00 	st.w [%sp]24,%d0
8002ed48:	0b 35 a0 72 	or.lt.u %d7,%d5,%d3
8002ed4c:	df 07 0b 80 	jne %d7,0,8002ed62 <__divdf3+0xac>
8002ed50:	1b f0 ff 6f 	addi %d6,%d0,-1
8002ed54:	77 23 80 30 	dextr %d3,%d3,%d2,1
8002ed58:	06 12       	sh %d2,1
8002ed5a:	59 a6 18 00 	st.w [%sp]24,%d6
8002ed5e:	0b 53 00 61 	eq %d6,%d3,%d5
8002ed62:	3b d0 03 10 	mov %d1,61
8002ed66:	d2 08       	mov %e8,0
8002ed68:	82 00       	mov %d0,0
8002ed6a:	7b 00 00 71 	movh %d7,4096
8002ed6e:	1d 00 04 00 	j 8002ed76 <__divdf3+0xc0>
8002ed72:	0b 53 00 61 	eq %d6,%d3,%d5
8002ed76:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
8002ed7a:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
8002ed7e:	df 06 0c 80 	jne %d6,0,8002ed96 <__divdf3+0xe0>
8002ed82:	0f 08 a0 a0 	or %d10,%d8,%d0
8002ed86:	0f 79 a0 60 	or %d6,%d9,%d7
8002ed8a:	0b 42 c0 20 	subx %d2,%d2,%d4
8002ed8e:	0b a6 10 88 	mov %e8,%d6,%d10
8002ed92:	0b 53 d0 30 	subc %d3,%d3,%d5
8002ed96:	c2 f1       	add %d1,-1
8002ed98:	77 07 80 0f 	dextr %d0,%d7,%d0,31
8002ed9c:	77 23 80 30 	dextr %d3,%d3,%d2,1
8002eda0:	06 f7       	sh %d7,-1
8002eda2:	06 12       	sh %d2,1
8002eda4:	df 01 e7 ff 	jne %d1,0,8002ed72 <__divdf3+0xbc>
8002eda8:	8f f8 0f 41 	and %d4,%d8,255
8002edac:	8b 04 28 42 	ne %d4,%d4,128
8002edb0:	df 04 1a 00 	jeq %d4,0,8002ede4 <__divdf3+0x12e>
8002edb4:	59 a8 1c 00 	st.w [%sp]28,%d8
8002edb8:	59 a9 20 00 	st.w [%sp]32,%d9
8002edbc:	1d ff 91 ff 	j 8002ecde <__divdf3+0x28>
8002edc0:	82 02       	mov %d2,0
8002edc2:	a0 02       	mov.a %a2,0
8002edc4:	a0 03       	mov.a %a3,0
8002edc6:	89 a2 dc 09 	st.da [%sp]28,%a2
8002edca:	59 a2 18 00 	st.w [%sp]24,%d2
8002edce:	d9 a4 10 00 	lea %a4,[%sp]16
8002edd2:	1d ff 88 ff 	j 8002ece2 <__divdf3+0x2c>
8002edd6:	82 42       	mov %d2,4
8002edd8:	d9 a4 10 00 	lea %a4,[%sp]16
8002eddc:	59 a2 10 00 	st.w [%sp]16,%d2
8002ede0:	1d ff 81 ff 	j 8002ece2 <__divdf3+0x2c>
8002ede4:	a6 32       	or %d2,%d3
8002ede6:	77 89 00 4c 	dextr %d4,%d9,%d8,24
8002edea:	8b 02 20 32 	ne %d3,%d2,0
8002edee:	0f 43 e0 20 	andn %d2,%d3,%d4
8002edf2:	df 02 e1 7f 	jeq %d2,0,8002edb4 <__divdf3+0xfe>
8002edf6:	8b 08 88 80 	addx %d8,%d8,128
8002edfa:	8b 09 a0 90 	addc %d9,%d9,0
8002edfe:	8f f8 cf 81 	andn %d8,%d8,255
8002ee02:	1d ff d9 ff 	j 8002edb4 <__divdf3+0xfe>

8002ee06 <__eqdf2>:
8002ee06:	20 38       	sub.a %sp,56
8002ee08:	d9 a5 10 00 	lea %a5,[%sp]16
8002ee0c:	40 a4       	mov.aa %a4,%sp
8002ee0e:	89 a4 40 09 	st.d [%sp],%e4
8002ee12:	89 a6 48 09 	st.d [%sp]8,%e6
8002ee16:	6d ff 81 c6 	call 80027b18 <__unpack_d>
8002ee1a:	d9 a5 24 00 	lea %a5,[%sp]36
8002ee1e:	d9 a4 08 00 	lea %a4,[%sp]8
8002ee22:	6d ff 7b c6 	call 80027b18 <__unpack_d>
8002ee26:	19 a3 10 00 	ld.w %d3,[%sp]16
8002ee2a:	82 12       	mov %d2,1
8002ee2c:	bf 23 0c 80 	jlt.u %d3,2,8002ee44 <__eqdf2+0x3e>
8002ee30:	19 a3 24 00 	ld.w %d3,[%sp]36
8002ee34:	bf 23 08 80 	jlt.u %d3,2,8002ee44 <__eqdf2+0x3e>
8002ee38:	d9 a5 24 00 	lea %a5,[%sp]36
8002ee3c:	d9 a4 10 00 	lea %a4,[%sp]16
8002ee40:	6d ff cb c6 	call 80027bd6 <__fpcmp_parts_d>
8002ee44:	00 90       	ret 

8002ee46 <__nedf2>:
8002ee46:	20 38       	sub.a %sp,56
8002ee48:	d9 a5 10 00 	lea %a5,[%sp]16
8002ee4c:	40 a4       	mov.aa %a4,%sp
8002ee4e:	89 a4 40 09 	st.d [%sp],%e4
8002ee52:	89 a6 48 09 	st.d [%sp]8,%e6
8002ee56:	6d ff 61 c6 	call 80027b18 <__unpack_d>
8002ee5a:	d9 a5 24 00 	lea %a5,[%sp]36
8002ee5e:	d9 a4 08 00 	lea %a4,[%sp]8
8002ee62:	6d ff 5b c6 	call 80027b18 <__unpack_d>
8002ee66:	19 a3 10 00 	ld.w %d3,[%sp]16
8002ee6a:	82 12       	mov %d2,1
8002ee6c:	bf 23 0c 80 	jlt.u %d3,2,8002ee84 <__nedf2+0x3e>
8002ee70:	19 a3 24 00 	ld.w %d3,[%sp]36
8002ee74:	bf 23 08 80 	jlt.u %d3,2,8002ee84 <__nedf2+0x3e>
8002ee78:	d9 a5 24 00 	lea %a5,[%sp]36
8002ee7c:	d9 a4 10 00 	lea %a4,[%sp]16
8002ee80:	6d ff ab c6 	call 80027bd6 <__fpcmp_parts_d>
8002ee84:	00 90       	ret 

8002ee86 <__gtdf2>:
8002ee86:	20 38       	sub.a %sp,56
8002ee88:	d9 a5 10 00 	lea %a5,[%sp]16
8002ee8c:	40 a4       	mov.aa %a4,%sp
8002ee8e:	89 a4 40 09 	st.d [%sp],%e4
8002ee92:	89 a6 48 09 	st.d [%sp]8,%e6
8002ee96:	6d ff 41 c6 	call 80027b18 <__unpack_d>
8002ee9a:	d9 a5 24 00 	lea %a5,[%sp]36
8002ee9e:	d9 a4 08 00 	lea %a4,[%sp]8
8002eea2:	6d ff 3b c6 	call 80027b18 <__unpack_d>
8002eea6:	19 a3 10 00 	ld.w %d3,[%sp]16
8002eeaa:	82 f2       	mov %d2,-1
8002eeac:	bf 23 0c 80 	jlt.u %d3,2,8002eec4 <__gtdf2+0x3e>
8002eeb0:	19 a3 24 00 	ld.w %d3,[%sp]36
8002eeb4:	bf 23 08 80 	jlt.u %d3,2,8002eec4 <__gtdf2+0x3e>
8002eeb8:	d9 a5 24 00 	lea %a5,[%sp]36
8002eebc:	d9 a4 10 00 	lea %a4,[%sp]16
8002eec0:	6d ff 8b c6 	call 80027bd6 <__fpcmp_parts_d>
8002eec4:	00 90       	ret 

8002eec6 <__ltdf2>:
8002eec6:	20 38       	sub.a %sp,56
8002eec8:	d9 a5 10 00 	lea %a5,[%sp]16
8002eecc:	40 a4       	mov.aa %a4,%sp
8002eece:	89 a4 40 09 	st.d [%sp],%e4
8002eed2:	89 a6 48 09 	st.d [%sp]8,%e6
8002eed6:	6d ff 21 c6 	call 80027b18 <__unpack_d>
8002eeda:	d9 a5 24 00 	lea %a5,[%sp]36
8002eede:	d9 a4 08 00 	lea %a4,[%sp]8
8002eee2:	6d ff 1b c6 	call 80027b18 <__unpack_d>
8002eee6:	19 a3 10 00 	ld.w %d3,[%sp]16
8002eeea:	82 12       	mov %d2,1
8002eeec:	bf 23 0c 80 	jlt.u %d3,2,8002ef04 <__ltdf2+0x3e>
8002eef0:	19 a3 24 00 	ld.w %d3,[%sp]36
8002eef4:	bf 23 08 80 	jlt.u %d3,2,8002ef04 <__ltdf2+0x3e>
8002eef8:	d9 a5 24 00 	lea %a5,[%sp]36
8002eefc:	d9 a4 10 00 	lea %a4,[%sp]16
8002ef00:	6d ff 6b c6 	call 80027bd6 <__fpcmp_parts_d>
8002ef04:	00 90       	ret 

8002ef06 <__ledf2>:
8002ef06:	20 38       	sub.a %sp,56
8002ef08:	d9 a5 10 00 	lea %a5,[%sp]16
8002ef0c:	40 a4       	mov.aa %a4,%sp
8002ef0e:	89 a4 40 09 	st.d [%sp],%e4
8002ef12:	89 a6 48 09 	st.d [%sp]8,%e6
8002ef16:	6d ff 01 c6 	call 80027b18 <__unpack_d>
8002ef1a:	d9 a5 24 00 	lea %a5,[%sp]36
8002ef1e:	d9 a4 08 00 	lea %a4,[%sp]8
8002ef22:	6d ff fb c5 	call 80027b18 <__unpack_d>
8002ef26:	19 a3 10 00 	ld.w %d3,[%sp]16
8002ef2a:	82 12       	mov %d2,1
8002ef2c:	bf 23 0c 80 	jlt.u %d3,2,8002ef44 <__ledf2+0x3e>
8002ef30:	19 a3 24 00 	ld.w %d3,[%sp]36
8002ef34:	bf 23 08 80 	jlt.u %d3,2,8002ef44 <__ledf2+0x3e>
8002ef38:	d9 a5 24 00 	lea %a5,[%sp]36
8002ef3c:	d9 a4 10 00 	lea %a4,[%sp]16
8002ef40:	6d ff 4b c6 	call 80027bd6 <__fpcmp_parts_d>
8002ef44:	00 90       	ret 

8002ef46 <__unorddf2>:
8002ef46:	20 38       	sub.a %sp,56
8002ef48:	d9 a5 10 00 	lea %a5,[%sp]16
8002ef4c:	40 a4       	mov.aa %a4,%sp
8002ef4e:	89 a4 40 09 	st.d [%sp],%e4
8002ef52:	89 a6 48 09 	st.d [%sp]8,%e6
8002ef56:	6d ff e1 c5 	call 80027b18 <__unpack_d>
8002ef5a:	d9 a5 24 00 	lea %a5,[%sp]36
8002ef5e:	d9 a4 08 00 	lea %a4,[%sp]8
8002ef62:	6d ff db c5 	call 80027b18 <__unpack_d>
8002ef66:	19 a3 10 00 	ld.w %d3,[%sp]16
8002ef6a:	82 12       	mov %d2,1
8002ef6c:	bf 23 06 80 	jlt.u %d3,2,8002ef78 <__unorddf2+0x32>
8002ef70:	19 a2 24 00 	ld.w %d2,[%sp]36
8002ef74:	8b 22 60 22 	lt.u %d2,%d2,2
8002ef78:	00 90       	ret 

8002ef7a <__floatsidf>:
8002ef7a:	82 32       	mov %d2,3
8002ef7c:	20 18       	sub.a %sp,24
8002ef7e:	59 a2 04 00 	st.w [%sp]4,%d2
8002ef82:	8f 14 1e 20 	sh %d2,%d4,-31
8002ef86:	59 a2 08 00 	st.w [%sp]8,%d2
8002ef8a:	df 04 0e 80 	jne %d4,0,8002efa6 <__floatsidf+0x2c>
8002ef8e:	82 22       	mov %d2,2
8002ef90:	59 a2 04 00 	st.w [%sp]4,%d2
8002ef94:	d9 a4 04 00 	lea %a4,[%sp]4
8002ef98:	6d ff f1 c4 	call 8002797a <__pack_d>
8002ef9c:	60 25       	mov.a %a5,%d2
8002ef9e:	60 34       	mov.a %a4,%d3
8002efa0:	80 52       	mov.d %d2,%a5
8002efa2:	80 43       	mov.d %d3,%a4
8002efa4:	00 90       	ret 
8002efa6:	ff 04 0a 00 	jge %d4,0,8002efba <__floatsidf+0x40>
8002efaa:	7b 00 00 28 	movh %d2,32768
8002efae:	a0 05       	mov.a %a5,0
8002efb0:	91 00 1e 4c 	movh.a %a4,49632
8002efb4:	5f 24 f6 7f 	jeq %d4,%d2,8002efa0 <__floatsidf+0x26>
8002efb8:	32 54       	rsub %d4
8002efba:	0f 04 b0 61 	clz %d6,%d4
8002efbe:	1b d6 01 60 	addi %d6,%d6,29
8002efc2:	8f f6 01 21 	and %d2,%d6,31
8002efc6:	82 05       	mov %d5,0
8002efc8:	8b 06 82 72 	ge %d7,%d6,32
8002efcc:	17 45 80 32 	dextr %d3,%d5,%d4,%d2
8002efd0:	0f 24 00 20 	sh %d2,%d4,%d2
8002efd4:	2b 23 50 37 	seln %d3,%d7,%d3,%d2
8002efd8:	8b c6 03 61 	rsub %d6,%d6,60
8002efdc:	ab 02 a0 27 	seln %d2,%d7,%d2,0
8002efe0:	59 a3 14 00 	st.w [%sp]20,%d3
8002efe4:	59 a6 0c 00 	st.w [%sp]12,%d6
8002efe8:	59 a2 10 00 	st.w [%sp]16,%d2
8002efec:	1d ff d4 ff 	j 8002ef94 <__floatsidf+0x1a>

8002eff0 <__floatunsidf>:
8002eff0:	82 02       	mov %d2,0
8002eff2:	20 18       	sub.a %sp,24
8002eff4:	59 a2 08 00 	st.w [%sp]8,%d2
8002eff8:	df 04 0a 80 	jne %d4,0,8002f00c <__floatunsidf+0x1c>
8002effc:	82 22       	mov %d2,2
8002effe:	d9 a4 04 00 	lea %a4,[%sp]4
8002f002:	59 a2 04 00 	st.w [%sp]4,%d2
8002f006:	6d ff ba c4 	call 8002797a <__pack_d>
8002f00a:	00 90       	ret 
8002f00c:	82 32       	mov %d2,3
8002f00e:	0f 04 b0 61 	clz %d6,%d4
8002f012:	1b d6 01 60 	addi %d6,%d6,29
8002f016:	59 a2 04 00 	st.w [%sp]4,%d2
8002f01a:	82 05       	mov %d5,0
8002f01c:	8f f6 01 21 	and %d2,%d6,31
8002f020:	8b 06 82 72 	ge %d7,%d6,32
8002f024:	17 45 80 32 	dextr %d3,%d5,%d4,%d2
8002f028:	0f 24 00 20 	sh %d2,%d4,%d2
8002f02c:	2b 23 50 37 	seln %d3,%d7,%d3,%d2
8002f030:	8b c6 03 61 	rsub %d6,%d6,60
8002f034:	ab 02 a0 27 	seln %d2,%d7,%d2,0
8002f038:	d9 a4 04 00 	lea %a4,[%sp]4
8002f03c:	59 a3 14 00 	st.w [%sp]20,%d3
8002f040:	59 a2 10 00 	st.w [%sp]16,%d2
8002f044:	59 a6 0c 00 	st.w [%sp]12,%d6
8002f048:	6d ff 99 c4 	call 8002797a <__pack_d>
8002f04c:	00 90       	ret 

8002f04e <__do_global_ctors_aux>:
8002f04e:	91 30 00 28 	movh.a %a2,32771
8002f052:	d9 22 00 2f 	lea %a2,[%a2]-3968 <8002f080 <__CTOR_END__>>
8002f056:	19 22 fc ff 	ld.w %d2,[%a2]-4 <8002fffc <__DTOR_END__+0xf64>>
8002f05a:	d9 23 fc ff 	lea %a3,[%a2]-4 <8002fffc <__DTOR_END__+0xf64>>
8002f05e:	df f2 0a 00 	jeq %d2,-1,8002f072 <__do_global_ctors_aux+0x24>
8002f062:	40 3c       	mov.aa %a12,%a3
8002f064:	60 22       	mov.a %a2,%d2
8002f066:	b0 cc       	add.a %a12,-4
8002f068:	2d 02 00 00 	calli %a2
8002f06c:	54 c2       	ld.w %d2,[%a12]
8002f06e:	df f2 fb ff 	jne %d2,-1,8002f064 <__do_global_ctors_aux+0x16>
8002f072:	00 90       	ret 
